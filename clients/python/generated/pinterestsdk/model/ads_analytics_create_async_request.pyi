# coding: utf-8

"""
    Pinterest REST API

    Pinterest's REST API  # noqa: E501

    The version of the OpenAPI document: 5.6.0
    Contact: blah@cliffano.com
    Generated by: https://openapi-generator.tech
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from pinterestsdk import schemas  # noqa: F401


class AdsAnalyticsCreateAsyncRequest(
    schemas.ComposedBase,
    schemas.DictSchema
):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """


    class MetaOapg:
        
        
        class all_of_0(
            schemas.DictSchema
        ):
        
        
            class MetaOapg:
                required = {
                    "end_date",
                    "granularity",
                    "start_date",
                }
                
                class properties:
                    
                    
                    class start_date(
                        schemas.StrSchema
                    ):
                        pass
                    
                    
                    class end_date(
                        schemas.StrSchema
                    ):
                        pass
                    
                    
                    class granularity(
                        schemas.ComposedBase,
                        schemas.StrSchema
                    ):
                    
                    
                        class MetaOapg:
                            
                            @classmethod
                            @functools.lru_cache()
                            def all_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    Granularity,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[str, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                        ) -> 'granularity':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                            )
                    
                    
                    class click_window_days(
                        schemas.ComposedBase,
                        schemas.IntSchema
                    ):
                    
                    
                        class MetaOapg:
                            
                            @classmethod
                            @functools.lru_cache()
                            def all_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    ConversionAttributionWindowDays,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[decimal.Decimal, int, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                        ) -> 'click_window_days':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                            )
                    
                    
                    class engagement_window_days(
                        schemas.ComposedBase,
                        schemas.IntSchema
                    ):
                    
                    
                        class MetaOapg:
                            
                            @classmethod
                            @functools.lru_cache()
                            def all_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    ConversionAttributionWindowDays,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[decimal.Decimal, int, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                        ) -> 'engagement_window_days':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                            )
                    
                    
                    class view_window_days(
                        schemas.ComposedBase,
                        schemas.IntSchema
                    ):
                    
                    
                        class MetaOapg:
                            
                            @classmethod
                            @functools.lru_cache()
                            def all_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    ConversionAttributionWindowDays,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[decimal.Decimal, int, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                        ) -> 'view_window_days':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                            )
                    
                    
                    class conversion_report_time(
                        schemas.ComposedBase,
                        schemas.StrSchema
                    ):
                    
                    
                        class MetaOapg:
                            
                            @classmethod
                            @functools.lru_cache()
                            def all_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    ConversionReportTimeType,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[str, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                        ) -> 'conversion_report_time':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                            )
                    
                    
                    class attribution_types(
                        schemas.ListSchema
                    ):
                    
                    
                        class MetaOapg:
                            
                            @staticmethod
                            def items() -> typing.Type['ConversionReportAttributionType']:
                                return ConversionReportAttributionType
                    
                        def __new__(
                            cls,
                            arg: typing.Union[typing.Tuple['ConversionReportAttributionType'], typing.List['ConversionReportAttributionType']],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                        ) -> 'attribution_types':
                            return super().__new__(
                                cls,
                                arg,
                                _configuration=_configuration,
                            )
                    
                        def __getitem__(self, i: int) -> 'ConversionReportAttributionType':
                            return super().__getitem__(i)
                    __annotations__ = {
                        "start_date": start_date,
                        "end_date": end_date,
                        "granularity": granularity,
                        "click_window_days": click_window_days,
                        "engagement_window_days": engagement_window_days,
                        "view_window_days": view_window_days,
                        "conversion_report_time": conversion_report_time,
                        "attribution_types": attribution_types,
                    }
            
            end_date: MetaOapg.properties.end_date
            granularity: MetaOapg.properties.granularity
            start_date: MetaOapg.properties.start_date
            
            @typing.overload
            def __getitem__(self, name: typing_extensions.Literal["start_date"]) -> MetaOapg.properties.start_date: ...
            
            @typing.overload
            def __getitem__(self, name: typing_extensions.Literal["end_date"]) -> MetaOapg.properties.end_date: ...
            
            @typing.overload
            def __getitem__(self, name: typing_extensions.Literal["granularity"]) -> MetaOapg.properties.granularity: ...
            
            @typing.overload
            def __getitem__(self, name: typing_extensions.Literal["click_window_days"]) -> MetaOapg.properties.click_window_days: ...
            
            @typing.overload
            def __getitem__(self, name: typing_extensions.Literal["engagement_window_days"]) -> MetaOapg.properties.engagement_window_days: ...
            
            @typing.overload
            def __getitem__(self, name: typing_extensions.Literal["view_window_days"]) -> MetaOapg.properties.view_window_days: ...
            
            @typing.overload
            def __getitem__(self, name: typing_extensions.Literal["conversion_report_time"]) -> MetaOapg.properties.conversion_report_time: ...
            
            @typing.overload
            def __getitem__(self, name: typing_extensions.Literal["attribution_types"]) -> MetaOapg.properties.attribution_types: ...
            
            @typing.overload
            def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
            
            def __getitem__(self, name: typing.Union[typing_extensions.Literal["start_date", "end_date", "granularity", "click_window_days", "engagement_window_days", "view_window_days", "conversion_report_time", "attribution_types", ], str]):
                # dict_instance[name] accessor
                return super().__getitem__(name)
            
            
            @typing.overload
            def get_item_oapg(self, name: typing_extensions.Literal["start_date"]) -> MetaOapg.properties.start_date: ...
            
            @typing.overload
            def get_item_oapg(self, name: typing_extensions.Literal["end_date"]) -> MetaOapg.properties.end_date: ...
            
            @typing.overload
            def get_item_oapg(self, name: typing_extensions.Literal["granularity"]) -> MetaOapg.properties.granularity: ...
            
            @typing.overload
            def get_item_oapg(self, name: typing_extensions.Literal["click_window_days"]) -> typing.Union[MetaOapg.properties.click_window_days, schemas.Unset]: ...
            
            @typing.overload
            def get_item_oapg(self, name: typing_extensions.Literal["engagement_window_days"]) -> typing.Union[MetaOapg.properties.engagement_window_days, schemas.Unset]: ...
            
            @typing.overload
            def get_item_oapg(self, name: typing_extensions.Literal["view_window_days"]) -> typing.Union[MetaOapg.properties.view_window_days, schemas.Unset]: ...
            
            @typing.overload
            def get_item_oapg(self, name: typing_extensions.Literal["conversion_report_time"]) -> typing.Union[MetaOapg.properties.conversion_report_time, schemas.Unset]: ...
            
            @typing.overload
            def get_item_oapg(self, name: typing_extensions.Literal["attribution_types"]) -> typing.Union[MetaOapg.properties.attribution_types, schemas.Unset]: ...
            
            @typing.overload
            def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
            
            def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["start_date", "end_date", "granularity", "click_window_days", "engagement_window_days", "view_window_days", "conversion_report_time", "attribution_types", ], str]):
                return super().get_item_oapg(name)
            
        
            def __new__(
                cls,
                *args: typing.Union[dict, frozendict.frozendict, ],
                end_date: typing.Union[MetaOapg.properties.end_date, str, ],
                granularity: typing.Union[MetaOapg.properties.granularity, str, ],
                start_date: typing.Union[MetaOapg.properties.start_date, str, ],
                click_window_days: typing.Union[MetaOapg.properties.click_window_days, decimal.Decimal, int, schemas.Unset] = schemas.unset,
                engagement_window_days: typing.Union[MetaOapg.properties.engagement_window_days, decimal.Decimal, int, schemas.Unset] = schemas.unset,
                view_window_days: typing.Union[MetaOapg.properties.view_window_days, decimal.Decimal, int, schemas.Unset] = schemas.unset,
                conversion_report_time: typing.Union[MetaOapg.properties.conversion_report_time, str, schemas.Unset] = schemas.unset,
                attribution_types: typing.Union[MetaOapg.properties.attribution_types, list, tuple, schemas.Unset] = schemas.unset,
                _configuration: typing.Optional[schemas.Configuration] = None,
                **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
            ) -> 'all_of_0':
                return super().__new__(
                    cls,
                    *args,
                    end_date=end_date,
                    granularity=granularity,
                    start_date=start_date,
                    click_window_days=click_window_days,
                    engagement_window_days=engagement_window_days,
                    view_window_days=view_window_days,
                    conversion_report_time=conversion_report_time,
                    attribution_types=attribution_types,
                    _configuration=_configuration,
                    **kwargs,
                )
        
        
        class all_of_1(
            schemas.ComposedBase,
            schemas.DictSchema
        ):
        
        
            class MetaOapg:
                
                
                class all_of_0(
                    schemas.DictSchema
                ):
                
                
                    class MetaOapg:
                        
                        class properties:
                            
                            
                            class campaign_ids(
                                schemas.ListSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    
                                    class items(
                                        schemas.StrSchema
                                    ):
                                        pass
                            
                                def __new__(
                                    cls,
                                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                ) -> 'campaign_ids':
                                    return super().__new__(
                                        cls,
                                        arg,
                                        _configuration=_configuration,
                                    )
                            
                                def __getitem__(self, i: int) -> MetaOapg.items:
                                    return super().__getitem__(i)
                            __annotations__ = {
                                "campaign_ids": campaign_ids,
                            }
                    
                    @typing.overload
                    def __getitem__(self, name: typing_extensions.Literal["campaign_ids"]) -> MetaOapg.properties.campaign_ids: ...
                    
                    @typing.overload
                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                    
                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["campaign_ids", ], str]):
                        # dict_instance[name] accessor
                        return super().__getitem__(name)
                    
                    
                    @typing.overload
                    def get_item_oapg(self, name: typing_extensions.Literal["campaign_ids"]) -> typing.Union[MetaOapg.properties.campaign_ids, schemas.Unset]: ...
                    
                    @typing.overload
                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                    
                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["campaign_ids", ], str]):
                        return super().get_item_oapg(name)
                    
                
                    def __new__(
                        cls,
                        *args: typing.Union[dict, frozendict.frozendict, ],
                        campaign_ids: typing.Union[MetaOapg.properties.campaign_ids, list, tuple, schemas.Unset] = schemas.unset,
                        _configuration: typing.Optional[schemas.Configuration] = None,
                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                    ) -> 'all_of_0':
                        return super().__new__(
                            cls,
                            *args,
                            campaign_ids=campaign_ids,
                            _configuration=_configuration,
                            **kwargs,
                        )
                
                
                class all_of_1(
                    schemas.DictSchema
                ):
                
                
                    class MetaOapg:
                        
                        class properties:
                            
                            
                            class campaign_statuses(
                                schemas.ListSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    @staticmethod
                                    def items() -> typing.Type['CampaignSummaryStatus']:
                                        return CampaignSummaryStatus
                            
                                def __new__(
                                    cls,
                                    arg: typing.Union[typing.Tuple['CampaignSummaryStatus'], typing.List['CampaignSummaryStatus']],
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                ) -> 'campaign_statuses':
                                    return super().__new__(
                                        cls,
                                        arg,
                                        _configuration=_configuration,
                                    )
                            
                                def __getitem__(self, i: int) -> 'CampaignSummaryStatus':
                                    return super().__getitem__(i)
                            __annotations__ = {
                                "campaign_statuses": campaign_statuses,
                            }
                    
                    @typing.overload
                    def __getitem__(self, name: typing_extensions.Literal["campaign_statuses"]) -> MetaOapg.properties.campaign_statuses: ...
                    
                    @typing.overload
                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                    
                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["campaign_statuses", ], str]):
                        # dict_instance[name] accessor
                        return super().__getitem__(name)
                    
                    
                    @typing.overload
                    def get_item_oapg(self, name: typing_extensions.Literal["campaign_statuses"]) -> typing.Union[MetaOapg.properties.campaign_statuses, schemas.Unset]: ...
                    
                    @typing.overload
                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                    
                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["campaign_statuses", ], str]):
                        return super().get_item_oapg(name)
                    
                
                    def __new__(
                        cls,
                        *args: typing.Union[dict, frozendict.frozendict, ],
                        campaign_statuses: typing.Union[MetaOapg.properties.campaign_statuses, list, tuple, schemas.Unset] = schemas.unset,
                        _configuration: typing.Optional[schemas.Configuration] = None,
                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                    ) -> 'all_of_1':
                        return super().__new__(
                            cls,
                            *args,
                            campaign_statuses=campaign_statuses,
                            _configuration=_configuration,
                            **kwargs,
                        )
                
                
                class all_of_2(
                    schemas.DictSchema
                ):
                
                
                    class MetaOapg:
                        
                        class properties:
                            
                            
                            class campaign_objective_types(
                                schemas.ListSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    @staticmethod
                                    def items() -> typing.Type['ObjectiveType']:
                                        return ObjectiveType
                            
                                def __new__(
                                    cls,
                                    arg: typing.Union[typing.Tuple['ObjectiveType'], typing.List['ObjectiveType']],
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                ) -> 'campaign_objective_types':
                                    return super().__new__(
                                        cls,
                                        arg,
                                        _configuration=_configuration,
                                    )
                            
                                def __getitem__(self, i: int) -> 'ObjectiveType':
                                    return super().__getitem__(i)
                            __annotations__ = {
                                "campaign_objective_types": campaign_objective_types,
                            }
                    
                    @typing.overload
                    def __getitem__(self, name: typing_extensions.Literal["campaign_objective_types"]) -> MetaOapg.properties.campaign_objective_types: ...
                    
                    @typing.overload
                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                    
                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["campaign_objective_types", ], str]):
                        # dict_instance[name] accessor
                        return super().__getitem__(name)
                    
                    
                    @typing.overload
                    def get_item_oapg(self, name: typing_extensions.Literal["campaign_objective_types"]) -> typing.Union[MetaOapg.properties.campaign_objective_types, schemas.Unset]: ...
                    
                    @typing.overload
                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                    
                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["campaign_objective_types", ], str]):
                        return super().get_item_oapg(name)
                    
                
                    def __new__(
                        cls,
                        *args: typing.Union[dict, frozendict.frozendict, ],
                        campaign_objective_types: typing.Union[MetaOapg.properties.campaign_objective_types, list, tuple, schemas.Unset] = schemas.unset,
                        _configuration: typing.Optional[schemas.Configuration] = None,
                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                    ) -> 'all_of_2':
                        return super().__new__(
                            cls,
                            *args,
                            campaign_objective_types=campaign_objective_types,
                            _configuration=_configuration,
                            **kwargs,
                        )
                
                
                class all_of_3(
                    schemas.DictSchema
                ):
                
                
                    class MetaOapg:
                        
                        class properties:
                            
                            
                            class ad_group_ids(
                                schemas.ListSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    
                                    class items(
                                        schemas.StrSchema
                                    ):
                                        pass
                            
                                def __new__(
                                    cls,
                                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                ) -> 'ad_group_ids':
                                    return super().__new__(
                                        cls,
                                        arg,
                                        _configuration=_configuration,
                                    )
                            
                                def __getitem__(self, i: int) -> MetaOapg.items:
                                    return super().__getitem__(i)
                            __annotations__ = {
                                "ad_group_ids": ad_group_ids,
                            }
                    
                    @typing.overload
                    def __getitem__(self, name: typing_extensions.Literal["ad_group_ids"]) -> MetaOapg.properties.ad_group_ids: ...
                    
                    @typing.overload
                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                    
                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["ad_group_ids", ], str]):
                        # dict_instance[name] accessor
                        return super().__getitem__(name)
                    
                    
                    @typing.overload
                    def get_item_oapg(self, name: typing_extensions.Literal["ad_group_ids"]) -> typing.Union[MetaOapg.properties.ad_group_ids, schemas.Unset]: ...
                    
                    @typing.overload
                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                    
                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["ad_group_ids", ], str]):
                        return super().get_item_oapg(name)
                    
                
                    def __new__(
                        cls,
                        *args: typing.Union[dict, frozendict.frozendict, ],
                        ad_group_ids: typing.Union[MetaOapg.properties.ad_group_ids, list, tuple, schemas.Unset] = schemas.unset,
                        _configuration: typing.Optional[schemas.Configuration] = None,
                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                    ) -> 'all_of_3':
                        return super().__new__(
                            cls,
                            *args,
                            ad_group_ids=ad_group_ids,
                            _configuration=_configuration,
                            **kwargs,
                        )
                
                
                class all_of_4(
                    schemas.DictSchema
                ):
                
                
                    class MetaOapg:
                        
                        class properties:
                            
                            
                            class ad_group_statuses(
                                schemas.ListSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    @staticmethod
                                    def items() -> typing.Type['AdGroupSummaryStatus']:
                                        return AdGroupSummaryStatus
                            
                                def __new__(
                                    cls,
                                    arg: typing.Union[typing.Tuple['AdGroupSummaryStatus'], typing.List['AdGroupSummaryStatus']],
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                ) -> 'ad_group_statuses':
                                    return super().__new__(
                                        cls,
                                        arg,
                                        _configuration=_configuration,
                                    )
                            
                                def __getitem__(self, i: int) -> 'AdGroupSummaryStatus':
                                    return super().__getitem__(i)
                            __annotations__ = {
                                "ad_group_statuses": ad_group_statuses,
                            }
                    
                    @typing.overload
                    def __getitem__(self, name: typing_extensions.Literal["ad_group_statuses"]) -> MetaOapg.properties.ad_group_statuses: ...
                    
                    @typing.overload
                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                    
                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["ad_group_statuses", ], str]):
                        # dict_instance[name] accessor
                        return super().__getitem__(name)
                    
                    
                    @typing.overload
                    def get_item_oapg(self, name: typing_extensions.Literal["ad_group_statuses"]) -> typing.Union[MetaOapg.properties.ad_group_statuses, schemas.Unset]: ...
                    
                    @typing.overload
                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                    
                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["ad_group_statuses", ], str]):
                        return super().get_item_oapg(name)
                    
                
                    def __new__(
                        cls,
                        *args: typing.Union[dict, frozendict.frozendict, ],
                        ad_group_statuses: typing.Union[MetaOapg.properties.ad_group_statuses, list, tuple, schemas.Unset] = schemas.unset,
                        _configuration: typing.Optional[schemas.Configuration] = None,
                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                    ) -> 'all_of_4':
                        return super().__new__(
                            cls,
                            *args,
                            ad_group_statuses=ad_group_statuses,
                            _configuration=_configuration,
                            **kwargs,
                        )
                
                
                class all_of_5(
                    schemas.DictSchema
                ):
                
                
                    class MetaOapg:
                        
                        class properties:
                            
                            
                            class ad_ids(
                                schemas.ListSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    
                                    class items(
                                        schemas.StrSchema
                                    ):
                                        pass
                            
                                def __new__(
                                    cls,
                                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                ) -> 'ad_ids':
                                    return super().__new__(
                                        cls,
                                        arg,
                                        _configuration=_configuration,
                                    )
                            
                                def __getitem__(self, i: int) -> MetaOapg.items:
                                    return super().__getitem__(i)
                            __annotations__ = {
                                "ad_ids": ad_ids,
                            }
                    
                    @typing.overload
                    def __getitem__(self, name: typing_extensions.Literal["ad_ids"]) -> MetaOapg.properties.ad_ids: ...
                    
                    @typing.overload
                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                    
                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["ad_ids", ], str]):
                        # dict_instance[name] accessor
                        return super().__getitem__(name)
                    
                    
                    @typing.overload
                    def get_item_oapg(self, name: typing_extensions.Literal["ad_ids"]) -> typing.Union[MetaOapg.properties.ad_ids, schemas.Unset]: ...
                    
                    @typing.overload
                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                    
                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["ad_ids", ], str]):
                        return super().get_item_oapg(name)
                    
                
                    def __new__(
                        cls,
                        *args: typing.Union[dict, frozendict.frozendict, ],
                        ad_ids: typing.Union[MetaOapg.properties.ad_ids, list, tuple, schemas.Unset] = schemas.unset,
                        _configuration: typing.Optional[schemas.Configuration] = None,
                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                    ) -> 'all_of_5':
                        return super().__new__(
                            cls,
                            *args,
                            ad_ids=ad_ids,
                            _configuration=_configuration,
                            **kwargs,
                        )
                
                
                class all_of_6(
                    schemas.DictSchema
                ):
                
                
                    class MetaOapg:
                        
                        class properties:
                            
                            
                            class ad_statuses(
                                schemas.ListSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    @staticmethod
                                    def items() -> typing.Type['PinPromotionSummaryStatus']:
                                        return PinPromotionSummaryStatus
                            
                                def __new__(
                                    cls,
                                    arg: typing.Union[typing.Tuple['PinPromotionSummaryStatus'], typing.List['PinPromotionSummaryStatus']],
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                ) -> 'ad_statuses':
                                    return super().__new__(
                                        cls,
                                        arg,
                                        _configuration=_configuration,
                                    )
                            
                                def __getitem__(self, i: int) -> 'PinPromotionSummaryStatus':
                                    return super().__getitem__(i)
                            __annotations__ = {
                                "ad_statuses": ad_statuses,
                            }
                    
                    @typing.overload
                    def __getitem__(self, name: typing_extensions.Literal["ad_statuses"]) -> MetaOapg.properties.ad_statuses: ...
                    
                    @typing.overload
                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                    
                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["ad_statuses", ], str]):
                        # dict_instance[name] accessor
                        return super().__getitem__(name)
                    
                    
                    @typing.overload
                    def get_item_oapg(self, name: typing_extensions.Literal["ad_statuses"]) -> typing.Union[MetaOapg.properties.ad_statuses, schemas.Unset]: ...
                    
                    @typing.overload
                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                    
                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["ad_statuses", ], str]):
                        return super().get_item_oapg(name)
                    
                
                    def __new__(
                        cls,
                        *args: typing.Union[dict, frozendict.frozendict, ],
                        ad_statuses: typing.Union[MetaOapg.properties.ad_statuses, list, tuple, schemas.Unset] = schemas.unset,
                        _configuration: typing.Optional[schemas.Configuration] = None,
                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                    ) -> 'all_of_6':
                        return super().__new__(
                            cls,
                            *args,
                            ad_statuses=ad_statuses,
                            _configuration=_configuration,
                            **kwargs,
                        )
                
                
                class all_of_7(
                    schemas.DictSchema
                ):
                
                
                    class MetaOapg:
                        
                        class properties:
                            
                            
                            class product_group_ids(
                                schemas.ListSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    
                                    class items(
                                        schemas.StrSchema
                                    ):
                                        pass
                            
                                def __new__(
                                    cls,
                                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                ) -> 'product_group_ids':
                                    return super().__new__(
                                        cls,
                                        arg,
                                        _configuration=_configuration,
                                    )
                            
                                def __getitem__(self, i: int) -> MetaOapg.items:
                                    return super().__getitem__(i)
                            __annotations__ = {
                                "product_group_ids": product_group_ids,
                            }
                    
                    @typing.overload
                    def __getitem__(self, name: typing_extensions.Literal["product_group_ids"]) -> MetaOapg.properties.product_group_ids: ...
                    
                    @typing.overload
                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                    
                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["product_group_ids", ], str]):
                        # dict_instance[name] accessor
                        return super().__getitem__(name)
                    
                    
                    @typing.overload
                    def get_item_oapg(self, name: typing_extensions.Literal["product_group_ids"]) -> typing.Union[MetaOapg.properties.product_group_ids, schemas.Unset]: ...
                    
                    @typing.overload
                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                    
                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["product_group_ids", ], str]):
                        return super().get_item_oapg(name)
                    
                
                    def __new__(
                        cls,
                        *args: typing.Union[dict, frozendict.frozendict, ],
                        product_group_ids: typing.Union[MetaOapg.properties.product_group_ids, list, tuple, schemas.Unset] = schemas.unset,
                        _configuration: typing.Optional[schemas.Configuration] = None,
                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                    ) -> 'all_of_7':
                        return super().__new__(
                            cls,
                            *args,
                            product_group_ids=product_group_ids,
                            _configuration=_configuration,
                            **kwargs,
                        )
                
                
                class all_of_8(
                    schemas.DictSchema
                ):
                
                
                    class MetaOapg:
                        
                        class properties:
                            
                            
                            class product_group_statuses(
                                schemas.ListSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    @staticmethod
                                    def items() -> typing.Type['ProductGroupSummaryStatus']:
                                        return ProductGroupSummaryStatus
                            
                                def __new__(
                                    cls,
                                    arg: typing.Union[typing.Tuple['ProductGroupSummaryStatus'], typing.List['ProductGroupSummaryStatus']],
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                ) -> 'product_group_statuses':
                                    return super().__new__(
                                        cls,
                                        arg,
                                        _configuration=_configuration,
                                    )
                            
                                def __getitem__(self, i: int) -> 'ProductGroupSummaryStatus':
                                    return super().__getitem__(i)
                            __annotations__ = {
                                "product_group_statuses": product_group_statuses,
                            }
                    
                    @typing.overload
                    def __getitem__(self, name: typing_extensions.Literal["product_group_statuses"]) -> MetaOapg.properties.product_group_statuses: ...
                    
                    @typing.overload
                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                    
                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["product_group_statuses", ], str]):
                        # dict_instance[name] accessor
                        return super().__getitem__(name)
                    
                    
                    @typing.overload
                    def get_item_oapg(self, name: typing_extensions.Literal["product_group_statuses"]) -> typing.Union[MetaOapg.properties.product_group_statuses, schemas.Unset]: ...
                    
                    @typing.overload
                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                    
                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["product_group_statuses", ], str]):
                        return super().get_item_oapg(name)
                    
                
                    def __new__(
                        cls,
                        *args: typing.Union[dict, frozendict.frozendict, ],
                        product_group_statuses: typing.Union[MetaOapg.properties.product_group_statuses, list, tuple, schemas.Unset] = schemas.unset,
                        _configuration: typing.Optional[schemas.Configuration] = None,
                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                    ) -> 'all_of_8':
                        return super().__new__(
                            cls,
                            *args,
                            product_group_statuses=product_group_statuses,
                            _configuration=_configuration,
                            **kwargs,
                        )
                
                
                class all_of_9(
                    schemas.DictSchema
                ):
                
                
                    class MetaOapg:
                        
                        class properties:
                            
                            
                            class product_item_ids(
                                schemas.ListSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    
                                    class items(
                                        schemas.StrSchema
                                    ):
                                        pass
                            
                                def __new__(
                                    cls,
                                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                ) -> 'product_item_ids':
                                    return super().__new__(
                                        cls,
                                        arg,
                                        _configuration=_configuration,
                                    )
                            
                                def __getitem__(self, i: int) -> MetaOapg.items:
                                    return super().__getitem__(i)
                            __annotations__ = {
                                "product_item_ids": product_item_ids,
                            }
                    
                    @typing.overload
                    def __getitem__(self, name: typing_extensions.Literal["product_item_ids"]) -> MetaOapg.properties.product_item_ids: ...
                    
                    @typing.overload
                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                    
                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["product_item_ids", ], str]):
                        # dict_instance[name] accessor
                        return super().__getitem__(name)
                    
                    
                    @typing.overload
                    def get_item_oapg(self, name: typing_extensions.Literal["product_item_ids"]) -> typing.Union[MetaOapg.properties.product_item_ids, schemas.Unset]: ...
                    
                    @typing.overload
                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                    
                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["product_item_ids", ], str]):
                        return super().get_item_oapg(name)
                    
                
                    def __new__(
                        cls,
                        *args: typing.Union[dict, frozendict.frozendict, ],
                        product_item_ids: typing.Union[MetaOapg.properties.product_item_ids, list, tuple, schemas.Unset] = schemas.unset,
                        _configuration: typing.Optional[schemas.Configuration] = None,
                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                    ) -> 'all_of_9':
                        return super().__new__(
                            cls,
                            *args,
                            product_item_ids=product_item_ids,
                            _configuration=_configuration,
                            **kwargs,
                        )
                
                
                class all_of_11(
                    schemas.DictSchema
                ):
                
                
                    class MetaOapg:
                        
                        class properties:
                            
                            
                            class metrics_filters(
                                schemas.ListSchema
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    @staticmethod
                                    def items() -> typing.Type['AdsAnalyticsMetricsFilter']:
                                        return AdsAnalyticsMetricsFilter
                            
                                def __new__(
                                    cls,
                                    arg: typing.Union[typing.Tuple['AdsAnalyticsMetricsFilter'], typing.List['AdsAnalyticsMetricsFilter']],
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                ) -> 'metrics_filters':
                                    return super().__new__(
                                        cls,
                                        arg,
                                        _configuration=_configuration,
                                    )
                            
                                def __getitem__(self, i: int) -> 'AdsAnalyticsMetricsFilter':
                                    return super().__getitem__(i)
                            __annotations__ = {
                                "metrics_filters": metrics_filters,
                            }
                    
                    @typing.overload
                    def __getitem__(self, name: typing_extensions.Literal["metrics_filters"]) -> MetaOapg.properties.metrics_filters: ...
                    
                    @typing.overload
                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                    
                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["metrics_filters", ], str]):
                        # dict_instance[name] accessor
                        return super().__getitem__(name)
                    
                    
                    @typing.overload
                    def get_item_oapg(self, name: typing_extensions.Literal["metrics_filters"]) -> typing.Union[MetaOapg.properties.metrics_filters, schemas.Unset]: ...
                    
                    @typing.overload
                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                    
                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["metrics_filters", ], str]):
                        return super().get_item_oapg(name)
                    
                
                    def __new__(
                        cls,
                        *args: typing.Union[dict, frozendict.frozendict, ],
                        metrics_filters: typing.Union[MetaOapg.properties.metrics_filters, list, tuple, schemas.Unset] = schemas.unset,
                        _configuration: typing.Optional[schemas.Configuration] = None,
                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                    ) -> 'all_of_11':
                        return super().__new__(
                            cls,
                            *args,
                            metrics_filters=metrics_filters,
                            _configuration=_configuration,
                            **kwargs,
                        )
                
                @classmethod
                @functools.lru_cache()
                def all_of(cls):
                    # we need this here to make our import statements work
                    # we must store _composed_schemas in here so the code is only run
                    # when we invoke this method. If we kept this at the class
                    # level we would get an error because the class level
                    # code would be run when this module is imported, and these composed
                    # classes don't exist yet because their module has not finished
                    # loading
                    return [
                        cls.all_of_0,
                        cls.all_of_1,
                        cls.all_of_2,
                        cls.all_of_3,
                        cls.all_of_4,
                        cls.all_of_5,
                        cls.all_of_6,
                        cls.all_of_7,
                        cls.all_of_8,
                        cls.all_of_9,
                        TargetingTypeFilter,
                        cls.all_of_11,
                    ]
        
        
            def __new__(
                cls,
                *args: typing.Union[dict, frozendict.frozendict, ],
                _configuration: typing.Optional[schemas.Configuration] = None,
                **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
            ) -> 'all_of_1':
                return super().__new__(
                    cls,
                    *args,
                    _configuration=_configuration,
                    **kwargs,
                )
        
        
        class all_of_2(
            schemas.DictSchema
        ):
        
        
            class MetaOapg:
                required = {
                    "level",
                    "columns",
                }
                
                class properties:
                    
                    
                    class columns(
                        schemas.ListSchema
                    ):
                    
                    
                        class MetaOapg:
                            
                            @staticmethod
                            def items() -> typing.Type['ReportingColumnAsync']:
                                return ReportingColumnAsync
                    
                        def __new__(
                            cls,
                            arg: typing.Union[typing.Tuple['ReportingColumnAsync'], typing.List['ReportingColumnAsync']],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                        ) -> 'columns':
                            return super().__new__(
                                cls,
                                arg,
                                _configuration=_configuration,
                            )
                    
                        def __getitem__(self, i: int) -> 'ReportingColumnAsync':
                            return super().__getitem__(i)
                    
                    
                    class level(
                        schemas.ComposedBase,
                        schemas.StrSchema
                    ):
                    
                    
                        class MetaOapg:
                            
                            @classmethod
                            @functools.lru_cache()
                            def all_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    MetricsReportingLevel,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[str, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                        ) -> 'level':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                            )
                    
                    
                    class report_format(
                        schemas.ComposedBase,
                        schemas.StrSchema
                    ):
                    
                    
                        class MetaOapg:
                            
                            @classmethod
                            @functools.lru_cache()
                            def all_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    DataOutputFormat,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[str, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                        ) -> 'report_format':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                            )
                    __annotations__ = {
                        "columns": columns,
                        "level": level,
                        "report_format": report_format,
                    }
            
            level: MetaOapg.properties.level
            columns: MetaOapg.properties.columns
            
            @typing.overload
            def __getitem__(self, name: typing_extensions.Literal["columns"]) -> MetaOapg.properties.columns: ...
            
            @typing.overload
            def __getitem__(self, name: typing_extensions.Literal["level"]) -> MetaOapg.properties.level: ...
            
            @typing.overload
            def __getitem__(self, name: typing_extensions.Literal["report_format"]) -> MetaOapg.properties.report_format: ...
            
            @typing.overload
            def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
            
            def __getitem__(self, name: typing.Union[typing_extensions.Literal["columns", "level", "report_format", ], str]):
                # dict_instance[name] accessor
                return super().__getitem__(name)
            
            
            @typing.overload
            def get_item_oapg(self, name: typing_extensions.Literal["columns"]) -> MetaOapg.properties.columns: ...
            
            @typing.overload
            def get_item_oapg(self, name: typing_extensions.Literal["level"]) -> MetaOapg.properties.level: ...
            
            @typing.overload
            def get_item_oapg(self, name: typing_extensions.Literal["report_format"]) -> typing.Union[MetaOapg.properties.report_format, schemas.Unset]: ...
            
            @typing.overload
            def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
            
            def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["columns", "level", "report_format", ], str]):
                return super().get_item_oapg(name)
            
        
            def __new__(
                cls,
                *args: typing.Union[dict, frozendict.frozendict, ],
                level: typing.Union[MetaOapg.properties.level, str, ],
                columns: typing.Union[MetaOapg.properties.columns, list, tuple, ],
                report_format: typing.Union[MetaOapg.properties.report_format, str, schemas.Unset] = schemas.unset,
                _configuration: typing.Optional[schemas.Configuration] = None,
                **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
            ) -> 'all_of_2':
                return super().__new__(
                    cls,
                    *args,
                    level=level,
                    columns=columns,
                    report_format=report_format,
                    _configuration=_configuration,
                    **kwargs,
                )
        
        @classmethod
        @functools.lru_cache()
        def all_of(cls):
            # we need this here to make our import statements work
            # we must store _composed_schemas in here so the code is only run
            # when we invoke this method. If we kept this at the class
            # level we would get an error because the class level
            # code would be run when this module is imported, and these composed
            # classes don't exist yet because their module has not finished
            # loading
            return [
                cls.all_of_0,
                cls.all_of_1,
                cls.all_of_2,
            ]


    def __new__(
        cls,
        *args: typing.Union[dict, frozendict.frozendict, ],
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'AdsAnalyticsCreateAsyncRequest':
        return super().__new__(
            cls,
            *args,
            _configuration=_configuration,
            **kwargs,
        )

from pinterestsdk.model.ad_group_summary_status import AdGroupSummaryStatus
from pinterestsdk.model.ads_analytics_metrics_filter import AdsAnalyticsMetricsFilter
from pinterestsdk.model.campaign_summary_status import CampaignSummaryStatus
from pinterestsdk.model.conversion_attribution_window_days import ConversionAttributionWindowDays
from pinterestsdk.model.conversion_report_attribution_type import ConversionReportAttributionType
from pinterestsdk.model.conversion_report_time_type import ConversionReportTimeType
from pinterestsdk.model.data_output_format import DataOutputFormat
from pinterestsdk.model.granularity import Granularity
from pinterestsdk.model.metrics_reporting_level import MetricsReportingLevel
from pinterestsdk.model.objective_type import ObjectiveType
from pinterestsdk.model.pin_promotion_summary_status import PinPromotionSummaryStatus
from pinterestsdk.model.product_group_summary_status import ProductGroupSummaryStatus
from pinterestsdk.model.reporting_column_async import ReportingColumnAsync
from pinterestsdk.model.targeting_type_filter import TargetingTypeFilter
