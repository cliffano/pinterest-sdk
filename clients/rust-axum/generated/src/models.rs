#![allow(unused_qualifications)]

use http::HeaderValue;
use validator::Validate;

#[cfg(feature = "server")]
use crate::header;
use crate::{models, types::*};

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdAccountSlashAnalyticsPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADACCOUNTSLASHANALYTICSPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADACCOUNTSLASHANALYTICSPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdAccountSlashAnalyticsQueryParams {
            /// Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
                #[serde(rename = "start_date")]
                pub start_date: chrono::naive::NaiveDate,
            /// Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
                #[serde(rename = "end_date")]
                pub end_date: chrono::naive::NaiveDate,
            /// Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile's currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it's microdollars. Otherwise, it's in microunits of the advertiser's currency.<br/>For example, if the advertiser's currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).<br/>If a column has no value, it may not be returned
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "columns")]
                pub columns: Vec<String>,
            /// TOTAL - metrics are aggregated over the specified date range.<br> DAY - metrics are broken down daily.<br> HOUR - metrics are broken down hourly.<br>WEEKLY - metrics are broken down weekly.<br>MONTHLY - metrics are broken down monthly
                #[serde(rename = "granularity")]
                pub granularity: models::Granularity,
            /// Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "click_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub click_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "engagement_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub engagement_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `1` day.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "view_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub view_window_days: Option<i32>,
            /// The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "conversion_report_time")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub conversion_report_time: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdAccountTargetingAnalyticsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADACCOUNTTARGETINGANALYTICSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADACCOUNTTARGETINGANALYTICSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdAccountTargetingAnalyticsSlashGetQueryParams {
            /// Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
                #[serde(rename = "start_date")]
                pub start_date: chrono::naive::NaiveDate,
            /// Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
                #[serde(rename = "end_date")]
                pub end_date: chrono::naive::NaiveDate,
            /// Targeting type breakdowns for the report. The reporting per targeting type <br> is independent from each other.
                #[serde(rename = "targeting_types")]
                #[validate(
                        length(min = 1, max = 15),
                    )]
                pub targeting_types: Vec<models::AdsAnalyticsTargetingType>,
            /// Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile's currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it's microdollars. Otherwise, it's in microunits of the advertiser's currency.<br/>For example, if the advertiser's currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).<br/>If a column has no value, it may not be returned
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "columns")]
                pub columns: Vec<String>,
            /// TOTAL - metrics are aggregated over the specified date range.<br> DAY - metrics are broken down daily.<br> HOUR - metrics are broken down hourly.<br>WEEKLY - metrics are broken down weekly.<br>MONTHLY - metrics are broken down monthly
                #[serde(rename = "granularity")]
                pub granularity: models::Granularity,
            /// Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "click_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub click_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "engagement_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub engagement_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `1` day.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "view_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub view_window_days: Option<i32>,
            /// The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "conversion_report_time")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub conversion_report_time: Option<String>,
            /// List of types of attribution for the conversion report
                #[serde(rename = "attribution_types")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub attribution_types: Option<models::ConversionReportAttributionType>,
    }

      
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdAccountsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADACCOUNTSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADACCOUNTSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdAccountsSlashListQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// Include shared ad accounts
                #[serde(rename = "include_shared_accounts")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub include_shared_accounts: Option<bool>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AnalyticsSlashCreateMmmReportPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ANALYTICSSLASHCREATEMMMREPORTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ANALYTICSSLASHCREATEMMMREPORTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AnalyticsSlashCreateReportPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ANALYTICSSLASHCREATEREPORTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ANALYTICSSLASHCREATEREPORTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AnalyticsSlashCreateTemplateReportPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ANALYTICSSLASHCREATETEMPLATEREPORTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
            /// Unique identifier of a template.
                #[validate(
                        length(max = 18),
                        regex = "RE_ANALYTICSSLASHCREATETEMPLATEREPORTPATHPARAMS_TEMPLATE_ID",
                    )]
                pub template_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ANALYTICSSLASHCREATETEMPLATEREPORTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_ANALYTICSSLASHCREATETEMPLATEREPORTPATHPARAMS_TEMPLATE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AnalyticsSlashCreateTemplateReportQueryParams {
            /// Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 2.5 years back from today.
                #[serde(rename = "start_date")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub start_date: Option<chrono::naive::NaiveDate>,
            /// Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 2.5 years past start date.
                #[serde(rename = "end_date")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub end_date: Option<chrono::naive::NaiveDate>,
            /// TOTAL - metrics are aggregated over the specified date range.<br> DAY - metrics are broken down daily.<br> HOUR - metrics are broken down hourly.<br>WEEKLY - metrics are broken down weekly.<br>MONTHLY - metrics are broken down monthly
                #[serde(rename = "granularity")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub granularity: Option<models::Granularity>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AnalyticsSlashGetMmmReportPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ANALYTICSSLASHGETMMMREPORTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ANALYTICSSLASHGETMMMREPORTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AnalyticsSlashGetMmmReportQueryParams {
            /// Token returned from the post request creation call
                #[serde(rename = "token")]
                pub token: String,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AnalyticsSlashGetReportPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ANALYTICSSLASHGETREPORTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ANALYTICSSLASHGETREPORTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AnalyticsSlashGetReportQueryParams {
            /// Token returned from the post request creation call
                #[serde(rename = "token")]
                pub token: String,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct SandboxSlashDeletePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_SANDBOXSLASHDELETEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_SANDBOXSLASHDELETEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct TemplatesSlashListPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_TEMPLATESSLASHLISTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_TEMPLATESSLASHLISTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct TemplatesSlashListQueryParams {
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// The order in which to sort the items returned: “ASCENDING” or “DESCENDING” by ID. Note that higher-value IDs are associated with more-recently added items.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub order: Option<String>,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdGroupsBidFloorSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADGROUPSBIDFLOORSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADGROUPSBIDFLOORSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdGroupsSlashAnalyticsPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADGROUPSSLASHANALYTICSPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADGROUPSSLASHANALYTICSPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdGroupsSlashAnalyticsQueryParams {
            /// Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
                #[serde(rename = "start_date")]
                pub start_date: chrono::naive::NaiveDate,
            /// Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
                #[serde(rename = "end_date")]
                pub end_date: chrono::naive::NaiveDate,
            /// List of Ad group Ids to use to filter the results.
                #[serde(rename = "ad_group_ids")]
                #[validate(
                        length(min = 1, max = 100),
                    )]
                pub ad_group_ids: Vec<String>,
            /// Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile's currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it's microdollars. Otherwise, it's in microunits of the advertiser's currency.<br/>For example, if the advertiser's currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).<br/>If a column has no value, it may not be returned
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "columns")]
                pub columns: Vec<String>,
            /// TOTAL - metrics are aggregated over the specified date range.<br> DAY - metrics are broken down daily.<br> HOUR - metrics are broken down hourly.<br>WEEKLY - metrics are broken down weekly.<br>MONTHLY - metrics are broken down monthly
                #[serde(rename = "granularity")]
                pub granularity: models::Granularity,
            /// Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "click_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub click_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "engagement_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub engagement_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `1` day.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "view_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub view_window_days: Option<i32>,
            /// The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "conversion_report_time")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub conversion_report_time: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdGroupsSlashAudienceSizingPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADGROUPSSLASHAUDIENCESIZINGPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADGROUPSSLASHAUDIENCESIZINGPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdGroupsSlashCreatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADGROUPSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADGROUPSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdGroupsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADGROUPSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
            /// Unique identifier of an ad group.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADGROUPSSLASHGETPATHPARAMS_AD_GROUP_ID",
                    )]
                pub ad_group_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADGROUPSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_ADGROUPSSLASHGETPATHPARAMS_AD_GROUP_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdGroupsSlashListPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADGROUPSSLASHLISTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADGROUPSSLASHLISTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdGroupsSlashListQueryParams {
            /// List of Campaign Ids to use to filter the results.
                #[serde(rename = "campaign_ids")]
                #[validate(
                        length(min = 1, max = 100),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub campaign_ids: Option<Vec<String>>,
            /// List of Ad group Ids to use to filter the results.
                #[serde(rename = "ad_group_ids")]
                #[validate(
                        length(min = 1, max = 100),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_group_ids: Option<Vec<String>>,
            /// Entity status
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "entity_statuses")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub entity_statuses: Option<Vec<String>>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// The order in which to sort the items returned: “ASCENDING” or “DESCENDING” by ID. Note that higher-value IDs are associated with more-recently added items.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub order: Option<String>,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Return interests as text names (if value is true) rather than topic IDs.
                #[serde(rename = "translate_interests_to_names")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub translate_interests_to_names: Option<bool>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdGroupsSlashUpdatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADGROUPSSLASHUPDATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADGROUPSSLASHUPDATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdGroupsTargetingAnalyticsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADGROUPSTARGETINGANALYTICSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADGROUPSTARGETINGANALYTICSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdGroupsTargetingAnalyticsSlashGetQueryParams {
            /// List of Ad group Ids to use to filter the results.
                #[serde(rename = "ad_group_ids")]
                #[validate(
                        length(min = 1, max = 100),
                    )]
                pub ad_group_ids: Vec<String>,
            /// Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
                #[serde(rename = "start_date")]
                pub start_date: chrono::naive::NaiveDate,
            /// Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
                #[serde(rename = "end_date")]
                pub end_date: chrono::naive::NaiveDate,
            /// Targeting type breakdowns for the report. The reporting per targeting type <br> is independent from each other.
                #[serde(rename = "targeting_types")]
                #[validate(
                        length(min = 1, max = 15),
                    )]
                pub targeting_types: Vec<models::AdsAnalyticsTargetingType>,
            /// Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile's currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it's microdollars. Otherwise, it's in microunits of the advertiser's currency.<br/>For example, if the advertiser's currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).<br/>If a column has no value, it may not be returned
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "columns")]
                pub columns: Vec<String>,
            /// TOTAL - metrics are aggregated over the specified date range.<br> DAY - metrics are broken down daily.<br> HOUR - metrics are broken down hourly.<br>WEEKLY - metrics are broken down weekly.<br>MONTHLY - metrics are broken down monthly
                #[serde(rename = "granularity")]
                pub granularity: models::Granularity,
            /// Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "click_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub click_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "engagement_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub engagement_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `1` day.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "view_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub view_window_days: Option<i32>,
            /// The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "conversion_report_time")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub conversion_report_time: Option<String>,
            /// List of types of attribution for the conversion report
                #[serde(rename = "attribution_types")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub attribution_types: Option<models::ConversionReportAttributionType>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdPreviewsSlashCreatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADPREVIEWSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADPREVIEWSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdTargetingAnalyticsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADTARGETINGANALYTICSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADTARGETINGANALYTICSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdTargetingAnalyticsSlashGetQueryParams {
            /// List of Ad Ids to use to filter the results.
                #[serde(rename = "ad_ids")]
                #[validate(
                        length(min = 1, max = 100),
                    )]
                pub ad_ids: Vec<String>,
            /// Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
                #[serde(rename = "start_date")]
                pub start_date: chrono::naive::NaiveDate,
            /// Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
                #[serde(rename = "end_date")]
                pub end_date: chrono::naive::NaiveDate,
            /// Targeting type breakdowns for the report. The reporting per targeting type <br> is independent from each other.
                #[serde(rename = "targeting_types")]
                #[validate(
                        length(min = 1, max = 15),
                    )]
                pub targeting_types: Vec<models::AdsAnalyticsTargetingType>,
            /// Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile's currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it's microdollars. Otherwise, it's in microunits of the advertiser's currency.<br/>For example, if the advertiser's currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).<br/>If a column has no value, it may not be returned
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "columns")]
                pub columns: Vec<String>,
            /// TOTAL - metrics are aggregated over the specified date range.<br> DAY - metrics are broken down daily.<br> HOUR - metrics are broken down hourly.<br>WEEKLY - metrics are broken down weekly.<br>MONTHLY - metrics are broken down monthly
                #[serde(rename = "granularity")]
                pub granularity: models::Granularity,
            /// Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "click_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub click_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "engagement_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub engagement_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `1` day.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "view_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub view_window_days: Option<i32>,
            /// The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "conversion_report_time")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub conversion_report_time: Option<String>,
            /// List of types of attribution for the conversion report
                #[serde(rename = "attribution_types")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub attribution_types: Option<models::ConversionReportAttributionType>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdsSlashAnalyticsPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADSSLASHANALYTICSPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADSSLASHANALYTICSPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdsSlashAnalyticsQueryParams {
            /// Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
                #[serde(rename = "start_date")]
                pub start_date: chrono::naive::NaiveDate,
            /// Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
                #[serde(rename = "end_date")]
                pub end_date: chrono::naive::NaiveDate,
            /// List of Ad Ids to use to filter the results.
                #[serde(rename = "ad_ids")]
                #[validate(
                        length(min = 1, max = 100),
                    )]
                pub ad_ids: Vec<String>,
            /// Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile's currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it's microdollars. Otherwise, it's in microunits of the advertiser's currency.<br/>For example, if the advertiser's currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).<br/>If a column has no value, it may not be returned
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "columns")]
                pub columns: Vec<String>,
            /// TOTAL - metrics are aggregated over the specified date range.<br> DAY - metrics are broken down daily.<br> HOUR - metrics are broken down hourly.<br>WEEKLY - metrics are broken down weekly.<br>MONTHLY - metrics are broken down monthly
                #[serde(rename = "granularity")]
                pub granularity: models::Granularity,
            /// Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "click_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub click_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "engagement_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub engagement_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `1` day.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "view_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub view_window_days: Option<i32>,
            /// The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "conversion_report_time")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub conversion_report_time: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdsSlashCreatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
            /// Unique identifier of an ad.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADSSLASHGETPATHPARAMS_AD_ID",
                    )]
                pub ad_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_ADSSLASHGETPATHPARAMS_AD_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdsSlashListPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADSSLASHLISTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADSSLASHLISTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdsSlashListQueryParams {
            /// List of Campaign Ids to use to filter the results.
                #[serde(rename = "campaign_ids")]
                #[validate(
                        length(min = 1, max = 100),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub campaign_ids: Option<Vec<String>>,
            /// List of Ad group Ids to use to filter the results.
                #[serde(rename = "ad_group_ids")]
                #[validate(
                        length(min = 1, max = 100),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_group_ids: Option<Vec<String>>,
            /// List of Ad Ids to use to filter the results.
                #[serde(rename = "ad_ids")]
                #[validate(
                        length(min = 1, max = 100),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_ids: Option<Vec<String>>,
            /// Entity status
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "entity_statuses")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub entity_statuses: Option<Vec<String>>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// The order in which to sort the items returned: “ASCENDING” or “DESCENDING” by ID. Note that higher-value IDs are associated with more-recently added items.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub order: Option<String>,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdsSlashUpdatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADSSLASHUPDATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADSSLASHUPDATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AudienceInsightsScopeAndTypeSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_AUDIENCEINSIGHTSSCOPEANDTYPESLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_AUDIENCEINSIGHTSSCOPEANDTYPESLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AudienceInsightsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_AUDIENCEINSIGHTSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_AUDIENCEINSIGHTSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AudienceInsightsSlashGetQueryParams {
            /// Type of audience insights.
                #[serde(rename = "audience_insight_type")]
                pub audience_insight_type: models::AudienceInsightType,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AudiencesSlashCreatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_AUDIENCESSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_AUDIENCESSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AudiencesSlashCreateCustomPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_AUDIENCESSLASHCREATECUSTOMPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_AUDIENCESSLASHCREATECUSTOMPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AudiencesSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_AUDIENCESSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
            /// Unique identifier of an audience
                #[validate(
                        length(max = 18),
                        regex = "RE_AUDIENCESSLASHGETPATHPARAMS_AUDIENCE_ID",
                    )]
                pub audience_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_AUDIENCESSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_AUDIENCESSLASHGETPATHPARAMS_AUDIENCE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AudiencesSlashListPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_AUDIENCESSLASHLISTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_AUDIENCESSLASHLISTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AudiencesSlashListQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// The order in which to sort the items returned: “ASCENDING” or “DESCENDING” by ID. For received audiences, it is sorted by sharing event time. Note that higher-value IDs are associated with more-recently added items.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub order: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// <strong>This feature is currently in beta and not available to all apps.</strong> Filter audiences by ownership type.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "ownership_type")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ownership_type: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AudiencesSlashUpdatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_AUDIENCESSLASHUPDATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
            /// Unique identifier of an audience
                #[validate(
                        length(max = 18),
                        regex = "RE_AUDIENCESSLASHUPDATEPATHPARAMS_AUDIENCE_ID",
                    )]
                pub audience_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_AUDIENCESSLASHUPDATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_AUDIENCESSLASHUPDATEPATHPARAMS_AUDIENCE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdsCreditSlashRedeemPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADSCREDITSLASHREDEEMPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADSCREDITSLASHREDEEMPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdsCreditsDiscountsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADSCREDITSDISCOUNTSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADSCREDITSDISCOUNTSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdsCreditsDiscountsSlashGetQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BillingProfilesSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_BILLINGPROFILESSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_BILLINGPROFILESSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BillingProfilesSlashGetQueryParams {
            /// Return active billing profiles, if false return all billing profiles.
                #[serde(rename = "is_active")]
                pub is_active: bool,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct SsioAccountsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_SSIOACCOUNTSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_SSIOACCOUNTSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct SsioInsertionOrderSlashCreatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_SSIOINSERTIONORDERSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_SSIOINSERTIONORDERSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct SsioInsertionOrderSlashEditPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_SSIOINSERTIONORDERSLASHEDITPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_SSIOINSERTIONORDERSLASHEDITPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct SsioInsertionOrdersStatusSlashGetByAdAccountPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_SSIOINSERTIONORDERSSTATUSSLASHGETBYADACCOUNTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_SSIOINSERTIONORDERSSTATUSSLASHGETBYADACCOUNTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct SsioInsertionOrdersStatusSlashGetByAdAccountQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct SsioInsertionOrdersStatusSlashGetByPinOrderIdPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_SSIOINSERTIONORDERSSTATUSSLASHGETBYPINORDERIDPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
            /// The pin order id associated with the ssio insertion order
                pub pin_order_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_SSIOINSERTIONORDERSSTATUSSLASHGETBYPINORDERIDPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct SsioOrderLinesSlashGetByAdAccountPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_SSIOORDERLINESSLASHGETBYADACCOUNTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_SSIOORDERLINESSLASHGETBYADACCOUNTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct SsioOrderLinesSlashGetByAdAccountQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// The pin order id associated with the ssio insertino order
                #[serde(rename = "pin_order_id")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pin_order_id: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardSectionsSlashCreatePathParams {
            /// Unique identifier of a board.
                #[validate(
                        regex = "RE_BOARDSECTIONSSLASHCREATEPATHPARAMS_BOARD_ID",
                    )]
                pub board_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSECTIONSSLASHCREATEPATHPARAMS_BOARD_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardSectionsSlashCreateQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_BOARDSECTIONSSLASHCREATEQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSECTIONSSLASHCREATEQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardSectionsSlashDeletePathParams {
            /// Unique identifier of a board.
                #[validate(
                        regex = "RE_BOARDSECTIONSSLASHDELETEPATHPARAMS_BOARD_ID",
                    )]
                pub board_id: String,
            /// Unique identifier of a board section.
                #[validate(
                        regex = "RE_BOARDSECTIONSSLASHDELETEPATHPARAMS_SECTION_ID",
                    )]
                pub section_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSECTIONSSLASHDELETEPATHPARAMS_BOARD_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_BOARDSECTIONSSLASHDELETEPATHPARAMS_SECTION_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardSectionsSlashDeleteQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_BOARDSECTIONSSLASHDELETEQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSECTIONSSLASHDELETEQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardSectionsSlashListPathParams {
            /// Unique identifier of a board.
                #[validate(
                        regex = "RE_BOARDSECTIONSSLASHLISTPATHPARAMS_BOARD_ID",
                    )]
                pub board_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSECTIONSSLASHLISTPATHPARAMS_BOARD_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardSectionsSlashListQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_BOARDSECTIONSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSECTIONSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardSectionsSlashListPinsPathParams {
            /// Unique identifier of a board.
                #[validate(
                        regex = "RE_BOARDSECTIONSSLASHLISTPINSPATHPARAMS_BOARD_ID",
                    )]
                pub board_id: String,
            /// Unique identifier of a board section.
                #[validate(
                        regex = "RE_BOARDSECTIONSSLASHLISTPINSPATHPARAMS_SECTION_ID",
                    )]
                pub section_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSECTIONSSLASHLISTPINSPATHPARAMS_BOARD_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_BOARDSECTIONSSLASHLISTPINSPATHPARAMS_SECTION_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardSectionsSlashListPinsQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_BOARDSECTIONSSLASHLISTPINSQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSECTIONSSLASHLISTPINSQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardSectionsSlashUpdatePathParams {
            /// Unique identifier of a board.
                #[validate(
                        regex = "RE_BOARDSECTIONSSLASHUPDATEPATHPARAMS_BOARD_ID",
                    )]
                pub board_id: String,
            /// Unique identifier of a board section.
                #[validate(
                        regex = "RE_BOARDSECTIONSSLASHUPDATEPATHPARAMS_SECTION_ID",
                    )]
                pub section_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSECTIONSSLASHUPDATEPATHPARAMS_BOARD_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_BOARDSECTIONSSLASHUPDATEPATHPARAMS_SECTION_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardSectionsSlashUpdateQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_BOARDSECTIONSSLASHUPDATEQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSECTIONSSLASHUPDATEQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardsSlashCreateQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_BOARDSSLASHCREATEQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSSLASHCREATEQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardsSlashDeletePathParams {
            /// Unique identifier of a board.
                #[validate(
                        regex = "RE_BOARDSSLASHDELETEPATHPARAMS_BOARD_ID",
                    )]
                pub board_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSSLASHDELETEPATHPARAMS_BOARD_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardsSlashDeleteQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_BOARDSSLASHDELETEQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSSLASHDELETEQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardsSlashGetPathParams {
            /// Unique identifier of a board.
                #[validate(
                        regex = "RE_BOARDSSLASHGETPATHPARAMS_BOARD_ID",
                    )]
                pub board_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSSLASHGETPATHPARAMS_BOARD_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardsSlashGetQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_BOARDSSLASHGETQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSSLASHGETQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardsSlashListQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_BOARDSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// Privacy setting for a board.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "privacy")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub privacy: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardsSlashListPinsPathParams {
            /// Unique identifier of a board.
                #[validate(
                        regex = "RE_BOARDSSLASHLISTPINSPATHPARAMS_BOARD_ID",
                    )]
                pub board_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSSLASHLISTPINSPATHPARAMS_BOARD_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardsSlashListPinsQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// Pin creative types filter. </p><strong>Note:</strong> SHOP_THE_PIN has been deprecated. Please use COLLECTION instead.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "creative_types")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub creative_types: Option<Vec<String>>,
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_BOARDSSLASHLISTPINSQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
            /// Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before <code>2023-03-20</code> lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
                #[serde(rename = "pin_metrics")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pin_metrics: Option<bool>,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSSLASHLISTPINSQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardsSlashUpdatePathParams {
            /// Unique identifier of a board.
                #[validate(
                        regex = "RE_BOARDSSLASHUPDATEPATHPARAMS_BOARD_ID",
                    )]
                pub board_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSSLASHUPDATEPATHPARAMS_BOARD_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardsSlashUpdateQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_BOARDSSLASHUPDATEQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSSLASHUPDATEQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BulkDownloadSlashCreatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_BULKDOWNLOADSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_BULKDOWNLOADSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BulkRequestSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_BULKREQUESTSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
            /// Unique identifier of a bulk upsert request.
                pub bulk_request_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_BULKREQUESTSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BulkRequestSlashGetQueryParams {
            /// if set to True then attach the errors/details to all the requests
                #[serde(rename = "include_details")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub include_details: Option<bool>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BulkUpsertSlashCreatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_BULKUPSERTSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_BULKUPSERTSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CampaignTargetingAnalyticsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_CAMPAIGNTARGETINGANALYTICSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CAMPAIGNTARGETINGANALYTICSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CampaignTargetingAnalyticsSlashGetQueryParams {
            /// List of Campaign Ids to use to filter the results.
                #[serde(rename = "campaign_ids")]
                #[validate(
                        length(min = 1, max = 100),
                    )]
                pub campaign_ids: Vec<String>,
            /// Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
                #[serde(rename = "start_date")]
                pub start_date: chrono::naive::NaiveDate,
            /// Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
                #[serde(rename = "end_date")]
                pub end_date: chrono::naive::NaiveDate,
            /// Targeting type breakdowns for the report. The reporting per targeting type <br> is independent from each other.
                #[serde(rename = "targeting_types")]
                #[validate(
                        length(min = 1, max = 15),
                    )]
                pub targeting_types: Vec<models::AdsAnalyticsTargetingType>,
            /// Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile's currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it's microdollars. Otherwise, it's in microunits of the advertiser's currency.<br/>For example, if the advertiser's currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).<br/>If a column has no value, it may not be returned
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "columns")]
                pub columns: Vec<String>,
            /// TOTAL - metrics are aggregated over the specified date range.<br> DAY - metrics are broken down daily.<br> HOUR - metrics are broken down hourly.<br>WEEKLY - metrics are broken down weekly.<br>MONTHLY - metrics are broken down monthly
                #[serde(rename = "granularity")]
                pub granularity: models::Granularity,
            /// Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "click_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub click_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "engagement_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub engagement_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `1` day.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "view_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub view_window_days: Option<i32>,
            /// The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "conversion_report_time")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub conversion_report_time: Option<String>,
            /// List of types of attribution for the conversion report
                #[serde(rename = "attribution_types")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub attribution_types: Option<models::ConversionReportAttributionType>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CampaignsSlashAnalyticsPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_CAMPAIGNSSLASHANALYTICSPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CAMPAIGNSSLASHANALYTICSPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CampaignsSlashAnalyticsQueryParams {
            /// Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
                #[serde(rename = "start_date")]
                pub start_date: chrono::naive::NaiveDate,
            /// Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
                #[serde(rename = "end_date")]
                pub end_date: chrono::naive::NaiveDate,
            /// List of Campaign Ids to use to filter the results.
                #[serde(rename = "campaign_ids")]
                #[validate(
                        length(min = 1, max = 100),
                    )]
                pub campaign_ids: Vec<String>,
            /// Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile's currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it's microdollars. Otherwise, it's in microunits of the advertiser's currency.<br/>For example, if the advertiser's currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).<br/>If a column has no value, it may not be returned
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "columns")]
                pub columns: Vec<String>,
            /// TOTAL - metrics are aggregated over the specified date range.<br> DAY - metrics are broken down daily.<br> HOUR - metrics are broken down hourly.<br>WEEKLY - metrics are broken down weekly.<br>MONTHLY - metrics are broken down monthly
                #[serde(rename = "granularity")]
                pub granularity: models::Granularity,
            /// Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "click_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub click_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "engagement_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub engagement_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `1` day.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "view_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub view_window_days: Option<i32>,
            /// The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "conversion_report_time")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub conversion_report_time: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CampaignsSlashCreatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_CAMPAIGNSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CAMPAIGNSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CampaignsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_CAMPAIGNSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
            /// Campaign ID, must be associated with the ad account ID provided in the path.
                #[validate(
                        length(max = 18),
                        regex = "RE_CAMPAIGNSSLASHGETPATHPARAMS_CAMPAIGN_ID",
                    )]
                pub campaign_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CAMPAIGNSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_CAMPAIGNSSLASHGETPATHPARAMS_CAMPAIGN_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CampaignsSlashListPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_CAMPAIGNSSLASHLISTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CAMPAIGNSSLASHLISTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CampaignsSlashListQueryParams {
            /// List of Campaign Ids to use to filter the results.
                #[serde(rename = "campaign_ids")]
                #[validate(
                        length(min = 1, max = 100),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub campaign_ids: Option<Vec<String>>,
            /// Entity status
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "entity_statuses")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub entity_statuses: Option<Vec<String>>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// The order in which to sort the items returned: “ASCENDING” or “DESCENDING” by ID. Note that higher-value IDs are associated with more-recently added items.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub order: Option<String>,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CampaignsSlashUpdatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_CAMPAIGNSSLASHUPDATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CAMPAIGNSSLASHUPDATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CatalogsProductGroupPinsSlashListPathParams {
            /// Unique identifier of a product group
                #[validate(
                        regex = "RE_CATALOGSPRODUCTGROUPPINSSLASHLISTPATHPARAMS_PRODUCT_GROUP_ID",
                    )]
                pub product_group_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CATALOGSPRODUCTGROUPPINSSLASHLISTPATHPARAMS_PRODUCT_GROUP_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CatalogsProductGroupPinsSlashListQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_CATALOGSPRODUCTGROUPPINSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_CATALOGSPRODUCTGROUPPINSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CatalogsProductGroupsSlashCreateQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_CATALOGSPRODUCTGROUPSSLASHCREATEQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_CATALOGSPRODUCTGROUPSSLASHCREATEQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CatalogsProductGroupsSlashDeletePathParams {
            /// Unique identifier of a product group
                #[validate(
                        regex = "RE_CATALOGSPRODUCTGROUPSSLASHDELETEPATHPARAMS_PRODUCT_GROUP_ID",
                    )]
                pub product_group_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CATALOGSPRODUCTGROUPSSLASHDELETEPATHPARAMS_PRODUCT_GROUP_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CatalogsProductGroupsSlashDeleteQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_CATALOGSPRODUCTGROUPSSLASHDELETEQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_CATALOGSPRODUCTGROUPSSLASHDELETEQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CatalogsProductGroupsSlashGetPathParams {
            /// Unique identifier of a product group
                #[validate(
                        regex = "RE_CATALOGSPRODUCTGROUPSSLASHGETPATHPARAMS_PRODUCT_GROUP_ID",
                    )]
                pub product_group_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CATALOGSPRODUCTGROUPSSLASHGETPATHPARAMS_PRODUCT_GROUP_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CatalogsProductGroupsSlashGetQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_CATALOGSPRODUCTGROUPSSLASHGETQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_CATALOGSPRODUCTGROUPSSLASHGETQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CatalogsProductGroupsSlashListQueryParams {
            /// Filter entities for a given feed_id. If not given, all feeds are considered.
                #[serde(rename = "feed_id")]
                #[validate(
                        regex = "RE_CATALOGSPRODUCTGROUPSSLASHLISTQUERYPARAMS_FEED_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub feed_id: Option<String>,
            /// Filter entities for a given catalog_id. If not given, all catalogs are considered.
                #[serde(rename = "catalog_id")]
                #[validate(
                        regex = "RE_CATALOGSPRODUCTGROUPSSLASHLISTQUERYPARAMS_CATALOG_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub catalog_id: Option<String>,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_CATALOGSPRODUCTGROUPSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_CATALOGSPRODUCTGROUPSSLASHLISTQUERYPARAMS_FEED_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_CATALOGSPRODUCTGROUPSSLASHLISTQUERYPARAMS_CATALOG_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_CATALOGSPRODUCTGROUPSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CatalogsProductGroupsSlashProductCountsGetPathParams {
            /// Unique identifier of a product group
                #[validate(
                        regex = "RE_CATALOGSPRODUCTGROUPSSLASHPRODUCTCOUNTSGETPATHPARAMS_PRODUCT_GROUP_ID",
                    )]
                pub product_group_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CATALOGSPRODUCTGROUPSSLASHPRODUCTCOUNTSGETPATHPARAMS_PRODUCT_GROUP_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CatalogsProductGroupsSlashProductCountsGetQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_CATALOGSPRODUCTGROUPSSLASHPRODUCTCOUNTSGETQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_CATALOGSPRODUCTGROUPSSLASHPRODUCTCOUNTSGETQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CatalogsProductGroupsSlashUpdatePathParams {
            /// Unique identifier of a product group
                #[validate(
                        regex = "RE_CATALOGSPRODUCTGROUPSSLASHUPDATEPATHPARAMS_PRODUCT_GROUP_ID",
                    )]
                pub product_group_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CATALOGSPRODUCTGROUPSSLASHUPDATEPATHPARAMS_PRODUCT_GROUP_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CatalogsProductGroupsSlashUpdateQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_CATALOGSPRODUCTGROUPSSLASHUPDATEQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_CATALOGSPRODUCTGROUPSSLASHUPDATEQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CatalogsSlashListQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_CATALOGSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_CATALOGSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct FeedProcessingResultsSlashListPathParams {
            /// Unique identifier of a feed
                #[validate(
                        regex = "RE_FEEDPROCESSINGRESULTSSLASHLISTPATHPARAMS_FEED_ID",
                    )]
                pub feed_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_FEEDPROCESSINGRESULTSSLASHLISTPATHPARAMS_FEED_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct FeedProcessingResultsSlashListQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_FEEDPROCESSINGRESULTSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_FEEDPROCESSINGRESULTSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct FeedsSlashCreateQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_FEEDSSLASHCREATEQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_FEEDSSLASHCREATEQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct FeedsSlashDeletePathParams {
            /// Unique identifier of a feed
                #[validate(
                        regex = "RE_FEEDSSLASHDELETEPATHPARAMS_FEED_ID",
                    )]
                pub feed_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_FEEDSSLASHDELETEPATHPARAMS_FEED_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct FeedsSlashDeleteQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_FEEDSSLASHDELETEQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_FEEDSSLASHDELETEQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct FeedsSlashGetPathParams {
            /// Unique identifier of a feed
                #[validate(
                        regex = "RE_FEEDSSLASHGETPATHPARAMS_FEED_ID",
                    )]
                pub feed_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_FEEDSSLASHGETPATHPARAMS_FEED_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct FeedsSlashGetQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_FEEDSSLASHGETQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_FEEDSSLASHGETQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct FeedsSlashListQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// Filter entities for a given catalog_id. If not given, all catalogs are considered.
                #[serde(rename = "catalog_id")]
                #[validate(
                        regex = "RE_FEEDSSLASHLISTQUERYPARAMS_CATALOG_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub catalog_id: Option<String>,
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_FEEDSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_FEEDSSLASHLISTQUERYPARAMS_CATALOG_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_FEEDSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct FeedsSlashUpdatePathParams {
            /// Unique identifier of a feed
                #[validate(
                        regex = "RE_FEEDSSLASHUPDATEPATHPARAMS_FEED_ID",
                    )]
                pub feed_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_FEEDSSLASHUPDATEPATHPARAMS_FEED_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct FeedsSlashUpdateQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_FEEDSSLASHUPDATEQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_FEEDSSLASHUPDATEQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ItemsBatchSlashGetPathParams {
            /// Id of a catalogs items batch to fetch
                pub batch_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ItemsBatchSlashGetQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_ITEMSBATCHSLASHGETQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_ITEMSBATCHSLASHGETQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ItemsBatchSlashPostQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_ITEMSBATCHSLASHPOSTQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_ITEMSBATCHSLASHPOSTQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ItemsIssuesSlashListPathParams {
            /// Unique identifier of a feed processing result. It can be acquired from the \"id\" field of the \"items\" array within the response of the [List processing results for a given feed](https://developers.pinterest.com/docs/api/v5/#operation/feed_processing_results/list).
                #[validate(
                        regex = "RE_ITEMSISSUESSLASHLISTPATHPARAMS_PROCESSING_RESULT_ID",
                    )]
                pub processing_result_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ITEMSISSUESSLASHLISTPATHPARAMS_PROCESSING_RESULT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ItemsIssuesSlashListQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// Item number based on order of appearance in the Catalogs Feed. For example, '0' refers to first item found in a feed that was downloaded from a 'location' specified during feed creation.
                #[serde(rename = "item_numbers")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub item_numbers: Option<Vec<i32>>,
            /// Filter item validation issues that have a given type of item validation issue.
                #[serde(rename = "item_validation_issue")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub item_validation_issue: Option<models::CatalogsItemValidationIssue>,
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_ITEMSISSUESSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_ITEMSISSUESSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ItemsSlashGetQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_ITEMSSLASHGETQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
            /// Country for the Catalogs Items
                #[serde(rename = "country")]
                pub country: String,
            /// Language for the Catalogs Items
                #[serde(rename = "language")]
                pub language: String,
            /// This parameter is deprecated. Use filters instead.
                #[serde(rename = "item_ids")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub item_ids: Option<Vec<String>>,
            /// Identifies items to be retrieved. This is a required parameter.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<models::OneOfLessThanCatalogsRetailItemsFilterCommaCatalogsHotelItemsFilterGreaterThan>,
    }

    lazy_static::lazy_static! {
        static ref RE_ITEMSSLASHGETQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ProductsByProductGroupFilterSlashListQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_PRODUCTSBYPRODUCTGROUPFILTERSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_PRODUCTSBYPRODUCTGROUPFILTERSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct EventsSlashCreatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_EVENTSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_EVENTSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct EventsSlashCreateQueryParams {
            /// Include query param ?test=true to mark the request as a test request. The events will not be recorded but the API will still return the same response messages. Use this mode to verify your requests are working and your events are constructed correctly. Warning: If you use this query parameter, be certain that it is off (set to false or deleted) before sending a legitimate (non-testing) request.
                #[serde(rename = "test")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub test: Option<bool>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ConversionTagsSlashCreatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_CONVERSIONTAGSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CONVERSIONTAGSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ConversionTagsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_CONVERSIONTAGSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
            /// Id of the conversion tag.
                #[validate(
                        length(max = 18),
                        regex = "RE_CONVERSIONTAGSSLASHGETPATHPARAMS_CONVERSION_TAG_ID",
                    )]
                pub conversion_tag_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CONVERSIONTAGSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_CONVERSIONTAGSSLASHGETPATHPARAMS_CONVERSION_TAG_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ConversionTagsSlashListPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_CONVERSIONTAGSSLASHLISTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CONVERSIONTAGSSLASHLISTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ConversionTagsSlashListQueryParams {
            /// Filter out deleted tags.
                #[serde(rename = "filter_deleted")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filter_deleted: Option<bool>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct OcpmEligibleConversionTagsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_OCPMELIGIBLECONVERSIONTAGSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_OCPMELIGIBLECONVERSIONTAGSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct PageVisitConversionTagsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_PAGEVISITCONVERSIONTAGSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_PAGEVISITCONVERSIONTAGSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct PageVisitConversionTagsSlashGetQueryParams {
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// The order in which to sort the items returned: “ASCENDING” or “DESCENDING” by ID. Note that higher-value IDs are associated with more-recently added items.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub order: Option<String>,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CustomerListsSlashCreatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_CUSTOMERLISTSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CUSTOMERLISTSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CustomerListsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_CUSTOMERLISTSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
            /// Unique identifier of a customer list
                #[validate(
                        length(max = 18),
                        regex = "RE_CUSTOMERLISTSSLASHGETPATHPARAMS_CUSTOMER_LIST_ID",
                    )]
                pub customer_list_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CUSTOMERLISTSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_CUSTOMERLISTSSLASHGETPATHPARAMS_CUSTOMER_LIST_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CustomerListsSlashListPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_CUSTOMERLISTSSLASHLISTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CUSTOMERLISTSSLASHLISTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CustomerListsSlashListQueryParams {
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// The order in which to sort the items returned: “ASCENDING” or “DESCENDING” by ID. Note that higher-value IDs are associated with more-recently added items.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub order: Option<String>,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CustomerListsSlashUpdatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_CUSTOMERLISTSSLASHUPDATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
            /// Unique identifier of a customer list
                #[validate(
                        length(max = 18),
                        regex = "RE_CUSTOMERLISTSSLASHUPDATEPATHPARAMS_CUSTOMER_LIST_ID",
                    )]
                pub customer_list_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_CUSTOMERLISTSSLASHUPDATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_CUSTOMERLISTSSLASHUPDATEPATHPARAMS_CUSTOMER_LIST_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct IntegrationsCommerceSlashDelPathParams {
            /// External business ID for the integration.
                pub external_business_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct IntegrationsCommerceSlashGetPathParams {
            /// External business ID for the integration.
                pub external_business_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct IntegrationsCommerceSlashPatchPathParams {
            /// External business ID for the integration.
                pub external_business_id: String,
    }


      
      
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct IntegrationsSlashGetByIdPathParams {
            /// Integration ID.
                pub id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct IntegrationsSlashGetListQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CountryKeywordsMetricsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_COUNTRYKEYWORDSMETRICSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_COUNTRYKEYWORDSMETRICSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CountryKeywordsMetricsSlashGetQueryParams {
            /// Two letter country code (ISO 3166-1 alpha-2)
                #[serde(rename = "country_code")]
                pub country_code: String,
            /// Comma-separated keywords
                #[serde(rename = "keywords")]
                #[validate(
                        length(min = 1, max = 2000),
                    )]
                pub keywords: Vec<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct KeywordsSlashCreatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_KEYWORDSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_KEYWORDSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct KeywordsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_KEYWORDSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_KEYWORDSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct KeywordsSlashGetQueryParams {
            /// Campaign Id to use to filter the results.
                #[serde(rename = "campaign_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_KEYWORDSSLASHGETQUERYPARAMS_CAMPAIGN_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub campaign_id: Option<String>,
            /// Ad group Id.
                #[serde(rename = "ad_group_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_KEYWORDSSLASHGETQUERYPARAMS_AD_GROUP_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_group_id: Option<String>,
            /// Keyword <a target=\"_blank\" href=\"/docs/ads/targeting/#Match%20type%20and%20targeting%20level\">match type</a>
                #[serde(rename = "match_types")]
                #[validate(
                        length(min = 1, max = 5),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub match_types: Option<Vec<models::MatchType>>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_KEYWORDSSLASHGETQUERYPARAMS_CAMPAIGN_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_KEYWORDSSLASHGETQUERYPARAMS_AD_GROUP_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct KeywordsSlashUpdatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_KEYWORDSSLASHUPDATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_KEYWORDSSLASHUPDATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct TrendingKeywordsSlashListPathParams {
            /// The geographic region of interest. Only top trends within the specified region will be returned.<br /> The `region` parameter is formatted as ISO 3166-2 country codes delimited by `+`, corresponding to the following geographic areas: - `US` - United States - `CA` - Canada - `DE` - Germany - `FR` - France - `ES` - Spain - `IT` - Italy - `DE+AT+CH` - Germanic countries - `GB+IE` - Great Britain & Ireland - `IT+ES+PT+GR+MT` - Southern Europe - `PL+RO+HU+SK+CZ` - Eastern Europe - `SE+DK+FI+NO` - Nordic countries - `NL+BE+LU` - Benelux - `AR` - Argentina - `BR` - Brazil - `CO` - Colombia - `MX` - Mexico - `MX+AR+CO+CL` - Hispanic LatAm - `AU+NZ` - Australasia
                pub region: models::TrendsSupportedRegion,
            /// The methodology used to rank how trendy a keyword is. - `growing` trends have high upward growth in search volume over the last quarter - `monthly` trends have high search volume in the last month - `yearly` trends have high search volume in the last year - `seasonal` trends have high upward growth in search volume over the last month and exhibit a seasonal recurring pattern (typically annual)
                pub trend_type: models::TrendType,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct TrendingKeywordsSlashListQueryParams {
            /// If set, filters the results to trends associated with the specified interests.<br /> If unset, trends for all interests will be returned.<br /> The list of supported interests is: - `animals` - Animals - `architecture` - Architecture - `art` - Art - `beauty` - Beauty - `childrens_fashion` - Children's Fashion - `design` - Design - `diy_and_crafts` - DIY & Crafts - `education` - Education - `electronics` - Electronics - `entertainment` - Entertainment - `event_planning` - Event Planning - `finance` - Finance - `food_and_drinks` - Food & Drink - `gardening` - Gardening - `health` - Health - `home_decor` - Home Decor - `mens_fashion` - Men's Fashion - `parenting` - Parenting - `quotes` - Quotes - `sport` - Sports - `travel` - Travel - `vehicles` - Vehicles - `wedding` - Wedding - `womens_fashion` - Women's Fashion
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "interests")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub interests: Option<Vec<String>>,
            /// If set, filters the results to trends among users who identify with the specified gender(s).<br /> If unset, trends among all genders will be returned.<br /> The `unknown` group includes users with unspecified or customized gender profile settings.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "genders")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub genders: Option<Vec<String>>,
            /// If set, filters the results to trends among users in the specified age range(s).<br /> If unset, trends among all age groups will be returned.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "ages")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ages: Option<Vec<String>>,
            /// Governs how the resulting time series data will be normalized to a [0-100] scale.<br /> By default (`false`), the data will be normalized independently for each keyword.  The peak search volume observation in *each* keyword's time series will be represented by the value 100.  This is ideal for analyzing when an individual keyword is expected to peak in interest.<br /> If set to `true`, the data will be normalized as a group.  The peak search volume observation across *all* keywords in the response will be represented by the value 100, and all other values scaled accordingly.  Use this option when you wish to compare relative search volume between multiple keywords.
                #[serde(rename = "normalize_against_group")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub normalize_against_group: Option<bool>,
            /// The maximum number of trending keywords that will be returned. Keywords are returned in trend-ranked order, so a `limit` of 50 will return the top 50 trends.
                #[serde(rename = "limit")]
                #[validate(
                        range(min = 1, max = 50),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub limit: Option<i32>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdAccountsSubscriptionsSlashDelByIdPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADACCOUNTSSUBSCRIPTIONSSLASHDELBYIDPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
            /// Unique identifier of a subscription.
                #[validate(
                        regex = "RE_ADACCOUNTSSUBSCRIPTIONSSLASHDELBYIDPATHPARAMS_SUBSCRIPTION_ID",
                    )]
                pub subscription_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADACCOUNTSSUBSCRIPTIONSSLASHDELBYIDPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_ADACCOUNTSSUBSCRIPTIONSSLASHDELBYIDPATHPARAMS_SUBSCRIPTION_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdAccountsSubscriptionsSlashGetByIdPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADACCOUNTSSUBSCRIPTIONSSLASHGETBYIDPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
            /// Unique identifier of a subscription.
                #[validate(
                        regex = "RE_ADACCOUNTSSUBSCRIPTIONSSLASHGETBYIDPATHPARAMS_SUBSCRIPTION_ID",
                    )]
                pub subscription_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADACCOUNTSSUBSCRIPTIONSSLASHGETBYIDPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_ADACCOUNTSSUBSCRIPTIONSSLASHGETBYIDPATHPARAMS_SUBSCRIPTION_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdAccountsSubscriptionsSlashGetListPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADACCOUNTSSUBSCRIPTIONSSLASHGETLISTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADACCOUNTSSUBSCRIPTIONSSLASHGETLISTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdAccountsSubscriptionsSlashGetListQueryParams {
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdAccountsSubscriptionsSlashPostPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADACCOUNTSSUBSCRIPTIONSSLASHPOSTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADACCOUNTSSUBSCRIPTIONSSLASHPOSTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct LeadFormSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_LEADFORMSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
            /// Unique identifier of a lead form.
                #[validate(
                        regex = "RE_LEADFORMSLASHGETPATHPARAMS_LEAD_FORM_ID",
                    )]
                pub lead_form_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_LEADFORMSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_LEADFORMSLASHGETPATHPARAMS_LEAD_FORM_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct LeadFormTestSlashCreatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_LEADFORMTESTSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
            /// Unique identifier of a lead form.
                #[validate(
                        regex = "RE_LEADFORMTESTSLASHCREATEPATHPARAMS_LEAD_FORM_ID",
                    )]
                pub lead_form_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_LEADFORMTESTSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_LEADFORMTESTSLASHCREATEPATHPARAMS_LEAD_FORM_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct LeadFormsSlashListPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_LEADFORMSSLASHLISTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_LEADFORMSSLASHLISTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct LeadFormsSlashListQueryParams {
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// The order in which to sort the items returned: “ASCENDING” or “DESCENDING” by ID. Note that higher-value IDs are associated with more-recently added items.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub order: Option<String>,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
    }

      
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct MediaSlashGetPathParams {
            /// Media identifier
                #[validate(
                        regex = "RE_MEDIASLASHGETPATHPARAMS_MEDIA_ID",
                    )]
                pub media_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_MEDIASLASHGETPATHPARAMS_MEDIA_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct MediaSlashListQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
    }

      
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct OrderLinesSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ORDERLINESSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
            /// Unique identifier of an order line.
                #[validate(
                        length(max = 18),
                        regex = "RE_ORDERLINESSLASHGETPATHPARAMS_ORDER_LINE_ID",
                    )]
                pub order_line_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ORDERLINESSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_ORDERLINESSLASHGETPATHPARAMS_ORDER_LINE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct OrderLinesSlashListPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ORDERLINESSLASHLISTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ORDERLINESSLASHLISTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct OrderLinesSlashListQueryParams {
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// The order in which to sort the items returned: “ASCENDING” or “DESCENDING” by ID. Note that higher-value IDs are associated with more-recently added items.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub order: Option<String>,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct PinsSlashAnalyticsPathParams {
            /// Unique identifier of a Pin.
                pub pin_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct PinsSlashAnalyticsQueryParams {
            /// Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
                #[serde(rename = "start_date")]
                pub start_date: chrono::naive::NaiveDate,
            /// Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
                #[serde(rename = "end_date")]
                pub end_date: chrono::naive::NaiveDate,
            /// Apps or devices to get data for, default is all.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "app_types")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub app_types: Option<String>,
            /// Pin metric types to get data for, default is all.
                #[serde(rename = "metric_types")]
                pub metric_types: Vec<models::PinsAnalyticsMetricTypesParameterInner>,
            /// How to split the data into groups. Not including this param means data won't be split.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "split_field")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub split_field: Option<String>,
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_PINSSLASHANALYTICSQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_PINSSLASHANALYTICSQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct PinsSlashCreateQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_PINSSLASHCREATEQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_PINSSLASHCREATEQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct PinsSlashDeletePathParams {
            /// Unique identifier of a Pin.
                pub pin_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct PinsSlashDeleteQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_PINSSLASHDELETEQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_PINSSLASHDELETEQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct PinsSlashGetPathParams {
            /// Unique identifier of a Pin.
                pub pin_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct PinsSlashGetQueryParams {
            /// Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before <code>2023-03-20</code> lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
                #[serde(rename = "pin_metrics")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pin_metrics: Option<bool>,
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_PINSSLASHGETQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_PINSSLASHGETQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct PinsSlashListQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// Pin filter.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "pin_filter")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pin_filter: Option<String>,
            /// Specify if return pins from protected boards
                #[serde(rename = "include_protected_pins")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub include_protected_pins: Option<bool>,
            /// The type of pins to return, currently only enabled for private pins
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "pin_type")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pin_type: Option<String>,
            /// Pin creative types filter. </p><strong>Note:</strong> SHOP_THE_PIN has been deprecated. Please use COLLECTION instead.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "creative_types")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub creative_types: Option<Vec<String>>,
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_PINSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
            /// Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before <code>2023-03-20</code> lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
                #[serde(rename = "pin_metrics")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pin_metrics: Option<bool>,
    }

    lazy_static::lazy_static! {
        static ref RE_PINSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct PinsSlashSavePathParams {
            /// Unique identifier of a Pin.
                pub pin_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct PinsSlashSaveQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_PINSSLASHSAVEQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_PINSSLASHSAVEQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct PinsSlashUpdatePathParams {
            /// Unique identifier of a Pin.
                pub pin_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct PinsSlashUpdateQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_PINSSLASHUPDATEQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_PINSSLASHUPDATEQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ProductGroupPromotionsSlashCreatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_PRODUCTGROUPPROMOTIONSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_PRODUCTGROUPPROMOTIONSSLASHCREATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ProductGroupPromotionsSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_PRODUCTGROUPPROMOTIONSSLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
            /// Unique identifier of a product group promotion
                #[validate(
                        length(max = 18),
                        regex = "RE_PRODUCTGROUPPROMOTIONSSLASHGETPATHPARAMS_PRODUCT_GROUP_PROMOTION_ID",
                    )]
                pub product_group_promotion_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_PRODUCTGROUPPROMOTIONSSLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_PRODUCTGROUPPROMOTIONSSLASHGETPATHPARAMS_PRODUCT_GROUP_PROMOTION_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ProductGroupPromotionsSlashListPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_PRODUCTGROUPPROMOTIONSSLASHLISTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_PRODUCTGROUPPROMOTIONSSLASHLISTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ProductGroupPromotionsSlashListQueryParams {
            /// List of Product group promotion Ids.
                #[serde(rename = "product_group_promotion_ids")]
                #[validate(
                        length(min = 1, max = 100),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub product_group_promotion_ids: Option<Vec<String>>,
            /// Entity status
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "entity_statuses")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub entity_statuses: Option<Vec<String>>,
            /// Ad group Id.
                #[serde(rename = "ad_group_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_PRODUCTGROUPPROMOTIONSSLASHLISTQUERYPARAMS_AD_GROUP_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_group_id: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// The order in which to sort the items returned: “ASCENDING” or “DESCENDING” by ID. Note that higher-value IDs are associated with more-recently added items.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub order: Option<String>,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_PRODUCTGROUPPROMOTIONSSLASHLISTQUERYPARAMS_AD_GROUP_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ProductGroupPromotionsSlashUpdatePathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_PRODUCTGROUPPROMOTIONSSLASHUPDATEPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_PRODUCTGROUPPROMOTIONSSLASHUPDATEPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ProductGroupsSlashAnalyticsPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_PRODUCTGROUPSSLASHANALYTICSPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_PRODUCTGROUPSSLASHANALYTICSPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ProductGroupsSlashAnalyticsQueryParams {
            /// Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
                #[serde(rename = "start_date")]
                pub start_date: chrono::naive::NaiveDate,
            /// Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
                #[serde(rename = "end_date")]
                pub end_date: chrono::naive::NaiveDate,
            /// List of Product group Ids to use to filter the results.
                #[serde(rename = "product_group_ids")]
                #[validate(
                        length(min = 1, max = 100),
                    )]
                pub product_group_ids: Vec<String>,
            /// Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile's currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it's microdollars. Otherwise, it's in microunits of the advertiser's currency.<br/>For example, if the advertiser's currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).<br/>If a column has no value, it may not be returned
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "columns")]
                pub columns: Vec<String>,
            /// TOTAL - metrics are aggregated over the specified date range.<br> DAY - metrics are broken down daily.<br> HOUR - metrics are broken down hourly.<br>WEEKLY - metrics are broken down weekly.<br>MONTHLY - metrics are broken down monthly
                #[serde(rename = "granularity")]
                pub granularity: models::Granularity,
            /// Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "click_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub click_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "engagement_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub engagement_window_days: Option<i32>,
            /// Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `1` day.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "view_window_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub view_window_days: Option<i32>,
            /// The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "conversion_report_time")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub conversion_report_time: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdAccountsCatalogsProductGroupsSlashListPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_ADACCOUNTSCATALOGSPRODUCTGROUPSSLASHLISTPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_ADACCOUNTSCATALOGSPRODUCTGROUPSSLASHLISTPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct AdAccountsCatalogsProductGroupsSlashListQueryParams {
            /// The feed profile id whose catalog product groups we want to return.
                #[serde(rename = "feed_profile_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_ADACCOUNTSCATALOGSPRODUCTGROUPSSLASHLISTQUERYPARAMS_FEED_PROFILE_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub feed_profile_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_ADACCOUNTSCATALOGSPRODUCTGROUPSSLASHLISTQUERYPARAMS_FEED_PROFILE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct DeliveryMetricsSlashGetQueryParams {
            /// Report type.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "report_type")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub report_type: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct InterestTargetingOptionsSlashGetPathParams {
            /// Unique identifier of an interest.
                #[validate(
                        length(max = 18),
                        regex = "RE_INTERESTTARGETINGOPTIONSSLASHGETPATHPARAMS_INTEREST_ID",
                    )]
                pub interest_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_INTERESTTARGETINGOPTIONSSLASHGETPATHPARAMS_INTEREST_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

      
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct MetricsReadyStateSlashGetQueryParams {
            /// Analytics reports request date (UTC). Format: YYYY-MM-DD
                #[serde(rename = "date")]
                #[validate(
                        regex = "RE_METRICSREADYSTATESLASHGETQUERYPARAMS_DATE",
                    )]
                pub date: String,
    }

    lazy_static::lazy_static! {
        static ref RE_METRICSREADYSTATESLASHGETQUERYPARAMS_DATE: regex::Regex = regex::Regex::new(r"^(\\d{4})-(\\d{2})-(\\d{2})$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct TargetingOptionsSlashGetPathParams {
            /// Public targeting type.
            /// Note: inline enums are not fully supported by openapi-generator
                pub targeting_type: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct TargetingOptionsSlashGetQueryParams {
            /// Client ID.
                #[serde(rename = "client_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_TARGETINGOPTIONSSLASHGETQUERYPARAMS_CLIENT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub client_id: Option<String>,
            /// Oauth signature
                #[serde(rename = "oauth_signature")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub oauth_signature: Option<String>,
            /// Timestamp
                #[serde(rename = "timestamp")]
                #[validate(
                        regex = "RE_TARGETINGOPTIONSSLASHGETQUERYPARAMS_TIMESTAMP",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub timestamp: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_TARGETINGOPTIONSSLASHGETQUERYPARAMS_CLIENT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
    lazy_static::lazy_static! {
        static ref RE_TARGETINGOPTIONSSLASHGETQUERYPARAMS_TIMESTAMP: regex::Regex = regex::Regex::new(r"\\d+").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct SearchPartnerPinsQueryParams {
            /// Search term to look up pins.
                #[serde(rename = "term")]
                pub term: String,
            /// Two letter country code (ISO 3166-1 alpha-2)
                #[serde(rename = "country_code")]
                pub country_code: String,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Search locale.
                #[serde(rename = "locale")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub locale: Option<String>,
            /// Max search result size
                #[serde(rename = "limit")]
                #[validate(
                        range(min = 1, max = 50),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub limit: Option<i32>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct SearchUserBoardsSlashGetQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_SEARCHUSERBOARDSSLASHGETQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// Search query. Can contain pin description keywords or comma-separated pin IDs.
                #[serde(rename = "query")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub query: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_SEARCHUSERBOARDSSLASHGETQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct SearchUserPinsSlashListQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_SEARCHUSERPINSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
            /// Search query. Can contain pin description keywords or comma-separated pin IDs.
                #[serde(rename = "query")]
                pub query: String,
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_SEARCHUSERPINSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct TermsRelatedSlashListQueryParams {
            /// List of input terms.
                #[serde(rename = "terms")]
                pub terms: Vec<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct TermsSuggestedSlashListQueryParams {
            /// Input term.
                #[serde(rename = "term")]
                pub term: String,
            /// Max suggested terms to return.
                #[serde(rename = "limit")]
                #[validate(
                        range(min = 1, max = 10),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub limit: Option<i32>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct TermsOfServiceSlashGetPathParams {
            /// Unique identifier of an ad account.
                #[validate(
                        length(max = 18),
                        regex = "RE_TERMSOFSERVICESLASHGETPATHPARAMS_AD_ACCOUNT_ID",
                    )]
                pub ad_account_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_TERMSOFSERVICESLASHGETPATHPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct TermsOfServiceSlashGetQueryParams {
            /// Return HTML in TOS text.
                #[serde(rename = "include_html")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub include_html: Option<bool>,
            /// Request type.
                #[serde(rename = "tos_type")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tos_type: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct BoardsUserFollowsSlashListQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows.
                #[serde(rename = "explicit_following")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub explicit_following: Option<bool>,
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_BOARDSUSERFOLLOWSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_BOARDSUSERFOLLOWSSLASHLISTQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct FollowUserSlashUpdatePathParams {
            /// A valid username
                #[validate(
                        regex = "RE_FOLLOWUSERSLASHUPDATEPATHPARAMS_USERNAME",
                    )]
                pub username: String,
    }

    lazy_static::lazy_static! {
        static ref RE_FOLLOWUSERSLASHUPDATEPATHPARAMS_USERNAME: regex::Regex = regex::Regex::new(r"(?!^\\d+$)^.+$").unwrap();
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct FollowersSlashListQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
    }

      
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct UnverifyWebsiteSlashDeleteQueryParams {
            /// Website with path or domain only
                #[serde(rename = "website")]
                pub website: String,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct UserAccountSlashAnalyticsQueryParams {
            /// Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
                #[serde(rename = "start_date")]
                pub start_date: chrono::naive::NaiveDate,
            /// Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
                #[serde(rename = "end_date")]
                pub end_date: chrono::naive::NaiveDate,
            /// Filter on Pins that match your claimed domain.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "from_claimed_content")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub from_claimed_content: Option<String>,
            /// Pin formats to get data for, default is all.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "pin_format")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pin_format: Option<String>,
            /// Apps or devices to get data for, default is all.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "app_types")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub app_types: Option<String>,
            /// Filter to paid or organic data. Default is all.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "content_type")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub content_type: Option<String>,
            /// Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "source")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub source: Option<String>,
            /// Metric types to get data for, default is all. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "metric_types")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub metric_types: Option<Vec<String>>,
            /// How to split the data into groups. Not including this param means data won't be split.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "split_field")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub split_field: Option<String>,
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_USERACCOUNTSLASHANALYTICSQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_USERACCOUNTSLASHANALYTICSQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct UserAccountSlashAnalyticsSlashTopPinsQueryParams {
            /// Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
                #[serde(rename = "start_date")]
                pub start_date: chrono::naive::NaiveDate,
            /// Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
                #[serde(rename = "end_date")]
                pub end_date: chrono::naive::NaiveDate,
            /// Specify sorting order for metrics
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "sort_by")]
                pub sort_by: String,
            /// Filter on Pins that match your claimed domain.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "from_claimed_content")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub from_claimed_content: Option<String>,
            /// Pin formats to get data for, default is all.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "pin_format")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pin_format: Option<String>,
            /// Apps or devices to get data for, default is all.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "app_types")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub app_types: Option<String>,
            /// Filter to paid or organic data. Default is all.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "content_type")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub content_type: Option<String>,
            /// Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "source")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub source: Option<String>,
            /// Metric types to get data for, default is all. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "metric_types")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub metric_types: Option<Vec<String>>,
            /// Number of pins to include, default is 10. Max is 50.
                #[serde(rename = "num_of_pins")]
                #[validate(
                        range(min = 1, max = 50),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub num_of_pins: Option<i32>,
            /// Get metrics for pins created in the last \"n\" days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "created_in_last_n_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub created_in_last_n_days: Option<i32>,
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_USERACCOUNTSLASHANALYTICSSLASHTOPPINSQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_USERACCOUNTSLASHANALYTICSSLASHTOPPINSQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct UserAccountSlashAnalyticsSlashTopVideoPinsQueryParams {
            /// Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
                #[serde(rename = "start_date")]
                pub start_date: chrono::naive::NaiveDate,
            /// Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
                #[serde(rename = "end_date")]
                pub end_date: chrono::naive::NaiveDate,
            /// Specify sorting order for video metrics
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "sort_by")]
                pub sort_by: String,
            /// Filter on Pins that match your claimed domain.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "from_claimed_content")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub from_claimed_content: Option<String>,
            /// Pin formats to get data for, default is all.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "pin_format")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pin_format: Option<String>,
            /// Apps or devices to get data for, default is all.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "app_types")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub app_types: Option<String>,
            /// Filter to paid or organic data. Default is all.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "content_type")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub content_type: Option<String>,
            /// Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "source")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub source: Option<String>,
            /// Metric types to get video data for, default is all. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "metric_types")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub metric_types: Option<Vec<String>>,
            /// Number of pins to include, default is 10. Max is 50.
                #[serde(rename = "num_of_pins")]
                #[validate(
                        range(min = 1, max = 50),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub num_of_pins: Option<i32>,
            /// Get metrics for pins created in the last \"n\" days.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "created_in_last_n_days")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub created_in_last_n_days: Option<i32>,
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_USERACCOUNTSLASHANALYTICSSLASHTOPVIDEOPINSQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_USERACCOUNTSLASHANALYTICSSLASHTOPVIDEOPINSQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct UserAccountSlashFollowedInterestsPathParams {
            /// A valid username
                #[validate(
                        regex = "RE_USERACCOUNTSLASHFOLLOWEDINTERESTSPATHPARAMS_USERNAME",
                    )]
                pub username: String,
    }

    lazy_static::lazy_static! {
        static ref RE_USERACCOUNTSLASHFOLLOWEDINTERESTSPATHPARAMS_USERNAME: regex::Regex = regex::Regex::new(r"(?!^\\d+$)^.+$").unwrap();
    }

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct UserAccountSlashFollowedInterestsQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct UserAccountSlashGetQueryParams {
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_USERACCOUNTSLASHGETQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_USERACCOUNTSLASHGETQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct UserFollowingSlashGetQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
            /// Thrift param specifying what type of followees will be kept. Default to include all followees.
                #[serde(rename = "feed_type")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub feed_type: Option<models::UserFollowingFeedType>,
            /// Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows.
                #[serde(rename = "explicit_following")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub explicit_following: Option<bool>,
            /// Unique identifier of an ad account.
                #[serde(rename = "ad_account_id")]
                #[validate(
                        length(max = 18),
                        regex = "RE_USERFOLLOWINGSLASHGETQUERYPARAMS_AD_ACCOUNT_ID",
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ad_account_id: Option<String>,
    }

    lazy_static::lazy_static! {
        static ref RE_USERFOLLOWINGSLASHGETQUERYPARAMS_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
    }
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct UserWebsitesSlashGetQueryParams {
            /// Cursor used to fetch the next page of items
                #[serde(rename = "bookmark")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub bookmark: Option<String>,
            /// Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/getting-started/pagination/'>Pagination</a> for more information.
                #[serde(rename = "page_size")]
                #[validate(
                        range(min = 1, max = 250),
                    )]
                #[serde(skip_serializing_if="Option::is_none")]
                pub page_size: Option<i32>,
    }

      
      





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Account {
/// Type of account
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "account_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account_type: Option<String>,

/// User account ID.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_ACCOUNT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "profile_image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub profile_image: Option<String>,

    #[serde(rename = "website_url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub website_url: Option<String>,

    #[serde(rename = "username")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,

/// Profile about description.
    #[serde(rename = "about")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub about: Option<String>,

    #[serde(rename = "business_name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub business_name: Option<Nullable<String>>,

/// User account board count.<br/>**Note**: Board count on user account level may differ from counts found elsewhere due to attribution of collaborative Boards.
    #[serde(rename = "board_count")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub board_count: Option<Nullable<i32>>,

/// User account pin count. This includes both created and saved pins.
    #[serde(rename = "pin_count")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pin_count: Option<Nullable<i32>>,

/// User account follower count.
    #[serde(rename = "follower_count")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub follower_count: Option<Nullable<i32>>,

/// User account following count.
    #[serde(rename = "following_count")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_count: Option<Nullable<i32>>,

/// User account monthly views.
    #[serde(rename = "monthly_views")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub monthly_views: Option<Nullable<i32>>,

}

lazy_static::lazy_static! {
    static ref RE_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl Account {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Account {
        Account {
            account_type: None,
            id: None,
            profile_image: None,
            website_url: None,
            username: None,
            about: None,
            business_name: None,
            board_count: None,
            pin_count: None,
            follower_count: None,
            following_count: None,
            monthly_views: None,
        }
    }
}

/// Converts the Account value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Account {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.account_type.as_ref().map(|account_type| {
                [
                    "account_type".to_string(),
                    account_type.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.profile_image.as_ref().map(|profile_image| {
                [
                    "profile_image".to_string(),
                    profile_image.to_string(),
                ].join(",")
            }),


            self.website_url.as_ref().map(|website_url| {
                [
                    "website_url".to_string(),
                    website_url.to_string(),
                ].join(",")
            }),


            self.username.as_ref().map(|username| {
                [
                    "username".to_string(),
                    username.to_string(),
                ].join(",")
            }),


            self.about.as_ref().map(|about| {
                [
                    "about".to_string(),
                    about.to_string(),
                ].join(",")
            }),


            self.business_name.as_ref().map(|business_name| {
                [
                    "business_name".to_string(),
                    business_name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.board_count.as_ref().map(|board_count| {
                [
                    "board_count".to_string(),
                    board_count.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.pin_count.as_ref().map(|pin_count| {
                [
                    "pin_count".to_string(),
                    pin_count.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.follower_count.as_ref().map(|follower_count| {
                [
                    "follower_count".to_string(),
                    follower_count.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.following_count.as_ref().map(|following_count| {
                [
                    "following_count".to_string(),
                    following_count.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.monthly_views.as_ref().map(|monthly_views| {
                [
                    "monthly_views".to_string(),
                    monthly_views.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Account value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Account {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub account_type: Vec<String>,
            pub id: Vec<String>,
            pub profile_image: Vec<String>,
            pub website_url: Vec<String>,
            pub username: Vec<String>,
            pub about: Vec<String>,
            pub business_name: Vec<String>,
            pub board_count: Vec<i32>,
            pub pin_count: Vec<i32>,
            pub follower_count: Vec<i32>,
            pub following_count: Vec<i32>,
            pub monthly_views: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Account".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "account_type" => intermediate_rep.account_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "profile_image" => intermediate_rep.profile_image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "website_url" => intermediate_rep.website_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "about" => intermediate_rep.about.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "business_name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Account".to_string()),
                    "board_count" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Account".to_string()),
                    "pin_count" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Account".to_string()),
                    "follower_count" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Account".to_string()),
                    "following_count" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Account".to_string()),
                    "monthly_views" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Account".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Account".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Account {
            account_type: intermediate_rep.account_type.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            profile_image: intermediate_rep.profile_image.into_iter().next(),
            website_url: intermediate_rep.website_url.into_iter().next(),
            username: intermediate_rep.username.into_iter().next(),
            about: intermediate_rep.about.into_iter().next(),
            business_name: std::result::Result::Err("Nullable types not supported in Account".to_string())?,
            board_count: std::result::Result::Err("Nullable types not supported in Account".to_string())?,
            pin_count: std::result::Result::Err("Nullable types not supported in Account".to_string())?,
            follower_count: std::result::Result::Err("Nullable types not supported in Account".to_string())?,
            following_count: std::result::Result::Err("Nullable types not supported in Account".to_string())?,
            monthly_views: std::result::Result::Err("Nullable types not supported in Account".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Account> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Account>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Account>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Account - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Account> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Account as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Account - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Ad group billable event type. For update, only draft ad groups may update billable event.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ActionType {
    #[serde(rename = "CLICKTHROUGH")]
    Clickthrough,
    #[serde(rename = "IMPRESSION")]
    Impression,
    #[serde(rename = "VIDEO_V_50_MRC")]
    VideoV50Mrc,
}

impl std::fmt::Display for ActionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ActionType::Clickthrough => write!(f, "CLICKTHROUGH"),
            ActionType::Impression => write!(f, "IMPRESSION"),
            ActionType::VideoV50Mrc => write!(f, "VIDEO_V_50_MRC"),
        }
    }
}

impl std::str::FromStr for ActionType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CLICKTHROUGH" => std::result::Result::Ok(ActionType::Clickthrough),
            "IMPRESSION" => std::result::Result::Ok(ActionType::Impression),
            "VIDEO_V_50_MRC" => std::result::Result::Ok(ActionType::VideoV50Mrc),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdAccount {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "owner")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<models::AdAccountOwner>,

    #[serde(rename = "country")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub country: Option<models::Country>,

    #[serde(rename = "currency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency: Option<models::Currency>,

    #[serde(rename = "permissions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<Vec<models::BusinessAccessRole>>,

/// Creation time. Unix timestamp in seconds.
    #[serde(rename = "created_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<Nullable<i32>>,

/// Last update time. Unix timestamp in seconds.
    #[serde(rename = "updated_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_time: Option<Nullable<i32>>,

}


impl AdAccount {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdAccount {
        AdAccount {
            id: None,
            name: None,
            owner: None,
            country: None,
            currency: None,
            permissions: None,
            created_time: None,
            updated_time: None,
        }
    }
}

/// Converts the AdAccount value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdAccount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping owner in query parameter serialization

            // Skipping country in query parameter serialization

            // Skipping currency in query parameter serialization

            // Skipping permissions in query parameter serialization


            self.created_time.as_ref().map(|created_time| {
                [
                    "created_time".to_string(),
                    created_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.updated_time.as_ref().map(|updated_time| {
                [
                    "updated_time".to_string(),
                    updated_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdAccount value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdAccount {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub owner: Vec<models::AdAccountOwner>,
            pub country: Vec<models::Country>,
            pub currency: Vec<models::Currency>,
            pub permissions: Vec<Vec<models::BusinessAccessRole>>,
            pub created_time: Vec<i32>,
            pub updated_time: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdAccount".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "owner" => intermediate_rep.owner.push(<models::AdAccountOwner as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "country" => intermediate_rep.country.push(<models::Country as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currency" => intermediate_rep.currency.push(<models::Currency as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "permissions" => return std::result::Result::Err("Parsing a container in this style is not supported in AdAccount".to_string()),
                    "created_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdAccount".to_string()),
                    "updated_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdAccount".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdAccount".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdAccount {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            owner: intermediate_rep.owner.into_iter().next(),
            country: intermediate_rep.country.into_iter().next(),
            currency: intermediate_rep.currency.into_iter().next(),
            permissions: intermediate_rep.permissions.into_iter().next(),
            created_time: std::result::Result::Err("Nullable types not supported in AdAccount".to_string())?,
            updated_time: std::result::Result::Err("Nullable types not supported in AdAccount".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdAccount> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdAccount>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdAccount>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdAccount - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdAccount> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdAccount as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdAccount - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdAccountAnalyticsResponseInner {
/// The ID of the advertiser that this metrics belongs to.
    #[serde(rename = "AD_ACCOUNT_ID")]
    #[validate(
           regex = "RE_ADACCOUNTANALYTICSRESPONSEINNER_AD_ACCOUNT_ID",
        )]
    pub ad_account_id: String,

/// Current metrics date. Only returned when granularity is a time-based value (`DAY`, `HOUR`, `WEEK`, `MONTH`)
    #[serde(rename = "DATE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::naive::NaiveDate>,

}

lazy_static::lazy_static! {
    static ref RE_ADACCOUNTANALYTICSRESPONSEINNER_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AdAccountAnalyticsResponseInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(ad_account_id: String, ) -> AdAccountAnalyticsResponseInner {
        AdAccountAnalyticsResponseInner {
            ad_account_id,
            date: None,
        }
    }
}

/// Converts the AdAccountAnalyticsResponseInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdAccountAnalyticsResponseInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("AD_ACCOUNT_ID".to_string()),
            Some(self.ad_account_id.to_string()),

            // Skipping DATE in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdAccountAnalyticsResponseInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdAccountAnalyticsResponseInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_account_id: Vec<String>,
            pub date: Vec<chrono::naive::NaiveDate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdAccountAnalyticsResponseInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "AD_ACCOUNT_ID" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DATE" => intermediate_rep.date.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdAccountAnalyticsResponseInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdAccountAnalyticsResponseInner {
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next().ok_or_else(|| "AD_ACCOUNT_ID missing in AdAccountAnalyticsResponseInner".to_string())?,
            date: intermediate_rep.date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdAccountAnalyticsResponseInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdAccountAnalyticsResponseInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdAccountAnalyticsResponseInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdAccountAnalyticsResponseInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdAccountAnalyticsResponseInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdAccountAnalyticsResponseInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdAccountAnalyticsResponseInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdAccountCreateRequest {
    #[serde(rename = "country")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub country: Option<models::Country>,

/// Ad Account name.
    #[serde(rename = "name")]
    #[validate(
            length(max = 256),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Advertiser's owning user ID.
    #[serde(rename = "owner_user_id")]
    #[validate(
           regex = "RE_ADACCOUNTCREATEREQUEST_OWNER_USER_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner_user_id: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_ADACCOUNTCREATEREQUEST_OWNER_USER_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AdAccountCreateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdAccountCreateRequest {
        AdAccountCreateRequest {
            country: None,
            name: None,
            owner_user_id: None,
        }
    }
}

/// Converts the AdAccountCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdAccountCreateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping country in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.owner_user_id.as_ref().map(|owner_user_id| {
                [
                    "owner_user_id".to_string(),
                    owner_user_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdAccountCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdAccountCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub country: Vec<models::Country>,
            pub name: Vec<String>,
            pub owner_user_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdAccountCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "country" => intermediate_rep.country.push(<models::Country as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "owner_user_id" => intermediate_rep.owner_user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdAccountCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdAccountCreateRequest {
            country: intermediate_rep.country.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            owner_user_id: intermediate_rep.owner_user_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdAccountCreateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdAccountCreateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdAccountCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdAccountCreateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdAccountCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdAccountCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdAccountCreateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdAccountCreateSubscriptionRequest {
/// Standard HTTPS webhook URL.
    #[serde(rename = "webhook_url")]
    pub webhook_url: String,

/// Lead form ID.
    #[serde(rename = "lead_form_id")]
    #[validate(
           regex = "RE_ADACCOUNTCREATESUBSCRIPTIONREQUEST_LEAD_FORM_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lead_form_id: Option<String>,

/// Partner access token. Only for clients that requires authentication. We recommend to avoid this param.
    #[serde(rename = "partner_access_token")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_access_token: Option<String>,

/// Partner refresh token. Only for clients that requires authentication. We recommend to avoid this param.
    #[serde(rename = "partner_refresh_token")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_refresh_token: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_ADACCOUNTCREATESUBSCRIPTIONREQUEST_LEAD_FORM_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AdAccountCreateSubscriptionRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(webhook_url: String, ) -> AdAccountCreateSubscriptionRequest {
        AdAccountCreateSubscriptionRequest {
            webhook_url,
            lead_form_id: None,
            partner_access_token: None,
            partner_refresh_token: None,
        }
    }
}

/// Converts the AdAccountCreateSubscriptionRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdAccountCreateSubscriptionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("webhook_url".to_string()),
            Some(self.webhook_url.to_string()),


            self.lead_form_id.as_ref().map(|lead_form_id| {
                [
                    "lead_form_id".to_string(),
                    lead_form_id.to_string(),
                ].join(",")
            }),


            self.partner_access_token.as_ref().map(|partner_access_token| {
                [
                    "partner_access_token".to_string(),
                    partner_access_token.to_string(),
                ].join(",")
            }),


            self.partner_refresh_token.as_ref().map(|partner_refresh_token| {
                [
                    "partner_refresh_token".to_string(),
                    partner_refresh_token.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdAccountCreateSubscriptionRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdAccountCreateSubscriptionRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub webhook_url: Vec<String>,
            pub lead_form_id: Vec<String>,
            pub partner_access_token: Vec<String>,
            pub partner_refresh_token: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdAccountCreateSubscriptionRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "webhook_url" => intermediate_rep.webhook_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lead_form_id" => intermediate_rep.lead_form_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partner_access_token" => intermediate_rep.partner_access_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partner_refresh_token" => intermediate_rep.partner_refresh_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdAccountCreateSubscriptionRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdAccountCreateSubscriptionRequest {
            webhook_url: intermediate_rep.webhook_url.into_iter().next().ok_or_else(|| "webhook_url missing in AdAccountCreateSubscriptionRequest".to_string())?,
            lead_form_id: intermediate_rep.lead_form_id.into_iter().next(),
            partner_access_token: intermediate_rep.partner_access_token.into_iter().next(),
            partner_refresh_token: intermediate_rep.partner_refresh_token.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdAccountCreateSubscriptionRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdAccountCreateSubscriptionRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdAccountCreateSubscriptionRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdAccountCreateSubscriptionRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdAccountCreateSubscriptionRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdAccountCreateSubscriptionRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdAccountCreateSubscriptionRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdAccountCreateSubscriptionResponse {
/// Subscription ID.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_ADACCOUNTCREATESUBSCRIPTIONRESPONSE_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Base64 encoded key for client to decrypt lead data.
    #[serde(rename = "cryptographic_key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cryptographic_key: Option<String>,

/// Lead data encryption algorithm.
    #[serde(rename = "cryptographic_algorithm")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cryptographic_algorithm: Option<String>,

/// Subscription creation time. Unix timestamp in milliseconds.
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<i32>,

}

lazy_static::lazy_static! {
    static ref RE_ADACCOUNTCREATESUBSCRIPTIONRESPONSE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AdAccountCreateSubscriptionResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdAccountCreateSubscriptionResponse {
        AdAccountCreateSubscriptionResponse {
            id: None,
            cryptographic_key: None,
            cryptographic_algorithm: None,
            created_time: None,
        }
    }
}

/// Converts the AdAccountCreateSubscriptionResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdAccountCreateSubscriptionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.cryptographic_key.as_ref().map(|cryptographic_key| {
                [
                    "cryptographic_key".to_string(),
                    cryptographic_key.to_string(),
                ].join(",")
            }),


            self.cryptographic_algorithm.as_ref().map(|cryptographic_algorithm| {
                [
                    "cryptographic_algorithm".to_string(),
                    cryptographic_algorithm.to_string(),
                ].join(",")
            }),


            self.created_time.as_ref().map(|created_time| {
                [
                    "created_time".to_string(),
                    created_time.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdAccountCreateSubscriptionResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdAccountCreateSubscriptionResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub cryptographic_key: Vec<String>,
            pub cryptographic_algorithm: Vec<String>,
            pub created_time: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdAccountCreateSubscriptionResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cryptographic_key" => intermediate_rep.cryptographic_key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cryptographic_algorithm" => intermediate_rep.cryptographic_algorithm.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_time" => intermediate_rep.created_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdAccountCreateSubscriptionResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdAccountCreateSubscriptionResponse {
            id: intermediate_rep.id.into_iter().next(),
            cryptographic_key: intermediate_rep.cryptographic_key.into_iter().next(),
            cryptographic_algorithm: intermediate_rep.cryptographic_algorithm.into_iter().next(),
            created_time: intermediate_rep.created_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdAccountCreateSubscriptionResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdAccountCreateSubscriptionResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdAccountCreateSubscriptionResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdAccountCreateSubscriptionResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdAccountCreateSubscriptionResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdAccountCreateSubscriptionResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdAccountCreateSubscriptionResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdAccountGetSubscriptionResponse {
/// Lead form ID.
    #[serde(rename = "lead_form_id")]
    #[validate(
           regex = "RE_ADACCOUNTGETSUBSCRIPTIONRESPONSE_LEAD_FORM_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lead_form_id: Option<Nullable<String>>,

/// Standard HTTPS webhook URL.
    #[serde(rename = "webhook_url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub webhook_url: Option<String>,

/// Subscription ID.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_ADACCOUNTGETSUBSCRIPTIONRESPONSE_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// User account used to subscribe lead data.
    #[serde(rename = "user_account_id")]
    #[validate(
           regex = "RE_ADACCOUNTGETSUBSCRIPTIONRESPONSE_USER_ACCOUNT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_account_id: Option<String>,

/// The Ad Account ID that this lead form belongs to.
    #[serde(rename = "ad_account_id")]
    #[validate(
           regex = "RE_ADACCOUNTGETSUBSCRIPTIONRESPONSE_AD_ACCOUNT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// API version.
    #[serde(rename = "api_version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_version: Option<String>,

/// Base64 encoded key for client to decrypt lead data.
    #[serde(rename = "cryptographic_key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cryptographic_key: Option<String>,

/// Lead data encryption algorithm.
    #[serde(rename = "cryptographic_algorithm")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cryptographic_algorithm: Option<String>,

/// Lead form creation time. Unix timestamp in milliseconds.
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<i32>,

}

lazy_static::lazy_static! {
    static ref RE_ADACCOUNTGETSUBSCRIPTIONRESPONSE_LEAD_FORM_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADACCOUNTGETSUBSCRIPTIONRESPONSE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADACCOUNTGETSUBSCRIPTIONRESPONSE_USER_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADACCOUNTGETSUBSCRIPTIONRESPONSE_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AdAccountGetSubscriptionResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdAccountGetSubscriptionResponse {
        AdAccountGetSubscriptionResponse {
            lead_form_id: None,
            webhook_url: None,
            id: None,
            user_account_id: None,
            ad_account_id: None,
            api_version: None,
            cryptographic_key: None,
            cryptographic_algorithm: None,
            created_time: None,
        }
    }
}

/// Converts the AdAccountGetSubscriptionResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdAccountGetSubscriptionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.lead_form_id.as_ref().map(|lead_form_id| {
                [
                    "lead_form_id".to_string(),
                    lead_form_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.webhook_url.as_ref().map(|webhook_url| {
                [
                    "webhook_url".to_string(),
                    webhook_url.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.user_account_id.as_ref().map(|user_account_id| {
                [
                    "user_account_id".to_string(),
                    user_account_id.to_string(),
                ].join(",")
            }),


            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.api_version.as_ref().map(|api_version| {
                [
                    "api_version".to_string(),
                    api_version.to_string(),
                ].join(",")
            }),


            self.cryptographic_key.as_ref().map(|cryptographic_key| {
                [
                    "cryptographic_key".to_string(),
                    cryptographic_key.to_string(),
                ].join(",")
            }),


            self.cryptographic_algorithm.as_ref().map(|cryptographic_algorithm| {
                [
                    "cryptographic_algorithm".to_string(),
                    cryptographic_algorithm.to_string(),
                ].join(",")
            }),


            self.created_time.as_ref().map(|created_time| {
                [
                    "created_time".to_string(),
                    created_time.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdAccountGetSubscriptionResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdAccountGetSubscriptionResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub lead_form_id: Vec<String>,
            pub webhook_url: Vec<String>,
            pub id: Vec<String>,
            pub user_account_id: Vec<String>,
            pub ad_account_id: Vec<String>,
            pub api_version: Vec<String>,
            pub cryptographic_key: Vec<String>,
            pub cryptographic_algorithm: Vec<String>,
            pub created_time: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdAccountGetSubscriptionResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "lead_form_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdAccountGetSubscriptionResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "webhook_url" => intermediate_rep.webhook_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user_account_id" => intermediate_rep.user_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "api_version" => intermediate_rep.api_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cryptographic_key" => intermediate_rep.cryptographic_key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cryptographic_algorithm" => intermediate_rep.cryptographic_algorithm.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_time" => intermediate_rep.created_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdAccountGetSubscriptionResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdAccountGetSubscriptionResponse {
            lead_form_id: std::result::Result::Err("Nullable types not supported in AdAccountGetSubscriptionResponse".to_string())?,
            webhook_url: intermediate_rep.webhook_url.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            user_account_id: intermediate_rep.user_account_id.into_iter().next(),
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            api_version: intermediate_rep.api_version.into_iter().next(),
            cryptographic_key: intermediate_rep.cryptographic_key.into_iter().next(),
            cryptographic_algorithm: intermediate_rep.cryptographic_algorithm.into_iter().next(),
            created_time: intermediate_rep.created_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdAccountGetSubscriptionResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdAccountGetSubscriptionResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdAccountGetSubscriptionResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdAccountGetSubscriptionResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdAccountGetSubscriptionResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdAccountGetSubscriptionResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdAccountGetSubscriptionResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdAccountOwner {
/// Public username for the user account
    #[serde(rename = "username")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,

/// The owning account's user ID.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}


impl AdAccountOwner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdAccountOwner {
        AdAccountOwner {
            username: None,
            id: None,
        }
    }
}

/// Converts the AdAccountOwner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdAccountOwner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.username.as_ref().map(|username| {
                [
                    "username".to_string(),
                    username.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdAccountOwner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdAccountOwner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub username: Vec<String>,
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdAccountOwner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdAccountOwner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdAccountOwner {
            username: intermediate_rep.username.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdAccountOwner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdAccountOwner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdAccountOwner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdAccountOwner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdAccountOwner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdAccountOwner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdAccountOwner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdAccountsCatalogsProductGroupsList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::CatalogProductGroup>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl AdAccountsCatalogsProductGroupsList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::CatalogProductGroup>, ) -> AdAccountsCatalogsProductGroupsList200Response {
        AdAccountsCatalogsProductGroupsList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the AdAccountsCatalogsProductGroupsList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdAccountsCatalogsProductGroupsList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdAccountsCatalogsProductGroupsList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdAccountsCatalogsProductGroupsList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::CatalogProductGroup>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdAccountsCatalogsProductGroupsList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in AdAccountsCatalogsProductGroupsList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdAccountsCatalogsProductGroupsList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdAccountsCatalogsProductGroupsList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdAccountsCatalogsProductGroupsList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in AdAccountsCatalogsProductGroupsList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in AdAccountsCatalogsProductGroupsList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdAccountsCatalogsProductGroupsList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdAccountsCatalogsProductGroupsList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdAccountsCatalogsProductGroupsList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdAccountsCatalogsProductGroupsList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdAccountsCatalogsProductGroupsList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdAccountsCatalogsProductGroupsList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdAccountsCatalogsProductGroupsList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdAccountsCountryResponse {
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::AdAccountsCountryResponseData>>,

}


impl AdAccountsCountryResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdAccountsCountryResponse {
        AdAccountsCountryResponse {
            items: None,
        }
    }
}

/// Converts the AdAccountsCountryResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdAccountsCountryResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdAccountsCountryResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdAccountsCountryResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::AdAccountsCountryResponseData>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdAccountsCountryResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in AdAccountsCountryResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdAccountsCountryResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdAccountsCountryResponse {
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdAccountsCountryResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdAccountsCountryResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdAccountsCountryResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdAccountsCountryResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdAccountsCountryResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdAccountsCountryResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdAccountsCountryResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdAccountsCountryResponseData {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<models::AdCountry>,

/// Country currency.
    #[serde(rename = "currency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency: Option<String>,

/// Country index
    #[serde(rename = "index")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index: Option<f64>,

/// Country name
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl AdAccountsCountryResponseData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdAccountsCountryResponseData {
        AdAccountsCountryResponseData {
            code: None,
            currency: None,
            index: None,
            name: None,
        }
    }
}

/// Converts the AdAccountsCountryResponseData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdAccountsCountryResponseData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping code in query parameter serialization


            self.currency.as_ref().map(|currency| {
                [
                    "currency".to_string(),
                    currency.to_string(),
                ].join(",")
            }),


            self.index.as_ref().map(|index| {
                [
                    "index".to_string(),
                    index.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdAccountsCountryResponseData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdAccountsCountryResponseData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<models::AdCountry>,
            pub currency: Vec<String>,
            pub index: Vec<f64>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdAccountsCountryResponseData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<models::AdCountry as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currency" => intermediate_rep.currency.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdAccountsCountryResponseData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdAccountsCountryResponseData {
            code: intermediate_rep.code.into_iter().next(),
            currency: intermediate_rep.currency.into_iter().next(),
            index: intermediate_rep.index.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdAccountsCountryResponseData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdAccountsCountryResponseData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdAccountsCountryResponseData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdAccountsCountryResponseData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdAccountsCountryResponseData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdAccountsCountryResponseData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdAccountsCountryResponseData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdAccountsList200Response {
/// Ad accounts
    #[serde(rename = "items")]
    pub items: Vec<models::AdAccount>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl AdAccountsList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::AdAccount>, ) -> AdAccountsList200Response {
        AdAccountsList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the AdAccountsList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdAccountsList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdAccountsList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdAccountsList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::AdAccount>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdAccountsList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in AdAccountsList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdAccountsList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdAccountsList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdAccountsList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in AdAccountsList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in AdAccountsList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdAccountsList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdAccountsList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdAccountsList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdAccountsList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdAccountsList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdAccountsList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdAccountsList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdAccountsSubscriptionsGetList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::AdAccountGetSubscriptionResponse>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl AdAccountsSubscriptionsGetList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::AdAccountGetSubscriptionResponse>, ) -> AdAccountsSubscriptionsGetList200Response {
        AdAccountsSubscriptionsGetList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the AdAccountsSubscriptionsGetList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdAccountsSubscriptionsGetList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdAccountsSubscriptionsGetList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdAccountsSubscriptionsGetList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::AdAccountGetSubscriptionResponse>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdAccountsSubscriptionsGetList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in AdAccountsSubscriptionsGetList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdAccountsSubscriptionsGetList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdAccountsSubscriptionsGetList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdAccountsSubscriptionsGetList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in AdAccountsSubscriptionsGetList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in AdAccountsSubscriptionsGetList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdAccountsSubscriptionsGetList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdAccountsSubscriptionsGetList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdAccountsSubscriptionsGetList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdAccountsSubscriptionsGetList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdAccountsSubscriptionsGetList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdAccountsSubscriptionsGetList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdAccountsSubscriptionsGetList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdArrayResponse {
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::AdArrayResponseElement>>,

}


impl AdArrayResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdArrayResponse {
        AdArrayResponse {
            items: None,
        }
    }
}

/// Converts the AdArrayResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdArrayResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdArrayResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdArrayResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::AdArrayResponseElement>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdArrayResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in AdArrayResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdArrayResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdArrayResponse {
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdArrayResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdArrayResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdArrayResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdArrayResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdArrayResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdArrayResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdArrayResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdArrayResponseElement {
    #[serde(rename = "data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<models::AdResponse>,

    #[serde(rename = "exceptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exceptions: Option<models::Exception>,

}


impl AdArrayResponseElement {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdArrayResponseElement {
        AdArrayResponseElement {
            data: None,
            exceptions: None,
        }
    }
}

/// Converts the AdArrayResponseElement value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdArrayResponseElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization

            // Skipping exceptions in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdArrayResponseElement value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdArrayResponseElement {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<models::AdResponse>,
            pub exceptions: Vec<models::Exception>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdArrayResponseElement".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::AdResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "exceptions" => intermediate_rep.exceptions.push(<models::Exception as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdArrayResponseElement".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdArrayResponseElement {
            data: intermediate_rep.data.into_iter().next(),
            exceptions: intermediate_rep.exceptions.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdArrayResponseElement> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdArrayResponseElement>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdArrayResponseElement>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdArrayResponseElement - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdArrayResponseElement> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdArrayResponseElement as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdArrayResponseElement - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Creation fields



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdCommon {
/// ID of the ad group that contains the ad.
    #[serde(rename = "ad_group_id")]
    #[validate(
           regex = "RE_ADCOMMON_AD_GROUP_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_group_id: Option<String>,

/// Deep link URL for Android devices. Not currently available. Using this field will generate an error.
    #[serde(rename = "android_deep_link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub android_deep_link: Option<Nullable<String>>,

/// Comma-separated deep links for the carousel pin on Android.
    #[serde(rename = "carousel_android_deep_links")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_android_deep_links: Option<Nullable<Vec<String>>>,

/// Comma-separated destination URLs for the carousel pin to promote.
    #[serde(rename = "carousel_destination_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_destination_urls: Option<Nullable<Vec<String>>>,

/// Comma-separated deep links for the carousel pin on iOS.
    #[serde(rename = "carousel_ios_deep_links")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_ios_deep_links: Option<Nullable<Vec<String>>>,

/// Tracking url for the ad clicks.
    #[serde(rename = "click_tracking_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub click_tracking_url: Option<Nullable<String>>,

    #[serde(rename = "creative_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creative_type: Option<models::CreativeType>,

/// Destination URL.
    #[serde(rename = "destination_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub destination_url: Option<Nullable<String>>,

/// Deep link URL for iOS devices. Not currently available. Using this field will generate an error.
    #[serde(rename = "ios_deep_link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ios_deep_link: Option<Nullable<String>>,

/// Is original pin deleted?
    #[serde(rename = "is_pin_deleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_pin_deleted: Option<bool>,

/// Is pin repinnable?
    #[serde(rename = "is_removable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_removable: Option<bool>,

/// Name of the ad - 255 chars max.
    #[serde(rename = "name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<Nullable<models::AdCommonTrackingUrls>>,

/// Tracking URL for ad impressions.
    #[serde(rename = "view_tracking_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub view_tracking_url: Option<Nullable<String>>,

/// Lead form ID for lead ad generation.
    #[serde(rename = "lead_form_id")]
    #[validate(
           regex = "RE_ADCOMMON_LEAD_FORM_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lead_form_id: Option<Nullable<String>>,

    #[serde(rename = "grid_click_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub grid_click_type: Option<Nullable<models::GridClickType>>,

/// Select a call to action (CTA) to display below your ad. Available only for ads with direct links enabled. CTA options for consideration and conversion campaigns are LEARN_MORE, SHOP_NOW, BOOK_NOW, SIGN_UP, VISIT_WEBSITE, BUY_NOW, GET_OFFER, ORDER_NOW, ADD_TO_CART (for conversion campaigns with add to cart conversion events only)
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "customizable_cta_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub customizable_cta_type: Option<Nullable<String>>,

    #[serde(rename = "quiz_pin_data")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quiz_pin_data: Option<Nullable<models::AdCommonQuizPinData>>,

}

lazy_static::lazy_static! {
    static ref RE_ADCOMMON_AD_GROUP_ID: regex::Regex = regex::Regex::new(r"^(AG)?\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADCOMMON_LEAD_FORM_ID: regex::Regex = regex::Regex::new(r"^(AG)?\\d+$").unwrap();
}

impl AdCommon {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdCommon {
        AdCommon {
            ad_group_id: None,
            android_deep_link: None,
            carousel_android_deep_links: None,
            carousel_destination_urls: None,
            carousel_ios_deep_links: None,
            click_tracking_url: None,
            creative_type: None,
            destination_url: None,
            ios_deep_link: None,
            is_pin_deleted: None,
            is_removable: None,
            name: None,
            status: None,
            tracking_urls: None,
            view_tracking_url: None,
            lead_form_id: None,
            grid_click_type: None,
            customizable_cta_type: None,
            quiz_pin_data: None,
        }
    }
}

/// Converts the AdCommon value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdCommon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ad_group_id.as_ref().map(|ad_group_id| {
                [
                    "ad_group_id".to_string(),
                    ad_group_id.to_string(),
                ].join(",")
            }),


            self.android_deep_link.as_ref().map(|android_deep_link| {
                [
                    "android_deep_link".to_string(),
                    android_deep_link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.carousel_android_deep_links.as_ref().map(|carousel_android_deep_links| {
                [
                    "carousel_android_deep_links".to_string(),
                    carousel_android_deep_links.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.carousel_destination_urls.as_ref().map(|carousel_destination_urls| {
                [
                    "carousel_destination_urls".to_string(),
                    carousel_destination_urls.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.carousel_ios_deep_links.as_ref().map(|carousel_ios_deep_links| {
                [
                    "carousel_ios_deep_links".to_string(),
                    carousel_ios_deep_links.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.click_tracking_url.as_ref().map(|click_tracking_url| {
                [
                    "click_tracking_url".to_string(),
                    click_tracking_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping creative_type in query parameter serialization


            self.destination_url.as_ref().map(|destination_url| {
                [
                    "destination_url".to_string(),
                    destination_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.ios_deep_link.as_ref().map(|ios_deep_link| {
                [
                    "ios_deep_link".to_string(),
                    ios_deep_link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_pin_deleted.as_ref().map(|is_pin_deleted| {
                [
                    "is_pin_deleted".to_string(),
                    is_pin_deleted.to_string(),
                ].join(",")
            }),


            self.is_removable.as_ref().map(|is_removable| {
                [
                    "is_removable".to_string(),
                    is_removable.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping status in query parameter serialization

            // Skipping tracking_urls in query parameter serialization


            self.view_tracking_url.as_ref().map(|view_tracking_url| {
                [
                    "view_tracking_url".to_string(),
                    view_tracking_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.lead_form_id.as_ref().map(|lead_form_id| {
                [
                    "lead_form_id".to_string(),
                    lead_form_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping grid_click_type in query parameter serialization


            self.customizable_cta_type.as_ref().map(|customizable_cta_type| {
                [
                    "customizable_cta_type".to_string(),
                    customizable_cta_type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping quiz_pin_data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdCommon value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdCommon {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_group_id: Vec<String>,
            pub android_deep_link: Vec<String>,
            pub carousel_android_deep_links: Vec<Vec<String>>,
            pub carousel_destination_urls: Vec<Vec<String>>,
            pub carousel_ios_deep_links: Vec<Vec<String>>,
            pub click_tracking_url: Vec<String>,
            pub creative_type: Vec<models::CreativeType>,
            pub destination_url: Vec<String>,
            pub ios_deep_link: Vec<String>,
            pub is_pin_deleted: Vec<bool>,
            pub is_removable: Vec<bool>,
            pub name: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub tracking_urls: Vec<models::AdCommonTrackingUrls>,
            pub view_tracking_url: Vec<String>,
            pub lead_form_id: Vec<String>,
            pub grid_click_type: Vec<models::GridClickType>,
            pub customizable_cta_type: Vec<String>,
            pub quiz_pin_data: Vec<models::AdCommonQuizPinData>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdCommon".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_group_id" => intermediate_rep.ad_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "android_deep_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCommon".to_string()),
                    "carousel_android_deep_links" => return std::result::Result::Err("Parsing a container in this style is not supported in AdCommon".to_string()),
                    "carousel_destination_urls" => return std::result::Result::Err("Parsing a container in this style is not supported in AdCommon".to_string()),
                    "carousel_ios_deep_links" => return std::result::Result::Err("Parsing a container in this style is not supported in AdCommon".to_string()),
                    "click_tracking_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCommon".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "creative_type" => intermediate_rep.creative_type.push(<models::CreativeType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "destination_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCommon".to_string()),
                    "ios_deep_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCommon".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "is_pin_deleted" => intermediate_rep.is_pin_deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_removable" => intermediate_rep.is_removable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCommon".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCommon".to_string()),
                    "view_tracking_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCommon".to_string()),
                    "lead_form_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCommon".to_string()),
                    "grid_click_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCommon".to_string()),
                    "customizable_cta_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCommon".to_string()),
                    "quiz_pin_data" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCommon".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdCommon".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdCommon {
            ad_group_id: intermediate_rep.ad_group_id.into_iter().next(),
            android_deep_link: std::result::Result::Err("Nullable types not supported in AdCommon".to_string())?,
            carousel_android_deep_links: std::result::Result::Err("Nullable types not supported in AdCommon".to_string())?,
            carousel_destination_urls: std::result::Result::Err("Nullable types not supported in AdCommon".to_string())?,
            carousel_ios_deep_links: std::result::Result::Err("Nullable types not supported in AdCommon".to_string())?,
            click_tracking_url: std::result::Result::Err("Nullable types not supported in AdCommon".to_string())?,
            creative_type: intermediate_rep.creative_type.into_iter().next(),
            destination_url: std::result::Result::Err("Nullable types not supported in AdCommon".to_string())?,
            ios_deep_link: std::result::Result::Err("Nullable types not supported in AdCommon".to_string())?,
            is_pin_deleted: intermediate_rep.is_pin_deleted.into_iter().next(),
            is_removable: intermediate_rep.is_removable.into_iter().next(),
            name: std::result::Result::Err("Nullable types not supported in AdCommon".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
            tracking_urls: std::result::Result::Err("Nullable types not supported in AdCommon".to_string())?,
            view_tracking_url: std::result::Result::Err("Nullable types not supported in AdCommon".to_string())?,
            lead_form_id: std::result::Result::Err("Nullable types not supported in AdCommon".to_string())?,
            grid_click_type: std::result::Result::Err("Nullable types not supported in AdCommon".to_string())?,
            customizable_cta_type: std::result::Result::Err("Nullable types not supported in AdCommon".to_string())?,
            quiz_pin_data: std::result::Result::Err("Nullable types not supported in AdCommon".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdCommon> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdCommon>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdCommon>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdCommon - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdCommon> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdCommon as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdCommon - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Before creating a quiz ad, you must create an organic Pin using POST/Create Pin for each result in the quiz. Quiz ads cannot be saved by a Pinner. Quiz ad results can be saved.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdCommonQuizPinData {
    #[serde(rename = "questions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub questions: Option<Vec<models::QuizPinQuestion>>,

    #[serde(rename = "results")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::QuizPinResult>>,

}


impl AdCommonQuizPinData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdCommonQuizPinData {
        AdCommonQuizPinData {
            questions: None,
            results: None,
        }
    }
}

/// Converts the AdCommonQuizPinData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdCommonQuizPinData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping questions in query parameter serialization

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdCommonQuizPinData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdCommonQuizPinData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub questions: Vec<Vec<models::QuizPinQuestion>>,
            pub results: Vec<Vec<models::QuizPinResult>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdCommonQuizPinData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "questions" => return std::result::Result::Err("Parsing a container in this style is not supported in AdCommonQuizPinData".to_string()),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in AdCommonQuizPinData".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdCommonQuizPinData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdCommonQuizPinData {
            questions: intermediate_rep.questions.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdCommonQuizPinData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdCommonQuizPinData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdCommonQuizPinData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdCommonQuizPinData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdCommonQuizPinData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdCommonQuizPinData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdCommonQuizPinData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdCommonTrackingUrls {
    #[serde(rename = "impression")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub impression: Option<Vec<String>>,

    #[serde(rename = "click")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub click: Option<Vec<String>>,

    #[serde(rename = "engagement")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub engagement: Option<Vec<String>>,

    #[serde(rename = "buyable_button")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub buyable_button: Option<Vec<String>>,

    #[serde(rename = "audience_verification")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audience_verification: Option<Vec<String>>,

}


impl AdCommonTrackingUrls {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdCommonTrackingUrls {
        AdCommonTrackingUrls {
            impression: None,
            click: None,
            engagement: None,
            buyable_button: None,
            audience_verification: None,
        }
    }
}

/// Converts the AdCommonTrackingUrls value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdCommonTrackingUrls {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.impression.as_ref().map(|impression| {
                [
                    "impression".to_string(),
                    impression.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.click.as_ref().map(|click| {
                [
                    "click".to_string(),
                    click.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.engagement.as_ref().map(|engagement| {
                [
                    "engagement".to_string(),
                    engagement.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.buyable_button.as_ref().map(|buyable_button| {
                [
                    "buyable_button".to_string(),
                    buyable_button.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.audience_verification.as_ref().map(|audience_verification| {
                [
                    "audience_verification".to_string(),
                    audience_verification.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdCommonTrackingUrls value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdCommonTrackingUrls {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub impression: Vec<Vec<String>>,
            pub click: Vec<Vec<String>>,
            pub engagement: Vec<Vec<String>>,
            pub buyable_button: Vec<Vec<String>>,
            pub audience_verification: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdCommonTrackingUrls".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "impression" => return std::result::Result::Err("Parsing a container in this style is not supported in AdCommonTrackingUrls".to_string()),
                    "click" => return std::result::Result::Err("Parsing a container in this style is not supported in AdCommonTrackingUrls".to_string()),
                    "engagement" => return std::result::Result::Err("Parsing a container in this style is not supported in AdCommonTrackingUrls".to_string()),
                    "buyable_button" => return std::result::Result::Err("Parsing a container in this style is not supported in AdCommonTrackingUrls".to_string()),
                    "audience_verification" => return std::result::Result::Err("Parsing a container in this style is not supported in AdCommonTrackingUrls".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdCommonTrackingUrls".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdCommonTrackingUrls {
            impression: intermediate_rep.impression.into_iter().next(),
            click: intermediate_rep.click.into_iter().next(),
            engagement: intermediate_rep.engagement.into_iter().next(),
            buyable_button: intermediate_rep.buyable_button.into_iter().next(),
            audience_verification: intermediate_rep.audience_verification.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdCommonTrackingUrls> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdCommonTrackingUrls>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdCommonTrackingUrls>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdCommonTrackingUrls - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdCommonTrackingUrls> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdCommonTrackingUrls as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdCommonTrackingUrls - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Country ID from ISO 3166-1 alpha-2.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AdCountry {
    #[serde(rename = "AD")]
    Ad,
    #[serde(rename = "AE")]
    Ae,
    #[serde(rename = "AF")]
    Af,
    #[serde(rename = "AG")]
    Ag,
    #[serde(rename = "AI")]
    Ai,
    #[serde(rename = "AL")]
    Al,
    #[serde(rename = "AM")]
    Am,
    #[serde(rename = "AO")]
    Ao,
    #[serde(rename = "AQ")]
    Aq,
    #[serde(rename = "AR")]
    Ar,
    #[serde(rename = "AS")]
    As,
    #[serde(rename = "AT")]
    At,
    #[serde(rename = "AU")]
    Au,
    #[serde(rename = "AW")]
    Aw,
    #[serde(rename = "AX")]
    Ax,
    #[serde(rename = "AZ")]
    Az,
    #[serde(rename = "BA")]
    Ba,
    #[serde(rename = "BB")]
    Bb,
    #[serde(rename = "BD")]
    Bd,
    #[serde(rename = "BE")]
    Be,
    #[serde(rename = "BF")]
    Bf,
    #[serde(rename = "BG")]
    Bg,
    #[serde(rename = "BH")]
    Bh,
    #[serde(rename = "BI")]
    Bi,
    #[serde(rename = "BJ")]
    Bj,
    #[serde(rename = "BL")]
    Bl,
    #[serde(rename = "BM")]
    Bm,
    #[serde(rename = "BN")]
    Bn,
    #[serde(rename = "BO")]
    Bo,
    #[serde(rename = "BQ")]
    Bq,
    #[serde(rename = "BR")]
    Br,
    #[serde(rename = "BS")]
    Bs,
    #[serde(rename = "BT")]
    Bt,
    #[serde(rename = "BV")]
    Bv,
    #[serde(rename = "BW")]
    Bw,
    #[serde(rename = "BY")]
    By,
    #[serde(rename = "BZ")]
    Bz,
    #[serde(rename = "CA")]
    Ca,
    #[serde(rename = "CC")]
    Cc,
    #[serde(rename = "CD")]
    Cd,
    #[serde(rename = "CF")]
    Cf,
    #[serde(rename = "CG")]
    Cg,
    #[serde(rename = "CH")]
    Ch,
    #[serde(rename = "CI")]
    Ci,
    #[serde(rename = "CK")]
    Ck,
    #[serde(rename = "CL")]
    Cl,
    #[serde(rename = "CM")]
    Cm,
    #[serde(rename = "CN")]
    Cn,
    #[serde(rename = "CO")]
    Co,
    #[serde(rename = "CR")]
    Cr,
    #[serde(rename = "CU")]
    Cu,
    #[serde(rename = "CV")]
    Cv,
    #[serde(rename = "CW")]
    Cw,
    #[serde(rename = "CX")]
    Cx,
    #[serde(rename = "CY")]
    Cy,
    #[serde(rename = "CZ")]
    Cz,
    #[serde(rename = "DE")]
    De,
    #[serde(rename = "DJ")]
    Dj,
    #[serde(rename = "DK")]
    Dk,
    #[serde(rename = "DM")]
    Dm,
    #[serde(rename = "DO")]
    Do,
    #[serde(rename = "DZ")]
    Dz,
    #[serde(rename = "EC")]
    Ec,
    #[serde(rename = "EE")]
    Ee,
    #[serde(rename = "EG")]
    Eg,
    #[serde(rename = "EH")]
    Eh,
    #[serde(rename = "ER")]
    Er,
    #[serde(rename = "ES")]
    Es,
    #[serde(rename = "ET")]
    Et,
    #[serde(rename = "FI")]
    Fi,
    #[serde(rename = "FJ")]
    Fj,
    #[serde(rename = "FK")]
    Fk,
    #[serde(rename = "FM")]
    Fm,
    #[serde(rename = "FO")]
    Fo,
    #[serde(rename = "FR")]
    Fr,
    #[serde(rename = "GA")]
    Ga,
    #[serde(rename = "GB")]
    Gb,
    #[serde(rename = "GD")]
    Gd,
    #[serde(rename = "GE")]
    Ge,
    #[serde(rename = "GF")]
    Gf,
    #[serde(rename = "GG")]
    Gg,
    #[serde(rename = "GH")]
    Gh,
    #[serde(rename = "GI")]
    Gi,
    #[serde(rename = "GL")]
    Gl,
    #[serde(rename = "GM")]
    Gm,
    #[serde(rename = "GN")]
    Gn,
    #[serde(rename = "GP")]
    Gp,
    #[serde(rename = "GQ")]
    Gq,
    #[serde(rename = "GR")]
    Gr,
    #[serde(rename = "GS")]
    Gs,
    #[serde(rename = "GT")]
    Gt,
    #[serde(rename = "GU")]
    Gu,
    #[serde(rename = "GW")]
    Gw,
    #[serde(rename = "GY")]
    Gy,
    #[serde(rename = "HK")]
    Hk,
    #[serde(rename = "HM")]
    Hm,
    #[serde(rename = "HN")]
    Hn,
    #[serde(rename = "HR")]
    Hr,
    #[serde(rename = "HT")]
    Ht,
    #[serde(rename = "HU")]
    Hu,
    #[serde(rename = "ID")]
    Id,
    #[serde(rename = "IE")]
    Ie,
    #[serde(rename = "IL")]
    Il,
    #[serde(rename = "IM")]
    Im,
    #[serde(rename = "IN")]
    In,
    #[serde(rename = "IO")]
    Io,
    #[serde(rename = "IQ")]
    Iq,
    #[serde(rename = "IR")]
    Ir,
    #[serde(rename = "IS")]
    Is,
    #[serde(rename = "IT")]
    It,
    #[serde(rename = "JE")]
    Je,
    #[serde(rename = "JM")]
    Jm,
    #[serde(rename = "JO")]
    Jo,
    #[serde(rename = "JP")]
    Jp,
    #[serde(rename = "KE")]
    Ke,
    #[serde(rename = "KG")]
    Kg,
    #[serde(rename = "KH")]
    Kh,
    #[serde(rename = "KI")]
    Ki,
    #[serde(rename = "KM")]
    Km,
    #[serde(rename = "KN")]
    Kn,
    #[serde(rename = "KR")]
    Kr,
    #[serde(rename = "KW")]
    Kw,
    #[serde(rename = "KY")]
    Ky,
    #[serde(rename = "KZ")]
    Kz,
    #[serde(rename = "LA")]
    La,
    #[serde(rename = "LB")]
    Lb,
    #[serde(rename = "LC")]
    Lc,
    #[serde(rename = "LI")]
    Li,
    #[serde(rename = "LK")]
    Lk,
    #[serde(rename = "LR")]
    Lr,
    #[serde(rename = "LS")]
    Ls,
    #[serde(rename = "LT")]
    Lt,
    #[serde(rename = "LU")]
    Lu,
    #[serde(rename = "LV")]
    Lv,
    #[serde(rename = "LY")]
    Ly,
    #[serde(rename = "MA")]
    Ma,
    #[serde(rename = "MC")]
    Mc,
    #[serde(rename = "MD")]
    Md,
    #[serde(rename = "ME")]
    Me,
    #[serde(rename = "MF")]
    Mf,
    #[serde(rename = "MG")]
    Mg,
    #[serde(rename = "MH")]
    Mh,
    #[serde(rename = "MK")]
    Mk,
    #[serde(rename = "ML")]
    Ml,
    #[serde(rename = "MM")]
    Mm,
    #[serde(rename = "MN")]
    Mn,
    #[serde(rename = "MO")]
    Mo,
    #[serde(rename = "MP")]
    Mp,
    #[serde(rename = "MQ")]
    Mq,
    #[serde(rename = "MR")]
    Mr,
    #[serde(rename = "MS")]
    Ms,
    #[serde(rename = "MT")]
    Mt,
    #[serde(rename = "MU")]
    Mu,
    #[serde(rename = "MV")]
    Mv,
    #[serde(rename = "MW")]
    Mw,
    #[serde(rename = "MX")]
    Mx,
    #[serde(rename = "MY")]
    My,
    #[serde(rename = "MZ")]
    Mz,
    #[serde(rename = "NA")]
    Na,
    #[serde(rename = "NC")]
    Nc,
    #[serde(rename = "NE")]
    Ne,
    #[serde(rename = "NF")]
    Nf,
    #[serde(rename = "NG")]
    Ng,
    #[serde(rename = "NI")]
    Ni,
    #[serde(rename = "NL")]
    Nl,
    #[serde(rename = "NO")]
    No,
    #[serde(rename = "NP")]
    Np,
    #[serde(rename = "NR")]
    Nr,
    #[serde(rename = "NU")]
    Nu,
    #[serde(rename = "NZ")]
    Nz,
    #[serde(rename = "OM")]
    Om,
    #[serde(rename = "PA")]
    Pa,
    #[serde(rename = "PE")]
    Pe,
    #[serde(rename = "PF")]
    Pf,
    #[serde(rename = "PG")]
    Pg,
    #[serde(rename = "PH")]
    Ph,
    #[serde(rename = "PK")]
    Pk,
    #[serde(rename = "PL")]
    Pl,
    #[serde(rename = "PM")]
    Pm,
    #[serde(rename = "PN")]
    Pn,
    #[serde(rename = "PR")]
    Pr,
    #[serde(rename = "PS")]
    Ps,
    #[serde(rename = "PT")]
    Pt,
    #[serde(rename = "PW")]
    Pw,
    #[serde(rename = "PY")]
    Py,
    #[serde(rename = "QA")]
    Qa,
    #[serde(rename = "RE")]
    Re,
    #[serde(rename = "RO")]
    Ro,
    #[serde(rename = "RS")]
    Rs,
    #[serde(rename = "RU")]
    Ru,
    #[serde(rename = "RW")]
    Rw,
    #[serde(rename = "SA")]
    Sa,
    #[serde(rename = "SB")]
    Sb,
    #[serde(rename = "SC")]
    Sc,
    #[serde(rename = "SD")]
    Sd,
    #[serde(rename = "SE")]
    Se,
    #[serde(rename = "SG")]
    Sg,
    #[serde(rename = "SH")]
    Sh,
    #[serde(rename = "SI")]
    Si,
    #[serde(rename = "SJ")]
    Sj,
    #[serde(rename = "SK")]
    Sk,
    #[serde(rename = "SL")]
    Sl,
    #[serde(rename = "SM")]
    Sm,
    #[serde(rename = "SN")]
    Sn,
    #[serde(rename = "SO")]
    So,
    #[serde(rename = "SR")]
    Sr,
    #[serde(rename = "SS")]
    Ss,
    #[serde(rename = "ST")]
    St,
    #[serde(rename = "SV")]
    Sv,
    #[serde(rename = "SX")]
    Sx,
    #[serde(rename = "SY")]
    Sy,
    #[serde(rename = "SZ")]
    Sz,
    #[serde(rename = "TC")]
    Tc,
    #[serde(rename = "TD")]
    Td,
    #[serde(rename = "TF")]
    Tf,
    #[serde(rename = "TG")]
    Tg,
    #[serde(rename = "TH")]
    Th,
    #[serde(rename = "TJ")]
    Tj,
    #[serde(rename = "TK")]
    Tk,
    #[serde(rename = "TL")]
    Tl,
    #[serde(rename = "TM")]
    Tm,
    #[serde(rename = "TN")]
    Tn,
    #[serde(rename = "TO")]
    To,
    #[serde(rename = "TR")]
    Tr,
    #[serde(rename = "TT")]
    Tt,
    #[serde(rename = "TV")]
    Tv,
    #[serde(rename = "TW")]
    Tw,
    #[serde(rename = "TZ")]
    Tz,
    #[serde(rename = "UA")]
    Ua,
    #[serde(rename = "UG")]
    Ug,
    #[serde(rename = "UM")]
    Um,
    #[serde(rename = "US")]
    Us,
    #[serde(rename = "UY")]
    Uy,
    #[serde(rename = "UZ")]
    Uz,
    #[serde(rename = "VA")]
    Va,
    #[serde(rename = "VC")]
    Vc,
    #[serde(rename = "VE")]
    Ve,
    #[serde(rename = "VG")]
    Vg,
    #[serde(rename = "VI")]
    Vi,
    #[serde(rename = "VN")]
    Vn,
    #[serde(rename = "VU")]
    Vu,
    #[serde(rename = "WF")]
    Wf,
    #[serde(rename = "WS")]
    Ws,
    #[serde(rename = "YE")]
    Ye,
    #[serde(rename = "YT")]
    Yt,
    #[serde(rename = "ZA")]
    Za,
    #[serde(rename = "ZM")]
    Zm,
    #[serde(rename = "ZW")]
    Zw,
}

impl std::fmt::Display for AdCountry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AdCountry::Ad => write!(f, "AD"),
            AdCountry::Ae => write!(f, "AE"),
            AdCountry::Af => write!(f, "AF"),
            AdCountry::Ag => write!(f, "AG"),
            AdCountry::Ai => write!(f, "AI"),
            AdCountry::Al => write!(f, "AL"),
            AdCountry::Am => write!(f, "AM"),
            AdCountry::Ao => write!(f, "AO"),
            AdCountry::Aq => write!(f, "AQ"),
            AdCountry::Ar => write!(f, "AR"),
            AdCountry::As => write!(f, "AS"),
            AdCountry::At => write!(f, "AT"),
            AdCountry::Au => write!(f, "AU"),
            AdCountry::Aw => write!(f, "AW"),
            AdCountry::Ax => write!(f, "AX"),
            AdCountry::Az => write!(f, "AZ"),
            AdCountry::Ba => write!(f, "BA"),
            AdCountry::Bb => write!(f, "BB"),
            AdCountry::Bd => write!(f, "BD"),
            AdCountry::Be => write!(f, "BE"),
            AdCountry::Bf => write!(f, "BF"),
            AdCountry::Bg => write!(f, "BG"),
            AdCountry::Bh => write!(f, "BH"),
            AdCountry::Bi => write!(f, "BI"),
            AdCountry::Bj => write!(f, "BJ"),
            AdCountry::Bl => write!(f, "BL"),
            AdCountry::Bm => write!(f, "BM"),
            AdCountry::Bn => write!(f, "BN"),
            AdCountry::Bo => write!(f, "BO"),
            AdCountry::Bq => write!(f, "BQ"),
            AdCountry::Br => write!(f, "BR"),
            AdCountry::Bs => write!(f, "BS"),
            AdCountry::Bt => write!(f, "BT"),
            AdCountry::Bv => write!(f, "BV"),
            AdCountry::Bw => write!(f, "BW"),
            AdCountry::By => write!(f, "BY"),
            AdCountry::Bz => write!(f, "BZ"),
            AdCountry::Ca => write!(f, "CA"),
            AdCountry::Cc => write!(f, "CC"),
            AdCountry::Cd => write!(f, "CD"),
            AdCountry::Cf => write!(f, "CF"),
            AdCountry::Cg => write!(f, "CG"),
            AdCountry::Ch => write!(f, "CH"),
            AdCountry::Ci => write!(f, "CI"),
            AdCountry::Ck => write!(f, "CK"),
            AdCountry::Cl => write!(f, "CL"),
            AdCountry::Cm => write!(f, "CM"),
            AdCountry::Cn => write!(f, "CN"),
            AdCountry::Co => write!(f, "CO"),
            AdCountry::Cr => write!(f, "CR"),
            AdCountry::Cu => write!(f, "CU"),
            AdCountry::Cv => write!(f, "CV"),
            AdCountry::Cw => write!(f, "CW"),
            AdCountry::Cx => write!(f, "CX"),
            AdCountry::Cy => write!(f, "CY"),
            AdCountry::Cz => write!(f, "CZ"),
            AdCountry::De => write!(f, "DE"),
            AdCountry::Dj => write!(f, "DJ"),
            AdCountry::Dk => write!(f, "DK"),
            AdCountry::Dm => write!(f, "DM"),
            AdCountry::Do => write!(f, "DO"),
            AdCountry::Dz => write!(f, "DZ"),
            AdCountry::Ec => write!(f, "EC"),
            AdCountry::Ee => write!(f, "EE"),
            AdCountry::Eg => write!(f, "EG"),
            AdCountry::Eh => write!(f, "EH"),
            AdCountry::Er => write!(f, "ER"),
            AdCountry::Es => write!(f, "ES"),
            AdCountry::Et => write!(f, "ET"),
            AdCountry::Fi => write!(f, "FI"),
            AdCountry::Fj => write!(f, "FJ"),
            AdCountry::Fk => write!(f, "FK"),
            AdCountry::Fm => write!(f, "FM"),
            AdCountry::Fo => write!(f, "FO"),
            AdCountry::Fr => write!(f, "FR"),
            AdCountry::Ga => write!(f, "GA"),
            AdCountry::Gb => write!(f, "GB"),
            AdCountry::Gd => write!(f, "GD"),
            AdCountry::Ge => write!(f, "GE"),
            AdCountry::Gf => write!(f, "GF"),
            AdCountry::Gg => write!(f, "GG"),
            AdCountry::Gh => write!(f, "GH"),
            AdCountry::Gi => write!(f, "GI"),
            AdCountry::Gl => write!(f, "GL"),
            AdCountry::Gm => write!(f, "GM"),
            AdCountry::Gn => write!(f, "GN"),
            AdCountry::Gp => write!(f, "GP"),
            AdCountry::Gq => write!(f, "GQ"),
            AdCountry::Gr => write!(f, "GR"),
            AdCountry::Gs => write!(f, "GS"),
            AdCountry::Gt => write!(f, "GT"),
            AdCountry::Gu => write!(f, "GU"),
            AdCountry::Gw => write!(f, "GW"),
            AdCountry::Gy => write!(f, "GY"),
            AdCountry::Hk => write!(f, "HK"),
            AdCountry::Hm => write!(f, "HM"),
            AdCountry::Hn => write!(f, "HN"),
            AdCountry::Hr => write!(f, "HR"),
            AdCountry::Ht => write!(f, "HT"),
            AdCountry::Hu => write!(f, "HU"),
            AdCountry::Id => write!(f, "ID"),
            AdCountry::Ie => write!(f, "IE"),
            AdCountry::Il => write!(f, "IL"),
            AdCountry::Im => write!(f, "IM"),
            AdCountry::In => write!(f, "IN"),
            AdCountry::Io => write!(f, "IO"),
            AdCountry::Iq => write!(f, "IQ"),
            AdCountry::Ir => write!(f, "IR"),
            AdCountry::Is => write!(f, "IS"),
            AdCountry::It => write!(f, "IT"),
            AdCountry::Je => write!(f, "JE"),
            AdCountry::Jm => write!(f, "JM"),
            AdCountry::Jo => write!(f, "JO"),
            AdCountry::Jp => write!(f, "JP"),
            AdCountry::Ke => write!(f, "KE"),
            AdCountry::Kg => write!(f, "KG"),
            AdCountry::Kh => write!(f, "KH"),
            AdCountry::Ki => write!(f, "KI"),
            AdCountry::Km => write!(f, "KM"),
            AdCountry::Kn => write!(f, "KN"),
            AdCountry::Kr => write!(f, "KR"),
            AdCountry::Kw => write!(f, "KW"),
            AdCountry::Ky => write!(f, "KY"),
            AdCountry::Kz => write!(f, "KZ"),
            AdCountry::La => write!(f, "LA"),
            AdCountry::Lb => write!(f, "LB"),
            AdCountry::Lc => write!(f, "LC"),
            AdCountry::Li => write!(f, "LI"),
            AdCountry::Lk => write!(f, "LK"),
            AdCountry::Lr => write!(f, "LR"),
            AdCountry::Ls => write!(f, "LS"),
            AdCountry::Lt => write!(f, "LT"),
            AdCountry::Lu => write!(f, "LU"),
            AdCountry::Lv => write!(f, "LV"),
            AdCountry::Ly => write!(f, "LY"),
            AdCountry::Ma => write!(f, "MA"),
            AdCountry::Mc => write!(f, "MC"),
            AdCountry::Md => write!(f, "MD"),
            AdCountry::Me => write!(f, "ME"),
            AdCountry::Mf => write!(f, "MF"),
            AdCountry::Mg => write!(f, "MG"),
            AdCountry::Mh => write!(f, "MH"),
            AdCountry::Mk => write!(f, "MK"),
            AdCountry::Ml => write!(f, "ML"),
            AdCountry::Mm => write!(f, "MM"),
            AdCountry::Mn => write!(f, "MN"),
            AdCountry::Mo => write!(f, "MO"),
            AdCountry::Mp => write!(f, "MP"),
            AdCountry::Mq => write!(f, "MQ"),
            AdCountry::Mr => write!(f, "MR"),
            AdCountry::Ms => write!(f, "MS"),
            AdCountry::Mt => write!(f, "MT"),
            AdCountry::Mu => write!(f, "MU"),
            AdCountry::Mv => write!(f, "MV"),
            AdCountry::Mw => write!(f, "MW"),
            AdCountry::Mx => write!(f, "MX"),
            AdCountry::My => write!(f, "MY"),
            AdCountry::Mz => write!(f, "MZ"),
            AdCountry::Na => write!(f, "NA"),
            AdCountry::Nc => write!(f, "NC"),
            AdCountry::Ne => write!(f, "NE"),
            AdCountry::Nf => write!(f, "NF"),
            AdCountry::Ng => write!(f, "NG"),
            AdCountry::Ni => write!(f, "NI"),
            AdCountry::Nl => write!(f, "NL"),
            AdCountry::No => write!(f, "NO"),
            AdCountry::Np => write!(f, "NP"),
            AdCountry::Nr => write!(f, "NR"),
            AdCountry::Nu => write!(f, "NU"),
            AdCountry::Nz => write!(f, "NZ"),
            AdCountry::Om => write!(f, "OM"),
            AdCountry::Pa => write!(f, "PA"),
            AdCountry::Pe => write!(f, "PE"),
            AdCountry::Pf => write!(f, "PF"),
            AdCountry::Pg => write!(f, "PG"),
            AdCountry::Ph => write!(f, "PH"),
            AdCountry::Pk => write!(f, "PK"),
            AdCountry::Pl => write!(f, "PL"),
            AdCountry::Pm => write!(f, "PM"),
            AdCountry::Pn => write!(f, "PN"),
            AdCountry::Pr => write!(f, "PR"),
            AdCountry::Ps => write!(f, "PS"),
            AdCountry::Pt => write!(f, "PT"),
            AdCountry::Pw => write!(f, "PW"),
            AdCountry::Py => write!(f, "PY"),
            AdCountry::Qa => write!(f, "QA"),
            AdCountry::Re => write!(f, "RE"),
            AdCountry::Ro => write!(f, "RO"),
            AdCountry::Rs => write!(f, "RS"),
            AdCountry::Ru => write!(f, "RU"),
            AdCountry::Rw => write!(f, "RW"),
            AdCountry::Sa => write!(f, "SA"),
            AdCountry::Sb => write!(f, "SB"),
            AdCountry::Sc => write!(f, "SC"),
            AdCountry::Sd => write!(f, "SD"),
            AdCountry::Se => write!(f, "SE"),
            AdCountry::Sg => write!(f, "SG"),
            AdCountry::Sh => write!(f, "SH"),
            AdCountry::Si => write!(f, "SI"),
            AdCountry::Sj => write!(f, "SJ"),
            AdCountry::Sk => write!(f, "SK"),
            AdCountry::Sl => write!(f, "SL"),
            AdCountry::Sm => write!(f, "SM"),
            AdCountry::Sn => write!(f, "SN"),
            AdCountry::So => write!(f, "SO"),
            AdCountry::Sr => write!(f, "SR"),
            AdCountry::Ss => write!(f, "SS"),
            AdCountry::St => write!(f, "ST"),
            AdCountry::Sv => write!(f, "SV"),
            AdCountry::Sx => write!(f, "SX"),
            AdCountry::Sy => write!(f, "SY"),
            AdCountry::Sz => write!(f, "SZ"),
            AdCountry::Tc => write!(f, "TC"),
            AdCountry::Td => write!(f, "TD"),
            AdCountry::Tf => write!(f, "TF"),
            AdCountry::Tg => write!(f, "TG"),
            AdCountry::Th => write!(f, "TH"),
            AdCountry::Tj => write!(f, "TJ"),
            AdCountry::Tk => write!(f, "TK"),
            AdCountry::Tl => write!(f, "TL"),
            AdCountry::Tm => write!(f, "TM"),
            AdCountry::Tn => write!(f, "TN"),
            AdCountry::To => write!(f, "TO"),
            AdCountry::Tr => write!(f, "TR"),
            AdCountry::Tt => write!(f, "TT"),
            AdCountry::Tv => write!(f, "TV"),
            AdCountry::Tw => write!(f, "TW"),
            AdCountry::Tz => write!(f, "TZ"),
            AdCountry::Ua => write!(f, "UA"),
            AdCountry::Ug => write!(f, "UG"),
            AdCountry::Um => write!(f, "UM"),
            AdCountry::Us => write!(f, "US"),
            AdCountry::Uy => write!(f, "UY"),
            AdCountry::Uz => write!(f, "UZ"),
            AdCountry::Va => write!(f, "VA"),
            AdCountry::Vc => write!(f, "VC"),
            AdCountry::Ve => write!(f, "VE"),
            AdCountry::Vg => write!(f, "VG"),
            AdCountry::Vi => write!(f, "VI"),
            AdCountry::Vn => write!(f, "VN"),
            AdCountry::Vu => write!(f, "VU"),
            AdCountry::Wf => write!(f, "WF"),
            AdCountry::Ws => write!(f, "WS"),
            AdCountry::Ye => write!(f, "YE"),
            AdCountry::Yt => write!(f, "YT"),
            AdCountry::Za => write!(f, "ZA"),
            AdCountry::Zm => write!(f, "ZM"),
            AdCountry::Zw => write!(f, "ZW"),
        }
    }
}

impl std::str::FromStr for AdCountry {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AD" => std::result::Result::Ok(AdCountry::Ad),
            "AE" => std::result::Result::Ok(AdCountry::Ae),
            "AF" => std::result::Result::Ok(AdCountry::Af),
            "AG" => std::result::Result::Ok(AdCountry::Ag),
            "AI" => std::result::Result::Ok(AdCountry::Ai),
            "AL" => std::result::Result::Ok(AdCountry::Al),
            "AM" => std::result::Result::Ok(AdCountry::Am),
            "AO" => std::result::Result::Ok(AdCountry::Ao),
            "AQ" => std::result::Result::Ok(AdCountry::Aq),
            "AR" => std::result::Result::Ok(AdCountry::Ar),
            "AS" => std::result::Result::Ok(AdCountry::As),
            "AT" => std::result::Result::Ok(AdCountry::At),
            "AU" => std::result::Result::Ok(AdCountry::Au),
            "AW" => std::result::Result::Ok(AdCountry::Aw),
            "AX" => std::result::Result::Ok(AdCountry::Ax),
            "AZ" => std::result::Result::Ok(AdCountry::Az),
            "BA" => std::result::Result::Ok(AdCountry::Ba),
            "BB" => std::result::Result::Ok(AdCountry::Bb),
            "BD" => std::result::Result::Ok(AdCountry::Bd),
            "BE" => std::result::Result::Ok(AdCountry::Be),
            "BF" => std::result::Result::Ok(AdCountry::Bf),
            "BG" => std::result::Result::Ok(AdCountry::Bg),
            "BH" => std::result::Result::Ok(AdCountry::Bh),
            "BI" => std::result::Result::Ok(AdCountry::Bi),
            "BJ" => std::result::Result::Ok(AdCountry::Bj),
            "BL" => std::result::Result::Ok(AdCountry::Bl),
            "BM" => std::result::Result::Ok(AdCountry::Bm),
            "BN" => std::result::Result::Ok(AdCountry::Bn),
            "BO" => std::result::Result::Ok(AdCountry::Bo),
            "BQ" => std::result::Result::Ok(AdCountry::Bq),
            "BR" => std::result::Result::Ok(AdCountry::Br),
            "BS" => std::result::Result::Ok(AdCountry::Bs),
            "BT" => std::result::Result::Ok(AdCountry::Bt),
            "BV" => std::result::Result::Ok(AdCountry::Bv),
            "BW" => std::result::Result::Ok(AdCountry::Bw),
            "BY" => std::result::Result::Ok(AdCountry::By),
            "BZ" => std::result::Result::Ok(AdCountry::Bz),
            "CA" => std::result::Result::Ok(AdCountry::Ca),
            "CC" => std::result::Result::Ok(AdCountry::Cc),
            "CD" => std::result::Result::Ok(AdCountry::Cd),
            "CF" => std::result::Result::Ok(AdCountry::Cf),
            "CG" => std::result::Result::Ok(AdCountry::Cg),
            "CH" => std::result::Result::Ok(AdCountry::Ch),
            "CI" => std::result::Result::Ok(AdCountry::Ci),
            "CK" => std::result::Result::Ok(AdCountry::Ck),
            "CL" => std::result::Result::Ok(AdCountry::Cl),
            "CM" => std::result::Result::Ok(AdCountry::Cm),
            "CN" => std::result::Result::Ok(AdCountry::Cn),
            "CO" => std::result::Result::Ok(AdCountry::Co),
            "CR" => std::result::Result::Ok(AdCountry::Cr),
            "CU" => std::result::Result::Ok(AdCountry::Cu),
            "CV" => std::result::Result::Ok(AdCountry::Cv),
            "CW" => std::result::Result::Ok(AdCountry::Cw),
            "CX" => std::result::Result::Ok(AdCountry::Cx),
            "CY" => std::result::Result::Ok(AdCountry::Cy),
            "CZ" => std::result::Result::Ok(AdCountry::Cz),
            "DE" => std::result::Result::Ok(AdCountry::De),
            "DJ" => std::result::Result::Ok(AdCountry::Dj),
            "DK" => std::result::Result::Ok(AdCountry::Dk),
            "DM" => std::result::Result::Ok(AdCountry::Dm),
            "DO" => std::result::Result::Ok(AdCountry::Do),
            "DZ" => std::result::Result::Ok(AdCountry::Dz),
            "EC" => std::result::Result::Ok(AdCountry::Ec),
            "EE" => std::result::Result::Ok(AdCountry::Ee),
            "EG" => std::result::Result::Ok(AdCountry::Eg),
            "EH" => std::result::Result::Ok(AdCountry::Eh),
            "ER" => std::result::Result::Ok(AdCountry::Er),
            "ES" => std::result::Result::Ok(AdCountry::Es),
            "ET" => std::result::Result::Ok(AdCountry::Et),
            "FI" => std::result::Result::Ok(AdCountry::Fi),
            "FJ" => std::result::Result::Ok(AdCountry::Fj),
            "FK" => std::result::Result::Ok(AdCountry::Fk),
            "FM" => std::result::Result::Ok(AdCountry::Fm),
            "FO" => std::result::Result::Ok(AdCountry::Fo),
            "FR" => std::result::Result::Ok(AdCountry::Fr),
            "GA" => std::result::Result::Ok(AdCountry::Ga),
            "GB" => std::result::Result::Ok(AdCountry::Gb),
            "GD" => std::result::Result::Ok(AdCountry::Gd),
            "GE" => std::result::Result::Ok(AdCountry::Ge),
            "GF" => std::result::Result::Ok(AdCountry::Gf),
            "GG" => std::result::Result::Ok(AdCountry::Gg),
            "GH" => std::result::Result::Ok(AdCountry::Gh),
            "GI" => std::result::Result::Ok(AdCountry::Gi),
            "GL" => std::result::Result::Ok(AdCountry::Gl),
            "GM" => std::result::Result::Ok(AdCountry::Gm),
            "GN" => std::result::Result::Ok(AdCountry::Gn),
            "GP" => std::result::Result::Ok(AdCountry::Gp),
            "GQ" => std::result::Result::Ok(AdCountry::Gq),
            "GR" => std::result::Result::Ok(AdCountry::Gr),
            "GS" => std::result::Result::Ok(AdCountry::Gs),
            "GT" => std::result::Result::Ok(AdCountry::Gt),
            "GU" => std::result::Result::Ok(AdCountry::Gu),
            "GW" => std::result::Result::Ok(AdCountry::Gw),
            "GY" => std::result::Result::Ok(AdCountry::Gy),
            "HK" => std::result::Result::Ok(AdCountry::Hk),
            "HM" => std::result::Result::Ok(AdCountry::Hm),
            "HN" => std::result::Result::Ok(AdCountry::Hn),
            "HR" => std::result::Result::Ok(AdCountry::Hr),
            "HT" => std::result::Result::Ok(AdCountry::Ht),
            "HU" => std::result::Result::Ok(AdCountry::Hu),
            "ID" => std::result::Result::Ok(AdCountry::Id),
            "IE" => std::result::Result::Ok(AdCountry::Ie),
            "IL" => std::result::Result::Ok(AdCountry::Il),
            "IM" => std::result::Result::Ok(AdCountry::Im),
            "IN" => std::result::Result::Ok(AdCountry::In),
            "IO" => std::result::Result::Ok(AdCountry::Io),
            "IQ" => std::result::Result::Ok(AdCountry::Iq),
            "IR" => std::result::Result::Ok(AdCountry::Ir),
            "IS" => std::result::Result::Ok(AdCountry::Is),
            "IT" => std::result::Result::Ok(AdCountry::It),
            "JE" => std::result::Result::Ok(AdCountry::Je),
            "JM" => std::result::Result::Ok(AdCountry::Jm),
            "JO" => std::result::Result::Ok(AdCountry::Jo),
            "JP" => std::result::Result::Ok(AdCountry::Jp),
            "KE" => std::result::Result::Ok(AdCountry::Ke),
            "KG" => std::result::Result::Ok(AdCountry::Kg),
            "KH" => std::result::Result::Ok(AdCountry::Kh),
            "KI" => std::result::Result::Ok(AdCountry::Ki),
            "KM" => std::result::Result::Ok(AdCountry::Km),
            "KN" => std::result::Result::Ok(AdCountry::Kn),
            "KR" => std::result::Result::Ok(AdCountry::Kr),
            "KW" => std::result::Result::Ok(AdCountry::Kw),
            "KY" => std::result::Result::Ok(AdCountry::Ky),
            "KZ" => std::result::Result::Ok(AdCountry::Kz),
            "LA" => std::result::Result::Ok(AdCountry::La),
            "LB" => std::result::Result::Ok(AdCountry::Lb),
            "LC" => std::result::Result::Ok(AdCountry::Lc),
            "LI" => std::result::Result::Ok(AdCountry::Li),
            "LK" => std::result::Result::Ok(AdCountry::Lk),
            "LR" => std::result::Result::Ok(AdCountry::Lr),
            "LS" => std::result::Result::Ok(AdCountry::Ls),
            "LT" => std::result::Result::Ok(AdCountry::Lt),
            "LU" => std::result::Result::Ok(AdCountry::Lu),
            "LV" => std::result::Result::Ok(AdCountry::Lv),
            "LY" => std::result::Result::Ok(AdCountry::Ly),
            "MA" => std::result::Result::Ok(AdCountry::Ma),
            "MC" => std::result::Result::Ok(AdCountry::Mc),
            "MD" => std::result::Result::Ok(AdCountry::Md),
            "ME" => std::result::Result::Ok(AdCountry::Me),
            "MF" => std::result::Result::Ok(AdCountry::Mf),
            "MG" => std::result::Result::Ok(AdCountry::Mg),
            "MH" => std::result::Result::Ok(AdCountry::Mh),
            "MK" => std::result::Result::Ok(AdCountry::Mk),
            "ML" => std::result::Result::Ok(AdCountry::Ml),
            "MM" => std::result::Result::Ok(AdCountry::Mm),
            "MN" => std::result::Result::Ok(AdCountry::Mn),
            "MO" => std::result::Result::Ok(AdCountry::Mo),
            "MP" => std::result::Result::Ok(AdCountry::Mp),
            "MQ" => std::result::Result::Ok(AdCountry::Mq),
            "MR" => std::result::Result::Ok(AdCountry::Mr),
            "MS" => std::result::Result::Ok(AdCountry::Ms),
            "MT" => std::result::Result::Ok(AdCountry::Mt),
            "MU" => std::result::Result::Ok(AdCountry::Mu),
            "MV" => std::result::Result::Ok(AdCountry::Mv),
            "MW" => std::result::Result::Ok(AdCountry::Mw),
            "MX" => std::result::Result::Ok(AdCountry::Mx),
            "MY" => std::result::Result::Ok(AdCountry::My),
            "MZ" => std::result::Result::Ok(AdCountry::Mz),
            "NA" => std::result::Result::Ok(AdCountry::Na),
            "NC" => std::result::Result::Ok(AdCountry::Nc),
            "NE" => std::result::Result::Ok(AdCountry::Ne),
            "NF" => std::result::Result::Ok(AdCountry::Nf),
            "NG" => std::result::Result::Ok(AdCountry::Ng),
            "NI" => std::result::Result::Ok(AdCountry::Ni),
            "NL" => std::result::Result::Ok(AdCountry::Nl),
            "NO" => std::result::Result::Ok(AdCountry::No),
            "NP" => std::result::Result::Ok(AdCountry::Np),
            "NR" => std::result::Result::Ok(AdCountry::Nr),
            "NU" => std::result::Result::Ok(AdCountry::Nu),
            "NZ" => std::result::Result::Ok(AdCountry::Nz),
            "OM" => std::result::Result::Ok(AdCountry::Om),
            "PA" => std::result::Result::Ok(AdCountry::Pa),
            "PE" => std::result::Result::Ok(AdCountry::Pe),
            "PF" => std::result::Result::Ok(AdCountry::Pf),
            "PG" => std::result::Result::Ok(AdCountry::Pg),
            "PH" => std::result::Result::Ok(AdCountry::Ph),
            "PK" => std::result::Result::Ok(AdCountry::Pk),
            "PL" => std::result::Result::Ok(AdCountry::Pl),
            "PM" => std::result::Result::Ok(AdCountry::Pm),
            "PN" => std::result::Result::Ok(AdCountry::Pn),
            "PR" => std::result::Result::Ok(AdCountry::Pr),
            "PS" => std::result::Result::Ok(AdCountry::Ps),
            "PT" => std::result::Result::Ok(AdCountry::Pt),
            "PW" => std::result::Result::Ok(AdCountry::Pw),
            "PY" => std::result::Result::Ok(AdCountry::Py),
            "QA" => std::result::Result::Ok(AdCountry::Qa),
            "RE" => std::result::Result::Ok(AdCountry::Re),
            "RO" => std::result::Result::Ok(AdCountry::Ro),
            "RS" => std::result::Result::Ok(AdCountry::Rs),
            "RU" => std::result::Result::Ok(AdCountry::Ru),
            "RW" => std::result::Result::Ok(AdCountry::Rw),
            "SA" => std::result::Result::Ok(AdCountry::Sa),
            "SB" => std::result::Result::Ok(AdCountry::Sb),
            "SC" => std::result::Result::Ok(AdCountry::Sc),
            "SD" => std::result::Result::Ok(AdCountry::Sd),
            "SE" => std::result::Result::Ok(AdCountry::Se),
            "SG" => std::result::Result::Ok(AdCountry::Sg),
            "SH" => std::result::Result::Ok(AdCountry::Sh),
            "SI" => std::result::Result::Ok(AdCountry::Si),
            "SJ" => std::result::Result::Ok(AdCountry::Sj),
            "SK" => std::result::Result::Ok(AdCountry::Sk),
            "SL" => std::result::Result::Ok(AdCountry::Sl),
            "SM" => std::result::Result::Ok(AdCountry::Sm),
            "SN" => std::result::Result::Ok(AdCountry::Sn),
            "SO" => std::result::Result::Ok(AdCountry::So),
            "SR" => std::result::Result::Ok(AdCountry::Sr),
            "SS" => std::result::Result::Ok(AdCountry::Ss),
            "ST" => std::result::Result::Ok(AdCountry::St),
            "SV" => std::result::Result::Ok(AdCountry::Sv),
            "SX" => std::result::Result::Ok(AdCountry::Sx),
            "SY" => std::result::Result::Ok(AdCountry::Sy),
            "SZ" => std::result::Result::Ok(AdCountry::Sz),
            "TC" => std::result::Result::Ok(AdCountry::Tc),
            "TD" => std::result::Result::Ok(AdCountry::Td),
            "TF" => std::result::Result::Ok(AdCountry::Tf),
            "TG" => std::result::Result::Ok(AdCountry::Tg),
            "TH" => std::result::Result::Ok(AdCountry::Th),
            "TJ" => std::result::Result::Ok(AdCountry::Tj),
            "TK" => std::result::Result::Ok(AdCountry::Tk),
            "TL" => std::result::Result::Ok(AdCountry::Tl),
            "TM" => std::result::Result::Ok(AdCountry::Tm),
            "TN" => std::result::Result::Ok(AdCountry::Tn),
            "TO" => std::result::Result::Ok(AdCountry::To),
            "TR" => std::result::Result::Ok(AdCountry::Tr),
            "TT" => std::result::Result::Ok(AdCountry::Tt),
            "TV" => std::result::Result::Ok(AdCountry::Tv),
            "TW" => std::result::Result::Ok(AdCountry::Tw),
            "TZ" => std::result::Result::Ok(AdCountry::Tz),
            "UA" => std::result::Result::Ok(AdCountry::Ua),
            "UG" => std::result::Result::Ok(AdCountry::Ug),
            "UM" => std::result::Result::Ok(AdCountry::Um),
            "US" => std::result::Result::Ok(AdCountry::Us),
            "UY" => std::result::Result::Ok(AdCountry::Uy),
            "UZ" => std::result::Result::Ok(AdCountry::Uz),
            "VA" => std::result::Result::Ok(AdCountry::Va),
            "VC" => std::result::Result::Ok(AdCountry::Vc),
            "VE" => std::result::Result::Ok(AdCountry::Ve),
            "VG" => std::result::Result::Ok(AdCountry::Vg),
            "VI" => std::result::Result::Ok(AdCountry::Vi),
            "VN" => std::result::Result::Ok(AdCountry::Vn),
            "VU" => std::result::Result::Ok(AdCountry::Vu),
            "WF" => std::result::Result::Ok(AdCountry::Wf),
            "WS" => std::result::Result::Ok(AdCountry::Ws),
            "YE" => std::result::Result::Ok(AdCountry::Ye),
            "YT" => std::result::Result::Ok(AdCountry::Yt),
            "ZA" => std::result::Result::Ok(AdCountry::Za),
            "ZM" => std::result::Result::Ok(AdCountry::Zm),
            "ZW" => std::result::Result::Ok(AdCountry::Zw),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdCreateRequest {
/// ID of the ad group that contains the ad.
    #[serde(rename = "ad_group_id")]
    #[validate(
           regex = "RE_ADCREATEREQUEST_AD_GROUP_ID",
        )]
    pub ad_group_id: String,

/// Deep link URL for Android devices. Not currently available. Using this field will generate an error.
    #[serde(rename = "android_deep_link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub android_deep_link: Option<Nullable<String>>,

/// Comma-separated deep links for the carousel pin on Android.
    #[serde(rename = "carousel_android_deep_links")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_android_deep_links: Option<Nullable<Vec<String>>>,

/// Comma-separated destination URLs for the carousel pin to promote.
    #[serde(rename = "carousel_destination_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_destination_urls: Option<Nullable<Vec<String>>>,

/// Comma-separated deep links for the carousel pin on iOS.
    #[serde(rename = "carousel_ios_deep_links")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_ios_deep_links: Option<Nullable<Vec<String>>>,

/// Tracking url for the ad clicks.
    #[serde(rename = "click_tracking_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub click_tracking_url: Option<Nullable<String>>,

    #[serde(rename = "creative_type")]
    pub creative_type: models::CreativeType,

/// Destination URL.
    #[serde(rename = "destination_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub destination_url: Option<Nullable<String>>,

/// Deep link URL for iOS devices. Not currently available. Using this field will generate an error.
    #[serde(rename = "ios_deep_link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ios_deep_link: Option<Nullable<String>>,

/// Is original pin deleted?
    #[serde(rename = "is_pin_deleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_pin_deleted: Option<bool>,

/// Is pin repinnable?
    #[serde(rename = "is_removable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_removable: Option<bool>,

/// Name of the ad - 255 chars max.
    #[serde(rename = "name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<Nullable<models::AdCommonTrackingUrls>>,

/// Tracking URL for ad impressions.
    #[serde(rename = "view_tracking_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub view_tracking_url: Option<Nullable<String>>,

/// Lead form ID for lead ad generation.
    #[serde(rename = "lead_form_id")]
    #[validate(
           regex = "RE_ADCREATEREQUEST_LEAD_FORM_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lead_form_id: Option<Nullable<String>>,

    #[serde(rename = "grid_click_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub grid_click_type: Option<Nullable<models::GridClickType>>,

/// Select a call to action (CTA) to display below your ad. Available only for ads with direct links enabled. CTA options for consideration and conversion campaigns are LEARN_MORE, SHOP_NOW, BOOK_NOW, SIGN_UP, VISIT_WEBSITE, BUY_NOW, GET_OFFER, ORDER_NOW, ADD_TO_CART (for conversion campaigns with add to cart conversion events only)
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "customizable_cta_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub customizable_cta_type: Option<Nullable<String>>,

    #[serde(rename = "quiz_pin_data")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quiz_pin_data: Option<Nullable<models::AdCommonQuizPinData>>,

/// Pin ID.
    #[serde(rename = "pin_id")]
    #[validate(
           regex = "RE_ADCREATEREQUEST_PIN_ID",
        )]
    pub pin_id: String,

}

lazy_static::lazy_static! {
    static ref RE_ADCREATEREQUEST_AD_GROUP_ID: regex::Regex = regex::Regex::new(r"^(AG)?\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADCREATEREQUEST_LEAD_FORM_ID: regex::Regex = regex::Regex::new(r"^(AG)?\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADCREATEREQUEST_PIN_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AdCreateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(ad_group_id: String, creative_type: models::CreativeType, pin_id: String, ) -> AdCreateRequest {
        AdCreateRequest {
            ad_group_id,
            android_deep_link: None,
            carousel_android_deep_links: None,
            carousel_destination_urls: None,
            carousel_ios_deep_links: None,
            click_tracking_url: None,
            creative_type,
            destination_url: None,
            ios_deep_link: None,
            is_pin_deleted: None,
            is_removable: None,
            name: None,
            status: None,
            tracking_urls: None,
            view_tracking_url: None,
            lead_form_id: None,
            grid_click_type: None,
            customizable_cta_type: None,
            quiz_pin_data: None,
            pin_id,
        }
    }
}

/// Converts the AdCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdCreateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("ad_group_id".to_string()),
            Some(self.ad_group_id.to_string()),


            self.android_deep_link.as_ref().map(|android_deep_link| {
                [
                    "android_deep_link".to_string(),
                    android_deep_link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.carousel_android_deep_links.as_ref().map(|carousel_android_deep_links| {
                [
                    "carousel_android_deep_links".to_string(),
                    carousel_android_deep_links.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.carousel_destination_urls.as_ref().map(|carousel_destination_urls| {
                [
                    "carousel_destination_urls".to_string(),
                    carousel_destination_urls.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.carousel_ios_deep_links.as_ref().map(|carousel_ios_deep_links| {
                [
                    "carousel_ios_deep_links".to_string(),
                    carousel_ios_deep_links.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.click_tracking_url.as_ref().map(|click_tracking_url| {
                [
                    "click_tracking_url".to_string(),
                    click_tracking_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping creative_type in query parameter serialization


            self.destination_url.as_ref().map(|destination_url| {
                [
                    "destination_url".to_string(),
                    destination_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.ios_deep_link.as_ref().map(|ios_deep_link| {
                [
                    "ios_deep_link".to_string(),
                    ios_deep_link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_pin_deleted.as_ref().map(|is_pin_deleted| {
                [
                    "is_pin_deleted".to_string(),
                    is_pin_deleted.to_string(),
                ].join(",")
            }),


            self.is_removable.as_ref().map(|is_removable| {
                [
                    "is_removable".to_string(),
                    is_removable.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping status in query parameter serialization

            // Skipping tracking_urls in query parameter serialization


            self.view_tracking_url.as_ref().map(|view_tracking_url| {
                [
                    "view_tracking_url".to_string(),
                    view_tracking_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.lead_form_id.as_ref().map(|lead_form_id| {
                [
                    "lead_form_id".to_string(),
                    lead_form_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping grid_click_type in query parameter serialization


            self.customizable_cta_type.as_ref().map(|customizable_cta_type| {
                [
                    "customizable_cta_type".to_string(),
                    customizable_cta_type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping quiz_pin_data in query parameter serialization


            Some("pin_id".to_string()),
            Some(self.pin_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_group_id: Vec<String>,
            pub android_deep_link: Vec<String>,
            pub carousel_android_deep_links: Vec<Vec<String>>,
            pub carousel_destination_urls: Vec<Vec<String>>,
            pub carousel_ios_deep_links: Vec<Vec<String>>,
            pub click_tracking_url: Vec<String>,
            pub creative_type: Vec<models::CreativeType>,
            pub destination_url: Vec<String>,
            pub ios_deep_link: Vec<String>,
            pub is_pin_deleted: Vec<bool>,
            pub is_removable: Vec<bool>,
            pub name: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub tracking_urls: Vec<models::AdCommonTrackingUrls>,
            pub view_tracking_url: Vec<String>,
            pub lead_form_id: Vec<String>,
            pub grid_click_type: Vec<models::GridClickType>,
            pub customizable_cta_type: Vec<String>,
            pub quiz_pin_data: Vec<models::AdCommonQuizPinData>,
            pub pin_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_group_id" => intermediate_rep.ad_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "android_deep_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCreateRequest".to_string()),
                    "carousel_android_deep_links" => return std::result::Result::Err("Parsing a container in this style is not supported in AdCreateRequest".to_string()),
                    "carousel_destination_urls" => return std::result::Result::Err("Parsing a container in this style is not supported in AdCreateRequest".to_string()),
                    "carousel_ios_deep_links" => return std::result::Result::Err("Parsing a container in this style is not supported in AdCreateRequest".to_string()),
                    "click_tracking_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "creative_type" => intermediate_rep.creative_type.push(<models::CreativeType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "destination_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCreateRequest".to_string()),
                    "ios_deep_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "is_pin_deleted" => intermediate_rep.is_pin_deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_removable" => intermediate_rep.is_removable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCreateRequest".to_string()),
                    "view_tracking_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCreateRequest".to_string()),
                    "lead_form_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCreateRequest".to_string()),
                    "grid_click_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCreateRequest".to_string()),
                    "customizable_cta_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCreateRequest".to_string()),
                    "quiz_pin_data" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pin_id" => intermediate_rep.pin_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdCreateRequest {
            ad_group_id: intermediate_rep.ad_group_id.into_iter().next().ok_or_else(|| "ad_group_id missing in AdCreateRequest".to_string())?,
            android_deep_link: std::result::Result::Err("Nullable types not supported in AdCreateRequest".to_string())?,
            carousel_android_deep_links: std::result::Result::Err("Nullable types not supported in AdCreateRequest".to_string())?,
            carousel_destination_urls: std::result::Result::Err("Nullable types not supported in AdCreateRequest".to_string())?,
            carousel_ios_deep_links: std::result::Result::Err("Nullable types not supported in AdCreateRequest".to_string())?,
            click_tracking_url: std::result::Result::Err("Nullable types not supported in AdCreateRequest".to_string())?,
            creative_type: intermediate_rep.creative_type.into_iter().next().ok_or_else(|| "creative_type missing in AdCreateRequest".to_string())?,
            destination_url: std::result::Result::Err("Nullable types not supported in AdCreateRequest".to_string())?,
            ios_deep_link: std::result::Result::Err("Nullable types not supported in AdCreateRequest".to_string())?,
            is_pin_deleted: intermediate_rep.is_pin_deleted.into_iter().next(),
            is_removable: intermediate_rep.is_removable.into_iter().next(),
            name: std::result::Result::Err("Nullable types not supported in AdCreateRequest".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
            tracking_urls: std::result::Result::Err("Nullable types not supported in AdCreateRequest".to_string())?,
            view_tracking_url: std::result::Result::Err("Nullable types not supported in AdCreateRequest".to_string())?,
            lead_form_id: std::result::Result::Err("Nullable types not supported in AdCreateRequest".to_string())?,
            grid_click_type: std::result::Result::Err("Nullable types not supported in AdCreateRequest".to_string())?,
            customizable_cta_type: std::result::Result::Err("Nullable types not supported in AdCreateRequest".to_string())?,
            quiz_pin_data: std::result::Result::Err("Nullable types not supported in AdCreateRequest".to_string())?,
            pin_id: intermediate_rep.pin_id.into_iter().next().ok_or_else(|| "pin_id missing in AdCreateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdCreateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdCreateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdCreateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdCreateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdGroupArrayResponse {
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::AdGroupArrayResponseElement>>,

}


impl AdGroupArrayResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdGroupArrayResponse {
        AdGroupArrayResponse {
            items: None,
        }
    }
}

/// Converts the AdGroupArrayResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdGroupArrayResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdGroupArrayResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdGroupArrayResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::AdGroupArrayResponseElement>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdGroupArrayResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in AdGroupArrayResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdGroupArrayResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdGroupArrayResponse {
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdGroupArrayResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdGroupArrayResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdGroupArrayResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdGroupArrayResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdGroupArrayResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdGroupArrayResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdGroupArrayResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdGroupArrayResponseElement {
    #[serde(rename = "data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<models::AdGroupResponse>,

    #[serde(rename = "exceptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exceptions: Option<Vec<models::Exception>>,

}


impl AdGroupArrayResponseElement {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdGroupArrayResponseElement {
        AdGroupArrayResponseElement {
            data: None,
            exceptions: None,
        }
    }
}

/// Converts the AdGroupArrayResponseElement value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdGroupArrayResponseElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization

            // Skipping exceptions in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdGroupArrayResponseElement value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdGroupArrayResponseElement {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<models::AdGroupResponse>,
            pub exceptions: Vec<Vec<models::Exception>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdGroupArrayResponseElement".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::AdGroupResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "exceptions" => return std::result::Result::Err("Parsing a container in this style is not supported in AdGroupArrayResponseElement".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdGroupArrayResponseElement".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdGroupArrayResponseElement {
            data: intermediate_rep.data.into_iter().next(),
            exceptions: intermediate_rep.exceptions.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdGroupArrayResponseElement> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdGroupArrayResponseElement>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdGroupArrayResponseElement>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdGroupArrayResponseElement - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdGroupArrayResponseElement> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdGroupArrayResponseElement as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdGroupArrayResponseElement - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdGroupAudienceSizingRequest {
/// Enable auto-targeting for ad group. Also known as <a href=\"https://help.pinterest.com/en/business/article/expanded-targeting\" target=\"_blank\">\"expanded targeting\"</a>.
    #[serde(rename = "auto_targeting_enabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_targeting_enabled: Option<bool>,

/// <a href=\"/docs/redoc/#section/Placement-group\">Placement group</a>.
    #[serde(rename = "placement_group")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub placement_group: Option<models::PlacementGroupType>,

/// Pin creative types filter. </p><strong>Note:</strong> SHOP_THE_PIN has been deprecated. Please use COLLECTION instead.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "creative_types")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creative_types: Option<Nullable<Vec<String>>>,

    #[serde(rename = "targeting_spec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub targeting_spec: Option<models::TargetingSpec>,

/// Targeted product group IDs. </p><strong>Note:</strong> This can only be combined with shopping/catalog sales campaigns. For more information, <a href=\"https://help.pinterest.com/en/business/article/shopping-ads#section-14571\" target=\"_blank\">click here</a>. SHOPPING_RETARGETING must be included in targeting_spec object or this field will be ignored.
    #[serde(rename = "product_group_ids")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_group_ids: Option<Nullable<Vec<String>>>,

/// Array of keyword objects. If the keywords field is missing, all keywords will be targeted.
    #[serde(rename = "keywords")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub keywords: Option<Nullable<Vec<models::AdGroupAudienceSizingRequestKeywordsInner>>>,

}


impl AdGroupAudienceSizingRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdGroupAudienceSizingRequest {
        AdGroupAudienceSizingRequest {
            auto_targeting_enabled: Some(true),
            placement_group: Some("ALL".to_string()),
            creative_types: None,
            targeting_spec: None,
            product_group_ids: None,
            keywords: None,
        }
    }
}

/// Converts the AdGroupAudienceSizingRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdGroupAudienceSizingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.auto_targeting_enabled.as_ref().map(|auto_targeting_enabled| {
                [
                    "auto_targeting_enabled".to_string(),
                    auto_targeting_enabled.to_string(),
                ].join(",")
            }),

            // Skipping placement_group in query parameter serialization


            self.creative_types.as_ref().map(|creative_types| {
                [
                    "creative_types".to_string(),
                    creative_types.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping targeting_spec in query parameter serialization


            self.product_group_ids.as_ref().map(|product_group_ids| {
                [
                    "product_group_ids".to_string(),
                    product_group_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping keywords in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdGroupAudienceSizingRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdGroupAudienceSizingRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub auto_targeting_enabled: Vec<bool>,
            pub placement_group: Vec<models::PlacementGroupType>,
            pub creative_types: Vec<Vec<String>>,
            pub targeting_spec: Vec<models::TargetingSpec>,
            pub product_group_ids: Vec<Vec<String>>,
            pub keywords: Vec<Vec<models::AdGroupAudienceSizingRequestKeywordsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdGroupAudienceSizingRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "auto_targeting_enabled" => intermediate_rep.auto_targeting_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "placement_group" => intermediate_rep.placement_group.push(<models::PlacementGroupType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "creative_types" => return std::result::Result::Err("Parsing a container in this style is not supported in AdGroupAudienceSizingRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "targeting_spec" => intermediate_rep.targeting_spec.push(<models::TargetingSpec as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "product_group_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in AdGroupAudienceSizingRequest".to_string()),
                    "keywords" => return std::result::Result::Err("Parsing a container in this style is not supported in AdGroupAudienceSizingRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdGroupAudienceSizingRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdGroupAudienceSizingRequest {
            auto_targeting_enabled: intermediate_rep.auto_targeting_enabled.into_iter().next(),
            placement_group: intermediate_rep.placement_group.into_iter().next(),
            creative_types: std::result::Result::Err("Nullable types not supported in AdGroupAudienceSizingRequest".to_string())?,
            targeting_spec: intermediate_rep.targeting_spec.into_iter().next(),
            product_group_ids: std::result::Result::Err("Nullable types not supported in AdGroupAudienceSizingRequest".to_string())?,
            keywords: std::result::Result::Err("Nullable types not supported in AdGroupAudienceSizingRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdGroupAudienceSizingRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdGroupAudienceSizingRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdGroupAudienceSizingRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdGroupAudienceSizingRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdGroupAudienceSizingRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdGroupAudienceSizingRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdGroupAudienceSizingRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdGroupAudienceSizingRequestKeywordsInner {
    #[serde(rename = "match_type")]
    pub match_type: Nullable<models::MatchTypeResponse>,

/// Keyword value (120 chars max).
    #[serde(rename = "value")]
    pub value: String,

}


impl AdGroupAudienceSizingRequestKeywordsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(match_type: Nullable<models::MatchTypeResponse>, value: String, ) -> AdGroupAudienceSizingRequestKeywordsInner {
        AdGroupAudienceSizingRequestKeywordsInner {
            match_type,
            value,
        }
    }
}

/// Converts the AdGroupAudienceSizingRequestKeywordsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdGroupAudienceSizingRequestKeywordsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping match_type in query parameter serialization


            Some("value".to_string()),
            Some(self.value.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdGroupAudienceSizingRequestKeywordsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdGroupAudienceSizingRequestKeywordsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub match_type: Vec<models::MatchTypeResponse>,
            pub value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdGroupAudienceSizingRequestKeywordsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "match_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupAudienceSizingRequestKeywordsInner".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdGroupAudienceSizingRequestKeywordsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdGroupAudienceSizingRequestKeywordsInner {
            match_type: std::result::Result::Err("Nullable types not supported in AdGroupAudienceSizingRequestKeywordsInner".to_string())?,
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in AdGroupAudienceSizingRequestKeywordsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdGroupAudienceSizingRequestKeywordsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdGroupAudienceSizingRequestKeywordsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdGroupAudienceSizingRequestKeywordsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdGroupAudienceSizingRequestKeywordsInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdGroupAudienceSizingRequestKeywordsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdGroupAudienceSizingRequestKeywordsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdGroupAudienceSizingRequestKeywordsInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdGroupAudienceSizingResponse {
/// The lower confidence bound of the estimated potential audience size. \"Potential audience size\" estimates the number of people you may be able to reach per month with your campaign. It is based on historical advertising data and the targeting criteria you select. It does not guarantee results or take into account factors such as bid, budget, schedule, seasonality or product experiments.
    #[serde(rename = "audience_size_lower_bound")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audience_size_lower_bound: Option<f64>,

/// The upper confidence bound of the estimated potential audience size. \"Potential audience size\" estimates the number of people you may be able to reach per month with your campaign. It is based on historical advertising data and the targeting criteria you select. It does not guarantee results or take into account factors such as bid, budget, schedule, seasonality or product experiments.
    #[serde(rename = "audience_size_upper_bound")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audience_size_upper_bound: Option<f64>,

}


impl AdGroupAudienceSizingResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdGroupAudienceSizingResponse {
        AdGroupAudienceSizingResponse {
            audience_size_lower_bound: None,
            audience_size_upper_bound: None,
        }
    }
}

/// Converts the AdGroupAudienceSizingResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdGroupAudienceSizingResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.audience_size_lower_bound.as_ref().map(|audience_size_lower_bound| {
                [
                    "audience_size_lower_bound".to_string(),
                    audience_size_lower_bound.to_string(),
                ].join(",")
            }),


            self.audience_size_upper_bound.as_ref().map(|audience_size_upper_bound| {
                [
                    "audience_size_upper_bound".to_string(),
                    audience_size_upper_bound.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdGroupAudienceSizingResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdGroupAudienceSizingResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub audience_size_lower_bound: Vec<f64>,
            pub audience_size_upper_bound: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdGroupAudienceSizingResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "audience_size_lower_bound" => intermediate_rep.audience_size_lower_bound.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "audience_size_upper_bound" => intermediate_rep.audience_size_upper_bound.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdGroupAudienceSizingResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdGroupAudienceSizingResponse {
            audience_size_lower_bound: intermediate_rep.audience_size_lower_bound.into_iter().next(),
            audience_size_upper_bound: intermediate_rep.audience_size_upper_bound.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdGroupAudienceSizingResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdGroupAudienceSizingResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdGroupAudienceSizingResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdGroupAudienceSizingResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdGroupAudienceSizingResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdGroupAudienceSizingResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdGroupAudienceSizingResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdGroupCommon {
/// Ad group name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Ad group/entity status.
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

/// Budget in micro currency. This field is **REQUIRED** for non-CBO (campaign budget optimization) campaigns.  A CBO campaign automatically generates ad group budgets from its campaign budget to maximize campaign outcome. A CBO campaign is limited to 70 or less ad groups.
    #[serde(rename = "budget_in_micro_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget_in_micro_currency: Option<Nullable<i32>>,

/// Bid price in micro currency. This field is **REQUIRED** for the following campaign objective_type/billable_event combinations: AWARENESS/IMPRESSION, CONSIDERATION/CLICKTHROUGH, CATALOG_SALES/CLICKTHROUGH, VIDEO_VIEW/VIDEO_V_50_MRC.
    #[serde(rename = "bid_in_micro_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid_in_micro_currency: Option<Nullable<i32>>,

    #[serde(rename = "optimization_goal_metadata")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optimization_goal_metadata: Option<Nullable<models::AdGroupCommonOptimizationGoalMetadata>>,

    #[serde(rename = "budget_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget_type: Option<models::BudgetType>,

/// Ad group start time. Unix timestamp in seconds. Defaults to current time.
    #[serde(rename = "start_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<Nullable<i32>>,

/// Ad group end time. Unix timestamp in seconds.
    #[serde(rename = "end_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<Nullable<i32>>,

    #[serde(rename = "targeting_spec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub targeting_spec: Option<models::TargetingSpec>,

/// Set a limit to the number of times a promoted pin from this campaign can be impressed by a pinner within the past rolling 30 days. Only available for CPM (cost per mille (1000 impressions))  ad groups. A CPM ad group has an IMPRESSION <a href=\"https://developers.pinterest.com/docs/redoc/#section/Billable-event\">billable_event</a> value. This field **REQUIRES** the `end_time` field.
    #[serde(rename = "lifetime_frequency_cap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifetime_frequency_cap: Option<i32>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<Nullable<models::AdGroupCommonTrackingUrls>>,

/// Enable auto-targeting for ad group. Also known as <a href=\"https://help.pinterest.com/en/business/article/expanded-targeting\" target=\"_blank\">\"expanded targeting\"</a>.
    #[serde(rename = "auto_targeting_enabled")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_targeting_enabled: Option<Nullable<bool>>,

/// <a href=\"https://developers.pinterest.com/docs/redoc/#section/Placement-group\">Placement group</a>.
    #[serde(rename = "placement_group")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub placement_group: Option<models::PlacementGroupType>,

    #[serde(rename = "pacing_delivery_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pacing_delivery_type: Option<models::PacingDeliveryType>,

/// Campaign ID of the ad group.
    #[serde(rename = "campaign_id")]
    #[validate(
           regex = "RE_ADGROUPCOMMON_CAMPAIGN_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_id: Option<String>,

    #[serde(rename = "billable_event")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billable_event: Option<models::ActionType>,

/// Bid strategy type
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "bid_strategy_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid_strategy_type: Option<Nullable<String>>,

}

lazy_static::lazy_static! {
    static ref RE_ADGROUPCOMMON_CAMPAIGN_ID: regex::Regex = regex::Regex::new(r"^[C]?\\d+$").unwrap();
}

impl AdGroupCommon {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdGroupCommon {
        AdGroupCommon {
            name: None,
            status: None,
            budget_in_micro_currency: None,
            bid_in_micro_currency: None,
            optimization_goal_metadata: None,
            budget_type: None,
            start_time: None,
            end_time: None,
            targeting_spec: None,
            lifetime_frequency_cap: None,
            tracking_urls: None,
            auto_targeting_enabled: None,
            placement_group: None,
            pacing_delivery_type: None,
            campaign_id: None,
            billable_event: None,
            bid_strategy_type: None,
        }
    }
}

/// Converts the AdGroupCommon value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdGroupCommon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.budget_in_micro_currency.as_ref().map(|budget_in_micro_currency| {
                [
                    "budget_in_micro_currency".to_string(),
                    budget_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.bid_in_micro_currency.as_ref().map(|bid_in_micro_currency| {
                [
                    "bid_in_micro_currency".to_string(),
                    bid_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping optimization_goal_metadata in query parameter serialization

            // Skipping budget_type in query parameter serialization


            self.start_time.as_ref().map(|start_time| {
                [
                    "start_time".to_string(),
                    start_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.end_time.as_ref().map(|end_time| {
                [
                    "end_time".to_string(),
                    end_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping targeting_spec in query parameter serialization


            self.lifetime_frequency_cap.as_ref().map(|lifetime_frequency_cap| {
                [
                    "lifetime_frequency_cap".to_string(),
                    lifetime_frequency_cap.to_string(),
                ].join(",")
            }),

            // Skipping tracking_urls in query parameter serialization


            self.auto_targeting_enabled.as_ref().map(|auto_targeting_enabled| {
                [
                    "auto_targeting_enabled".to_string(),
                    auto_targeting_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping placement_group in query parameter serialization

            // Skipping pacing_delivery_type in query parameter serialization


            self.campaign_id.as_ref().map(|campaign_id| {
                [
                    "campaign_id".to_string(),
                    campaign_id.to_string(),
                ].join(",")
            }),

            // Skipping billable_event in query parameter serialization


            self.bid_strategy_type.as_ref().map(|bid_strategy_type| {
                [
                    "bid_strategy_type".to_string(),
                    bid_strategy_type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdGroupCommon value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdGroupCommon {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub budget_in_micro_currency: Vec<i32>,
            pub bid_in_micro_currency: Vec<i32>,
            pub optimization_goal_metadata: Vec<models::AdGroupCommonOptimizationGoalMetadata>,
            pub budget_type: Vec<models::BudgetType>,
            pub start_time: Vec<i32>,
            pub end_time: Vec<i32>,
            pub targeting_spec: Vec<models::TargetingSpec>,
            pub lifetime_frequency_cap: Vec<i32>,
            pub tracking_urls: Vec<models::AdGroupCommonTrackingUrls>,
            pub auto_targeting_enabled: Vec<bool>,
            pub placement_group: Vec<models::PlacementGroupType>,
            pub pacing_delivery_type: Vec<models::PacingDeliveryType>,
            pub campaign_id: Vec<String>,
            pub billable_event: Vec<models::ActionType>,
            pub bid_strategy_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdGroupCommon".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "budget_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupCommon".to_string()),
                    "bid_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupCommon".to_string()),
                    "optimization_goal_metadata" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupCommon".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "budget_type" => intermediate_rep.budget_type.push(<models::BudgetType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "start_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupCommon".to_string()),
                    "end_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupCommon".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "targeting_spec" => intermediate_rep.targeting_spec.push(<models::TargetingSpec as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifetime_frequency_cap" => intermediate_rep.lifetime_frequency_cap.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupCommon".to_string()),
                    "auto_targeting_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupCommon".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "placement_group" => intermediate_rep.placement_group.push(<models::PlacementGroupType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pacing_delivery_type" => intermediate_rep.pacing_delivery_type.push(<models::PacingDeliveryType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "campaign_id" => intermediate_rep.campaign_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billable_event" => intermediate_rep.billable_event.push(<models::ActionType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "bid_strategy_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupCommon".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdGroupCommon".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdGroupCommon {
            name: intermediate_rep.name.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            budget_in_micro_currency: std::result::Result::Err("Nullable types not supported in AdGroupCommon".to_string())?,
            bid_in_micro_currency: std::result::Result::Err("Nullable types not supported in AdGroupCommon".to_string())?,
            optimization_goal_metadata: std::result::Result::Err("Nullable types not supported in AdGroupCommon".to_string())?,
            budget_type: intermediate_rep.budget_type.into_iter().next(),
            start_time: std::result::Result::Err("Nullable types not supported in AdGroupCommon".to_string())?,
            end_time: std::result::Result::Err("Nullable types not supported in AdGroupCommon".to_string())?,
            targeting_spec: intermediate_rep.targeting_spec.into_iter().next(),
            lifetime_frequency_cap: intermediate_rep.lifetime_frequency_cap.into_iter().next(),
            tracking_urls: std::result::Result::Err("Nullable types not supported in AdGroupCommon".to_string())?,
            auto_targeting_enabled: std::result::Result::Err("Nullable types not supported in AdGroupCommon".to_string())?,
            placement_group: intermediate_rep.placement_group.into_iter().next(),
            pacing_delivery_type: intermediate_rep.pacing_delivery_type.into_iter().next(),
            campaign_id: intermediate_rep.campaign_id.into_iter().next(),
            billable_event: intermediate_rep.billable_event.into_iter().next(),
            bid_strategy_type: std::result::Result::Err("Nullable types not supported in AdGroupCommon".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdGroupCommon> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdGroupCommon>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdGroupCommon>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdGroupCommon - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdGroupCommon> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdGroupCommon as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdGroupCommon - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Optimization goals for objective-based performance campaigns. **REQUIRED** when campaign's `objective_type` is set to `\"WEB_CONVERSION\"`.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdGroupCommonOptimizationGoalMetadata {
    #[serde(rename = "conversion_tag_v3_goal_metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conversion_tag_v3_goal_metadata: Option<models::OptimizationGoalMetadataConversionTagV3GoalMetadata>,

    #[serde(rename = "frequency_goal_metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub frequency_goal_metadata: Option<models::OptimizationGoalMetadataFrequencyGoalMetadata>,

    #[serde(rename = "scrollup_goal_metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scrollup_goal_metadata: Option<models::OptimizationGoalMetadataScrollupGoalMetadata>,

}


impl AdGroupCommonOptimizationGoalMetadata {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdGroupCommonOptimizationGoalMetadata {
        AdGroupCommonOptimizationGoalMetadata {
            conversion_tag_v3_goal_metadata: None,
            frequency_goal_metadata: None,
            scrollup_goal_metadata: None,
        }
    }
}

/// Converts the AdGroupCommonOptimizationGoalMetadata value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdGroupCommonOptimizationGoalMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping conversion_tag_v3_goal_metadata in query parameter serialization

            // Skipping frequency_goal_metadata in query parameter serialization

            // Skipping scrollup_goal_metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdGroupCommonOptimizationGoalMetadata value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdGroupCommonOptimizationGoalMetadata {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub conversion_tag_v3_goal_metadata: Vec<models::OptimizationGoalMetadataConversionTagV3GoalMetadata>,
            pub frequency_goal_metadata: Vec<models::OptimizationGoalMetadataFrequencyGoalMetadata>,
            pub scrollup_goal_metadata: Vec<models::OptimizationGoalMetadataScrollupGoalMetadata>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdGroupCommonOptimizationGoalMetadata".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "conversion_tag_v3_goal_metadata" => intermediate_rep.conversion_tag_v3_goal_metadata.push(<models::OptimizationGoalMetadataConversionTagV3GoalMetadata as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "frequency_goal_metadata" => intermediate_rep.frequency_goal_metadata.push(<models::OptimizationGoalMetadataFrequencyGoalMetadata as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scrollup_goal_metadata" => intermediate_rep.scrollup_goal_metadata.push(<models::OptimizationGoalMetadataScrollupGoalMetadata as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdGroupCommonOptimizationGoalMetadata".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdGroupCommonOptimizationGoalMetadata {
            conversion_tag_v3_goal_metadata: intermediate_rep.conversion_tag_v3_goal_metadata.into_iter().next(),
            frequency_goal_metadata: intermediate_rep.frequency_goal_metadata.into_iter().next(),
            scrollup_goal_metadata: intermediate_rep.scrollup_goal_metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdGroupCommonOptimizationGoalMetadata> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdGroupCommonOptimizationGoalMetadata>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdGroupCommonOptimizationGoalMetadata>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdGroupCommonOptimizationGoalMetadata - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdGroupCommonOptimizationGoalMetadata> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdGroupCommonOptimizationGoalMetadata as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdGroupCommonOptimizationGoalMetadata - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Third-party tracking URLs.<br> JSON object with the format: {\"<a href=\"https://developers.pinterest.com/docs/redoc/#section/Tracking-URL-event\">Tracking event enum</a>\":[URL string array],...}<br> For example: {\"impression\": [\"URL1\", \"URL2\"], \"click\": [\"URL1\", \"URL2\", \"URL3\"]}.<br>Up to three tracking URLs are supported for each event type. Tracking URLs set at the ad group or ad level can override those set at the campaign level. May be null. Pass in an empty object - {} - to remove tracking URLs.<br><br> For more information, see <a href=\"https://help.pinterest.com/en/business/article/third-party-and-dynamic-tracking\" target=\"_blank\">Third-party and dynamic tracking</a>.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdGroupCommonTrackingUrls {
    #[serde(rename = "impression")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub impression: Option<Vec<String>>,

    #[serde(rename = "click")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub click: Option<Vec<String>>,

    #[serde(rename = "engagement")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub engagement: Option<Vec<String>>,

    #[serde(rename = "buyable_button")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub buyable_button: Option<Vec<String>>,

    #[serde(rename = "audience_verification")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audience_verification: Option<Vec<String>>,

}


impl AdGroupCommonTrackingUrls {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdGroupCommonTrackingUrls {
        AdGroupCommonTrackingUrls {
            impression: None,
            click: None,
            engagement: None,
            buyable_button: None,
            audience_verification: None,
        }
    }
}

/// Converts the AdGroupCommonTrackingUrls value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdGroupCommonTrackingUrls {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.impression.as_ref().map(|impression| {
                [
                    "impression".to_string(),
                    impression.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.click.as_ref().map(|click| {
                [
                    "click".to_string(),
                    click.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.engagement.as_ref().map(|engagement| {
                [
                    "engagement".to_string(),
                    engagement.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.buyable_button.as_ref().map(|buyable_button| {
                [
                    "buyable_button".to_string(),
                    buyable_button.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.audience_verification.as_ref().map(|audience_verification| {
                [
                    "audience_verification".to_string(),
                    audience_verification.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdGroupCommonTrackingUrls value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdGroupCommonTrackingUrls {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub impression: Vec<Vec<String>>,
            pub click: Vec<Vec<String>>,
            pub engagement: Vec<Vec<String>>,
            pub buyable_button: Vec<Vec<String>>,
            pub audience_verification: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdGroupCommonTrackingUrls".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "impression" => return std::result::Result::Err("Parsing a container in this style is not supported in AdGroupCommonTrackingUrls".to_string()),
                    "click" => return std::result::Result::Err("Parsing a container in this style is not supported in AdGroupCommonTrackingUrls".to_string()),
                    "engagement" => return std::result::Result::Err("Parsing a container in this style is not supported in AdGroupCommonTrackingUrls".to_string()),
                    "buyable_button" => return std::result::Result::Err("Parsing a container in this style is not supported in AdGroupCommonTrackingUrls".to_string()),
                    "audience_verification" => return std::result::Result::Err("Parsing a container in this style is not supported in AdGroupCommonTrackingUrls".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdGroupCommonTrackingUrls".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdGroupCommonTrackingUrls {
            impression: intermediate_rep.impression.into_iter().next(),
            click: intermediate_rep.click.into_iter().next(),
            engagement: intermediate_rep.engagement.into_iter().next(),
            buyable_button: intermediate_rep.buyable_button.into_iter().next(),
            audience_verification: intermediate_rep.audience_verification.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdGroupCommonTrackingUrls> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdGroupCommonTrackingUrls>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdGroupCommonTrackingUrls>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdGroupCommonTrackingUrls - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdGroupCommonTrackingUrls> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdGroupCommonTrackingUrls as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdGroupCommonTrackingUrls - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdGroupCreateRequest {
/// Ad group name.
    #[serde(rename = "name")]
    pub name: String,

/// Ad group/entity status.
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

/// Budget in micro currency. This field is **REQUIRED** for non-CBO (campaign budget optimization) campaigns.  A CBO campaign automatically generates ad group budgets from its campaign budget to maximize campaign outcome. A CBO campaign is limited to 70 or less ad groups.
    #[serde(rename = "budget_in_micro_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget_in_micro_currency: Option<Nullable<i32>>,

/// Bid price in micro currency. This field is **REQUIRED** for the following campaign objective_type/billable_event combinations: AWARENESS/IMPRESSION, CONSIDERATION/CLICKTHROUGH, CATALOG_SALES/CLICKTHROUGH, VIDEO_VIEW/VIDEO_V_50_MRC.
    #[serde(rename = "bid_in_micro_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid_in_micro_currency: Option<Nullable<i32>>,

    #[serde(rename = "optimization_goal_metadata")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optimization_goal_metadata: Option<Nullable<models::AdGroupCommonOptimizationGoalMetadata>>,

    #[serde(rename = "budget_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget_type: Option<models::BudgetType>,

/// Ad group start time. Unix timestamp in seconds. Defaults to current time.
    #[serde(rename = "start_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<Nullable<i32>>,

/// Ad group end time. Unix timestamp in seconds.
    #[serde(rename = "end_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<Nullable<i32>>,

    #[serde(rename = "targeting_spec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub targeting_spec: Option<models::TargetingSpec>,

/// Set a limit to the number of times a promoted pin from this campaign can be impressed by a pinner within the past rolling 30 days. Only available for CPM (cost per mille (1000 impressions))  ad groups. A CPM ad group has an IMPRESSION <a href=\"https://developers.pinterest.com/docs/redoc/#section/Billable-event\">billable_event</a> value. This field **REQUIRES** the `end_time` field.
    #[serde(rename = "lifetime_frequency_cap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifetime_frequency_cap: Option<i32>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<Nullable<models::AdGroupCommonTrackingUrls>>,

/// Enable auto-targeting for ad group.Default value is True. Also known as <a href=\"https://help.pinterest.com/en/business/article/expanded-targeting\" target=\"_blank\">\"expanded targeting\"</a>.
    #[serde(rename = "auto_targeting_enabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_targeting_enabled: Option<bool>,

/// <a href=\"https://developers.pinterest.com/docs/redoc/#section/Placement-group\">Placement group</a>.
    #[serde(rename = "placement_group")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub placement_group: Option<models::PlacementGroupType>,

    #[serde(rename = "pacing_delivery_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pacing_delivery_type: Option<models::PacingDeliveryType>,

/// Campaign ID of the ad group.
    #[serde(rename = "campaign_id")]
    #[validate(
           regex = "RE_ADGROUPCREATEREQUEST_CAMPAIGN_ID",
        )]
    pub campaign_id: String,

    #[serde(rename = "billable_event")]
    pub billable_event: models::ActionType,

/// Bid strategy type
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "bid_strategy_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid_strategy_type: Option<Nullable<String>>,

}

lazy_static::lazy_static! {
    static ref RE_ADGROUPCREATEREQUEST_CAMPAIGN_ID: regex::Regex = regex::Regex::new(r"^[C]?\\d+$").unwrap();
}

impl AdGroupCreateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, campaign_id: String, billable_event: models::ActionType, ) -> AdGroupCreateRequest {
        AdGroupCreateRequest {
            name,
            status: None,
            budget_in_micro_currency: None,
            bid_in_micro_currency: None,
            optimization_goal_metadata: None,
            budget_type: Some("DAILY".to_string()),
            start_time: None,
            end_time: None,
            targeting_spec: None,
            lifetime_frequency_cap: None,
            tracking_urls: None,
            auto_targeting_enabled: None,
            placement_group: None,
            pacing_delivery_type: Some("STANDARD".to_string()),
            campaign_id,
            billable_event,
            bid_strategy_type: None,
        }
    }
}

/// Converts the AdGroupCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdGroupCreateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping status in query parameter serialization


            self.budget_in_micro_currency.as_ref().map(|budget_in_micro_currency| {
                [
                    "budget_in_micro_currency".to_string(),
                    budget_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.bid_in_micro_currency.as_ref().map(|bid_in_micro_currency| {
                [
                    "bid_in_micro_currency".to_string(),
                    bid_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping optimization_goal_metadata in query parameter serialization

            // Skipping budget_type in query parameter serialization


            self.start_time.as_ref().map(|start_time| {
                [
                    "start_time".to_string(),
                    start_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.end_time.as_ref().map(|end_time| {
                [
                    "end_time".to_string(),
                    end_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping targeting_spec in query parameter serialization


            self.lifetime_frequency_cap.as_ref().map(|lifetime_frequency_cap| {
                [
                    "lifetime_frequency_cap".to_string(),
                    lifetime_frequency_cap.to_string(),
                ].join(",")
            }),

            // Skipping tracking_urls in query parameter serialization


            self.auto_targeting_enabled.as_ref().map(|auto_targeting_enabled| {
                [
                    "auto_targeting_enabled".to_string(),
                    auto_targeting_enabled.to_string(),
                ].join(",")
            }),

            // Skipping placement_group in query parameter serialization

            // Skipping pacing_delivery_type in query parameter serialization


            Some("campaign_id".to_string()),
            Some(self.campaign_id.to_string()),

            // Skipping billable_event in query parameter serialization


            self.bid_strategy_type.as_ref().map(|bid_strategy_type| {
                [
                    "bid_strategy_type".to_string(),
                    bid_strategy_type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdGroupCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdGroupCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub budget_in_micro_currency: Vec<i32>,
            pub bid_in_micro_currency: Vec<i32>,
            pub optimization_goal_metadata: Vec<models::AdGroupCommonOptimizationGoalMetadata>,
            pub budget_type: Vec<models::BudgetType>,
            pub start_time: Vec<i32>,
            pub end_time: Vec<i32>,
            pub targeting_spec: Vec<models::TargetingSpec>,
            pub lifetime_frequency_cap: Vec<i32>,
            pub tracking_urls: Vec<models::AdGroupCommonTrackingUrls>,
            pub auto_targeting_enabled: Vec<bool>,
            pub placement_group: Vec<models::PlacementGroupType>,
            pub pacing_delivery_type: Vec<models::PacingDeliveryType>,
            pub campaign_id: Vec<String>,
            pub billable_event: Vec<models::ActionType>,
            pub bid_strategy_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdGroupCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "budget_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupCreateRequest".to_string()),
                    "bid_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupCreateRequest".to_string()),
                    "optimization_goal_metadata" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "budget_type" => intermediate_rep.budget_type.push(<models::BudgetType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "start_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupCreateRequest".to_string()),
                    "end_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "targeting_spec" => intermediate_rep.targeting_spec.push(<models::TargetingSpec as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifetime_frequency_cap" => intermediate_rep.lifetime_frequency_cap.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "auto_targeting_enabled" => intermediate_rep.auto_targeting_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "placement_group" => intermediate_rep.placement_group.push(<models::PlacementGroupType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pacing_delivery_type" => intermediate_rep.pacing_delivery_type.push(<models::PacingDeliveryType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "campaign_id" => intermediate_rep.campaign_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billable_event" => intermediate_rep.billable_event.push(<models::ActionType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "bid_strategy_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupCreateRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdGroupCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdGroupCreateRequest {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in AdGroupCreateRequest".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
            budget_in_micro_currency: std::result::Result::Err("Nullable types not supported in AdGroupCreateRequest".to_string())?,
            bid_in_micro_currency: std::result::Result::Err("Nullable types not supported in AdGroupCreateRequest".to_string())?,
            optimization_goal_metadata: std::result::Result::Err("Nullable types not supported in AdGroupCreateRequest".to_string())?,
            budget_type: intermediate_rep.budget_type.into_iter().next(),
            start_time: std::result::Result::Err("Nullable types not supported in AdGroupCreateRequest".to_string())?,
            end_time: std::result::Result::Err("Nullable types not supported in AdGroupCreateRequest".to_string())?,
            targeting_spec: intermediate_rep.targeting_spec.into_iter().next(),
            lifetime_frequency_cap: intermediate_rep.lifetime_frequency_cap.into_iter().next(),
            tracking_urls: std::result::Result::Err("Nullable types not supported in AdGroupCreateRequest".to_string())?,
            auto_targeting_enabled: intermediate_rep.auto_targeting_enabled.into_iter().next(),
            placement_group: intermediate_rep.placement_group.into_iter().next(),
            pacing_delivery_type: intermediate_rep.pacing_delivery_type.into_iter().next(),
            campaign_id: intermediate_rep.campaign_id.into_iter().next().ok_or_else(|| "campaign_id missing in AdGroupCreateRequest".to_string())?,
            billable_event: intermediate_rep.billable_event.into_iter().next().ok_or_else(|| "billable_event missing in AdGroupCreateRequest".to_string())?,
            bid_strategy_type: std::result::Result::Err("Nullable types not supported in AdGroupCreateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdGroupCreateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdGroupCreateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdGroupCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdGroupCreateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdGroupCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdGroupCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdGroupCreateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdGroupResponse {
/// Ad group name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Ad group/entity status.
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

/// Budget in micro currency. This field is **REQUIRED** for non-CBO (campaign budget optimization) campaigns.  A CBO campaign automatically generates ad group budgets from its campaign budget to maximize campaign outcome. A CBO campaign is limited to 70 or less ad groups.
    #[serde(rename = "budget_in_micro_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget_in_micro_currency: Option<Nullable<i32>>,

/// Bid price in micro currency. This field is **REQUIRED** for the following campaign objective_type/billable_event combinations: AWARENESS/IMPRESSION, CONSIDERATION/CLICKTHROUGH, CATALOG_SALES/CLICKTHROUGH, VIDEO_VIEW/VIDEO_V_50_MRC.
    #[serde(rename = "bid_in_micro_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid_in_micro_currency: Option<Nullable<i32>>,

    #[serde(rename = "optimization_goal_metadata")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optimization_goal_metadata: Option<Nullable<models::AdGroupCommonOptimizationGoalMetadata>>,

    #[serde(rename = "budget_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget_type: Option<models::BudgetType>,

/// Ad group start time. Unix timestamp in seconds. Defaults to current time.
    #[serde(rename = "start_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<Nullable<i32>>,

/// Ad group end time. Unix timestamp in seconds.
    #[serde(rename = "end_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<Nullable<i32>>,

    #[serde(rename = "targeting_spec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub targeting_spec: Option<models::TargetingSpec>,

/// Set a limit to the number of times a promoted pin from this campaign can be impressed by a pinner within the past rolling 30 days. Only available for CPM (cost per mille (1000 impressions))  ad groups. A CPM ad group has an IMPRESSION <a href=\"https://developers.pinterest.com/docs/redoc/#section/Billable-event\">billable_event</a> value. This field **REQUIRES** the `end_time` field.
    #[serde(rename = "lifetime_frequency_cap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifetime_frequency_cap: Option<i32>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<Nullable<models::AdGroupCommonTrackingUrls>>,

/// Enable auto-targeting for ad group. Also known as <a href=\"https://help.pinterest.com/en/business/article/expanded-targeting\" target=\"_blank\">\"expanded targeting\"</a>.
    #[serde(rename = "auto_targeting_enabled")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_targeting_enabled: Option<Nullable<bool>>,

/// <a href=\"https://developers.pinterest.com/docs/redoc/#section/Placement-group\">Placement group</a>.
    #[serde(rename = "placement_group")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub placement_group: Option<models::PlacementGroupType>,

    #[serde(rename = "pacing_delivery_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pacing_delivery_type: Option<models::PacingDeliveryType>,

/// Campaign ID of the ad group.
    #[serde(rename = "campaign_id")]
    #[validate(
           regex = "RE_ADGROUPRESPONSE_CAMPAIGN_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_id: Option<String>,

    #[serde(rename = "billable_event")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billable_event: Option<models::ActionType>,

/// Bid strategy type
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "bid_strategy_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid_strategy_type: Option<Nullable<String>>,

/// Ad group ID.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_ADGROUPRESPONSE_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Advertiser ID.
    #[serde(rename = "ad_account_id")]
    #[validate(
           regex = "RE_ADGROUPRESPONSE_AD_ACCOUNT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// Ad group creation time. Unix timestamp in seconds.
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<i32>,

/// Ad group last update time. Unix timestamp in seconds.
    #[serde(rename = "updated_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_time: Option<i32>,

/// Always \"adgroup\".
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

/// oCPM learn mode
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "conversion_learning_mode_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conversion_learning_mode_type: Option<Nullable<String>>,

/// Ad group summary status.
    #[serde(rename = "summary_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary_status: Option<models::AdGroupSummaryStatus>,

/// Feed Profile ID associated to the adgroup.
    #[serde(rename = "feed_profile_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feed_profile_id: Option<String>,

/// [DCA] The Dynamic creative assets to use for DCA. Dynamic Creative Assembly (DCA) accepts basic creative assets of an ad (image, video, title, call to action, logo etc). Then it automatically generates optimized ad combinations based on these assets.
    #[serde(rename = "dca_assets")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dca_assets: Option<crate::types::Object>,

}

lazy_static::lazy_static! {
    static ref RE_ADGROUPRESPONSE_CAMPAIGN_ID: regex::Regex = regex::Regex::new(r"^[C]?\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADGROUPRESPONSE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADGROUPRESPONSE_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AdGroupResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdGroupResponse {
        AdGroupResponse {
            name: None,
            status: None,
            budget_in_micro_currency: None,
            bid_in_micro_currency: None,
            optimization_goal_metadata: None,
            budget_type: None,
            start_time: None,
            end_time: None,
            targeting_spec: None,
            lifetime_frequency_cap: None,
            tracking_urls: None,
            auto_targeting_enabled: None,
            placement_group: None,
            pacing_delivery_type: None,
            campaign_id: None,
            billable_event: None,
            bid_strategy_type: None,
            id: None,
            ad_account_id: None,
            created_time: None,
            updated_time: None,
            r#type: Some("adgroup".to_string()),
            conversion_learning_mode_type: None,
            summary_status: None,
            feed_profile_id: None,
            dca_assets: None,
        }
    }
}

/// Converts the AdGroupResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdGroupResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.budget_in_micro_currency.as_ref().map(|budget_in_micro_currency| {
                [
                    "budget_in_micro_currency".to_string(),
                    budget_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.bid_in_micro_currency.as_ref().map(|bid_in_micro_currency| {
                [
                    "bid_in_micro_currency".to_string(),
                    bid_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping optimization_goal_metadata in query parameter serialization

            // Skipping budget_type in query parameter serialization


            self.start_time.as_ref().map(|start_time| {
                [
                    "start_time".to_string(),
                    start_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.end_time.as_ref().map(|end_time| {
                [
                    "end_time".to_string(),
                    end_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping targeting_spec in query parameter serialization


            self.lifetime_frequency_cap.as_ref().map(|lifetime_frequency_cap| {
                [
                    "lifetime_frequency_cap".to_string(),
                    lifetime_frequency_cap.to_string(),
                ].join(",")
            }),

            // Skipping tracking_urls in query parameter serialization


            self.auto_targeting_enabled.as_ref().map(|auto_targeting_enabled| {
                [
                    "auto_targeting_enabled".to_string(),
                    auto_targeting_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping placement_group in query parameter serialization

            // Skipping pacing_delivery_type in query parameter serialization


            self.campaign_id.as_ref().map(|campaign_id| {
                [
                    "campaign_id".to_string(),
                    campaign_id.to_string(),
                ].join(",")
            }),

            // Skipping billable_event in query parameter serialization


            self.bid_strategy_type.as_ref().map(|bid_strategy_type| {
                [
                    "bid_strategy_type".to_string(),
                    bid_strategy_type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.created_time.as_ref().map(|created_time| {
                [
                    "created_time".to_string(),
                    created_time.to_string(),
                ].join(",")
            }),


            self.updated_time.as_ref().map(|updated_time| {
                [
                    "updated_time".to_string(),
                    updated_time.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.conversion_learning_mode_type.as_ref().map(|conversion_learning_mode_type| {
                [
                    "conversion_learning_mode_type".to_string(),
                    conversion_learning_mode_type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping summary_status in query parameter serialization


            self.feed_profile_id.as_ref().map(|feed_profile_id| {
                [
                    "feed_profile_id".to_string(),
                    feed_profile_id.to_string(),
                ].join(",")
            }),

            // Skipping dca_assets in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdGroupResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdGroupResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub budget_in_micro_currency: Vec<i32>,
            pub bid_in_micro_currency: Vec<i32>,
            pub optimization_goal_metadata: Vec<models::AdGroupCommonOptimizationGoalMetadata>,
            pub budget_type: Vec<models::BudgetType>,
            pub start_time: Vec<i32>,
            pub end_time: Vec<i32>,
            pub targeting_spec: Vec<models::TargetingSpec>,
            pub lifetime_frequency_cap: Vec<i32>,
            pub tracking_urls: Vec<models::AdGroupCommonTrackingUrls>,
            pub auto_targeting_enabled: Vec<bool>,
            pub placement_group: Vec<models::PlacementGroupType>,
            pub pacing_delivery_type: Vec<models::PacingDeliveryType>,
            pub campaign_id: Vec<String>,
            pub billable_event: Vec<models::ActionType>,
            pub bid_strategy_type: Vec<String>,
            pub id: Vec<String>,
            pub ad_account_id: Vec<String>,
            pub created_time: Vec<i32>,
            pub updated_time: Vec<i32>,
            pub r#type: Vec<String>,
            pub conversion_learning_mode_type: Vec<String>,
            pub summary_status: Vec<models::AdGroupSummaryStatus>,
            pub feed_profile_id: Vec<String>,
            pub dca_assets: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdGroupResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "budget_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponse".to_string()),
                    "bid_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponse".to_string()),
                    "optimization_goal_metadata" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "budget_type" => intermediate_rep.budget_type.push(<models::BudgetType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "start_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponse".to_string()),
                    "end_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "targeting_spec" => intermediate_rep.targeting_spec.push(<models::TargetingSpec as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifetime_frequency_cap" => intermediate_rep.lifetime_frequency_cap.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponse".to_string()),
                    "auto_targeting_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "placement_group" => intermediate_rep.placement_group.push(<models::PlacementGroupType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pacing_delivery_type" => intermediate_rep.pacing_delivery_type.push(<models::PacingDeliveryType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "campaign_id" => intermediate_rep.campaign_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billable_event" => intermediate_rep.billable_event.push(<models::ActionType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "bid_strategy_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_time" => intermediate_rep.created_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updated_time" => intermediate_rep.updated_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "conversion_learning_mode_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "summary_status" => intermediate_rep.summary_status.push(<models::AdGroupSummaryStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "feed_profile_id" => intermediate_rep.feed_profile_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dca_assets" => intermediate_rep.dca_assets.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdGroupResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdGroupResponse {
            name: intermediate_rep.name.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            budget_in_micro_currency: std::result::Result::Err("Nullable types not supported in AdGroupResponse".to_string())?,
            bid_in_micro_currency: std::result::Result::Err("Nullable types not supported in AdGroupResponse".to_string())?,
            optimization_goal_metadata: std::result::Result::Err("Nullable types not supported in AdGroupResponse".to_string())?,
            budget_type: intermediate_rep.budget_type.into_iter().next(),
            start_time: std::result::Result::Err("Nullable types not supported in AdGroupResponse".to_string())?,
            end_time: std::result::Result::Err("Nullable types not supported in AdGroupResponse".to_string())?,
            targeting_spec: intermediate_rep.targeting_spec.into_iter().next(),
            lifetime_frequency_cap: intermediate_rep.lifetime_frequency_cap.into_iter().next(),
            tracking_urls: std::result::Result::Err("Nullable types not supported in AdGroupResponse".to_string())?,
            auto_targeting_enabled: std::result::Result::Err("Nullable types not supported in AdGroupResponse".to_string())?,
            placement_group: intermediate_rep.placement_group.into_iter().next(),
            pacing_delivery_type: intermediate_rep.pacing_delivery_type.into_iter().next(),
            campaign_id: intermediate_rep.campaign_id.into_iter().next(),
            billable_event: intermediate_rep.billable_event.into_iter().next(),
            bid_strategy_type: std::result::Result::Err("Nullable types not supported in AdGroupResponse".to_string())?,
            id: intermediate_rep.id.into_iter().next(),
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            created_time: intermediate_rep.created_time.into_iter().next(),
            updated_time: intermediate_rep.updated_time.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            conversion_learning_mode_type: std::result::Result::Err("Nullable types not supported in AdGroupResponse".to_string())?,
            summary_status: intermediate_rep.summary_status.into_iter().next(),
            feed_profile_id: intermediate_rep.feed_profile_id.into_iter().next(),
            dca_assets: intermediate_rep.dca_assets.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdGroupResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdGroupResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdGroupResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdGroupResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdGroupResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdGroupResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdGroupResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Summary status for ad group
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AdGroupSummaryStatus {
    #[serde(rename = "RUNNING")]
    Running,
    #[serde(rename = "PAUSED")]
    Paused,
    #[serde(rename = "NOT_STARTED")]
    NotStarted,
    #[serde(rename = "COMPLETED")]
    Completed,
    #[serde(rename = "ADVERTISER_DISABLED")]
    AdvertiserDisabled,
    #[serde(rename = "ARCHIVED")]
    Archived,
    #[serde(rename = "DRAFT")]
    Draft,
    #[serde(rename = "DELETED_DRAFT")]
    DeletedDraft,
}

impl std::fmt::Display for AdGroupSummaryStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AdGroupSummaryStatus::Running => write!(f, "RUNNING"),
            AdGroupSummaryStatus::Paused => write!(f, "PAUSED"),
            AdGroupSummaryStatus::NotStarted => write!(f, "NOT_STARTED"),
            AdGroupSummaryStatus::Completed => write!(f, "COMPLETED"),
            AdGroupSummaryStatus::AdvertiserDisabled => write!(f, "ADVERTISER_DISABLED"),
            AdGroupSummaryStatus::Archived => write!(f, "ARCHIVED"),
            AdGroupSummaryStatus::Draft => write!(f, "DRAFT"),
            AdGroupSummaryStatus::DeletedDraft => write!(f, "DELETED_DRAFT"),
        }
    }
}

impl std::str::FromStr for AdGroupSummaryStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "RUNNING" => std::result::Result::Ok(AdGroupSummaryStatus::Running),
            "PAUSED" => std::result::Result::Ok(AdGroupSummaryStatus::Paused),
            "NOT_STARTED" => std::result::Result::Ok(AdGroupSummaryStatus::NotStarted),
            "COMPLETED" => std::result::Result::Ok(AdGroupSummaryStatus::Completed),
            "ADVERTISER_DISABLED" => std::result::Result::Ok(AdGroupSummaryStatus::AdvertiserDisabled),
            "ARCHIVED" => std::result::Result::Ok(AdGroupSummaryStatus::Archived),
            "DRAFT" => std::result::Result::Ok(AdGroupSummaryStatus::Draft),
            "DELETED_DRAFT" => std::result::Result::Ok(AdGroupSummaryStatus::DeletedDraft),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdGroupUpdateRequest {
/// Ad group name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Ad group/entity status.
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

/// Budget in micro currency. This field is **REQUIRED** for non-CBO (campaign budget optimization) campaigns.  A CBO campaign automatically generates ad group budgets from its campaign budget to maximize campaign outcome. A CBO campaign is limited to 70 or less ad groups.
    #[serde(rename = "budget_in_micro_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget_in_micro_currency: Option<Nullable<i32>>,

/// Bid price in micro currency. This field is **REQUIRED** for the following campaign objective_type/billable_event combinations: AWARENESS/IMPRESSION, CONSIDERATION/CLICKTHROUGH, CATALOG_SALES/CLICKTHROUGH, VIDEO_VIEW/VIDEO_V_50_MRC.
    #[serde(rename = "bid_in_micro_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid_in_micro_currency: Option<Nullable<i32>>,

    #[serde(rename = "optimization_goal_metadata")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optimization_goal_metadata: Option<Nullable<models::AdGroupCommonOptimizationGoalMetadata>>,

    #[serde(rename = "budget_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget_type: Option<models::BudgetType>,

/// Ad group start time. Unix timestamp in seconds. Defaults to current time.
    #[serde(rename = "start_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<Nullable<i32>>,

/// Ad group end time. Unix timestamp in seconds.
    #[serde(rename = "end_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<Nullable<i32>>,

    #[serde(rename = "targeting_spec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub targeting_spec: Option<models::TargetingSpec>,

/// Set a limit to the number of times a promoted pin from this campaign can be impressed by a pinner within the past rolling 30 days. Only available for CPM (cost per mille (1000 impressions))  ad groups. A CPM ad group has an IMPRESSION <a href=\"https://developers.pinterest.com/docs/redoc/#section/Billable-event\">billable_event</a> value. This field **REQUIRES** the `end_time` field.
    #[serde(rename = "lifetime_frequency_cap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifetime_frequency_cap: Option<i32>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<Nullable<models::AdGroupCommonTrackingUrls>>,

/// Enable auto-targeting for ad group. Also known as <a href=\"https://help.pinterest.com/en/business/article/expanded-targeting\" target=\"_blank\">\"expanded targeting\"</a>.
    #[serde(rename = "auto_targeting_enabled")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_targeting_enabled: Option<Nullable<bool>>,

/// <a href=\"https://developers.pinterest.com/docs/redoc/#section/Placement-group\">Placement group</a>.
    #[serde(rename = "placement_group")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub placement_group: Option<models::PlacementGroupType>,

    #[serde(rename = "pacing_delivery_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pacing_delivery_type: Option<models::PacingDeliveryType>,

/// Campaign ID of the ad group.
    #[serde(rename = "campaign_id")]
    #[validate(
           regex = "RE_ADGROUPUPDATEREQUEST_CAMPAIGN_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_id: Option<String>,

    #[serde(rename = "billable_event")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billable_event: Option<models::ActionType>,

/// Bid strategy type
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "bid_strategy_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid_strategy_type: Option<Nullable<String>>,

/// Ad group ID.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_ADGROUPUPDATEREQUEST_ID",
        )]
    pub id: String,

}

lazy_static::lazy_static! {
    static ref RE_ADGROUPUPDATEREQUEST_CAMPAIGN_ID: regex::Regex = regex::Regex::new(r"^[C]?\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADGROUPUPDATEREQUEST_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AdGroupUpdateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, ) -> AdGroupUpdateRequest {
        AdGroupUpdateRequest {
            name: None,
            status: None,
            budget_in_micro_currency: None,
            bid_in_micro_currency: None,
            optimization_goal_metadata: None,
            budget_type: None,
            start_time: None,
            end_time: None,
            targeting_spec: None,
            lifetime_frequency_cap: None,
            tracking_urls: None,
            auto_targeting_enabled: None,
            placement_group: None,
            pacing_delivery_type: None,
            campaign_id: None,
            billable_event: None,
            bid_strategy_type: None,
            id,
        }
    }
}

/// Converts the AdGroupUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdGroupUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.budget_in_micro_currency.as_ref().map(|budget_in_micro_currency| {
                [
                    "budget_in_micro_currency".to_string(),
                    budget_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.bid_in_micro_currency.as_ref().map(|bid_in_micro_currency| {
                [
                    "bid_in_micro_currency".to_string(),
                    bid_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping optimization_goal_metadata in query parameter serialization

            // Skipping budget_type in query parameter serialization


            self.start_time.as_ref().map(|start_time| {
                [
                    "start_time".to_string(),
                    start_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.end_time.as_ref().map(|end_time| {
                [
                    "end_time".to_string(),
                    end_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping targeting_spec in query parameter serialization


            self.lifetime_frequency_cap.as_ref().map(|lifetime_frequency_cap| {
                [
                    "lifetime_frequency_cap".to_string(),
                    lifetime_frequency_cap.to_string(),
                ].join(",")
            }),

            // Skipping tracking_urls in query parameter serialization


            self.auto_targeting_enabled.as_ref().map(|auto_targeting_enabled| {
                [
                    "auto_targeting_enabled".to_string(),
                    auto_targeting_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping placement_group in query parameter serialization

            // Skipping pacing_delivery_type in query parameter serialization


            self.campaign_id.as_ref().map(|campaign_id| {
                [
                    "campaign_id".to_string(),
                    campaign_id.to_string(),
                ].join(",")
            }),

            // Skipping billable_event in query parameter serialization


            self.bid_strategy_type.as_ref().map(|bid_strategy_type| {
                [
                    "bid_strategy_type".to_string(),
                    bid_strategy_type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            Some("id".to_string()),
            Some(self.id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdGroupUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdGroupUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub budget_in_micro_currency: Vec<i32>,
            pub bid_in_micro_currency: Vec<i32>,
            pub optimization_goal_metadata: Vec<models::AdGroupCommonOptimizationGoalMetadata>,
            pub budget_type: Vec<models::BudgetType>,
            pub start_time: Vec<i32>,
            pub end_time: Vec<i32>,
            pub targeting_spec: Vec<models::TargetingSpec>,
            pub lifetime_frequency_cap: Vec<i32>,
            pub tracking_urls: Vec<models::AdGroupCommonTrackingUrls>,
            pub auto_targeting_enabled: Vec<bool>,
            pub placement_group: Vec<models::PlacementGroupType>,
            pub pacing_delivery_type: Vec<models::PacingDeliveryType>,
            pub campaign_id: Vec<String>,
            pub billable_event: Vec<models::ActionType>,
            pub bid_strategy_type: Vec<String>,
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdGroupUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "budget_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupUpdateRequest".to_string()),
                    "bid_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupUpdateRequest".to_string()),
                    "optimization_goal_metadata" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "budget_type" => intermediate_rep.budget_type.push(<models::BudgetType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "start_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupUpdateRequest".to_string()),
                    "end_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "targeting_spec" => intermediate_rep.targeting_spec.push(<models::TargetingSpec as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lifetime_frequency_cap" => intermediate_rep.lifetime_frequency_cap.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupUpdateRequest".to_string()),
                    "auto_targeting_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "placement_group" => intermediate_rep.placement_group.push(<models::PlacementGroupType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pacing_delivery_type" => intermediate_rep.pacing_delivery_type.push(<models::PacingDeliveryType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "campaign_id" => intermediate_rep.campaign_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billable_event" => intermediate_rep.billable_event.push(<models::ActionType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "bid_strategy_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdGroupUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdGroupUpdateRequest {
            name: intermediate_rep.name.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            budget_in_micro_currency: std::result::Result::Err("Nullable types not supported in AdGroupUpdateRequest".to_string())?,
            bid_in_micro_currency: std::result::Result::Err("Nullable types not supported in AdGroupUpdateRequest".to_string())?,
            optimization_goal_metadata: std::result::Result::Err("Nullable types not supported in AdGroupUpdateRequest".to_string())?,
            budget_type: intermediate_rep.budget_type.into_iter().next(),
            start_time: std::result::Result::Err("Nullable types not supported in AdGroupUpdateRequest".to_string())?,
            end_time: std::result::Result::Err("Nullable types not supported in AdGroupUpdateRequest".to_string())?,
            targeting_spec: intermediate_rep.targeting_spec.into_iter().next(),
            lifetime_frequency_cap: intermediate_rep.lifetime_frequency_cap.into_iter().next(),
            tracking_urls: std::result::Result::Err("Nullable types not supported in AdGroupUpdateRequest".to_string())?,
            auto_targeting_enabled: std::result::Result::Err("Nullable types not supported in AdGroupUpdateRequest".to_string())?,
            placement_group: intermediate_rep.placement_group.into_iter().next(),
            pacing_delivery_type: intermediate_rep.pacing_delivery_type.into_iter().next(),
            campaign_id: intermediate_rep.campaign_id.into_iter().next(),
            billable_event: intermediate_rep.billable_event.into_iter().next(),
            bid_strategy_type: std::result::Result::Err("Nullable types not supported in AdGroupUpdateRequest".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in AdGroupUpdateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdGroupUpdateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdGroupUpdateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdGroupUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdGroupUpdateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdGroupUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdGroupUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdGroupUpdateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdGroupsAnalyticsResponseInner {
/// The ID of the ad group that this metrics belongs to.
    #[serde(rename = "AD_GROUP_ID")]
    #[validate(
           regex = "RE_ADGROUPSANALYTICSRESPONSEINNER_AD_GROUP_ID",
        )]
    pub ad_group_id: String,

/// Current metrics date. Only returned when granularity is a time-based value (`DAY`, `HOUR`, `WEEK`, `MONTH`)
    #[serde(rename = "DATE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::naive::NaiveDate>,

}

lazy_static::lazy_static! {
    static ref RE_ADGROUPSANALYTICSRESPONSEINNER_AD_GROUP_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AdGroupsAnalyticsResponseInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(ad_group_id: String, ) -> AdGroupsAnalyticsResponseInner {
        AdGroupsAnalyticsResponseInner {
            ad_group_id,
            date: None,
        }
    }
}

/// Converts the AdGroupsAnalyticsResponseInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdGroupsAnalyticsResponseInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("AD_GROUP_ID".to_string()),
            Some(self.ad_group_id.to_string()),

            // Skipping DATE in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdGroupsAnalyticsResponseInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdGroupsAnalyticsResponseInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_group_id: Vec<String>,
            pub date: Vec<chrono::naive::NaiveDate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdGroupsAnalyticsResponseInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "AD_GROUP_ID" => intermediate_rep.ad_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DATE" => intermediate_rep.date.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdGroupsAnalyticsResponseInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdGroupsAnalyticsResponseInner {
            ad_group_id: intermediate_rep.ad_group_id.into_iter().next().ok_or_else(|| "AD_GROUP_ID missing in AdGroupsAnalyticsResponseInner".to_string())?,
            date: intermediate_rep.date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdGroupsAnalyticsResponseInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdGroupsAnalyticsResponseInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdGroupsAnalyticsResponseInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdGroupsAnalyticsResponseInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdGroupsAnalyticsResponseInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdGroupsAnalyticsResponseInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdGroupsAnalyticsResponseInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdGroupsList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::AdGroupResponse>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl AdGroupsList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::AdGroupResponse>, ) -> AdGroupsList200Response {
        AdGroupsList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the AdGroupsList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdGroupsList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdGroupsList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdGroupsList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::AdGroupResponse>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdGroupsList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in AdGroupsList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupsList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdGroupsList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdGroupsList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in AdGroupsList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in AdGroupsList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdGroupsList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdGroupsList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdGroupsList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdGroupsList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdGroupsList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdGroupsList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdGroupsList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdPinId {
/// Pin ID.
    #[serde(rename = "pin_id")]
    #[validate(
           regex = "RE_ADPINID_PIN_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pin_id: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_ADPINID_PIN_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AdPinId {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdPinId {
        AdPinId {
            pin_id: None,
        }
    }
}

/// Converts the AdPinId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdPinId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.pin_id.as_ref().map(|pin_id| {
                [
                    "pin_id".to_string(),
                    pin_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdPinId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdPinId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pin_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdPinId".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pin_id" => intermediate_rep.pin_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdPinId".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdPinId {
            pin_id: intermediate_rep.pin_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdPinId> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdPinId>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdPinId>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdPinId - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdPinId> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdPinId as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdPinId - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdPreviewCreateFromImage {
/// Image URL.
    #[serde(rename = "image_url")]
    pub image_url: String,

/// Title displayed below ad.
    #[serde(rename = "title")]
    pub title: String,

}


impl AdPreviewCreateFromImage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(image_url: String, title: String, ) -> AdPreviewCreateFromImage {
        AdPreviewCreateFromImage {
            image_url,
            title,
        }
    }
}

/// Converts the AdPreviewCreateFromImage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdPreviewCreateFromImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("image_url".to_string()),
            Some(self.image_url.to_string()),


            Some("title".to_string()),
            Some(self.title.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdPreviewCreateFromImage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdPreviewCreateFromImage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub image_url: Vec<String>,
            pub title: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdPreviewCreateFromImage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "image_url" => intermediate_rep.image_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdPreviewCreateFromImage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdPreviewCreateFromImage {
            image_url: intermediate_rep.image_url.into_iter().next().ok_or_else(|| "image_url missing in AdPreviewCreateFromImage".to_string())?,
            title: intermediate_rep.title.into_iter().next().ok_or_else(|| "title missing in AdPreviewCreateFromImage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdPreviewCreateFromImage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdPreviewCreateFromImage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdPreviewCreateFromImage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdPreviewCreateFromImage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdPreviewCreateFromImage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdPreviewCreateFromImage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdPreviewCreateFromImage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdPreviewCreateFromPin {
/// Pin ID.
    #[serde(rename = "pin_id")]
    pub pin_id: String,

}


impl AdPreviewCreateFromPin {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(pin_id: String, ) -> AdPreviewCreateFromPin {
        AdPreviewCreateFromPin {
            pin_id,
        }
    }
}

/// Converts the AdPreviewCreateFromPin value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdPreviewCreateFromPin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("pin_id".to_string()),
            Some(self.pin_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdPreviewCreateFromPin value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdPreviewCreateFromPin {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pin_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdPreviewCreateFromPin".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pin_id" => intermediate_rep.pin_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdPreviewCreateFromPin".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdPreviewCreateFromPin {
            pin_id: intermediate_rep.pin_id.into_iter().next().ok_or_else(|| "pin_id missing in AdPreviewCreateFromPin".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdPreviewCreateFromPin> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdPreviewCreateFromPin>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdPreviewCreateFromPin>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdPreviewCreateFromPin - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdPreviewCreateFromPin> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdPreviewCreateFromPin as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdPreviewCreateFromPin - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - AdPreviewCreateFromImage
/// - AdPreviewCreateFromPin
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AdPreviewRequest(Box<serde_json::value::RawValue>);

impl validator::Validate for AdPreviewRequest
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdPreviewRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdPreviewRequest {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for AdPreviewRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdPreviewUrlResponse {
/// 'Preview URL, expires in 7 days. Can be used in an iframe. For example: https://ads.pinterest.com/ad-preview/74667c814dd2b19/ The preview object ID/key is the last param - 74667c814dd2b19'
    #[serde(rename = "url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,

}


impl AdPreviewUrlResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdPreviewUrlResponse {
        AdPreviewUrlResponse {
            url: None,
        }
    }
}

/// Converts the AdPreviewUrlResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdPreviewUrlResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.url.as_ref().map(|url| {
                [
                    "url".to_string(),
                    url.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdPreviewUrlResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdPreviewUrlResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdPreviewUrlResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdPreviewUrlResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdPreviewUrlResponse {
            url: intermediate_rep.url.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdPreviewUrlResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdPreviewUrlResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdPreviewUrlResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdPreviewUrlResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdPreviewUrlResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdPreviewUrlResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdPreviewUrlResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdResponse {
/// ID of the ad group that contains the ad.
    #[serde(rename = "ad_group_id")]
    #[validate(
           regex = "RE_ADRESPONSE_AD_GROUP_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_group_id: Option<String>,

/// Deep link URL for Android devices. Not currently available. Using this field will generate an error.
    #[serde(rename = "android_deep_link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub android_deep_link: Option<Nullable<String>>,

/// Comma-separated deep links for the carousel pin on Android.
    #[serde(rename = "carousel_android_deep_links")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_android_deep_links: Option<Nullable<Vec<String>>>,

/// Comma-separated destination URLs for the carousel pin to promote.
    #[serde(rename = "carousel_destination_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_destination_urls: Option<Nullable<Vec<String>>>,

/// Comma-separated deep links for the carousel pin on iOS.
    #[serde(rename = "carousel_ios_deep_links")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_ios_deep_links: Option<Nullable<Vec<String>>>,

/// Tracking url for the ad clicks.
    #[serde(rename = "click_tracking_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub click_tracking_url: Option<Nullable<String>>,

    #[serde(rename = "creative_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creative_type: Option<models::CreativeType>,

/// Destination URL.
    #[serde(rename = "destination_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub destination_url: Option<Nullable<String>>,

/// Deep link URL for iOS devices. Not currently available. Using this field will generate an error.
    #[serde(rename = "ios_deep_link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ios_deep_link: Option<Nullable<String>>,

/// Is original pin deleted?
    #[serde(rename = "is_pin_deleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_pin_deleted: Option<bool>,

/// Is pin repinnable?
    #[serde(rename = "is_removable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_removable: Option<bool>,

/// Name of the ad - 255 chars max.
    #[serde(rename = "name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<Nullable<models::AdCommonTrackingUrls>>,

/// Tracking URL for ad impressions.
    #[serde(rename = "view_tracking_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub view_tracking_url: Option<Nullable<String>>,

/// Lead form ID for lead ad generation.
    #[serde(rename = "lead_form_id")]
    #[validate(
           regex = "RE_ADRESPONSE_LEAD_FORM_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lead_form_id: Option<Nullable<String>>,

    #[serde(rename = "grid_click_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub grid_click_type: Option<Nullable<models::GridClickType>>,

/// Select a call to action (CTA) to display below your ad. Available only for ads with direct links enabled. CTA options for consideration and conversion campaigns are LEARN_MORE, SHOP_NOW, BOOK_NOW, SIGN_UP, VISIT_WEBSITE, BUY_NOW, GET_OFFER, ORDER_NOW, ADD_TO_CART (for conversion campaigns with add to cart conversion events only)
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "customizable_cta_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub customizable_cta_type: Option<Nullable<String>>,

    #[serde(rename = "quiz_pin_data")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quiz_pin_data: Option<Nullable<models::AdCommonQuizPinData>>,

/// Pin ID.
    #[serde(rename = "pin_id")]
    #[validate(
           regex = "RE_ADRESPONSE_PIN_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pin_id: Option<String>,

/// The ID of the advertiser that this ad belongs to.
    #[serde(rename = "ad_account_id")]
    #[validate(
           regex = "RE_ADRESPONSE_AD_ACCOUNT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// ID of the ad campaign that contains this ad.
    #[serde(rename = "campaign_id")]
    #[validate(
           regex = "RE_ADRESPONSE_CAMPAIGN_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_id: Option<String>,

/// Destination URL template for all items within a collections drawer.
    #[serde(rename = "collection_items_destination_url_template")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub collection_items_destination_url_template: Option<Nullable<String>>,

/// Pin creation time. Unix timestamp in seconds.
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<i32>,

/// The ID of this ad.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_ADRESPONSE_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Enum reason why the pin was rejected. Returned if <code>review_status</code> is \"REJECTED\".
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "rejected_reasons")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rejected_reasons: Option<Vec<String>>,

/// Text reason why the pin was rejected. Returned if <code>review_status</code> is \"REJECTED\".
    #[serde(rename = "rejection_labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rejection_labels: Option<Vec<String>>,

/// Ad review status
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "review_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_status: Option<String>,

/// Always \"ad\".
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

/// Last update time. Unix timestamp in seconds.
    #[serde(rename = "updated_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_time: Option<i32>,

/// Ad summary status
    #[serde(rename = "summary_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary_status: Option<models::PinPromotionSummaryStatus>,

}

lazy_static::lazy_static! {
    static ref RE_ADRESPONSE_AD_GROUP_ID: regex::Regex = regex::Regex::new(r"^(AG)?\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADRESPONSE_LEAD_FORM_ID: regex::Regex = regex::Regex::new(r"^(AG)?\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADRESPONSE_PIN_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADRESPONSE_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADRESPONSE_CAMPAIGN_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADRESPONSE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AdResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdResponse {
        AdResponse {
            ad_group_id: None,
            android_deep_link: None,
            carousel_android_deep_links: None,
            carousel_destination_urls: None,
            carousel_ios_deep_links: None,
            click_tracking_url: None,
            creative_type: None,
            destination_url: None,
            ios_deep_link: None,
            is_pin_deleted: None,
            is_removable: None,
            name: None,
            status: None,
            tracking_urls: None,
            view_tracking_url: None,
            lead_form_id: None,
            grid_click_type: None,
            customizable_cta_type: None,
            quiz_pin_data: None,
            pin_id: None,
            ad_account_id: None,
            campaign_id: None,
            collection_items_destination_url_template: None,
            created_time: None,
            id: None,
            rejected_reasons: None,
            rejection_labels: None,
            review_status: None,
            r#type: None,
            updated_time: None,
            summary_status: None,
        }
    }
}

/// Converts the AdResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ad_group_id.as_ref().map(|ad_group_id| {
                [
                    "ad_group_id".to_string(),
                    ad_group_id.to_string(),
                ].join(",")
            }),


            self.android_deep_link.as_ref().map(|android_deep_link| {
                [
                    "android_deep_link".to_string(),
                    android_deep_link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.carousel_android_deep_links.as_ref().map(|carousel_android_deep_links| {
                [
                    "carousel_android_deep_links".to_string(),
                    carousel_android_deep_links.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.carousel_destination_urls.as_ref().map(|carousel_destination_urls| {
                [
                    "carousel_destination_urls".to_string(),
                    carousel_destination_urls.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.carousel_ios_deep_links.as_ref().map(|carousel_ios_deep_links| {
                [
                    "carousel_ios_deep_links".to_string(),
                    carousel_ios_deep_links.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.click_tracking_url.as_ref().map(|click_tracking_url| {
                [
                    "click_tracking_url".to_string(),
                    click_tracking_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping creative_type in query parameter serialization


            self.destination_url.as_ref().map(|destination_url| {
                [
                    "destination_url".to_string(),
                    destination_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.ios_deep_link.as_ref().map(|ios_deep_link| {
                [
                    "ios_deep_link".to_string(),
                    ios_deep_link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_pin_deleted.as_ref().map(|is_pin_deleted| {
                [
                    "is_pin_deleted".to_string(),
                    is_pin_deleted.to_string(),
                ].join(",")
            }),


            self.is_removable.as_ref().map(|is_removable| {
                [
                    "is_removable".to_string(),
                    is_removable.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping status in query parameter serialization

            // Skipping tracking_urls in query parameter serialization


            self.view_tracking_url.as_ref().map(|view_tracking_url| {
                [
                    "view_tracking_url".to_string(),
                    view_tracking_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.lead_form_id.as_ref().map(|lead_form_id| {
                [
                    "lead_form_id".to_string(),
                    lead_form_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping grid_click_type in query parameter serialization


            self.customizable_cta_type.as_ref().map(|customizable_cta_type| {
                [
                    "customizable_cta_type".to_string(),
                    customizable_cta_type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping quiz_pin_data in query parameter serialization


            self.pin_id.as_ref().map(|pin_id| {
                [
                    "pin_id".to_string(),
                    pin_id.to_string(),
                ].join(",")
            }),


            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.campaign_id.as_ref().map(|campaign_id| {
                [
                    "campaign_id".to_string(),
                    campaign_id.to_string(),
                ].join(",")
            }),


            self.collection_items_destination_url_template.as_ref().map(|collection_items_destination_url_template| {
                [
                    "collection_items_destination_url_template".to_string(),
                    collection_items_destination_url_template.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.created_time.as_ref().map(|created_time| {
                [
                    "created_time".to_string(),
                    created_time.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.rejected_reasons.as_ref().map(|rejected_reasons| {
                [
                    "rejected_reasons".to_string(),
                    rejected_reasons.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.rejection_labels.as_ref().map(|rejection_labels| {
                [
                    "rejection_labels".to_string(),
                    rejection_labels.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.review_status.as_ref().map(|review_status| {
                [
                    "review_status".to_string(),
                    review_status.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.updated_time.as_ref().map(|updated_time| {
                [
                    "updated_time".to_string(),
                    updated_time.to_string(),
                ].join(",")
            }),

            // Skipping summary_status in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_group_id: Vec<String>,
            pub android_deep_link: Vec<String>,
            pub carousel_android_deep_links: Vec<Vec<String>>,
            pub carousel_destination_urls: Vec<Vec<String>>,
            pub carousel_ios_deep_links: Vec<Vec<String>>,
            pub click_tracking_url: Vec<String>,
            pub creative_type: Vec<models::CreativeType>,
            pub destination_url: Vec<String>,
            pub ios_deep_link: Vec<String>,
            pub is_pin_deleted: Vec<bool>,
            pub is_removable: Vec<bool>,
            pub name: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub tracking_urls: Vec<models::AdCommonTrackingUrls>,
            pub view_tracking_url: Vec<String>,
            pub lead_form_id: Vec<String>,
            pub grid_click_type: Vec<models::GridClickType>,
            pub customizable_cta_type: Vec<String>,
            pub quiz_pin_data: Vec<models::AdCommonQuizPinData>,
            pub pin_id: Vec<String>,
            pub ad_account_id: Vec<String>,
            pub campaign_id: Vec<String>,
            pub collection_items_destination_url_template: Vec<String>,
            pub created_time: Vec<i32>,
            pub id: Vec<String>,
            pub rejected_reasons: Vec<Vec<String>>,
            pub rejection_labels: Vec<Vec<String>>,
            pub review_status: Vec<String>,
            pub r#type: Vec<String>,
            pub updated_time: Vec<i32>,
            pub summary_status: Vec<models::PinPromotionSummaryStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_group_id" => intermediate_rep.ad_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "android_deep_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    "carousel_android_deep_links" => return std::result::Result::Err("Parsing a container in this style is not supported in AdResponse".to_string()),
                    "carousel_destination_urls" => return std::result::Result::Err("Parsing a container in this style is not supported in AdResponse".to_string()),
                    "carousel_ios_deep_links" => return std::result::Result::Err("Parsing a container in this style is not supported in AdResponse".to_string()),
                    "click_tracking_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "creative_type" => intermediate_rep.creative_type.push(<models::CreativeType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "destination_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    "ios_deep_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "is_pin_deleted" => intermediate_rep.is_pin_deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_removable" => intermediate_rep.is_removable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    "view_tracking_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    "lead_form_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    "grid_click_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    "customizable_cta_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    "quiz_pin_data" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pin_id" => intermediate_rep.pin_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "campaign_id" => intermediate_rep.campaign_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "collection_items_destination_url_template" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "created_time" => intermediate_rep.created_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "rejected_reasons" => return std::result::Result::Err("Parsing a container in this style is not supported in AdResponse".to_string()),
                    "rejection_labels" => return std::result::Result::Err("Parsing a container in this style is not supported in AdResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "review_status" => intermediate_rep.review_status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updated_time" => intermediate_rep.updated_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "summary_status" => intermediate_rep.summary_status.push(<models::PinPromotionSummaryStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdResponse {
            ad_group_id: intermediate_rep.ad_group_id.into_iter().next(),
            android_deep_link: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            carousel_android_deep_links: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            carousel_destination_urls: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            carousel_ios_deep_links: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            click_tracking_url: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            creative_type: intermediate_rep.creative_type.into_iter().next(),
            destination_url: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            ios_deep_link: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            is_pin_deleted: intermediate_rep.is_pin_deleted.into_iter().next(),
            is_removable: intermediate_rep.is_removable.into_iter().next(),
            name: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
            tracking_urls: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            view_tracking_url: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            lead_form_id: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            grid_click_type: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            customizable_cta_type: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            quiz_pin_data: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            pin_id: intermediate_rep.pin_id.into_iter().next(),
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            campaign_id: intermediate_rep.campaign_id.into_iter().next(),
            collection_items_destination_url_template: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            created_time: intermediate_rep.created_time.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            rejected_reasons: intermediate_rep.rejected_reasons.into_iter().next(),
            rejection_labels: intermediate_rep.rejection_labels.into_iter().next(),
            review_status: intermediate_rep.review_status.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            updated_time: intermediate_rep.updated_time.into_iter().next(),
            summary_status: intermediate_rep.summary_status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdUpdateRequest {
/// ID of the ad group that contains the ad.
    #[serde(rename = "ad_group_id")]
    #[validate(
           regex = "RE_ADUPDATEREQUEST_AD_GROUP_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_group_id: Option<String>,

/// Deep link URL for Android devices. Not currently available. Using this field will generate an error.
    #[serde(rename = "android_deep_link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub android_deep_link: Option<Nullable<String>>,

/// Comma-separated deep links for the carousel pin on Android.
    #[serde(rename = "carousel_android_deep_links")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_android_deep_links: Option<Nullable<Vec<String>>>,

/// Comma-separated destination URLs for the carousel pin to promote.
    #[serde(rename = "carousel_destination_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_destination_urls: Option<Nullable<Vec<String>>>,

/// Comma-separated deep links for the carousel pin on iOS.
    #[serde(rename = "carousel_ios_deep_links")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_ios_deep_links: Option<Nullable<Vec<String>>>,

/// Tracking url for the ad clicks.
    #[serde(rename = "click_tracking_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub click_tracking_url: Option<Nullable<String>>,

    #[serde(rename = "creative_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creative_type: Option<models::CreativeType>,

/// Destination URL.
    #[serde(rename = "destination_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub destination_url: Option<Nullable<String>>,

/// Deep link URL for iOS devices. Not currently available. Using this field will generate an error.
    #[serde(rename = "ios_deep_link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ios_deep_link: Option<Nullable<String>>,

/// Is original pin deleted?
    #[serde(rename = "is_pin_deleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_pin_deleted: Option<bool>,

/// Is pin repinnable?
    #[serde(rename = "is_removable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_removable: Option<bool>,

/// Name of the ad - 255 chars max.
    #[serde(rename = "name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<Nullable<models::AdCommonTrackingUrls>>,

/// Tracking URL for ad impressions.
    #[serde(rename = "view_tracking_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub view_tracking_url: Option<Nullable<String>>,

/// Lead form ID for lead ad generation.
    #[serde(rename = "lead_form_id")]
    #[validate(
           regex = "RE_ADUPDATEREQUEST_LEAD_FORM_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lead_form_id: Option<Nullable<String>>,

    #[serde(rename = "grid_click_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub grid_click_type: Option<Nullable<models::GridClickType>>,

/// Select a call to action (CTA) to display below your ad. Available only for ads with direct links enabled. CTA options for consideration and conversion campaigns are LEARN_MORE, SHOP_NOW, BOOK_NOW, SIGN_UP, VISIT_WEBSITE, BUY_NOW, GET_OFFER, ORDER_NOW, ADD_TO_CART (for conversion campaigns with add to cart conversion events only)
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "customizable_cta_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub customizable_cta_type: Option<Nullable<String>>,

    #[serde(rename = "quiz_pin_data")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quiz_pin_data: Option<Nullable<models::AdCommonQuizPinData>>,

/// The ID of this ad.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_ADUPDATEREQUEST_ID",
        )]
    pub id: String,

/// Pin ID. This field may only be updated for draft ads.
    #[serde(rename = "pin_id")]
    #[validate(
           regex = "RE_ADUPDATEREQUEST_PIN_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pin_id: Option<Nullable<String>>,

}

lazy_static::lazy_static! {
    static ref RE_ADUPDATEREQUEST_AD_GROUP_ID: regex::Regex = regex::Regex::new(r"^(AG)?\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADUPDATEREQUEST_LEAD_FORM_ID: regex::Regex = regex::Regex::new(r"^(AG)?\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADUPDATEREQUEST_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADUPDATEREQUEST_PIN_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AdUpdateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, ) -> AdUpdateRequest {
        AdUpdateRequest {
            ad_group_id: None,
            android_deep_link: None,
            carousel_android_deep_links: None,
            carousel_destination_urls: None,
            carousel_ios_deep_links: None,
            click_tracking_url: None,
            creative_type: None,
            destination_url: None,
            ios_deep_link: None,
            is_pin_deleted: None,
            is_removable: None,
            name: None,
            status: None,
            tracking_urls: None,
            view_tracking_url: None,
            lead_form_id: None,
            grid_click_type: None,
            customizable_cta_type: None,
            quiz_pin_data: None,
            id,
            pin_id: None,
        }
    }
}

/// Converts the AdUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ad_group_id.as_ref().map(|ad_group_id| {
                [
                    "ad_group_id".to_string(),
                    ad_group_id.to_string(),
                ].join(",")
            }),


            self.android_deep_link.as_ref().map(|android_deep_link| {
                [
                    "android_deep_link".to_string(),
                    android_deep_link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.carousel_android_deep_links.as_ref().map(|carousel_android_deep_links| {
                [
                    "carousel_android_deep_links".to_string(),
                    carousel_android_deep_links.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.carousel_destination_urls.as_ref().map(|carousel_destination_urls| {
                [
                    "carousel_destination_urls".to_string(),
                    carousel_destination_urls.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.carousel_ios_deep_links.as_ref().map(|carousel_ios_deep_links| {
                [
                    "carousel_ios_deep_links".to_string(),
                    carousel_ios_deep_links.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.click_tracking_url.as_ref().map(|click_tracking_url| {
                [
                    "click_tracking_url".to_string(),
                    click_tracking_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping creative_type in query parameter serialization


            self.destination_url.as_ref().map(|destination_url| {
                [
                    "destination_url".to_string(),
                    destination_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.ios_deep_link.as_ref().map(|ios_deep_link| {
                [
                    "ios_deep_link".to_string(),
                    ios_deep_link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_pin_deleted.as_ref().map(|is_pin_deleted| {
                [
                    "is_pin_deleted".to_string(),
                    is_pin_deleted.to_string(),
                ].join(",")
            }),


            self.is_removable.as_ref().map(|is_removable| {
                [
                    "is_removable".to_string(),
                    is_removable.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping status in query parameter serialization

            // Skipping tracking_urls in query parameter serialization


            self.view_tracking_url.as_ref().map(|view_tracking_url| {
                [
                    "view_tracking_url".to_string(),
                    view_tracking_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.lead_form_id.as_ref().map(|lead_form_id| {
                [
                    "lead_form_id".to_string(),
                    lead_form_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping grid_click_type in query parameter serialization


            self.customizable_cta_type.as_ref().map(|customizable_cta_type| {
                [
                    "customizable_cta_type".to_string(),
                    customizable_cta_type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping quiz_pin_data in query parameter serialization


            Some("id".to_string()),
            Some(self.id.to_string()),


            self.pin_id.as_ref().map(|pin_id| {
                [
                    "pin_id".to_string(),
                    pin_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_group_id: Vec<String>,
            pub android_deep_link: Vec<String>,
            pub carousel_android_deep_links: Vec<Vec<String>>,
            pub carousel_destination_urls: Vec<Vec<String>>,
            pub carousel_ios_deep_links: Vec<Vec<String>>,
            pub click_tracking_url: Vec<String>,
            pub creative_type: Vec<models::CreativeType>,
            pub destination_url: Vec<String>,
            pub ios_deep_link: Vec<String>,
            pub is_pin_deleted: Vec<bool>,
            pub is_removable: Vec<bool>,
            pub name: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub tracking_urls: Vec<models::AdCommonTrackingUrls>,
            pub view_tracking_url: Vec<String>,
            pub lead_form_id: Vec<String>,
            pub grid_click_type: Vec<models::GridClickType>,
            pub customizable_cta_type: Vec<String>,
            pub quiz_pin_data: Vec<models::AdCommonQuizPinData>,
            pub id: Vec<String>,
            pub pin_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_group_id" => intermediate_rep.ad_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "android_deep_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdUpdateRequest".to_string()),
                    "carousel_android_deep_links" => return std::result::Result::Err("Parsing a container in this style is not supported in AdUpdateRequest".to_string()),
                    "carousel_destination_urls" => return std::result::Result::Err("Parsing a container in this style is not supported in AdUpdateRequest".to_string()),
                    "carousel_ios_deep_links" => return std::result::Result::Err("Parsing a container in this style is not supported in AdUpdateRequest".to_string()),
                    "click_tracking_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "creative_type" => intermediate_rep.creative_type.push(<models::CreativeType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "destination_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdUpdateRequest".to_string()),
                    "ios_deep_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "is_pin_deleted" => intermediate_rep.is_pin_deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_removable" => intermediate_rep.is_removable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdUpdateRequest".to_string()),
                    "view_tracking_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdUpdateRequest".to_string()),
                    "lead_form_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdUpdateRequest".to_string()),
                    "grid_click_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdUpdateRequest".to_string()),
                    "customizable_cta_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdUpdateRequest".to_string()),
                    "quiz_pin_data" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pin_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdUpdateRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdUpdateRequest {
            ad_group_id: intermediate_rep.ad_group_id.into_iter().next(),
            android_deep_link: std::result::Result::Err("Nullable types not supported in AdUpdateRequest".to_string())?,
            carousel_android_deep_links: std::result::Result::Err("Nullable types not supported in AdUpdateRequest".to_string())?,
            carousel_destination_urls: std::result::Result::Err("Nullable types not supported in AdUpdateRequest".to_string())?,
            carousel_ios_deep_links: std::result::Result::Err("Nullable types not supported in AdUpdateRequest".to_string())?,
            click_tracking_url: std::result::Result::Err("Nullable types not supported in AdUpdateRequest".to_string())?,
            creative_type: intermediate_rep.creative_type.into_iter().next(),
            destination_url: std::result::Result::Err("Nullable types not supported in AdUpdateRequest".to_string())?,
            ios_deep_link: std::result::Result::Err("Nullable types not supported in AdUpdateRequest".to_string())?,
            is_pin_deleted: intermediate_rep.is_pin_deleted.into_iter().next(),
            is_removable: intermediate_rep.is_removable.into_iter().next(),
            name: std::result::Result::Err("Nullable types not supported in AdUpdateRequest".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
            tracking_urls: std::result::Result::Err("Nullable types not supported in AdUpdateRequest".to_string())?,
            view_tracking_url: std::result::Result::Err("Nullable types not supported in AdUpdateRequest".to_string())?,
            lead_form_id: std::result::Result::Err("Nullable types not supported in AdUpdateRequest".to_string())?,
            grid_click_type: std::result::Result::Err("Nullable types not supported in AdUpdateRequest".to_string())?,
            customizable_cta_type: std::result::Result::Err("Nullable types not supported in AdUpdateRequest".to_string())?,
            quiz_pin_data: std::result::Result::Err("Nullable types not supported in AdUpdateRequest".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in AdUpdateRequest".to_string())?,
            pin_id: std::result::Result::Err("Nullable types not supported in AdUpdateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdUpdateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdUpdateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdUpdateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdUpdateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdsAnalyticsCreateAsyncRequest {
/// Metric report start date (UTC). Format: YYYY-MM-DD
    #[serde(rename = "start_date")]
    #[validate(
           regex = "RE_ADSANALYTICSCREATEASYNCREQUEST_START_DATE",
        )]
    pub start_date: String,

/// Metric report end date (UTC). Format: YYYY-MM-DD
    #[serde(rename = "end_date")]
    #[validate(
           regex = "RE_ADSANALYTICSCREATEASYNCREQUEST_END_DATE",
        )]
    pub end_date: String,

/// TOTAL - metrics are aggregated over the specified date range.<br> DAY - metrics are broken down daily.<br> HOUR - metrics are broken down hourly.<br>WEEKLY - metrics are broken down weekly.<br>MONTHLY - metrics are broken down monthly
    #[serde(rename = "granularity")]
    pub granularity: models::Granularity,

/// Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
    #[serde(rename = "click_window_days")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub click_window_days: Option<models::ConversionAttributionWindowDays>,

/// Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
    #[serde(rename = "engagement_window_days")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub engagement_window_days: Option<models::ConversionAttributionWindowDays>,

/// Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `1` day.
    #[serde(rename = "view_window_days")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub view_window_days: Option<models::ConversionAttributionWindowDays>,

/// The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
    #[serde(rename = "conversion_report_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conversion_report_time: Option<models::ConversionReportTimeType>,

/// List of types of attribution for the conversion report
    #[serde(rename = "attribution_types")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attribution_types: Option<Vec<models::ConversionReportAttributionType>>,

/// List of campaign ids
    #[serde(rename = "campaign_ids")]
    #[validate(
            length(min = 1, max = 500),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_ids: Option<Vec<String>>,

/// List of status values for filtering
    #[serde(rename = "campaign_statuses")]
    #[validate(
            length(min = 1, max = 6),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_statuses: Option<Vec<models::CampaignSummaryStatus>>,

/// List of values for filtering. [\"WEB_SESSIONS\"] in BETA.
    #[serde(rename = "campaign_objective_types")]
    #[validate(
            length(min = 1, max = 6),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_objective_types: Option<Vec<models::ObjectiveType>>,

/// List of ad group ids
    #[serde(rename = "ad_group_ids")]
    #[validate(
            length(min = 1, max = 500),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_group_ids: Option<Vec<String>>,

/// List of values for filtering
    #[serde(rename = "ad_group_statuses")]
    #[validate(
            length(min = 1, max = 6),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_group_statuses: Option<Vec<models::AdGroupSummaryStatus>>,

/// List of ad ids [This parameter is no supported for Product Item Level Reports]
    #[serde(rename = "ad_ids")]
    #[validate(
            length(min = 1, max = 500),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_ids: Option<Vec<String>>,

/// List of values for filtering [This parameter is not supported for Product Item Level Reports]
    #[serde(rename = "ad_statuses")]
    #[validate(
            length(min = 1, max = 6),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_statuses: Option<Vec<models::PinPromotionSummaryStatus>>,

/// List of product group ids
    #[serde(rename = "product_group_ids")]
    #[validate(
            length(min = 1, max = 500),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_group_ids: Option<Vec<String>>,

/// List of values for filtering
    #[serde(rename = "product_group_statuses")]
    #[validate(
            length(min = 1, max = 6),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_group_statuses: Option<Vec<models::ProductGroupSummaryStatus>>,

/// List of product item ids
    #[serde(rename = "product_item_ids")]
    #[validate(
            length(min = 1, max = 500),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_item_ids: Option<Vec<String>>,

/// List of targeting types. Requires `level` to be a value ending in `_TARGETING`.
    #[serde(rename = "targeting_types")]
    #[validate(
            length(min = 1, max = 5),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub targeting_types: Option<Vec<models::AdsAnalyticsTargetingType>>,

/// List of metrics filters
    #[serde(rename = "metrics_filters")]
    #[validate(
            length(min = 1),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metrics_filters: Option<Vec<models::AdsAnalyticsMetricsFilter>>,

/// Metric and entity columns. Pin promotion and ad related columns are not supported for the Product Item level reports.
    #[serde(rename = "columns")]
    pub columns: Vec<models::ReportingColumnAsync>,

/// Level of the report
    #[serde(rename = "level")]
    pub level: models::MetricsReportingLevel,

/// Specification for formatting the report data. Reports in JSON will not zero-fill metrics, whereas reports in CSV will. Both report formats will omit rows where all the columns are equal to 0.
    #[serde(rename = "report_format")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub report_format: Option<models::DataOutputFormat>,

}

lazy_static::lazy_static! {
    static ref RE_ADSANALYTICSCREATEASYNCREQUEST_START_DATE: regex::Regex = regex::Regex::new(r"^(\\d{4})-(\\d{2})-(\\d{2})$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_ADSANALYTICSCREATEASYNCREQUEST_END_DATE: regex::Regex = regex::Regex::new(r"^(\\d{4})-(\\d{2})-(\\d{2})$").unwrap();
}

impl AdsAnalyticsCreateAsyncRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(start_date: String, end_date: String, granularity: models::Granularity, columns: Vec<models::ReportingColumnAsync>, level: models::MetricsReportingLevel, ) -> AdsAnalyticsCreateAsyncRequest {
        AdsAnalyticsCreateAsyncRequest {
            start_date,
            end_date,
            granularity,
            click_window_days: Some(30),
            engagement_window_days: Some(30),
            view_window_days: Some(1),
            conversion_report_time: Some("TIME_OF_AD_ACTION".to_string()),
            attribution_types: None,
            campaign_ids: None,
            campaign_statuses: None,
            campaign_objective_types: None,
            ad_group_ids: None,
            ad_group_statuses: None,
            ad_ids: None,
            ad_statuses: None,
            product_group_ids: None,
            product_group_statuses: None,
            product_item_ids: None,
            targeting_types: None,
            metrics_filters: None,
            columns,
            level,
            report_format: Some("JSON".to_string()),
        }
    }
}

/// Converts the AdsAnalyticsCreateAsyncRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdsAnalyticsCreateAsyncRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("start_date".to_string()),
            Some(self.start_date.to_string()),


            Some("end_date".to_string()),
            Some(self.end_date.to_string()),

            // Skipping granularity in query parameter serialization

            // Skipping click_window_days in query parameter serialization

            // Skipping engagement_window_days in query parameter serialization

            // Skipping view_window_days in query parameter serialization

            // Skipping conversion_report_time in query parameter serialization

            // Skipping attribution_types in query parameter serialization


            self.campaign_ids.as_ref().map(|campaign_ids| {
                [
                    "campaign_ids".to_string(),
                    campaign_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping campaign_statuses in query parameter serialization

            // Skipping campaign_objective_types in query parameter serialization


            self.ad_group_ids.as_ref().map(|ad_group_ids| {
                [
                    "ad_group_ids".to_string(),
                    ad_group_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping ad_group_statuses in query parameter serialization


            self.ad_ids.as_ref().map(|ad_ids| {
                [
                    "ad_ids".to_string(),
                    ad_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping ad_statuses in query parameter serialization


            self.product_group_ids.as_ref().map(|product_group_ids| {
                [
                    "product_group_ids".to_string(),
                    product_group_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping product_group_statuses in query parameter serialization


            self.product_item_ids.as_ref().map(|product_item_ids| {
                [
                    "product_item_ids".to_string(),
                    product_item_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping targeting_types in query parameter serialization

            // Skipping metrics_filters in query parameter serialization

            // Skipping columns in query parameter serialization

            // Skipping level in query parameter serialization

            // Skipping report_format in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdsAnalyticsCreateAsyncRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdsAnalyticsCreateAsyncRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub start_date: Vec<String>,
            pub end_date: Vec<String>,
            pub granularity: Vec<models::Granularity>,
            pub click_window_days: Vec<models::ConversionAttributionWindowDays>,
            pub engagement_window_days: Vec<models::ConversionAttributionWindowDays>,
            pub view_window_days: Vec<models::ConversionAttributionWindowDays>,
            pub conversion_report_time: Vec<models::ConversionReportTimeType>,
            pub attribution_types: Vec<Vec<models::ConversionReportAttributionType>>,
            pub campaign_ids: Vec<Vec<String>>,
            pub campaign_statuses: Vec<Vec<models::CampaignSummaryStatus>>,
            pub campaign_objective_types: Vec<Vec<models::ObjectiveType>>,
            pub ad_group_ids: Vec<Vec<String>>,
            pub ad_group_statuses: Vec<Vec<models::AdGroupSummaryStatus>>,
            pub ad_ids: Vec<Vec<String>>,
            pub ad_statuses: Vec<Vec<models::PinPromotionSummaryStatus>>,
            pub product_group_ids: Vec<Vec<String>>,
            pub product_group_statuses: Vec<Vec<models::ProductGroupSummaryStatus>>,
            pub product_item_ids: Vec<Vec<String>>,
            pub targeting_types: Vec<Vec<models::AdsAnalyticsTargetingType>>,
            pub metrics_filters: Vec<Vec<models::AdsAnalyticsMetricsFilter>>,
            pub columns: Vec<Vec<models::ReportingColumnAsync>>,
            pub level: Vec<models::MetricsReportingLevel>,
            pub report_format: Vec<models::DataOutputFormat>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdsAnalyticsCreateAsyncRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "start_date" => intermediate_rep.start_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end_date" => intermediate_rep.end_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "granularity" => intermediate_rep.granularity.push(<models::Granularity as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "click_window_days" => intermediate_rep.click_window_days.push(<models::ConversionAttributionWindowDays as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "engagement_window_days" => intermediate_rep.engagement_window_days.push(<models::ConversionAttributionWindowDays as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "view_window_days" => intermediate_rep.view_window_days.push(<models::ConversionAttributionWindowDays as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "conversion_report_time" => intermediate_rep.conversion_report_time.push(<models::ConversionReportTimeType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "attribution_types" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "campaign_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "campaign_statuses" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "campaign_objective_types" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "ad_group_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "ad_group_statuses" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "ad_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "ad_statuses" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "product_group_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "product_group_statuses" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "product_item_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "targeting_types" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "metrics_filters" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "columns" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "level" => intermediate_rep.level.push(<models::MetricsReportingLevel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "report_format" => intermediate_rep.report_format.push(<models::DataOutputFormat as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdsAnalyticsCreateAsyncRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdsAnalyticsCreateAsyncRequest {
            start_date: intermediate_rep.start_date.into_iter().next().ok_or_else(|| "start_date missing in AdsAnalyticsCreateAsyncRequest".to_string())?,
            end_date: intermediate_rep.end_date.into_iter().next().ok_or_else(|| "end_date missing in AdsAnalyticsCreateAsyncRequest".to_string())?,
            granularity: intermediate_rep.granularity.into_iter().next().ok_or_else(|| "granularity missing in AdsAnalyticsCreateAsyncRequest".to_string())?,
            click_window_days: intermediate_rep.click_window_days.into_iter().next(),
            engagement_window_days: intermediate_rep.engagement_window_days.into_iter().next(),
            view_window_days: intermediate_rep.view_window_days.into_iter().next(),
            conversion_report_time: intermediate_rep.conversion_report_time.into_iter().next(),
            attribution_types: intermediate_rep.attribution_types.into_iter().next(),
            campaign_ids: intermediate_rep.campaign_ids.into_iter().next(),
            campaign_statuses: intermediate_rep.campaign_statuses.into_iter().next(),
            campaign_objective_types: intermediate_rep.campaign_objective_types.into_iter().next(),
            ad_group_ids: intermediate_rep.ad_group_ids.into_iter().next(),
            ad_group_statuses: intermediate_rep.ad_group_statuses.into_iter().next(),
            ad_ids: intermediate_rep.ad_ids.into_iter().next(),
            ad_statuses: intermediate_rep.ad_statuses.into_iter().next(),
            product_group_ids: intermediate_rep.product_group_ids.into_iter().next(),
            product_group_statuses: intermediate_rep.product_group_statuses.into_iter().next(),
            product_item_ids: intermediate_rep.product_item_ids.into_iter().next(),
            targeting_types: intermediate_rep.targeting_types.into_iter().next(),
            metrics_filters: intermediate_rep.metrics_filters.into_iter().next(),
            columns: intermediate_rep.columns.into_iter().next().ok_or_else(|| "columns missing in AdsAnalyticsCreateAsyncRequest".to_string())?,
            level: intermediate_rep.level.into_iter().next().ok_or_else(|| "level missing in AdsAnalyticsCreateAsyncRequest".to_string())?,
            report_format: intermediate_rep.report_format.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdsAnalyticsCreateAsyncRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdsAnalyticsCreateAsyncRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdsAnalyticsCreateAsyncRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdsAnalyticsCreateAsyncRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdsAnalyticsCreateAsyncRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdsAnalyticsCreateAsyncRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdsAnalyticsCreateAsyncRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdsAnalyticsCreateAsyncResponse {
    #[serde(rename = "report_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub report_status: Option<models::BulkReportingJobStatus>,

    #[serde(rename = "token")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub token: Option<String>,

    #[serde(rename = "message")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<Nullable<String>>,

}


impl AdsAnalyticsCreateAsyncResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdsAnalyticsCreateAsyncResponse {
        AdsAnalyticsCreateAsyncResponse {
            report_status: None,
            token: None,
            message: None,
        }
    }
}

/// Converts the AdsAnalyticsCreateAsyncResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdsAnalyticsCreateAsyncResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping report_status in query parameter serialization


            self.token.as_ref().map(|token| {
                [
                    "token".to_string(),
                    token.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdsAnalyticsCreateAsyncResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdsAnalyticsCreateAsyncResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub report_status: Vec<models::BulkReportingJobStatus>,
            pub token: Vec<String>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdsAnalyticsCreateAsyncResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "report_status" => intermediate_rep.report_status.push(<models::BulkReportingJobStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "token" => intermediate_rep.token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "message" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdsAnalyticsCreateAsyncResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdsAnalyticsCreateAsyncResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdsAnalyticsCreateAsyncResponse {
            report_status: intermediate_rep.report_status.into_iter().next(),
            token: intermediate_rep.token.into_iter().next(),
            message: std::result::Result::Err("Nullable types not supported in AdsAnalyticsCreateAsyncResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdsAnalyticsCreateAsyncResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdsAnalyticsCreateAsyncResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdsAnalyticsCreateAsyncResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdsAnalyticsCreateAsyncResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdsAnalyticsCreateAsyncResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdsAnalyticsCreateAsyncResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdsAnalyticsCreateAsyncResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Reporting columns for sync reporting data filter
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AdsAnalyticsFilterColumn {
    #[serde(rename = "SPEND_IN_DOLLAR")]
    SpendInDollar,
    #[serde(rename = "TOTAL_IMPRESSION")]
    TotalImpression,
}

impl std::fmt::Display for AdsAnalyticsFilterColumn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AdsAnalyticsFilterColumn::SpendInDollar => write!(f, "SPEND_IN_DOLLAR"),
            AdsAnalyticsFilterColumn::TotalImpression => write!(f, "TOTAL_IMPRESSION"),
        }
    }
}

impl std::str::FromStr for AdsAnalyticsFilterColumn {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SPEND_IN_DOLLAR" => std::result::Result::Ok(AdsAnalyticsFilterColumn::SpendInDollar),
            "TOTAL_IMPRESSION" => std::result::Result::Ok(AdsAnalyticsFilterColumn::TotalImpression),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Filter operator for sync reporting
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AdsAnalyticsFilterOperator {
    #[serde(rename = "LESS_THAN")]
    LessThan,
    #[serde(rename = "GREATER_THAN")]
    GreaterThan,
}

impl std::fmt::Display for AdsAnalyticsFilterOperator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AdsAnalyticsFilterOperator::LessThan => write!(f, "LESS_THAN"),
            AdsAnalyticsFilterOperator::GreaterThan => write!(f, "GREATER_THAN"),
        }
    }
}

impl std::str::FromStr for AdsAnalyticsFilterOperator {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "LESS_THAN" => std::result::Result::Ok(AdsAnalyticsFilterOperator::LessThan),
            "GREATER_THAN" => std::result::Result::Ok(AdsAnalyticsFilterOperator::GreaterThan),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdsAnalyticsGetAsyncResponse {
    #[serde(rename = "report_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub report_status: Option<models::BulkReportingJobStatus>,

    #[serde(rename = "url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<Nullable<String>>,

    #[serde(rename = "size")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<Nullable<f64>>,

}


impl AdsAnalyticsGetAsyncResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdsAnalyticsGetAsyncResponse {
        AdsAnalyticsGetAsyncResponse {
            report_status: None,
            url: None,
            size: None,
        }
    }
}

/// Converts the AdsAnalyticsGetAsyncResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdsAnalyticsGetAsyncResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping report_status in query parameter serialization


            self.url.as_ref().map(|url| {
                [
                    "url".to_string(),
                    url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "size".to_string(),
                    size.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdsAnalyticsGetAsyncResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdsAnalyticsGetAsyncResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub report_status: Vec<models::BulkReportingJobStatus>,
            pub url: Vec<String>,
            pub size: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdsAnalyticsGetAsyncResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "report_status" => intermediate_rep.report_status.push(<models::BulkReportingJobStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdsAnalyticsGetAsyncResponse".to_string()),
                    "size" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdsAnalyticsGetAsyncResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdsAnalyticsGetAsyncResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdsAnalyticsGetAsyncResponse {
            report_status: intermediate_rep.report_status.into_iter().next(),
            url: std::result::Result::Err("Nullable types not supported in AdsAnalyticsGetAsyncResponse".to_string())?,
            size: std::result::Result::Err("Nullable types not supported in AdsAnalyticsGetAsyncResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdsAnalyticsGetAsyncResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdsAnalyticsGetAsyncResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdsAnalyticsGetAsyncResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdsAnalyticsGetAsyncResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdsAnalyticsGetAsyncResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdsAnalyticsGetAsyncResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdsAnalyticsGetAsyncResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdsAnalyticsMetricsFilter {
    #[serde(rename = "field")]
    pub field: models::AdsAnalyticsFilterColumn,

    #[serde(rename = "operator")]
    pub operator: models::AdsAnalyticsFilterOperator,

/// List of values for filtering
    #[serde(rename = "values")]
    #[validate(
            length(min = 1),
        )]
    pub values: Vec<f64>,

}


impl AdsAnalyticsMetricsFilter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(field: models::AdsAnalyticsFilterColumn, operator: models::AdsAnalyticsFilterOperator, values: Vec<f64>, ) -> AdsAnalyticsMetricsFilter {
        AdsAnalyticsMetricsFilter {
            field,
            operator,
            values,
        }
    }
}

/// Converts the AdsAnalyticsMetricsFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdsAnalyticsMetricsFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping field in query parameter serialization

            // Skipping operator in query parameter serialization


            Some("values".to_string()),
            Some(self.values.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdsAnalyticsMetricsFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdsAnalyticsMetricsFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub field: Vec<models::AdsAnalyticsFilterColumn>,
            pub operator: Vec<models::AdsAnalyticsFilterOperator>,
            pub values: Vec<Vec<f64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdsAnalyticsMetricsFilter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "field" => intermediate_rep.field.push(<models::AdsAnalyticsFilterColumn as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operator" => intermediate_rep.operator.push(<models::AdsAnalyticsFilterOperator as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "values" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsMetricsFilter".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdsAnalyticsMetricsFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdsAnalyticsMetricsFilter {
            field: intermediate_rep.field.into_iter().next().ok_or_else(|| "field missing in AdsAnalyticsMetricsFilter".to_string())?,
            operator: intermediate_rep.operator.into_iter().next().ok_or_else(|| "operator missing in AdsAnalyticsMetricsFilter".to_string())?,
            values: intermediate_rep.values.into_iter().next().ok_or_else(|| "values missing in AdsAnalyticsMetricsFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdsAnalyticsMetricsFilter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdsAnalyticsMetricsFilter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdsAnalyticsMetricsFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdsAnalyticsMetricsFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdsAnalyticsMetricsFilter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdsAnalyticsMetricsFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdsAnalyticsMetricsFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdsAnalyticsResponseInner {
/// The ID of the ad that this metrics belongs to.
    #[serde(rename = "AD_ID")]
    #[validate(
           regex = "RE_ADSANALYTICSRESPONSEINNER_AD_ID",
        )]
    pub ad_id: String,

/// Current metrics date. Only returned when granularity is a time-based value (`DAY`, `HOUR`, `WEEK`, `MONTH`)
    #[serde(rename = "DATE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::naive::NaiveDate>,

}

lazy_static::lazy_static! {
    static ref RE_ADSANALYTICSRESPONSEINNER_AD_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AdsAnalyticsResponseInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(ad_id: String, ) -> AdsAnalyticsResponseInner {
        AdsAnalyticsResponseInner {
            ad_id,
            date: None,
        }
    }
}

/// Converts the AdsAnalyticsResponseInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdsAnalyticsResponseInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("AD_ID".to_string()),
            Some(self.ad_id.to_string()),

            // Skipping DATE in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdsAnalyticsResponseInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdsAnalyticsResponseInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_id: Vec<String>,
            pub date: Vec<chrono::naive::NaiveDate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdsAnalyticsResponseInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "AD_ID" => intermediate_rep.ad_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DATE" => intermediate_rep.date.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdsAnalyticsResponseInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdsAnalyticsResponseInner {
            ad_id: intermediate_rep.ad_id.into_iter().next().ok_or_else(|| "AD_ID missing in AdsAnalyticsResponseInner".to_string())?,
            date: intermediate_rep.date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdsAnalyticsResponseInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdsAnalyticsResponseInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdsAnalyticsResponseInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdsAnalyticsResponseInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdsAnalyticsResponseInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdsAnalyticsResponseInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdsAnalyticsResponseInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Reporting targeting type
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AdsAnalyticsTargetingType {
    #[serde(rename = "KEYWORD")]
    Keyword,
    #[serde(rename = "APPTYPE")]
    Apptype,
    #[serde(rename = "GENDER")]
    Gender,
    #[serde(rename = "LOCATION")]
    Location,
    #[serde(rename = "PLACEMENT")]
    Placement,
    #[serde(rename = "COUNTRY")]
    Country,
    #[serde(rename = "TARGETED_INTEREST")]
    TargetedInterest,
    #[serde(rename = "PINNER_INTEREST")]
    PinnerInterest,
    #[serde(rename = "AUDIENCE_INCLUDE")]
    AudienceInclude,
    #[serde(rename = "GEO")]
    Geo,
    #[serde(rename = "AGE_BUCKET")]
    AgeBucket,
    #[serde(rename = "REGION")]
    Region,
}

impl std::fmt::Display for AdsAnalyticsTargetingType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AdsAnalyticsTargetingType::Keyword => write!(f, "KEYWORD"),
            AdsAnalyticsTargetingType::Apptype => write!(f, "APPTYPE"),
            AdsAnalyticsTargetingType::Gender => write!(f, "GENDER"),
            AdsAnalyticsTargetingType::Location => write!(f, "LOCATION"),
            AdsAnalyticsTargetingType::Placement => write!(f, "PLACEMENT"),
            AdsAnalyticsTargetingType::Country => write!(f, "COUNTRY"),
            AdsAnalyticsTargetingType::TargetedInterest => write!(f, "TARGETED_INTEREST"),
            AdsAnalyticsTargetingType::PinnerInterest => write!(f, "PINNER_INTEREST"),
            AdsAnalyticsTargetingType::AudienceInclude => write!(f, "AUDIENCE_INCLUDE"),
            AdsAnalyticsTargetingType::Geo => write!(f, "GEO"),
            AdsAnalyticsTargetingType::AgeBucket => write!(f, "AGE_BUCKET"),
            AdsAnalyticsTargetingType::Region => write!(f, "REGION"),
        }
    }
}

impl std::str::FromStr for AdsAnalyticsTargetingType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "KEYWORD" => std::result::Result::Ok(AdsAnalyticsTargetingType::Keyword),
            "APPTYPE" => std::result::Result::Ok(AdsAnalyticsTargetingType::Apptype),
            "GENDER" => std::result::Result::Ok(AdsAnalyticsTargetingType::Gender),
            "LOCATION" => std::result::Result::Ok(AdsAnalyticsTargetingType::Location),
            "PLACEMENT" => std::result::Result::Ok(AdsAnalyticsTargetingType::Placement),
            "COUNTRY" => std::result::Result::Ok(AdsAnalyticsTargetingType::Country),
            "TARGETED_INTEREST" => std::result::Result::Ok(AdsAnalyticsTargetingType::TargetedInterest),
            "PINNER_INTEREST" => std::result::Result::Ok(AdsAnalyticsTargetingType::PinnerInterest),
            "AUDIENCE_INCLUDE" => std::result::Result::Ok(AdsAnalyticsTargetingType::AudienceInclude),
            "GEO" => std::result::Result::Ok(AdsAnalyticsTargetingType::Geo),
            "AGE_BUCKET" => std::result::Result::Ok(AdsAnalyticsTargetingType::AgeBucket),
            "REGION" => std::result::Result::Ok(AdsAnalyticsTargetingType::Region),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdsCreditDiscountsResponse {
/// True if the offer code is currently active.
    #[serde(rename = "active")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub active: Option<bool>,

/// Advertiser ID the offer was applied to.
    #[serde(rename = "advertiser_id")]
    #[validate(
           regex = "RE_ADSCREDITDISCOUNTSRESPONSE_ADVERTISER_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub advertiser_id: Option<String>,

/// The type of discount of this credit
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "discountType")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub discount_type: Option<Nullable<String>>,

/// The discount applied in the offer’s currency value.
    #[serde(rename = "discountInMicroCurrency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub discount_in_micro_currency: Option<Nullable<f64>>,

/// Currency value for the discount.
    #[serde(rename = "discountCurrency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub discount_currency: Option<Nullable<String>>,

/// Human readable title of the offer code.
    #[serde(rename = "title")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<Nullable<String>>,

/// The credits left to spend.
    #[serde(rename = "remainingDiscountInMicroCurrency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub remaining_discount_in_micro_currency: Option<Nullable<f64>>,

}

lazy_static::lazy_static! {
    static ref RE_ADSCREDITDISCOUNTSRESPONSE_ADVERTISER_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AdsCreditDiscountsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdsCreditDiscountsResponse {
        AdsCreditDiscountsResponse {
            active: None,
            advertiser_id: None,
            discount_type: None,
            discount_in_micro_currency: None,
            discount_currency: None,
            title: None,
            remaining_discount_in_micro_currency: None,
        }
    }
}

/// Converts the AdsCreditDiscountsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdsCreditDiscountsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.active.as_ref().map(|active| {
                [
                    "active".to_string(),
                    active.to_string(),
                ].join(",")
            }),


            self.advertiser_id.as_ref().map(|advertiser_id| {
                [
                    "advertiser_id".to_string(),
                    advertiser_id.to_string(),
                ].join(",")
            }),


            self.discount_type.as_ref().map(|discount_type| {
                [
                    "discountType".to_string(),
                    discount_type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.discount_in_micro_currency.as_ref().map(|discount_in_micro_currency| {
                [
                    "discountInMicroCurrency".to_string(),
                    discount_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.discount_currency.as_ref().map(|discount_currency| {
                [
                    "discountCurrency".to_string(),
                    discount_currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.title.as_ref().map(|title| {
                [
                    "title".to_string(),
                    title.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.remaining_discount_in_micro_currency.as_ref().map(|remaining_discount_in_micro_currency| {
                [
                    "remainingDiscountInMicroCurrency".to_string(),
                    remaining_discount_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdsCreditDiscountsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdsCreditDiscountsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub active: Vec<bool>,
            pub advertiser_id: Vec<String>,
            pub discount_type: Vec<String>,
            pub discount_in_micro_currency: Vec<f64>,
            pub discount_currency: Vec<String>,
            pub title: Vec<String>,
            pub remaining_discount_in_micro_currency: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdsCreditDiscountsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "active" => intermediate_rep.active.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "advertiser_id" => intermediate_rep.advertiser_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "discountType" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdsCreditDiscountsResponse".to_string()),
                    "discountInMicroCurrency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdsCreditDiscountsResponse".to_string()),
                    "discountCurrency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdsCreditDiscountsResponse".to_string()),
                    "title" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdsCreditDiscountsResponse".to_string()),
                    "remainingDiscountInMicroCurrency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdsCreditDiscountsResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdsCreditDiscountsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdsCreditDiscountsResponse {
            active: intermediate_rep.active.into_iter().next(),
            advertiser_id: intermediate_rep.advertiser_id.into_iter().next(),
            discount_type: std::result::Result::Err("Nullable types not supported in AdsCreditDiscountsResponse".to_string())?,
            discount_in_micro_currency: std::result::Result::Err("Nullable types not supported in AdsCreditDiscountsResponse".to_string())?,
            discount_currency: std::result::Result::Err("Nullable types not supported in AdsCreditDiscountsResponse".to_string())?,
            title: std::result::Result::Err("Nullable types not supported in AdsCreditDiscountsResponse".to_string())?,
            remaining_discount_in_micro_currency: std::result::Result::Err("Nullable types not supported in AdsCreditDiscountsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdsCreditDiscountsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdsCreditDiscountsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdsCreditDiscountsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdsCreditDiscountsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdsCreditDiscountsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdsCreditDiscountsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdsCreditDiscountsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdsCreditRedeemRequest {
/// Takes in a SHA256 hash of the offerCode.
    #[serde(rename = "offerCodeHash")]
    #[validate(
           regex = "RE_ADSCREDITREDEEMREQUEST_OFFER_CODE_HASH",
        )]
    pub offer_code_hash: String,

/// If true, only validate if we can redeem offer code. Otherwise it will actually apply the offer code to the account
    #[serde(rename = "validateOnly")]
    pub validate_only: bool,

}

lazy_static::lazy_static! {
    static ref RE_ADSCREDITREDEEMREQUEST_OFFER_CODE_HASH: regex::Regex = regex::Regex::new(r"^[a-z0-9]*$").unwrap();
}

impl AdsCreditRedeemRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(offer_code_hash: String, validate_only: bool, ) -> AdsCreditRedeemRequest {
        AdsCreditRedeemRequest {
            offer_code_hash,
            validate_only,
        }
    }
}

/// Converts the AdsCreditRedeemRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdsCreditRedeemRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("offerCodeHash".to_string()),
            Some(self.offer_code_hash.to_string()),


            Some("validateOnly".to_string()),
            Some(self.validate_only.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdsCreditRedeemRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdsCreditRedeemRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub offer_code_hash: Vec<String>,
            pub validate_only: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdsCreditRedeemRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "offerCodeHash" => intermediate_rep.offer_code_hash.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "validateOnly" => intermediate_rep.validate_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdsCreditRedeemRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdsCreditRedeemRequest {
            offer_code_hash: intermediate_rep.offer_code_hash.into_iter().next().ok_or_else(|| "offerCodeHash missing in AdsCreditRedeemRequest".to_string())?,
            validate_only: intermediate_rep.validate_only.into_iter().next().ok_or_else(|| "validateOnly missing in AdsCreditRedeemRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdsCreditRedeemRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdsCreditRedeemRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdsCreditRedeemRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdsCreditRedeemRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdsCreditRedeemRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdsCreditRedeemRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdsCreditRedeemRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdsCreditRedeemResponse {
/// Returns true if the offer code was successfully applied(validateOnly=false) or can be applied(validateOnly=true).
    #[serde(rename = "success")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub success: Option<bool>,

/// Error code type if error occurs
    #[serde(rename = "errorCode")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_code: Option<Nullable<i32>>,

/// Reason for failure
    #[serde(rename = "errorMessage")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_message: Option<Nullable<String>>,

}


impl AdsCreditRedeemResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdsCreditRedeemResponse {
        AdsCreditRedeemResponse {
            success: None,
            error_code: None,
            error_message: None,
        }
    }
}

/// Converts the AdsCreditRedeemResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdsCreditRedeemResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.success.as_ref().map(|success| {
                [
                    "success".to_string(),
                    success.to_string(),
                ].join(",")
            }),


            self.error_code.as_ref().map(|error_code| {
                [
                    "errorCode".to_string(),
                    error_code.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.error_message.as_ref().map(|error_message| {
                [
                    "errorMessage".to_string(),
                    error_message.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdsCreditRedeemResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdsCreditRedeemResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub success: Vec<bool>,
            pub error_code: Vec<i32>,
            pub error_message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdsCreditRedeemResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "success" => intermediate_rep.success.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errorCode" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdsCreditRedeemResponse".to_string()),
                    "errorMessage" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdsCreditRedeemResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdsCreditRedeemResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdsCreditRedeemResponse {
            success: intermediate_rep.success.into_iter().next(),
            error_code: std::result::Result::Err("Nullable types not supported in AdsCreditRedeemResponse".to_string())?,
            error_message: std::result::Result::Err("Nullable types not supported in AdsCreditRedeemResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdsCreditRedeemResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdsCreditRedeemResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdsCreditRedeemResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdsCreditRedeemResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdsCreditRedeemResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdsCreditRedeemResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdsCreditRedeemResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdsCreditsDiscountsGet200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::AdsCreditDiscountsResponse>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl AdsCreditsDiscountsGet200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::AdsCreditDiscountsResponse>, ) -> AdsCreditsDiscountsGet200Response {
        AdsCreditsDiscountsGet200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the AdsCreditsDiscountsGet200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdsCreditsDiscountsGet200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdsCreditsDiscountsGet200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdsCreditsDiscountsGet200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::AdsCreditDiscountsResponse>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdsCreditsDiscountsGet200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsCreditsDiscountsGet200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdsCreditsDiscountsGet200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdsCreditsDiscountsGet200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdsCreditsDiscountsGet200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in AdsCreditsDiscountsGet200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in AdsCreditsDiscountsGet200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdsCreditsDiscountsGet200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdsCreditsDiscountsGet200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdsCreditsDiscountsGet200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdsCreditsDiscountsGet200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdsCreditsDiscountsGet200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdsCreditsDiscountsGet200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdsCreditsDiscountsGet200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdsList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::AdResponse>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl AdsList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::AdResponse>, ) -> AdsList200Response {
        AdsList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the AdsList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdsList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdsList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdsList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::AdResponse>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdsList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdsList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdsList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdsList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in AdsList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in AdsList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdsList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdsList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdsList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdsList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdsList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdsList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdsList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AnalyticsDailyMetrics {
    #[serde(rename = "data_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data_status: Option<models::DataStatus>,

/// Metrics date (UTC): YYYY-MM-DD.
    #[serde(rename = "date")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<String>,

/// The metric name and daily value for each requested metric
    #[serde(rename = "metrics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metrics: Option<std::collections::HashMap<String, f64>>,

}


impl AnalyticsDailyMetrics {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AnalyticsDailyMetrics {
        AnalyticsDailyMetrics {
            data_status: None,
            date: None,
            metrics: None,
        }
    }
}

/// Converts the AnalyticsDailyMetrics value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AnalyticsDailyMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data_status in query parameter serialization


            self.date.as_ref().map(|date| {
                [
                    "date".to_string(),
                    date.to_string(),
                ].join(",")
            }),

            // Skipping metrics in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AnalyticsDailyMetrics value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AnalyticsDailyMetrics {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data_status: Vec<models::DataStatus>,
            pub date: Vec<String>,
            pub metrics: Vec<std::collections::HashMap<String, f64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AnalyticsDailyMetrics".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "data_status" => intermediate_rep.data_status.push(<models::DataStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "date" => intermediate_rep.date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "metrics" => return std::result::Result::Err("Parsing a container in this style is not supported in AnalyticsDailyMetrics".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AnalyticsDailyMetrics".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AnalyticsDailyMetrics {
            data_status: intermediate_rep.data_status.into_iter().next(),
            date: intermediate_rep.date.into_iter().next(),
            metrics: intermediate_rep.metrics.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AnalyticsDailyMetrics> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AnalyticsDailyMetrics>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AnalyticsDailyMetrics>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AnalyticsDailyMetrics - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AnalyticsDailyMetrics> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AnalyticsDailyMetrics as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AnalyticsDailyMetrics - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AnalyticsMetricsResponse {
/// The metric name and value over the requested period for each requested metric
    #[serde(rename = "summary_metrics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary_metrics: Option<std::collections::HashMap<String, f64>>,

/// Array with the requested daily metric records
    #[serde(rename = "daily_metrics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub daily_metrics: Option<Vec<models::AnalyticsDailyMetrics>>,

}


impl AnalyticsMetricsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AnalyticsMetricsResponse {
        AnalyticsMetricsResponse {
            summary_metrics: None,
            daily_metrics: None,
        }
    }
}

/// Converts the AnalyticsMetricsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AnalyticsMetricsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping summary_metrics in query parameter serialization

            // Skipping daily_metrics in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AnalyticsMetricsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AnalyticsMetricsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub summary_metrics: Vec<std::collections::HashMap<String, f64>>,
            pub daily_metrics: Vec<Vec<models::AnalyticsDailyMetrics>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AnalyticsMetricsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "summary_metrics" => return std::result::Result::Err("Parsing a container in this style is not supported in AnalyticsMetricsResponse".to_string()),
                    "daily_metrics" => return std::result::Result::Err("Parsing a container in this style is not supported in AnalyticsMetricsResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AnalyticsMetricsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AnalyticsMetricsResponse {
            summary_metrics: intermediate_rep.summary_metrics.into_iter().next(),
            daily_metrics: intermediate_rep.daily_metrics.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AnalyticsMetricsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AnalyticsMetricsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AnalyticsMetricsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AnalyticsMetricsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AnalyticsMetricsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AnalyticsMetricsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AnalyticsMetricsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Audience {
/// Ad account ID.
    #[serde(rename = "ad_account_id")]
    #[validate(
           regex = "RE_AUDIENCE_AD_ACCOUNT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// Audience ID.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_AUDIENCE_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Audience name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// <a href=\"/docs/reference/glossary/#Audience Types\">Audience types</a>: ACTALIKE, ENGAGEMENT, CUSTOMER_LIST and VISITOR
    #[serde(rename = "audience_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audience_type: Option<String>,

/// Audience description.
    #[serde(rename = "description")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

    #[serde(rename = "rule")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule: Option<models::AudienceRule>,

/// Audience size.
    #[serde(rename = "size")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<Nullable<i32>>,

/// Audience status. READY, INITIALIZING, TOO_SMALL - Each audience list needs to have at least 100 people with Pinterest accounts before you can start using it.
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

/// Always \"audience\".
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

/// Creation time. Unix timestamp in seconds.
    #[serde(rename = "created_timestamp")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_timestamp: Option<Nullable<i32>>,

/// Last update time. Unix timestamp in seconds.
    #[serde(rename = "updated_timestamp")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_timestamp: Option<Nullable<i32>>,

}

lazy_static::lazy_static! {
    static ref RE_AUDIENCE_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_AUDIENCE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl Audience {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Audience {
        Audience {
            ad_account_id: None,
            id: None,
            name: None,
            audience_type: None,
            description: None,
            rule: None,
            size: None,
            status: None,
            r#type: None,
            created_timestamp: None,
            updated_timestamp: None,
        }
    }
}

/// Converts the Audience value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Audience {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.audience_type.as_ref().map(|audience_type| {
                [
                    "audience_type".to_string(),
                    audience_type.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping rule in query parameter serialization


            self.size.as_ref().map(|size| {
                [
                    "size".to_string(),
                    size.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.created_timestamp.as_ref().map(|created_timestamp| {
                [
                    "created_timestamp".to_string(),
                    created_timestamp.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.updated_timestamp.as_ref().map(|updated_timestamp| {
                [
                    "updated_timestamp".to_string(),
                    updated_timestamp.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Audience value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Audience {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_account_id: Vec<String>,
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub audience_type: Vec<String>,
            pub description: Vec<String>,
            pub rule: Vec<models::AudienceRule>,
            pub size: Vec<i32>,
            pub status: Vec<String>,
            pub r#type: Vec<String>,
            pub created_timestamp: Vec<i32>,
            pub updated_timestamp: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Audience".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "audience_type" => intermediate_rep.audience_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Audience".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "rule" => intermediate_rep.rule.push(<models::AudienceRule as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "size" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Audience".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "created_timestamp" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Audience".to_string()),
                    "updated_timestamp" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Audience".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Audience".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Audience {
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            audience_type: intermediate_rep.audience_type.into_iter().next(),
            description: std::result::Result::Err("Nullable types not supported in Audience".to_string())?,
            rule: intermediate_rep.rule.into_iter().next(),
            size: std::result::Result::Err("Nullable types not supported in Audience".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            created_timestamp: std::result::Result::Err("Nullable types not supported in Audience".to_string())?,
            updated_timestamp: std::result::Result::Err("Nullable types not supported in Audience".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Audience> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Audience>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Audience>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Audience - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Audience> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Audience as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Audience - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceCategory {
/// Interest unique key (same as ID).
    #[serde(rename = "key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

/// Interest name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Interest's percent of category's total audience.
    #[serde(rename = "ratio")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ratio: Option<f64>,

/// Interest affinity index.
    #[serde(rename = "index")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index: Option<f64>,

/// Interest ID.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Subcategory interest distribution
    #[serde(rename = "subcategories")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subcategories: Option<Vec<models::AudienceSubcategory>>,

}


impl AudienceCategory {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AudienceCategory {
        AudienceCategory {
            key: None,
            name: None,
            ratio: None,
            index: None,
            id: None,
            subcategories: None,
        }
    }
}

/// Converts the AudienceCategory value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AudienceCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.key.as_ref().map(|key| {
                [
                    "key".to_string(),
                    key.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.ratio.as_ref().map(|ratio| {
                [
                    "ratio".to_string(),
                    ratio.to_string(),
                ].join(",")
            }),


            self.index.as_ref().map(|index| {
                [
                    "index".to_string(),
                    index.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping subcategories in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AudienceCategory value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AudienceCategory {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub key: Vec<String>,
            pub name: Vec<String>,
            pub ratio: Vec<f64>,
            pub index: Vec<f64>,
            pub id: Vec<String>,
            pub subcategories: Vec<Vec<models::AudienceSubcategory>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AudienceCategory".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ratio" => intermediate_rep.ratio.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "subcategories" => return std::result::Result::Err("Parsing a container in this style is not supported in AudienceCategory".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AudienceCategory".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AudienceCategory {
            key: intermediate_rep.key.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            ratio: intermediate_rep.ratio.into_iter().next(),
            index: intermediate_rep.index.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            subcategories: intermediate_rep.subcategories.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AudienceCategory> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AudienceCategory>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AudienceCategory>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AudienceCategory - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AudienceCategory> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AudienceCategory as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AudienceCategory - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceCommon {
/// Ad account ID.
    #[serde(rename = "ad_account_id")]
    #[validate(
           regex = "RE_AUDIENCECOMMON_AD_ACCOUNT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// Audience name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "rule")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule: Option<models::AudienceRule>,

}

lazy_static::lazy_static! {
    static ref RE_AUDIENCECOMMON_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AudienceCommon {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AudienceCommon {
        AudienceCommon {
            ad_account_id: None,
            name: None,
            rule: None,
        }
    }
}

/// Converts the AudienceCommon value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AudienceCommon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping rule in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AudienceCommon value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AudienceCommon {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_account_id: Vec<String>,
            pub name: Vec<String>,
            pub rule: Vec<models::AudienceRule>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AudienceCommon".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rule" => intermediate_rep.rule.push(<models::AudienceRule as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AudienceCommon".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AudienceCommon {
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            rule: intermediate_rep.rule.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AudienceCommon> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AudienceCommon>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AudienceCommon>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AudienceCommon - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AudienceCommon> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AudienceCommon as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AudienceCommon - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceCreateCustomRequest {
/// Ad account ID.
    #[serde(rename = "ad_account_id")]
    #[validate(
           regex = "RE_AUDIENCECREATECUSTOMREQUEST_AD_ACCOUNT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// Audience name.
    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "rule")]
    pub rule: models::AudienceRule,

    #[serde(rename = "sharing_type")]
    pub sharing_type: models::AudienceSharingType,

    #[serde(rename = "data_party")]
    pub data_party: models::AudienceDataParty,

    #[serde(rename = "category")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_AUDIENCECREATECUSTOMREQUEST_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AudienceCreateCustomRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, rule: models::AudienceRule, sharing_type: models::AudienceSharingType, data_party: models::AudienceDataParty, ) -> AudienceCreateCustomRequest {
        AudienceCreateCustomRequest {
            ad_account_id: None,
            name,
            rule,
            sharing_type,
            data_party,
            category: None,
        }
    }
}

/// Converts the AudienceCreateCustomRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AudienceCreateCustomRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping rule in query parameter serialization

            // Skipping sharing_type in query parameter serialization

            // Skipping data_party in query parameter serialization


            self.category.as_ref().map(|category| {
                [
                    "category".to_string(),
                    category.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AudienceCreateCustomRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AudienceCreateCustomRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_account_id: Vec<String>,
            pub name: Vec<String>,
            pub rule: Vec<models::AudienceRule>,
            pub sharing_type: Vec<models::AudienceSharingType>,
            pub data_party: Vec<models::AudienceDataParty>,
            pub category: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AudienceCreateCustomRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rule" => intermediate_rep.rule.push(<models::AudienceRule as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sharing_type" => intermediate_rep.sharing_type.push(<models::AudienceSharingType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data_party" => intermediate_rep.data_party.push(<models::AudienceDataParty as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "category" => intermediate_rep.category.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AudienceCreateCustomRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AudienceCreateCustomRequest {
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in AudienceCreateCustomRequest".to_string())?,
            rule: intermediate_rep.rule.into_iter().next().ok_or_else(|| "rule missing in AudienceCreateCustomRequest".to_string())?,
            sharing_type: intermediate_rep.sharing_type.into_iter().next().ok_or_else(|| "sharing_type missing in AudienceCreateCustomRequest".to_string())?,
            data_party: intermediate_rep.data_party.into_iter().next().ok_or_else(|| "data_party missing in AudienceCreateCustomRequest".to_string())?,
            category: intermediate_rep.category.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AudienceCreateCustomRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AudienceCreateCustomRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AudienceCreateCustomRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AudienceCreateCustomRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AudienceCreateCustomRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AudienceCreateCustomRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AudienceCreateCustomRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceCreateRequest {
/// Ad account ID.
    #[serde(rename = "ad_account_id")]
    #[validate(
           regex = "RE_AUDIENCECREATEREQUEST_AD_ACCOUNT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// Audience name.
    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "rule")]
    pub rule: models::AudienceRule,

/// Audience description.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "audience_type")]
    pub audience_type: models::AudienceCreateRequest1AudienceType,

}

lazy_static::lazy_static! {
    static ref RE_AUDIENCECREATEREQUEST_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AudienceCreateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, rule: models::AudienceRule, audience_type: models::AudienceCreateRequest1AudienceType, ) -> AudienceCreateRequest {
        AudienceCreateRequest {
            ad_account_id: None,
            name,
            rule,
            description: None,
            audience_type,
        }
    }
}

/// Converts the AudienceCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AudienceCreateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping rule in query parameter serialization


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping audience_type in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AudienceCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AudienceCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_account_id: Vec<String>,
            pub name: Vec<String>,
            pub rule: Vec<models::AudienceRule>,
            pub description: Vec<String>,
            pub audience_type: Vec<models::AudienceCreateRequest1AudienceType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AudienceCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rule" => intermediate_rep.rule.push(<models::AudienceRule as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "audience_type" => intermediate_rep.audience_type.push(<models::AudienceCreateRequest1AudienceType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AudienceCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AudienceCreateRequest {
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in AudienceCreateRequest".to_string())?,
            rule: intermediate_rep.rule.into_iter().next().ok_or_else(|| "rule missing in AudienceCreateRequest".to_string())?,
            description: intermediate_rep.description.into_iter().next(),
            audience_type: intermediate_rep.audience_type.into_iter().next().ok_or_else(|| "audience_type missing in AudienceCreateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AudienceCreateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AudienceCreateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AudienceCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AudienceCreateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AudienceCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AudienceCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AudienceCreateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceCreateRequest1AudienceType {
}


impl AudienceCreateRequest1AudienceType {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AudienceCreateRequest1AudienceType {
        AudienceCreateRequest1AudienceType {
        }
    }
}

/// Converts the AudienceCreateRequest1AudienceType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AudienceCreateRequest1AudienceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AudienceCreateRequest1AudienceType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AudienceCreateRequest1AudienceType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AudienceCreateRequest1AudienceType".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => return std::result::Result::Err("Unexpected key while parsing AudienceCreateRequest1AudienceType".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AudienceCreateRequest1AudienceType {
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AudienceCreateRequest1AudienceType> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AudienceCreateRequest1AudienceType>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AudienceCreateRequest1AudienceType>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AudienceCreateRequest1AudienceType - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AudienceCreateRequest1AudienceType> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AudienceCreateRequest1AudienceType as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AudienceCreateRequest1AudienceType - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Whether the data is owned by the partner (1p) or by the data provider (3p)
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AudienceDataParty {
    #[serde(rename = "1p")]
    Variant1p,
    #[serde(rename = "3p")]
    Variant3p,
}

impl std::fmt::Display for AudienceDataParty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AudienceDataParty::Variant1p => write!(f, "1p"),
            AudienceDataParty::Variant3p => write!(f, "3p"),
        }
    }
}

impl std::str::FromStr for AudienceDataParty {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "1p" => std::result::Result::Ok(AudienceDataParty::Variant1p),
            "3p" => std::result::Result::Ok(AudienceDataParty::Variant3p),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Queryable audience representation.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceDefinition {
/// Generation date
    #[serde(rename = "date")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<Nullable<String>>,

/// Generated audience type to request.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

/// Generated audience scope to request.
    #[serde(rename = "scope")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scope: Option<String>,

}


impl AudienceDefinition {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AudienceDefinition {
        AudienceDefinition {
            date: None,
            r#type: None,
            scope: None,
        }
    }
}

/// Converts the AudienceDefinition value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AudienceDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.date.as_ref().map(|date| {
                [
                    "date".to_string(),
                    date.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.scope.as_ref().map(|scope| {
                [
                    "scope".to_string(),
                    scope.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AudienceDefinition value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AudienceDefinition {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub date: Vec<String>,
            pub r#type: Vec<String>,
            pub scope: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AudienceDefinition".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "date" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AudienceDefinition".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AudienceDefinition".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AudienceDefinition {
            date: std::result::Result::Err("Nullable types not supported in AudienceDefinition".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next(),
            scope: intermediate_rep.scope.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AudienceDefinition> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AudienceDefinition>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AudienceDefinition>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AudienceDefinition - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AudienceDefinition> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AudienceDefinition as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AudienceDefinition - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceDefinitionResponse {
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::AudienceDefinition>>,

}


impl AudienceDefinitionResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AudienceDefinitionResponse {
        AudienceDefinitionResponse {
            items: None,
        }
    }
}

/// Converts the AudienceDefinitionResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AudienceDefinitionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AudienceDefinitionResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AudienceDefinitionResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::AudienceDefinition>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AudienceDefinitionResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in AudienceDefinitionResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AudienceDefinitionResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AudienceDefinitionResponse {
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AudienceDefinitionResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AudienceDefinitionResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AudienceDefinitionResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AudienceDefinitionResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AudienceDefinitionResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AudienceDefinitionResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AudienceDefinitionResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Generated audience scope to request.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceDefinitionScope(String);

impl validator::Validate for AudienceDefinitionScope {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for AudienceDefinitionScope {
    fn from(x: String) -> Self {
        AudienceDefinitionScope(x)
    }
}

impl std::fmt::Display for AudienceDefinitionScope {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for AudienceDefinitionScope {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(AudienceDefinitionScope(x.to_string()))
    }
}

impl std::convert::From<AudienceDefinitionScope> for String {
    fn from(x: AudienceDefinitionScope) -> Self {
        x.0
    }
}

impl std::ops::Deref for AudienceDefinitionScope {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for AudienceDefinitionScope {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// Generated audience type to request.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceDefinitionType(String);

impl validator::Validate for AudienceDefinitionType {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for AudienceDefinitionType {
    fn from(x: String) -> Self {
        AudienceDefinitionType(x)
    }
}

impl std::fmt::Display for AudienceDefinitionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for AudienceDefinitionType {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(AudienceDefinitionType(x.to_string()))
    }
}

impl std::convert::From<AudienceDefinitionType> for String {
    fn from(x: AudienceDefinitionType) -> Self {
        x.0
    }
}

impl std::ops::Deref for AudienceDefinitionType {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for AudienceDefinitionType {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// Demographic detail for a single audience demographic



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceDemographicValue {
/// Unique key for demographic item
    #[serde(rename = "key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

/// Display name for demographic
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Value of demographic item as a percent of total audience
    #[serde(rename = "ratio")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ratio: Option<f64>,

}


impl AudienceDemographicValue {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AudienceDemographicValue {
        AudienceDemographicValue {
            key: None,
            name: None,
            ratio: None,
        }
    }
}

/// Converts the AudienceDemographicValue value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AudienceDemographicValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.key.as_ref().map(|key| {
                [
                    "key".to_string(),
                    key.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.ratio.as_ref().map(|ratio| {
                [
                    "ratio".to_string(),
                    ratio.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AudienceDemographicValue value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AudienceDemographicValue {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub key: Vec<String>,
            pub name: Vec<String>,
            pub ratio: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AudienceDemographicValue".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ratio" => intermediate_rep.ratio.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AudienceDemographicValue".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AudienceDemographicValue {
            key: intermediate_rep.key.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            ratio: intermediate_rep.ratio.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AudienceDemographicValue> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AudienceDemographicValue>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AudienceDemographicValue>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AudienceDemographicValue - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AudienceDemographicValue> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AudienceDemographicValue as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AudienceDemographicValue - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Audience demographics



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceDemographics {
/// Ages distribution.
    #[serde(rename = "ages")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ages: Option<Vec<models::AudienceDemographicValue>>,

/// Gender distribution.
    #[serde(rename = "genders")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub genders: Option<Vec<models::AudienceDemographicValue>>,

/// Device usage distribution.
    #[serde(rename = "devices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub devices: Option<Vec<models::AudienceDemographicValue>>,

/// Geographic metro area distribution.
    #[serde(rename = "metros")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metros: Option<Vec<models::AudienceDemographicValue>>,

/// Country area distribution.
    #[serde(rename = "countries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub countries: Option<Vec<models::AudienceDemographicValue>>,

}


impl AudienceDemographics {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AudienceDemographics {
        AudienceDemographics {
            ages: None,
            genders: None,
            devices: None,
            metros: None,
            countries: None,
        }
    }
}

/// Converts the AudienceDemographics value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AudienceDemographics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping ages in query parameter serialization

            // Skipping genders in query parameter serialization

            // Skipping devices in query parameter serialization

            // Skipping metros in query parameter serialization

            // Skipping countries in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AudienceDemographics value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AudienceDemographics {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ages: Vec<Vec<models::AudienceDemographicValue>>,
            pub genders: Vec<Vec<models::AudienceDemographicValue>>,
            pub devices: Vec<Vec<models::AudienceDemographicValue>>,
            pub metros: Vec<Vec<models::AudienceDemographicValue>>,
            pub countries: Vec<Vec<models::AudienceDemographicValue>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AudienceDemographics".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ages" => return std::result::Result::Err("Parsing a container in this style is not supported in AudienceDemographics".to_string()),
                    "genders" => return std::result::Result::Err("Parsing a container in this style is not supported in AudienceDemographics".to_string()),
                    "devices" => return std::result::Result::Err("Parsing a container in this style is not supported in AudienceDemographics".to_string()),
                    "metros" => return std::result::Result::Err("Parsing a container in this style is not supported in AudienceDemographics".to_string()),
                    "countries" => return std::result::Result::Err("Parsing a container in this style is not supported in AudienceDemographics".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AudienceDemographics".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AudienceDemographics {
            ages: intermediate_rep.ages.into_iter().next(),
            genders: intermediate_rep.genders.into_iter().next(),
            devices: intermediate_rep.devices.into_iter().next(),
            metros: intermediate_rep.metros.into_iter().next(),
            countries: intermediate_rep.countries.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AudienceDemographics> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AudienceDemographics>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AudienceDemographics>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AudienceDemographics - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AudienceDemographics> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AudienceDemographics as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AudienceDemographics - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Audience description.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceDescription(String);

impl validator::Validate for AudienceDescription {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for AudienceDescription {
    fn from(x: String) -> Self {
        AudienceDescription(x)
    }
}

impl std::fmt::Display for AudienceDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for AudienceDescription {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(AudienceDescription(x.to_string()))
    }
}

impl std::convert::From<AudienceDescription> for String {
    fn from(x: AudienceDescription) -> Self {
        x.0
    }
}

impl std::ops::Deref for AudienceDescription {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for AudienceDescription {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceInsightCategoryArrayResponse {
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::AudienceInsightCategoryCommon>>,

}


impl AudienceInsightCategoryArrayResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AudienceInsightCategoryArrayResponse {
        AudienceInsightCategoryArrayResponse {
            items: None,
        }
    }
}

/// Converts the AudienceInsightCategoryArrayResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AudienceInsightCategoryArrayResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AudienceInsightCategoryArrayResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AudienceInsightCategoryArrayResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::AudienceInsightCategoryCommon>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AudienceInsightCategoryArrayResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in AudienceInsightCategoryArrayResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AudienceInsightCategoryArrayResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AudienceInsightCategoryArrayResponse {
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AudienceInsightCategoryArrayResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AudienceInsightCategoryArrayResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AudienceInsightCategoryArrayResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AudienceInsightCategoryArrayResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AudienceInsightCategoryArrayResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AudienceInsightCategoryArrayResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AudienceInsightCategoryArrayResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceInsightCategoryCommon {
    #[serde(rename = "key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "ratio")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ratio: Option<f64>,

    #[serde(rename = "index")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index: Option<f64>,

    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}


impl AudienceInsightCategoryCommon {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AudienceInsightCategoryCommon {
        AudienceInsightCategoryCommon {
            key: None,
            name: None,
            ratio: None,
            index: None,
            id: None,
        }
    }
}

/// Converts the AudienceInsightCategoryCommon value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AudienceInsightCategoryCommon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.key.as_ref().map(|key| {
                [
                    "key".to_string(),
                    key.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.ratio.as_ref().map(|ratio| {
                [
                    "ratio".to_string(),
                    ratio.to_string(),
                ].join(",")
            }),


            self.index.as_ref().map(|index| {
                [
                    "index".to_string(),
                    index.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AudienceInsightCategoryCommon value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AudienceInsightCategoryCommon {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub key: Vec<String>,
            pub name: Vec<String>,
            pub ratio: Vec<f64>,
            pub index: Vec<f64>,
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AudienceInsightCategoryCommon".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ratio" => intermediate_rep.ratio.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AudienceInsightCategoryCommon".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AudienceInsightCategoryCommon {
            key: intermediate_rep.key.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            ratio: intermediate_rep.ratio.into_iter().next(),
            index: intermediate_rep.index.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AudienceInsightCategoryCommon> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AudienceInsightCategoryCommon>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AudienceInsightCategoryCommon>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AudienceInsightCategoryCommon - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AudienceInsightCategoryCommon> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AudienceInsightCategoryCommon as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AudienceInsightCategoryCommon - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AudienceInsightType {
    #[serde(rename = "YOUR_TOTAL_AUDIENCE")]
    YourTotalAudience,
    #[serde(rename = "YOUR_ENGAGED_AUDIENCE")]
    YourEngagedAudience,
    #[serde(rename = "PINTEREST_TOTAL_AUDIENCE")]
    PinterestTotalAudience,
}

impl std::fmt::Display for AudienceInsightType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AudienceInsightType::YourTotalAudience => write!(f, "YOUR_TOTAL_AUDIENCE"),
            AudienceInsightType::YourEngagedAudience => write!(f, "YOUR_ENGAGED_AUDIENCE"),
            AudienceInsightType::PinterestTotalAudience => write!(f, "PINTEREST_TOTAL_AUDIENCE"),
        }
    }
}

impl std::str::FromStr for AudienceInsightType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "YOUR_TOTAL_AUDIENCE" => std::result::Result::Ok(AudienceInsightType::YourTotalAudience),
            "YOUR_ENGAGED_AUDIENCE" => std::result::Result::Ok(AudienceInsightType::YourEngagedAudience),
            "PINTEREST_TOTAL_AUDIENCE" => std::result::Result::Ok(AudienceInsightType::PinterestTotalAudience),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Audience interests and demographics.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceInsightsResponse {
/// Category interest distribution
    #[serde(rename = "categories")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub categories: Option<Vec<models::AudienceCategory>>,

    #[serde(rename = "demographics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub demographics: Option<models::AudienceDemographics>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::AudienceInsightType>,

/// Generation date
    #[serde(rename = "date")]
    #[validate(
           regex = "RE_AUDIENCEINSIGHTSRESPONSE_DATE",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<Nullable<String>>,

/// Population count.
    #[serde(rename = "size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i32>,

/// Indicates whether the audience size has been rounded up to the next highest upper boundary.
    #[serde(rename = "size_is_upper_bound")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_is_upper_bound: Option<bool>,

}

lazy_static::lazy_static! {
    static ref RE_AUDIENCEINSIGHTSRESPONSE_DATE: regex::Regex = regex::Regex::new(r"^\\d{4}-\\d{2}-\\d{2}$").unwrap();
}

impl AudienceInsightsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AudienceInsightsResponse {
        AudienceInsightsResponse {
            categories: None,
            demographics: None,
            r#type: None,
            date: None,
            size: None,
            size_is_upper_bound: None,
        }
    }
}

/// Converts the AudienceInsightsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AudienceInsightsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping categories in query parameter serialization

            // Skipping demographics in query parameter serialization

            // Skipping type in query parameter serialization


            self.date.as_ref().map(|date| {
                [
                    "date".to_string(),
                    date.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "size".to_string(),
                    size.to_string(),
                ].join(",")
            }),


            self.size_is_upper_bound.as_ref().map(|size_is_upper_bound| {
                [
                    "size_is_upper_bound".to_string(),
                    size_is_upper_bound.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AudienceInsightsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AudienceInsightsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub categories: Vec<Vec<models::AudienceCategory>>,
            pub demographics: Vec<models::AudienceDemographics>,
            pub r#type: Vec<models::AudienceInsightType>,
            pub date: Vec<String>,
            pub size: Vec<i32>,
            pub size_is_upper_bound: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AudienceInsightsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "categories" => return std::result::Result::Err("Parsing a container in this style is not supported in AudienceInsightsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "demographics" => intermediate_rep.demographics.push(<models::AudienceDemographics as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::AudienceInsightType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "date" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AudienceInsightsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "size" => intermediate_rep.size.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "size_is_upper_bound" => intermediate_rep.size_is_upper_bound.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AudienceInsightsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AudienceInsightsResponse {
            categories: intermediate_rep.categories.into_iter().next(),
            demographics: intermediate_rep.demographics.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            date: std::result::Result::Err("Nullable types not supported in AudienceInsightsResponse".to_string())?,
            size: intermediate_rep.size.into_iter().next(),
            size_is_upper_bound: intermediate_rep.size_is_upper_bound.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AudienceInsightsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AudienceInsightsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AudienceInsightsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AudienceInsightsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AudienceInsightsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AudienceInsightsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AudienceInsightsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// JSON object defining targeted audience users. Example rule formats per audience type:<br>CUSTOMER_LIST: { \"customer_list_id\": \"&lt;customer list ID&gt;\"}<br>ACTALIKE: { \"seed_id\": [\"&lt;audience ID&gt;\"], \"country\": \"US\", \"percentage\": \"10\" }<br>(Valid countries include: \"US\", \"CA\", and \"GB\". Percentage should be 1-10.<br>The targeted audience should be this % size across Pinterest.)<br>VISITOR: { \"visitor_source_id\": [\"&lt;conversion tag ID&gt;\"], \"retention_days\": \"180\", \"event_source\": {\"=\": [\"web\", \"mobile\"]}, \"ingestion_source\": {\"=\": [\"tag\"]}}<br>(Retention days should be 1-540. Retention applies to specific customers.)<br>ENGAGEMENT: {\"engagement_domain\": [\"www.entomi.com\"], \"engager_type\": 1}<br>For more details on engagement audiences, see <a href=\"https://developers.pinterest.com/docs/redoc/adtech_ads_v4/#section/November-2021\" target=\"_blank\">November 2021 changelog</a>.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceRule {
/// Valid countries include: \"US\", \"CA\", and \"GB\".
    #[serde(rename = "country")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub country: Option<String>,

/// Customer list ID. For CUSTOMER_LIST `audience_type`.
    #[serde(rename = "customer_list_id")]
    #[validate(
           regex = "RE_AUDIENCERULE_CUSTOMER_LIST_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub customer_list_id: Option<String>,

/// The audience account's verified domain. **Required** for ENGAGEMENT `audience_type`.
    #[serde(rename = "engagement_domain")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub engagement_domain: Option<Vec<String>>,

/// Engagement type enum. Optional for ENGAGEMENT `audience_type`. Supported values are `click`, `save`, `closeup`, `comment` and `like`. All engagements are included if this field is not set. 
    #[serde(rename = "engagement_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub engagement_type: Option<String>,

/// A Pinterest tag event. Optional for VISITOR `audience_type`. Possible values are `pagevisit`, `signup`, `checkout`, `viewcategory`, `search`, `addtocart`, `watchvideo`, `lead`, and `custom`. This field also accepts a partner-defined Pinterest tag event.
    #[serde(rename = "event")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,

    #[serde(rename = "event_data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_data: Option<models::PinterestTagEventData>,

/// Percentage should be 1-10. The targeted audience should be this % size across Pinterest.
    #[serde(rename = "percentage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub percentage: Option<i32>,

/// IDs of engaged organic pins. Optional for ENGAGEMENT `audience_type`. For example, \"pin_id:\": [\"34567\"]
    #[serde(rename = "pin_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pin_id: Option<Vec<String>>,

/// Optional for VISITOR `audience_type`. If `true`, the specified rule on existing engagement data is applied to pre-populate the audience. If `false`, the audience is empty at creation time. The default is `true`.
    #[serde(rename = "prefill")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub prefill: Option<bool>,

/// Number of days a Pinterest user remains in the audience. Optional for ENGAGEMENT and VISITOR `audience_type`. Accepted range is 1-540. Defaults to 180 if not specified.
    #[serde(rename = "retention_days")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub retention_days: Option<i32>,

/// Audience ID(s). For ACTALIKE `audience_type`. 
    #[serde(rename = "seed_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seed_id: Option<Vec<String>>,

/// Optional for ENGAGEMENT or VISITOR `audience_type`. For ENGAGEMENT, it is the engaged pin's URL. For VISITOR, you can use it as a string or a {operator: value} object for filtering visitors based on conversion tag event URLs. Supported operators are [ =, !=, contains, not_contains].<br>Example 1:  \"url\": \"http://www.myonlinestore123.com/view_item/shoe\"<br>Example 2: \"url\": {\"contains\": \"/view_item/shoe\"}
    #[serde(rename = "url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<Vec<String>>,

/// The conversion tag ID, or the Pinterest tag ID, that you use on your website. For VISITOR `audience_type`.
    #[serde(rename = "visitor_source_id")]
    #[validate(
           regex = "RE_AUDIENCERULE_VISITOR_SOURCE_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub visitor_source_id: Option<String>,

/// Optional for VISITOR. You can use it as a {'=': [value]}. Supported values are: web, mobile, offline
    #[serde(rename = "event_source")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_source: Option<crate::types::Object>,

/// Optional for VISITOR. You can use it as a {'=': [value]}. Supported values are: tag, mmp, file_upload, conversions_api
    #[serde(rename = "ingestion_source")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ingestion_source: Option<crate::types::Object>,

/// Optional for ENGAGEMENT. Engager type value should be 1-2.
    #[serde(rename = "engager_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub engager_type: Option<i32>,

/// Campaign ID for engagement audience filter.
    #[serde(rename = "campaign_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_id: Option<Vec<String>>,

/// Ad ID for engagement audience filter.
    #[serde(rename = "ad_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_id: Option<Vec<String>>,

/// Objective for engagement audience filter.
    #[serde(rename = "objective_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub objective_type: Option<Vec<models::ObjectiveType>>,

/// Ad account ID.
    #[serde(rename = "ad_account_id")]
    #[validate(
           regex = "RE_AUDIENCERULE_AD_ACCOUNT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_AUDIENCERULE_CUSTOMER_LIST_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_AUDIENCERULE_VISITOR_SOURCE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_AUDIENCERULE_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AudienceRule {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AudienceRule {
        AudienceRule {
            country: None,
            customer_list_id: None,
            engagement_domain: None,
            engagement_type: None,
            event: None,
            event_data: None,
            percentage: None,
            pin_id: None,
            prefill: None,
            retention_days: None,
            seed_id: None,
            url: None,
            visitor_source_id: None,
            event_source: None,
            ingestion_source: None,
            engager_type: None,
            campaign_id: None,
            ad_id: None,
            objective_type: None,
            ad_account_id: None,
        }
    }
}

/// Converts the AudienceRule value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AudienceRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.country.as_ref().map(|country| {
                [
                    "country".to_string(),
                    country.to_string(),
                ].join(",")
            }),


            self.customer_list_id.as_ref().map(|customer_list_id| {
                [
                    "customer_list_id".to_string(),
                    customer_list_id.to_string(),
                ].join(",")
            }),


            self.engagement_domain.as_ref().map(|engagement_domain| {
                [
                    "engagement_domain".to_string(),
                    engagement_domain.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.engagement_type.as_ref().map(|engagement_type| {
                [
                    "engagement_type".to_string(),
                    engagement_type.to_string(),
                ].join(",")
            }),


            self.event.as_ref().map(|event| {
                [
                    "event".to_string(),
                    event.to_string(),
                ].join(",")
            }),

            // Skipping event_data in query parameter serialization


            self.percentage.as_ref().map(|percentage| {
                [
                    "percentage".to_string(),
                    percentage.to_string(),
                ].join(",")
            }),


            self.pin_id.as_ref().map(|pin_id| {
                [
                    "pin_id".to_string(),
                    pin_id.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.prefill.as_ref().map(|prefill| {
                [
                    "prefill".to_string(),
                    prefill.to_string(),
                ].join(",")
            }),


            self.retention_days.as_ref().map(|retention_days| {
                [
                    "retention_days".to_string(),
                    retention_days.to_string(),
                ].join(",")
            }),


            self.seed_id.as_ref().map(|seed_id| {
                [
                    "seed_id".to_string(),
                    seed_id.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.url.as_ref().map(|url| {
                [
                    "url".to_string(),
                    url.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.visitor_source_id.as_ref().map(|visitor_source_id| {
                [
                    "visitor_source_id".to_string(),
                    visitor_source_id.to_string(),
                ].join(",")
            }),

            // Skipping event_source in query parameter serialization

            // Skipping ingestion_source in query parameter serialization


            self.engager_type.as_ref().map(|engager_type| {
                [
                    "engager_type".to_string(),
                    engager_type.to_string(),
                ].join(",")
            }),


            self.campaign_id.as_ref().map(|campaign_id| {
                [
                    "campaign_id".to_string(),
                    campaign_id.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.ad_id.as_ref().map(|ad_id| {
                [
                    "ad_id".to_string(),
                    ad_id.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping objective_type in query parameter serialization


            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AudienceRule value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AudienceRule {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub country: Vec<String>,
            pub customer_list_id: Vec<String>,
            pub engagement_domain: Vec<Vec<String>>,
            pub engagement_type: Vec<String>,
            pub event: Vec<String>,
            pub event_data: Vec<models::PinterestTagEventData>,
            pub percentage: Vec<i32>,
            pub pin_id: Vec<Vec<String>>,
            pub prefill: Vec<bool>,
            pub retention_days: Vec<i32>,
            pub seed_id: Vec<Vec<String>>,
            pub url: Vec<Vec<String>>,
            pub visitor_source_id: Vec<String>,
            pub event_source: Vec<crate::types::Object>,
            pub ingestion_source: Vec<crate::types::Object>,
            pub engager_type: Vec<i32>,
            pub campaign_id: Vec<Vec<String>>,
            pub ad_id: Vec<Vec<String>>,
            pub objective_type: Vec<Vec<models::ObjectiveType>>,
            pub ad_account_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AudienceRule".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "country" => intermediate_rep.country.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "customer_list_id" => intermediate_rep.customer_list_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "engagement_domain" => return std::result::Result::Err("Parsing a container in this style is not supported in AudienceRule".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "engagement_type" => intermediate_rep.engagement_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "event_data" => intermediate_rep.event_data.push(<models::PinterestTagEventData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "percentage" => intermediate_rep.percentage.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pin_id" => return std::result::Result::Err("Parsing a container in this style is not supported in AudienceRule".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "prefill" => intermediate_rep.prefill.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "retention_days" => intermediate_rep.retention_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "seed_id" => return std::result::Result::Err("Parsing a container in this style is not supported in AudienceRule".to_string()),
                    "url" => return std::result::Result::Err("Parsing a container in this style is not supported in AudienceRule".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "visitor_source_id" => intermediate_rep.visitor_source_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "event_source" => intermediate_rep.event_source.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ingestion_source" => intermediate_rep.ingestion_source.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "engager_type" => intermediate_rep.engager_type.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "campaign_id" => return std::result::Result::Err("Parsing a container in this style is not supported in AudienceRule".to_string()),
                    "ad_id" => return std::result::Result::Err("Parsing a container in this style is not supported in AudienceRule".to_string()),
                    "objective_type" => return std::result::Result::Err("Parsing a container in this style is not supported in AudienceRule".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AudienceRule".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AudienceRule {
            country: intermediate_rep.country.into_iter().next(),
            customer_list_id: intermediate_rep.customer_list_id.into_iter().next(),
            engagement_domain: intermediate_rep.engagement_domain.into_iter().next(),
            engagement_type: intermediate_rep.engagement_type.into_iter().next(),
            event: intermediate_rep.event.into_iter().next(),
            event_data: intermediate_rep.event_data.into_iter().next(),
            percentage: intermediate_rep.percentage.into_iter().next(),
            pin_id: intermediate_rep.pin_id.into_iter().next(),
            prefill: intermediate_rep.prefill.into_iter().next(),
            retention_days: intermediate_rep.retention_days.into_iter().next(),
            seed_id: intermediate_rep.seed_id.into_iter().next(),
            url: intermediate_rep.url.into_iter().next(),
            visitor_source_id: intermediate_rep.visitor_source_id.into_iter().next(),
            event_source: intermediate_rep.event_source.into_iter().next(),
            ingestion_source: intermediate_rep.ingestion_source.into_iter().next(),
            engager_type: intermediate_rep.engager_type.into_iter().next(),
            campaign_id: intermediate_rep.campaign_id.into_iter().next(),
            ad_id: intermediate_rep.ad_id.into_iter().next(),
            objective_type: intermediate_rep.objective_type.into_iter().next(),
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AudienceRule> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AudienceRule>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AudienceRule>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AudienceRule - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AudienceRule> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AudienceRule as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AudienceRule - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Audience sharing type: [\"CUSTOM\", \"SYNDICATED\"]
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AudienceSharingType {
    #[serde(rename = "CUSTOM")]
    Custom,
    #[serde(rename = "SYNDICATED")]
    Syndicated,
}

impl std::fmt::Display for AudienceSharingType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AudienceSharingType::Custom => write!(f, "CUSTOM"),
            AudienceSharingType::Syndicated => write!(f, "SYNDICATED"),
        }
    }
}

impl std::str::FromStr for AudienceSharingType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CUSTOM" => std::result::Result::Ok(AudienceSharingType::Custom),
            "SYNDICATED" => std::result::Result::Ok(AudienceSharingType::Syndicated),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceSubcategory {
/// Interest unique key (same as ID).
    #[serde(rename = "key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

/// Subinterest name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Subinterest's percent of category's total audience.
    #[serde(rename = "ratio")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ratio: Option<f64>,

/// Subinterest affinity index.
    #[serde(rename = "index")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index: Option<f64>,

/// Subinterest ID.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}


impl AudienceSubcategory {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AudienceSubcategory {
        AudienceSubcategory {
            key: None,
            name: None,
            ratio: None,
            index: None,
            id: None,
        }
    }
}

/// Converts the AudienceSubcategory value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AudienceSubcategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.key.as_ref().map(|key| {
                [
                    "key".to_string(),
                    key.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.ratio.as_ref().map(|ratio| {
                [
                    "ratio".to_string(),
                    ratio.to_string(),
                ].join(",")
            }),


            self.index.as_ref().map(|index| {
                [
                    "index".to_string(),
                    index.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AudienceSubcategory value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AudienceSubcategory {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub key: Vec<String>,
            pub name: Vec<String>,
            pub ratio: Vec<f64>,
            pub index: Vec<f64>,
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AudienceSubcategory".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ratio" => intermediate_rep.ratio.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AudienceSubcategory".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AudienceSubcategory {
            key: intermediate_rep.key.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            ratio: intermediate_rep.ratio.into_iter().next(),
            index: intermediate_rep.index.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AudienceSubcategory> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AudienceSubcategory>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AudienceSubcategory>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AudienceSubcategory - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AudienceSubcategory> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AudienceSubcategory as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AudienceSubcategory - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Audience type
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AudienceType {
    #[serde(rename = "CUSTOMER_LIST")]
    CustomerList,
    #[serde(rename = "VISITOR")]
    Visitor,
    #[serde(rename = "ENGAGEMENT")]
    Engagement,
    #[serde(rename = "ACTALIKE")]
    Actalike,
    #[serde(rename = "PERSONA")]
    Persona,
}

impl std::fmt::Display for AudienceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AudienceType::CustomerList => write!(f, "CUSTOMER_LIST"),
            AudienceType::Visitor => write!(f, "VISITOR"),
            AudienceType::Engagement => write!(f, "ENGAGEMENT"),
            AudienceType::Actalike => write!(f, "ACTALIKE"),
            AudienceType::Persona => write!(f, "PERSONA"),
        }
    }
}

impl std::str::FromStr for AudienceType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CUSTOMER_LIST" => std::result::Result::Ok(AudienceType::CustomerList),
            "VISITOR" => std::result::Result::Ok(AudienceType::Visitor),
            "ENGAGEMENT" => std::result::Result::Ok(AudienceType::Engagement),
            "ACTALIKE" => std::result::Result::Ok(AudienceType::Actalike),
            "PERSONA" => std::result::Result::Ok(AudienceType::Persona),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Audience operation type (update or remove).
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AudienceUpdateOperationType {
    #[serde(rename = "UPDATE")]
    Update,
    #[serde(rename = "REMOVE")]
    Remove,
}

impl std::fmt::Display for AudienceUpdateOperationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AudienceUpdateOperationType::Update => write!(f, "UPDATE"),
            AudienceUpdateOperationType::Remove => write!(f, "REMOVE"),
        }
    }
}

impl std::str::FromStr for AudienceUpdateOperationType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "UPDATE" => std::result::Result::Ok(AudienceUpdateOperationType::Update),
            "REMOVE" => std::result::Result::Ok(AudienceUpdateOperationType::Remove),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudienceUpdateRequest {
/// Ad account ID.
    #[serde(rename = "ad_account_id")]
    #[validate(
           regex = "RE_AUDIENCEUPDATEREQUEST_AD_ACCOUNT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// Audience name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "rule")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule: Option<models::AudienceRule>,

/// Audience description.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "operation_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub operation_type: Option<models::AudienceUpdateOperationType>,

}

lazy_static::lazy_static! {
    static ref RE_AUDIENCEUPDATEREQUEST_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl AudienceUpdateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AudienceUpdateRequest {
        AudienceUpdateRequest {
            ad_account_id: None,
            name: None,
            rule: None,
            description: None,
            operation_type: None,
        }
    }
}

/// Converts the AudienceUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AudienceUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping rule in query parameter serialization


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping operation_type in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AudienceUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AudienceUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_account_id: Vec<String>,
            pub name: Vec<String>,
            pub rule: Vec<models::AudienceRule>,
            pub description: Vec<String>,
            pub operation_type: Vec<models::AudienceUpdateOperationType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AudienceUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rule" => intermediate_rep.rule.push(<models::AudienceRule as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operation_type" => intermediate_rep.operation_type.push(<models::AudienceUpdateOperationType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AudienceUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AudienceUpdateRequest {
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            rule: intermediate_rep.rule.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            operation_type: intermediate_rep.operation_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AudienceUpdateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AudienceUpdateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AudienceUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AudienceUpdateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AudienceUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AudienceUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AudienceUpdateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AudiencesList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::Audience>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl AudiencesList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::Audience>, ) -> AudiencesList200Response {
        AudiencesList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the AudiencesList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AudiencesList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AudiencesList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AudiencesList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::Audience>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AudiencesList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in AudiencesList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AudiencesList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AudiencesList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AudiencesList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in AudiencesList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in AudiencesList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AudiencesList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AudiencesList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AudiencesList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AudiencesList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AudiencesList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AudiencesList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AudiencesList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AvailabilityFilter {
    #[serde(rename = "AVAILABILITY")]
    pub availability: models::CatalogsProductGroupMultipleStringCriteria,

}


impl AvailabilityFilter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(availability: models::CatalogsProductGroupMultipleStringCriteria, ) -> AvailabilityFilter {
        AvailabilityFilter {
            availability,
        }
    }
}

/// Converts the AvailabilityFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AvailabilityFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping AVAILABILITY in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AvailabilityFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AvailabilityFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub availability: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AvailabilityFilter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "AVAILABILITY" => intermediate_rep.availability.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AvailabilityFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AvailabilityFilter {
            availability: intermediate_rep.availability.into_iter().next().ok_or_else(|| "AVAILABILITY missing in AvailabilityFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AvailabilityFilter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AvailabilityFilter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AvailabilityFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AvailabilityFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AvailabilityFilter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AvailabilityFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AvailabilityFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The operation performed by the batch. The DELETE_DISCONTINUED operation only updates availablity to \"Out of Stock\".
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum BatchOperation {
    #[serde(rename = "UPDATE")]
    Update,
    #[serde(rename = "UPSERT")]
    Upsert,
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "DELETE_DISCONTINUED")]
    DeleteDiscontinued,
    #[serde(rename = "DELETE")]
    Delete,
}

impl std::fmt::Display for BatchOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            BatchOperation::Update => write!(f, "UPDATE"),
            BatchOperation::Upsert => write!(f, "UPSERT"),
            BatchOperation::Create => write!(f, "CREATE"),
            BatchOperation::DeleteDiscontinued => write!(f, "DELETE_DISCONTINUED"),
            BatchOperation::Delete => write!(f, "DELETE"),
        }
    }
}

impl std::str::FromStr for BatchOperation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "UPDATE" => std::result::Result::Ok(BatchOperation::Update),
            "UPSERT" => std::result::Result::Ok(BatchOperation::Upsert),
            "CREATE" => std::result::Result::Ok(BatchOperation::Create),
            "DELETE_DISCONTINUED" => std::result::Result::Ok(BatchOperation::DeleteDiscontinued),
            "DELETE" => std::result::Result::Ok(BatchOperation::Delete),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// The status of the operation performed by the batch
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum BatchOperationStatus {
    #[serde(rename = "PROCESSING")]
    Processing,
    #[serde(rename = "COMPLETED")]
    Completed,
}

impl std::fmt::Display for BatchOperationStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            BatchOperationStatus::Processing => write!(f, "PROCESSING"),
            BatchOperationStatus::Completed => write!(f, "COMPLETED"),
        }
    }
}

impl std::str::FromStr for BatchOperationStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PROCESSING" => std::result::Result::Ok(BatchOperationStatus::Processing),
            "COMPLETED" => std::result::Result::Ok(BatchOperationStatus::Completed),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BidFloor {
/// A list of bid floors in micro currency. For example, [100000, 200000]
    #[serde(rename = "bid_floors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid_floors: Option<Vec<i32>>,

/// Always the string 'bidfloor'
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

}


impl BidFloor {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BidFloor {
        BidFloor {
            bid_floors: None,
            r#type: Some("bidfloor".to_string()),
        }
    }
}

/// Converts the BidFloor value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BidFloor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.bid_floors.as_ref().map(|bid_floors| {
                [
                    "bid_floors".to_string(),
                    bid_floors.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BidFloor value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BidFloor {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub bid_floors: Vec<Vec<i32>>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BidFloor".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "bid_floors" => return std::result::Result::Err("Parsing a container in this style is not supported in BidFloor".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BidFloor".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BidFloor {
            bid_floors: intermediate_rep.bid_floors.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BidFloor> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BidFloor>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BidFloor>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BidFloor - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BidFloor> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BidFloor as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BidFloor - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BidFloorRequest {
    #[serde(rename = "bid_floor_specs")]
    pub bid_floor_specs: Vec<models::BidFloorSpec>,

    #[serde(rename = "targeting_spec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub targeting_spec: Option<models::TargetingSpec>,

}


impl BidFloorRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(bid_floor_specs: Vec<models::BidFloorSpec>, ) -> BidFloorRequest {
        BidFloorRequest {
            bid_floor_specs,
            targeting_spec: None,
        }
    }
}

/// Converts the BidFloorRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BidFloorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping bid_floor_specs in query parameter serialization

            // Skipping targeting_spec in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BidFloorRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BidFloorRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub bid_floor_specs: Vec<Vec<models::BidFloorSpec>>,
            pub targeting_spec: Vec<models::TargetingSpec>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BidFloorRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "bid_floor_specs" => return std::result::Result::Err("Parsing a container in this style is not supported in BidFloorRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "targeting_spec" => intermediate_rep.targeting_spec.push(<models::TargetingSpec as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BidFloorRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BidFloorRequest {
            bid_floor_specs: intermediate_rep.bid_floor_specs.into_iter().next().ok_or_else(|| "bid_floor_specs missing in BidFloorRequest".to_string())?,
            targeting_spec: intermediate_rep.targeting_spec.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BidFloorRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BidFloorRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BidFloorRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BidFloorRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BidFloorRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BidFloorRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BidFloorRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BidFloorSpec {
    #[serde(rename = "countries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub countries: Option<Vec<models::Country>>,

    #[serde(rename = "currency")]
    pub currency: models::Currency,

    #[serde(rename = "objective_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub objective_type: Option<models::ObjectiveType>,

    #[serde(rename = "billable_event")]
    pub billable_event: models::ActionType,

    #[serde(rename = "optimization_goal_metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optimization_goal_metadata: Option<models::OptimizationGoalMetadata>,

    #[serde(rename = "creative_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creative_type: Option<models::CreativeType>,

}


impl BidFloorSpec {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(currency: models::Currency, billable_event: models::ActionType, ) -> BidFloorSpec {
        BidFloorSpec {
            countries: None,
            currency,
            objective_type: None,
            billable_event,
            optimization_goal_metadata: None,
            creative_type: None,
        }
    }
}

/// Converts the BidFloorSpec value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BidFloorSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping countries in query parameter serialization

            // Skipping currency in query parameter serialization

            // Skipping objective_type in query parameter serialization

            // Skipping billable_event in query parameter serialization

            // Skipping optimization_goal_metadata in query parameter serialization

            // Skipping creative_type in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BidFloorSpec value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BidFloorSpec {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub countries: Vec<Vec<models::Country>>,
            pub currency: Vec<models::Currency>,
            pub objective_type: Vec<models::ObjectiveType>,
            pub billable_event: Vec<models::ActionType>,
            pub optimization_goal_metadata: Vec<models::OptimizationGoalMetadata>,
            pub creative_type: Vec<models::CreativeType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BidFloorSpec".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "countries" => return std::result::Result::Err("Parsing a container in this style is not supported in BidFloorSpec".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "currency" => intermediate_rep.currency.push(<models::Currency as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "objective_type" => intermediate_rep.objective_type.push(<models::ObjectiveType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billable_event" => intermediate_rep.billable_event.push(<models::ActionType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "optimization_goal_metadata" => intermediate_rep.optimization_goal_metadata.push(<models::OptimizationGoalMetadata as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "creative_type" => intermediate_rep.creative_type.push(<models::CreativeType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BidFloorSpec".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BidFloorSpec {
            countries: intermediate_rep.countries.into_iter().next(),
            currency: intermediate_rep.currency.into_iter().next().ok_or_else(|| "currency missing in BidFloorSpec".to_string())?,
            objective_type: intermediate_rep.objective_type.into_iter().next(),
            billable_event: intermediate_rep.billable_event.into_iter().next().ok_or_else(|| "billable_event missing in BidFloorSpec".to_string())?,
            optimization_goal_metadata: intermediate_rep.optimization_goal_metadata.into_iter().next(),
            creative_type: intermediate_rep.creative_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BidFloorSpec> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BidFloorSpec>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BidFloorSpec>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BidFloorSpec - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BidFloorSpec> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BidFloorSpec as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BidFloorSpec - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BillingProfilesGet200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::BillingProfilesResponse>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl BillingProfilesGet200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::BillingProfilesResponse>, ) -> BillingProfilesGet200Response {
        BillingProfilesGet200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the BillingProfilesGet200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BillingProfilesGet200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BillingProfilesGet200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BillingProfilesGet200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::BillingProfilesResponse>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BillingProfilesGet200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in BillingProfilesGet200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in BillingProfilesGet200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing BillingProfilesGet200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BillingProfilesGet200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in BillingProfilesGet200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in BillingProfilesGet200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BillingProfilesGet200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BillingProfilesGet200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BillingProfilesGet200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BillingProfilesGet200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BillingProfilesGet200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BillingProfilesGet200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BillingProfilesGet200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BillingProfilesResponse {
/// Billing ID.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_BILLINGPROFILESRESPONSE_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Type of the card.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "card_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub card_type: Option<String>,

/// Status of the billing.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

/// Advertiser ID of the billing.
    #[serde(rename = "advertiser_id")]
    #[validate(
           regex = "RE_BILLINGPROFILESRESPONSE_ADVERTISER_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub advertiser_id: Option<String>,

/// Brand of the payment method.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "payment_method_brand")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub payment_method_brand: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_BILLINGPROFILESRESPONSE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_BILLINGPROFILESRESPONSE_ADVERTISER_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl BillingProfilesResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BillingProfilesResponse {
        BillingProfilesResponse {
            id: None,
            card_type: None,
            status: None,
            advertiser_id: None,
            payment_method_brand: None,
        }
    }
}

/// Converts the BillingProfilesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BillingProfilesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.card_type.as_ref().map(|card_type| {
                [
                    "card_type".to_string(),
                    card_type.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),


            self.advertiser_id.as_ref().map(|advertiser_id| {
                [
                    "advertiser_id".to_string(),
                    advertiser_id.to_string(),
                ].join(",")
            }),


            self.payment_method_brand.as_ref().map(|payment_method_brand| {
                [
                    "payment_method_brand".to_string(),
                    payment_method_brand.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BillingProfilesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BillingProfilesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub card_type: Vec<String>,
            pub status: Vec<String>,
            pub advertiser_id: Vec<String>,
            pub payment_method_brand: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BillingProfilesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "card_type" => intermediate_rep.card_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "advertiser_id" => intermediate_rep.advertiser_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "payment_method_brand" => intermediate_rep.payment_method_brand.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BillingProfilesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BillingProfilesResponse {
            id: intermediate_rep.id.into_iter().next(),
            card_type: intermediate_rep.card_type.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            advertiser_id: intermediate_rep.advertiser_id.into_iter().next(),
            payment_method_brand: intermediate_rep.payment_method_brand.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BillingProfilesResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BillingProfilesResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BillingProfilesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BillingProfilesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BillingProfilesResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BillingProfilesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BillingProfilesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Board



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Board {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Date and time of board creation.
    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

/// Date and time of last board pins modified.
    #[serde(rename = "board_pins_modified_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub board_pins_modified_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

/// Count of collaborators on the board.
    #[serde(rename = "collaborator_count")]
    #[validate(
            range(min = 0),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborator_count: Option<u32>,

/// Count of pins on the board.
    #[serde(rename = "pin_count")]
    #[validate(
            range(min = 0),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pin_count: Option<u32>,

/// Board follower count.
    #[serde(rename = "follower_count")]
    #[validate(
            range(min = 0),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub follower_count: Option<u32>,

    #[serde(rename = "media")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media: Option<models::BoardMedia>,

    #[serde(rename = "owner")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<models::BoardOwner>,

/// Privacy setting for a board. Learn more about <a href=\"https://help.pinterest.com/en/article/secret-boards\">secret boards</a> and <a href=\"https://help.pinterest.com/en/business/article/protected-boards\">protected boards</a>
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "privacy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,

}


impl Board {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, ) -> Board {
        Board {
            id: None,
            created_at: None,
            board_pins_modified_at: None,
            name,
            description: None,
            collaborator_count: None,
            pin_count: None,
            follower_count: None,
            media: None,
            owner: None,
            privacy: Some("PUBLIC".to_string()),
        }
    }
}

/// Converts the Board value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Board {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping created_at in query parameter serialization

            // Skipping board_pins_modified_at in query parameter serialization


            Some("name".to_string()),
            Some(self.name.to_string()),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.collaborator_count.as_ref().map(|collaborator_count| {
                [
                    "collaborator_count".to_string(),
                    collaborator_count.to_string(),
                ].join(",")
            }),


            self.pin_count.as_ref().map(|pin_count| {
                [
                    "pin_count".to_string(),
                    pin_count.to_string(),
                ].join(",")
            }),


            self.follower_count.as_ref().map(|follower_count| {
                [
                    "follower_count".to_string(),
                    follower_count.to_string(),
                ].join(",")
            }),

            // Skipping media in query parameter serialization

            // Skipping owner in query parameter serialization


            self.privacy.as_ref().map(|privacy| {
                [
                    "privacy".to_string(),
                    privacy.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Board value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Board {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub board_pins_modified_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub collaborator_count: Vec<u32>,
            pub pin_count: Vec<u32>,
            pub follower_count: Vec<u32>,
            pub media: Vec<models::BoardMedia>,
            pub owner: Vec<models::BoardOwner>,
            pub privacy: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Board".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "board_pins_modified_at" => intermediate_rep.board_pins_modified_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Board".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "collaborator_count" => intermediate_rep.collaborator_count.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pin_count" => intermediate_rep.pin_count.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "follower_count" => intermediate_rep.follower_count.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media" => intermediate_rep.media.push(<models::BoardMedia as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "owner" => intermediate_rep.owner.push(<models::BoardOwner as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "privacy" => intermediate_rep.privacy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Board".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Board {
            id: intermediate_rep.id.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            board_pins_modified_at: intermediate_rep.board_pins_modified_at.into_iter().next(),
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in Board".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in Board".to_string())?,
            collaborator_count: intermediate_rep.collaborator_count.into_iter().next(),
            pin_count: intermediate_rep.pin_count.into_iter().next(),
            follower_count: intermediate_rep.follower_count.into_iter().next(),
            media: intermediate_rep.media.into_iter().next(),
            owner: intermediate_rep.owner.into_iter().next(),
            privacy: intermediate_rep.privacy.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Board> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Board>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Board>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Board - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Board> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Board as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Board - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Board media.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BoardMedia {
/// Board cover image.
    #[serde(rename = "image_cover_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_cover_url: Option<Nullable<String>>,

/// Board pin thumbnail urls.
    #[serde(rename = "pin_thumbnail_urls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pin_thumbnail_urls: Option<Vec<String>>,

}


impl BoardMedia {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BoardMedia {
        BoardMedia {
            image_cover_url: None,
            pin_thumbnail_urls: None,
        }
    }
}

/// Converts the BoardMedia value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BoardMedia {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.image_cover_url.as_ref().map(|image_cover_url| {
                [
                    "image_cover_url".to_string(),
                    image_cover_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.pin_thumbnail_urls.as_ref().map(|pin_thumbnail_urls| {
                [
                    "pin_thumbnail_urls".to_string(),
                    pin_thumbnail_urls.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BoardMedia value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BoardMedia {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub image_cover_url: Vec<String>,
            pub pin_thumbnail_urls: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BoardMedia".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "image_cover_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in BoardMedia".to_string()),
                    "pin_thumbnail_urls" => return std::result::Result::Err("Parsing a container in this style is not supported in BoardMedia".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing BoardMedia".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BoardMedia {
            image_cover_url: std::result::Result::Err("Nullable types not supported in BoardMedia".to_string())?,
            pin_thumbnail_urls: intermediate_rep.pin_thumbnail_urls.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BoardMedia> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BoardMedia>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BoardMedia>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BoardMedia - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BoardMedia> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BoardMedia as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BoardMedia - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BoardOwner {
    #[serde(rename = "username")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,

}


impl BoardOwner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BoardOwner {
        BoardOwner {
            username: None,
        }
    }
}

/// Converts the BoardOwner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BoardOwner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.username.as_ref().map(|username| {
                [
                    "username".to_string(),
                    username.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BoardOwner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BoardOwner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BoardOwner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BoardOwner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BoardOwner {
            username: intermediate_rep.username.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BoardOwner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BoardOwner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BoardOwner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BoardOwner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BoardOwner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BoardOwner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BoardOwner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Sections help organize pins within a board.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BoardSection {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[validate(
            length(min = 1, max = 180),
        )]
    pub name: String,

}


impl BoardSection {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, ) -> BoardSection {
        BoardSection {
            id: None,
            name,
        }
    }
}

/// Converts the BoardSection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BoardSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            Some("name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BoardSection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BoardSection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BoardSection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BoardSection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BoardSection {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in BoardSection".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BoardSection> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BoardSection>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BoardSection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BoardSection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BoardSection> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BoardSection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BoardSection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BoardSectionsList200Response {
/// Board sections
    #[serde(rename = "items")]
    pub items: Vec<models::BoardSection>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl BoardSectionsList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::BoardSection>, ) -> BoardSectionsList200Response {
        BoardSectionsList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the BoardSectionsList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BoardSectionsList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BoardSectionsList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BoardSectionsList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::BoardSection>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BoardSectionsList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in BoardSectionsList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in BoardSectionsList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing BoardSectionsList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BoardSectionsList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in BoardSectionsList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in BoardSectionsList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BoardSectionsList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BoardSectionsList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BoardSectionsList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BoardSectionsList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BoardSectionsList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BoardSectionsList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BoardSectionsList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Board fields for updates



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BoardUpdate {
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "privacy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,

}


impl BoardUpdate {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BoardUpdate {
        BoardUpdate {
            name: None,
            description: None,
            privacy: None,
        }
    }
}

/// Converts the BoardUpdate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BoardUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.privacy.as_ref().map(|privacy| {
                [
                    "privacy".to_string(),
                    privacy.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BoardUpdate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BoardUpdate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub privacy: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BoardUpdate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in BoardUpdate".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "privacy" => intermediate_rep.privacy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BoardUpdate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BoardUpdate {
            name: intermediate_rep.name.into_iter().next(),
            description: std::result::Result::Err("Nullable types not supported in BoardUpdate".to_string())?,
            privacy: intermediate_rep.privacy.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BoardUpdate> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BoardUpdate>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BoardUpdate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BoardUpdate - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BoardUpdate> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BoardUpdate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BoardUpdate - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BoardsList200Response {
/// Boards
    #[serde(rename = "items")]
    pub items: Vec<models::Board>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl BoardsList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::Board>, ) -> BoardsList200Response {
        BoardsList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the BoardsList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BoardsList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BoardsList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BoardsList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::Board>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BoardsList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in BoardsList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in BoardsList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing BoardsList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BoardsList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in BoardsList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in BoardsList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BoardsList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BoardsList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BoardsList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BoardsList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BoardsList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BoardsList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BoardsList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BoardsListPins200Response {
/// Pins
    #[serde(rename = "items")]
    pub items: Vec<models::Pin>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl BoardsListPins200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::Pin>, ) -> BoardsListPins200Response {
        BoardsListPins200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the BoardsListPins200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BoardsListPins200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BoardsListPins200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BoardsListPins200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::Pin>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BoardsListPins200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in BoardsListPins200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in BoardsListPins200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing BoardsListPins200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BoardsListPins200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in BoardsListPins200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in BoardsListPins200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BoardsListPins200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BoardsListPins200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BoardsListPins200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BoardsListPins200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BoardsListPins200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BoardsListPins200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BoardsListPins200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BoardsUserFollowsList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::Board>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl BoardsUserFollowsList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::Board>, ) -> BoardsUserFollowsList200Response {
        BoardsUserFollowsList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the BoardsUserFollowsList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BoardsUserFollowsList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BoardsUserFollowsList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BoardsUserFollowsList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::Board>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BoardsUserFollowsList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in BoardsUserFollowsList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in BoardsUserFollowsList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing BoardsUserFollowsList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BoardsUserFollowsList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in BoardsUserFollowsList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in BoardsUserFollowsList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BoardsUserFollowsList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BoardsUserFollowsList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BoardsUserFollowsList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BoardsUserFollowsList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BoardsUserFollowsList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BoardsUserFollowsList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BoardsUserFollowsList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Creation fields



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BookClosedResponse {
/// Are conversion metrics ready?
    #[serde(rename = "conversion_metrics_ready")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conversion_metrics_ready: Option<bool>,

/// Are non-conversion metrics ready?
    #[serde(rename = "non_conversion_metrics_ready")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub non_conversion_metrics_ready: Option<bool>,

}


impl BookClosedResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BookClosedResponse {
        BookClosedResponse {
            conversion_metrics_ready: None,
            non_conversion_metrics_ready: None,
        }
    }
}

/// Converts the BookClosedResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BookClosedResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.conversion_metrics_ready.as_ref().map(|conversion_metrics_ready| {
                [
                    "conversion_metrics_ready".to_string(),
                    conversion_metrics_ready.to_string(),
                ].join(",")
            }),


            self.non_conversion_metrics_ready.as_ref().map(|non_conversion_metrics_ready| {
                [
                    "non_conversion_metrics_ready".to_string(),
                    non_conversion_metrics_ready.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BookClosedResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BookClosedResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub conversion_metrics_ready: Vec<bool>,
            pub non_conversion_metrics_ready: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BookClosedResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "conversion_metrics_ready" => intermediate_rep.conversion_metrics_ready.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "non_conversion_metrics_ready" => intermediate_rep.non_conversion_metrics_ready.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BookClosedResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BookClosedResponse {
            conversion_metrics_ready: intermediate_rep.conversion_metrics_ready.into_iter().next(),
            non_conversion_metrics_ready: intermediate_rep.non_conversion_metrics_ready.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BookClosedResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BookClosedResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BookClosedResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BookClosedResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BookClosedResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BookClosedResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BookClosedResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BrandFilter {
    #[serde(rename = "BRAND")]
    pub brand: models::CatalogsProductGroupMultipleStringCriteria,

}


impl BrandFilter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(brand: models::CatalogsProductGroupMultipleStringCriteria, ) -> BrandFilter {
        BrandFilter {
            brand,
        }
    }
}

/// Converts the BrandFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BrandFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping BRAND in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BrandFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BrandFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub brand: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BrandFilter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "BRAND" => intermediate_rep.brand.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BrandFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BrandFilter {
            brand: intermediate_rep.brand.into_iter().next().ok_or_else(|| "BRAND missing in BrandFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BrandFilter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BrandFilter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BrandFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BrandFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BrandFilter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BrandFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BrandFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Budget type. If DAILY, an ad group's daily spend will not exceed the budget parameter value. If LIFETIME, the end_time parameter is **REQUIRED**, and the ad group spend is spread evenly between the ad group `start_time` and `end_time` range. A CBO campaign automatically generates ad group budgets from its campaign budget to maximize campaign outcome. For CBO campaigns, only \"CBO_ADGROUP\" is allowed. For WEB_SESSIONS campaigns, only \"LIFETIME\" is allowed. For update, only draft ad groups may update budget type.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum BudgetType {
    #[serde(rename = "DAILY")]
    Daily,
    #[serde(rename = "LIFETIME")]
    Lifetime,
    #[serde(rename = "CBO_ADGROUP")]
    CboAdgroup,
}

impl std::fmt::Display for BudgetType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            BudgetType::Daily => write!(f, "DAILY"),
            BudgetType::Lifetime => write!(f, "LIFETIME"),
            BudgetType::CboAdgroup => write!(f, "CBO_ADGROUP"),
        }
    }
}

impl std::str::FromStr for BudgetType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DAILY" => std::result::Result::Ok(BudgetType::Daily),
            "LIFETIME" => std::result::Result::Ok(BudgetType::Lifetime),
            "CBO_ADGROUP" => std::result::Result::Ok(BudgetType::CboAdgroup),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Ad entities to get in bulk request.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BulkDownloadRequest {
/// All entity types specified will be downloaded. Fewer types result in faster downloads.
    #[serde(rename = "entity_types")]
    #[validate(
            length(min = 1, max = 5),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub entity_types: Option<Vec<models::BulkEntityType>>,

/// All entities specified by these IDs as well as their children and grandchildren will be downloaded if the entity type is one of the types requested to be downloaded.
    #[serde(rename = "entity_ids")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub entity_ids: Option<Vec<String>>,

/// Unix UTC timestamp to retrieve all entities that have changed since this time.
    #[serde(rename = "updated_since")]
    #[validate(
           regex = "RE_BULKDOWNLOADREQUEST_UPDATED_SINCE",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_since: Option<String>,

    #[serde(rename = "campaign_filter")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_filter: Option<models::BulkDownloadRequestCampaignFilter>,

    #[serde(rename = "output_format")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output_format: Option<models::BulkOutputFormat>,

}

lazy_static::lazy_static! {
    static ref RE_BULKDOWNLOADREQUEST_UPDATED_SINCE: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl BulkDownloadRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BulkDownloadRequest {
        BulkDownloadRequest {
            entity_types: None,
            entity_ids: None,
            updated_since: None,
            campaign_filter: None,
            output_format: Some("JSON".to_string()),
        }
    }
}

/// Converts the BulkDownloadRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BulkDownloadRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping entity_types in query parameter serialization


            self.entity_ids.as_ref().map(|entity_ids| {
                [
                    "entity_ids".to_string(),
                    entity_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.updated_since.as_ref().map(|updated_since| {
                [
                    "updated_since".to_string(),
                    updated_since.to_string(),
                ].join(",")
            }),

            // Skipping campaign_filter in query parameter serialization

            // Skipping output_format in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BulkDownloadRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BulkDownloadRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub entity_types: Vec<Vec<models::BulkEntityType>>,
            pub entity_ids: Vec<Vec<String>>,
            pub updated_since: Vec<String>,
            pub campaign_filter: Vec<models::BulkDownloadRequestCampaignFilter>,
            pub output_format: Vec<models::BulkOutputFormat>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BulkDownloadRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "entity_types" => return std::result::Result::Err("Parsing a container in this style is not supported in BulkDownloadRequest".to_string()),
                    "entity_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in BulkDownloadRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "updated_since" => intermediate_rep.updated_since.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "campaign_filter" => intermediate_rep.campaign_filter.push(<models::BulkDownloadRequestCampaignFilter as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_format" => intermediate_rep.output_format.push(<models::BulkOutputFormat as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BulkDownloadRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BulkDownloadRequest {
            entity_types: intermediate_rep.entity_types.into_iter().next(),
            entity_ids: intermediate_rep.entity_ids.into_iter().next(),
            updated_since: intermediate_rep.updated_since.into_iter().next(),
            campaign_filter: intermediate_rep.campaign_filter.into_iter().next(),
            output_format: intermediate_rep.output_format.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BulkDownloadRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BulkDownloadRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BulkDownloadRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BulkDownloadRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BulkDownloadRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BulkDownloadRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BulkDownloadRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BulkDownloadRequestCampaignFilter {
/// Unix UTC timestamp.
    #[serde(rename = "start_time")]
    #[validate(
           regex = "RE_BULKDOWNLOADREQUESTCAMPAIGNFILTER_START_TIME",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<String>,

/// Unix UTC timestamp.
    #[serde(rename = "end_time")]
    #[validate(
           regex = "RE_BULKDOWNLOADREQUESTCAMPAIGNFILTER_END_TIME",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<String>,

/// Campaign name
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "campaign_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_status: Option<Vec<models::CampaignSummaryStatus>>,

    #[serde(rename = "objective_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub objective_type: Option<Vec<models::ObjectiveType>>,

}

lazy_static::lazy_static! {
    static ref RE_BULKDOWNLOADREQUESTCAMPAIGNFILTER_START_TIME: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_BULKDOWNLOADREQUESTCAMPAIGNFILTER_END_TIME: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl BulkDownloadRequestCampaignFilter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BulkDownloadRequestCampaignFilter {
        BulkDownloadRequestCampaignFilter {
            start_time: None,
            end_time: None,
            name: None,
            campaign_status: None,
            objective_type: None,
        }
    }
}

/// Converts the BulkDownloadRequestCampaignFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BulkDownloadRequestCampaignFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.start_time.as_ref().map(|start_time| {
                [
                    "start_time".to_string(),
                    start_time.to_string(),
                ].join(",")
            }),


            self.end_time.as_ref().map(|end_time| {
                [
                    "end_time".to_string(),
                    end_time.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping campaign_status in query parameter serialization

            // Skipping objective_type in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BulkDownloadRequestCampaignFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BulkDownloadRequestCampaignFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub start_time: Vec<String>,
            pub end_time: Vec<String>,
            pub name: Vec<String>,
            pub campaign_status: Vec<Vec<models::CampaignSummaryStatus>>,
            pub objective_type: Vec<Vec<models::ObjectiveType>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BulkDownloadRequestCampaignFilter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "start_time" => intermediate_rep.start_time.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end_time" => intermediate_rep.end_time.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "campaign_status" => return std::result::Result::Err("Parsing a container in this style is not supported in BulkDownloadRequestCampaignFilter".to_string()),
                    "objective_type" => return std::result::Result::Err("Parsing a container in this style is not supported in BulkDownloadRequestCampaignFilter".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing BulkDownloadRequestCampaignFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BulkDownloadRequestCampaignFilter {
            start_time: intermediate_rep.start_time.into_iter().next(),
            end_time: intermediate_rep.end_time.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            campaign_status: intermediate_rep.campaign_status.into_iter().next(),
            objective_type: intermediate_rep.objective_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BulkDownloadRequestCampaignFilter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BulkDownloadRequestCampaignFilter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BulkDownloadRequestCampaignFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BulkDownloadRequestCampaignFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BulkDownloadRequestCampaignFilter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BulkDownloadRequestCampaignFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BulkDownloadRequestCampaignFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BulkDownloadResponse {
/// ID of the bulk request.
    #[serde(rename = "request_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub request_id: Option<String>,

}


impl BulkDownloadResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BulkDownloadResponse {
        BulkDownloadResponse {
            request_id: None,
        }
    }
}

/// Converts the BulkDownloadResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BulkDownloadResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.request_id.as_ref().map(|request_id| {
                [
                    "request_id".to_string(),
                    request_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BulkDownloadResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BulkDownloadResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub request_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BulkDownloadResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "request_id" => intermediate_rep.request_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BulkDownloadResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BulkDownloadResponse {
            request_id: intermediate_rep.request_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BulkDownloadResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BulkDownloadResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BulkDownloadResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BulkDownloadResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BulkDownloadResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BulkDownloadResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BulkDownloadResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Refers ads entity type
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum BulkEntityType {
    #[serde(rename = "CAMPAIGN")]
    Campaign,
    #[serde(rename = "AD_GROUP")]
    AdGroup,
    #[serde(rename = "PRODUCT_GROUP")]
    ProductGroup,
    #[serde(rename = "AD")]
    Ad,
    #[serde(rename = "KEYWORD")]
    Keyword,
}

impl std::fmt::Display for BulkEntityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            BulkEntityType::Campaign => write!(f, "CAMPAIGN"),
            BulkEntityType::AdGroup => write!(f, "AD_GROUP"),
            BulkEntityType::ProductGroup => write!(f, "PRODUCT_GROUP"),
            BulkEntityType::Ad => write!(f, "AD"),
            BulkEntityType::Keyword => write!(f, "KEYWORD"),
        }
    }
}

impl std::str::FromStr for BulkEntityType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CAMPAIGN" => std::result::Result::Ok(BulkEntityType::Campaign),
            "AD_GROUP" => std::result::Result::Ok(BulkEntityType::AdGroup),
            "PRODUCT_GROUP" => std::result::Result::Ok(BulkEntityType::ProductGroup),
            "AD" => std::result::Result::Ok(BulkEntityType::Ad),
            "KEYWORD" => std::result::Result::Ok(BulkEntityType::Keyword),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Bulk file output format
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum BulkOutputFormat {
    #[serde(rename = "CSV")]
    Csv,
    #[serde(rename = "JSON")]
    Json,
}

impl std::fmt::Display for BulkOutputFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            BulkOutputFormat::Csv => write!(f, "CSV"),
            BulkOutputFormat::Json => write!(f, "JSON"),
        }
    }
}

impl std::str::FromStr for BulkOutputFormat {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CSV" => std::result::Result::Ok(BulkOutputFormat::Csv),
            "JSON" => std::result::Result::Ok(BulkOutputFormat::Json),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Possible status for a bulk reporting job
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum BulkReportingJobStatus {
    #[serde(rename = "DOES_NOT_EXIST")]
    DoesNotExist,
    #[serde(rename = "FINISHED")]
    Finished,
    #[serde(rename = "IN_PROGRESS")]
    InProgress,
    #[serde(rename = "EXPIRED")]
    Expired,
    #[serde(rename = "FAILED")]
    Failed,
    #[serde(rename = "CANCELLED")]
    Cancelled,
}

impl std::fmt::Display for BulkReportingJobStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            BulkReportingJobStatus::DoesNotExist => write!(f, "DOES_NOT_EXIST"),
            BulkReportingJobStatus::Finished => write!(f, "FINISHED"),
            BulkReportingJobStatus::InProgress => write!(f, "IN_PROGRESS"),
            BulkReportingJobStatus::Expired => write!(f, "EXPIRED"),
            BulkReportingJobStatus::Failed => write!(f, "FAILED"),
            BulkReportingJobStatus::Cancelled => write!(f, "CANCELLED"),
        }
    }
}

impl std::str::FromStr for BulkReportingJobStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DOES_NOT_EXIST" => std::result::Result::Ok(BulkReportingJobStatus::DoesNotExist),
            "FINISHED" => std::result::Result::Ok(BulkReportingJobStatus::Finished),
            "IN_PROGRESS" => std::result::Result::Ok(BulkReportingJobStatus::InProgress),
            "EXPIRED" => std::result::Result::Ok(BulkReportingJobStatus::Expired),
            "FAILED" => std::result::Result::Ok(BulkReportingJobStatus::Failed),
            "CANCELLED" => std::result::Result::Ok(BulkReportingJobStatus::Cancelled),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Two set of objects to be managed asyncronusly by bulk. One for creations, one for modifications.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BulkUpsertRequest {
    #[serde(rename = "create")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub create: Option<models::BulkUpsertRequestCreate>,

    #[serde(rename = "update")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub update: Option<models::BulkUpsertRequestUpdate>,

}


impl BulkUpsertRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BulkUpsertRequest {
        BulkUpsertRequest {
            create: None,
            update: None,
        }
    }
}

/// Converts the BulkUpsertRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BulkUpsertRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping create in query parameter serialization

            // Skipping update in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BulkUpsertRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BulkUpsertRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub create: Vec<models::BulkUpsertRequestCreate>,
            pub update: Vec<models::BulkUpsertRequestUpdate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BulkUpsertRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "create" => intermediate_rep.create.push(<models::BulkUpsertRequestCreate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "update" => intermediate_rep.update.push(<models::BulkUpsertRequestUpdate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BulkUpsertRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BulkUpsertRequest {
            create: intermediate_rep.create.into_iter().next(),
            update: intermediate_rep.update.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BulkUpsertRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BulkUpsertRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BulkUpsertRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BulkUpsertRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BulkUpsertRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BulkUpsertRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BulkUpsertRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Request for creation of entities in bulk.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BulkUpsertRequestCreate {
    #[serde(rename = "campaigns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaigns: Option<Vec<models::CampaignCreateRequest>>,

    #[serde(rename = "ad_groups")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_groups: Option<Vec<models::AdGroupCreateRequest>>,

    #[serde(rename = "ads")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ads: Option<Vec<models::AdCreateRequest>>,

    #[serde(rename = "product_groups")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_groups: Option<Vec<models::ProductGroupPromotionCreateRequest>>,

    #[serde(rename = "keywords")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub keywords: Option<Vec<models::KeywordsRequest>>,

}


impl BulkUpsertRequestCreate {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BulkUpsertRequestCreate {
        BulkUpsertRequestCreate {
            campaigns: None,
            ad_groups: None,
            ads: None,
            product_groups: None,
            keywords: None,
        }
    }
}

/// Converts the BulkUpsertRequestCreate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BulkUpsertRequestCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping campaigns in query parameter serialization

            // Skipping ad_groups in query parameter serialization

            // Skipping ads in query parameter serialization

            // Skipping product_groups in query parameter serialization

            // Skipping keywords in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BulkUpsertRequestCreate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BulkUpsertRequestCreate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub campaigns: Vec<Vec<models::CampaignCreateRequest>>,
            pub ad_groups: Vec<Vec<models::AdGroupCreateRequest>>,
            pub ads: Vec<Vec<models::AdCreateRequest>>,
            pub product_groups: Vec<Vec<models::ProductGroupPromotionCreateRequest>>,
            pub keywords: Vec<Vec<models::KeywordsRequest>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BulkUpsertRequestCreate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "campaigns" => return std::result::Result::Err("Parsing a container in this style is not supported in BulkUpsertRequestCreate".to_string()),
                    "ad_groups" => return std::result::Result::Err("Parsing a container in this style is not supported in BulkUpsertRequestCreate".to_string()),
                    "ads" => return std::result::Result::Err("Parsing a container in this style is not supported in BulkUpsertRequestCreate".to_string()),
                    "product_groups" => return std::result::Result::Err("Parsing a container in this style is not supported in BulkUpsertRequestCreate".to_string()),
                    "keywords" => return std::result::Result::Err("Parsing a container in this style is not supported in BulkUpsertRequestCreate".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing BulkUpsertRequestCreate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BulkUpsertRequestCreate {
            campaigns: intermediate_rep.campaigns.into_iter().next(),
            ad_groups: intermediate_rep.ad_groups.into_iter().next(),
            ads: intermediate_rep.ads.into_iter().next(),
            product_groups: intermediate_rep.product_groups.into_iter().next(),
            keywords: intermediate_rep.keywords.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BulkUpsertRequestCreate> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BulkUpsertRequestCreate>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BulkUpsertRequestCreate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BulkUpsertRequestCreate - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BulkUpsertRequestCreate> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BulkUpsertRequestCreate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BulkUpsertRequestCreate - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Request for creation of entities in bulk.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BulkUpsertRequestUpdate {
    #[serde(rename = "campaigns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaigns: Option<Vec<models::CampaignUpdateRequest>>,

    #[serde(rename = "ad_groups")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_groups: Option<Vec<models::AdGroupUpdateRequest>>,

    #[serde(rename = "ads")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ads: Option<Vec<models::AdUpdateRequest>>,

    #[serde(rename = "product_groups")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_groups: Option<Vec<models::ProductGroupPromotionUpdateRequest>>,

    #[serde(rename = "keywords")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub keywords: Option<Vec<models::KeywordUpdate>>,

}


impl BulkUpsertRequestUpdate {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BulkUpsertRequestUpdate {
        BulkUpsertRequestUpdate {
            campaigns: None,
            ad_groups: None,
            ads: None,
            product_groups: None,
            keywords: None,
        }
    }
}

/// Converts the BulkUpsertRequestUpdate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BulkUpsertRequestUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping campaigns in query parameter serialization

            // Skipping ad_groups in query parameter serialization

            // Skipping ads in query parameter serialization

            // Skipping product_groups in query parameter serialization

            // Skipping keywords in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BulkUpsertRequestUpdate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BulkUpsertRequestUpdate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub campaigns: Vec<Vec<models::CampaignUpdateRequest>>,
            pub ad_groups: Vec<Vec<models::AdGroupUpdateRequest>>,
            pub ads: Vec<Vec<models::AdUpdateRequest>>,
            pub product_groups: Vec<Vec<models::ProductGroupPromotionUpdateRequest>>,
            pub keywords: Vec<Vec<models::KeywordUpdate>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BulkUpsertRequestUpdate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "campaigns" => return std::result::Result::Err("Parsing a container in this style is not supported in BulkUpsertRequestUpdate".to_string()),
                    "ad_groups" => return std::result::Result::Err("Parsing a container in this style is not supported in BulkUpsertRequestUpdate".to_string()),
                    "ads" => return std::result::Result::Err("Parsing a container in this style is not supported in BulkUpsertRequestUpdate".to_string()),
                    "product_groups" => return std::result::Result::Err("Parsing a container in this style is not supported in BulkUpsertRequestUpdate".to_string()),
                    "keywords" => return std::result::Result::Err("Parsing a container in this style is not supported in BulkUpsertRequestUpdate".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing BulkUpsertRequestUpdate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BulkUpsertRequestUpdate {
            campaigns: intermediate_rep.campaigns.into_iter().next(),
            ad_groups: intermediate_rep.ad_groups.into_iter().next(),
            ads: intermediate_rep.ads.into_iter().next(),
            product_groups: intermediate_rep.product_groups.into_iter().next(),
            keywords: intermediate_rep.keywords.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BulkUpsertRequestUpdate> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BulkUpsertRequestUpdate>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BulkUpsertRequestUpdate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BulkUpsertRequestUpdate - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BulkUpsertRequestUpdate> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BulkUpsertRequestUpdate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BulkUpsertRequestUpdate - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ID of the bulk request.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BulkUpsertResponse {
    #[serde(rename = "request_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub request_id: Option<String>,

}


impl BulkUpsertResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BulkUpsertResponse {
        BulkUpsertResponse {
            request_id: None,
        }
    }
}

/// Converts the BulkUpsertResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BulkUpsertResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.request_id.as_ref().map(|request_id| {
                [
                    "request_id".to_string(),
                    request_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BulkUpsertResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BulkUpsertResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub request_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BulkUpsertResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "request_id" => intermediate_rep.request_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BulkUpsertResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BulkUpsertResponse {
            request_id: intermediate_rep.request_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BulkUpsertResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BulkUpsertResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BulkUpsertResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BulkUpsertResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BulkUpsertResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BulkUpsertResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BulkUpsertResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum BulkUpsertStatus {
    #[serde(rename = "RUNNING")]
    Running,
    #[serde(rename = "SUCCEEDED")]
    Succeeded,
    #[serde(rename = "FAILED")]
    Failed,
}

impl std::fmt::Display for BulkUpsertStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            BulkUpsertStatus::Running => write!(f, "RUNNING"),
            BulkUpsertStatus::Succeeded => write!(f, "SUCCEEDED"),
            BulkUpsertStatus::Failed => write!(f, "FAILED"),
        }
    }
}

impl std::str::FromStr for BulkUpsertStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "RUNNING" => std::result::Result::Ok(BulkUpsertStatus::Running),
            "SUCCEEDED" => std::result::Result::Ok(BulkUpsertStatus::Succeeded),
            "FAILED" => std::result::Result::Ok(BulkUpsertStatus::Failed),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// ID of the bulk request.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BulkUpsertStatusResponse {
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::BulkUpsertStatus>,

    #[serde(rename = "result_url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result_url: Option<String>,

}


impl BulkUpsertStatusResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BulkUpsertStatusResponse {
        BulkUpsertStatusResponse {
            status: None,
            result_url: None,
        }
    }
}

/// Converts the BulkUpsertStatusResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BulkUpsertStatusResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping status in query parameter serialization


            self.result_url.as_ref().map(|result_url| {
                [
                    "result_url".to_string(),
                    result_url.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BulkUpsertStatusResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BulkUpsertStatusResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<models::BulkUpsertStatus>,
            pub result_url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BulkUpsertStatusResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::BulkUpsertStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result_url" => intermediate_rep.result_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BulkUpsertStatusResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BulkUpsertStatusResponse {
            status: intermediate_rep.status.into_iter().next(),
            result_url: intermediate_rep.result_url.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BulkUpsertStatusResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BulkUpsertStatusResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BulkUpsertStatusResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BulkUpsertStatusResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BulkUpsertStatusResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BulkUpsertStatusResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BulkUpsertStatusResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Permission role for business access.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum BusinessAccessRole {
    #[serde(rename = "OWNER")]
    Owner,
    #[serde(rename = "ADMIN")]
    Admin,
    #[serde(rename = "ANALYST")]
    Analyst,
    #[serde(rename = "SOS_READER")]
    SosReader,
    #[serde(rename = "FINANCE_MANAGER")]
    FinanceManager,
    #[serde(rename = "AUDIENCE_MANAGER")]
    AudienceManager,
    #[serde(rename = "CAMPAIGN_MANAGER")]
    CampaignManager,
    #[serde(rename = "CATALOGS_MANAGER")]
    CatalogsManager,
    #[serde(rename = "RESTRICTED_OWNER")]
    RestrictedOwner,
    #[serde(rename = "PROFILE_MANAGER")]
    ProfileManager,
    #[serde(rename = "PROFILE_PUBLISHER")]
    ProfilePublisher,
    #[serde(rename = "RESOURCE_PINNER_LIST_OWNER")]
    ResourcePinnerListOwner,
    #[serde(rename = "RESOURCE_PINNER_LIST_READER")]
    ResourcePinnerListReader,
    #[serde(rename = "BIZ_PINNER_LIST_SHARER")]
    BizPinnerListSharer,
    #[serde(rename = "RESOURCE_CONVERSION_TAGS_READER")]
    ResourceConversionTagsReader,
}

impl std::fmt::Display for BusinessAccessRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            BusinessAccessRole::Owner => write!(f, "OWNER"),
            BusinessAccessRole::Admin => write!(f, "ADMIN"),
            BusinessAccessRole::Analyst => write!(f, "ANALYST"),
            BusinessAccessRole::SosReader => write!(f, "SOS_READER"),
            BusinessAccessRole::FinanceManager => write!(f, "FINANCE_MANAGER"),
            BusinessAccessRole::AudienceManager => write!(f, "AUDIENCE_MANAGER"),
            BusinessAccessRole::CampaignManager => write!(f, "CAMPAIGN_MANAGER"),
            BusinessAccessRole::CatalogsManager => write!(f, "CATALOGS_MANAGER"),
            BusinessAccessRole::RestrictedOwner => write!(f, "RESTRICTED_OWNER"),
            BusinessAccessRole::ProfileManager => write!(f, "PROFILE_MANAGER"),
            BusinessAccessRole::ProfilePublisher => write!(f, "PROFILE_PUBLISHER"),
            BusinessAccessRole::ResourcePinnerListOwner => write!(f, "RESOURCE_PINNER_LIST_OWNER"),
            BusinessAccessRole::ResourcePinnerListReader => write!(f, "RESOURCE_PINNER_LIST_READER"),
            BusinessAccessRole::BizPinnerListSharer => write!(f, "BIZ_PINNER_LIST_SHARER"),
            BusinessAccessRole::ResourceConversionTagsReader => write!(f, "RESOURCE_CONVERSION_TAGS_READER"),
        }
    }
}

impl std::str::FromStr for BusinessAccessRole {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "OWNER" => std::result::Result::Ok(BusinessAccessRole::Owner),
            "ADMIN" => std::result::Result::Ok(BusinessAccessRole::Admin),
            "ANALYST" => std::result::Result::Ok(BusinessAccessRole::Analyst),
            "SOS_READER" => std::result::Result::Ok(BusinessAccessRole::SosReader),
            "FINANCE_MANAGER" => std::result::Result::Ok(BusinessAccessRole::FinanceManager),
            "AUDIENCE_MANAGER" => std::result::Result::Ok(BusinessAccessRole::AudienceManager),
            "CAMPAIGN_MANAGER" => std::result::Result::Ok(BusinessAccessRole::CampaignManager),
            "CATALOGS_MANAGER" => std::result::Result::Ok(BusinessAccessRole::CatalogsManager),
            "RESTRICTED_OWNER" => std::result::Result::Ok(BusinessAccessRole::RestrictedOwner),
            "PROFILE_MANAGER" => std::result::Result::Ok(BusinessAccessRole::ProfileManager),
            "PROFILE_PUBLISHER" => std::result::Result::Ok(BusinessAccessRole::ProfilePublisher),
            "RESOURCE_PINNER_LIST_OWNER" => std::result::Result::Ok(BusinessAccessRole::ResourcePinnerListOwner),
            "RESOURCE_PINNER_LIST_READER" => std::result::Result::Ok(BusinessAccessRole::ResourcePinnerListReader),
            "BIZ_PINNER_LIST_SHARER" => std::result::Result::Ok(BusinessAccessRole::BizPinnerListSharer),
            "RESOURCE_CONVERSION_TAGS_READER" => std::result::Result::Ok(BusinessAccessRole::ResourceConversionTagsReader),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Campaign Data



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignCommon {
/// Campaign's Advertiser ID. If you want to create a campaign in a Business Account shared account you need to specify the Business Access advertiser ID in both the query path param as well as the request body schema.
    #[serde(rename = "ad_account_id")]
    #[validate(
           regex = "RE_CAMPAIGNCOMMON_AD_ACCOUNT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// Campaign name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

/// Campaign total spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"daily_spend_cap\" cannot be set at the same time.
    #[serde(rename = "lifetime_spend_cap")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifetime_spend_cap: Option<Nullable<i32>>,

/// Campaign daily spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"lifetime_spend_cap\" cannot be set at the same time.
    #[serde(rename = "daily_spend_cap")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub daily_spend_cap: Option<Nullable<i32>>,

/// Order line ID that appears on the invoice.
    #[serde(rename = "order_line_id")]
    #[validate(
           regex = "RE_CAMPAIGNCOMMON_ORDER_LINE_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_line_id: Option<Nullable<String>>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<Nullable<models::AdCommonTrackingUrls>>,

/// Campaign start time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
    #[serde(rename = "start_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<Nullable<i32>>,

/// Campaign end time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
    #[serde(rename = "end_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<Nullable<i32>>,

    #[serde(rename = "summary_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary_status: Option<models::CampaignSummaryStatus>,

}

lazy_static::lazy_static! {
    static ref RE_CAMPAIGNCOMMON_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_CAMPAIGNCOMMON_ORDER_LINE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CampaignCommon {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CampaignCommon {
        CampaignCommon {
            ad_account_id: None,
            name: None,
            status: None,
            lifetime_spend_cap: None,
            daily_spend_cap: None,
            order_line_id: None,
            tracking_urls: None,
            start_time: None,
            end_time: None,
            summary_status: None,
        }
    }
}

/// Converts the CampaignCommon value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CampaignCommon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.lifetime_spend_cap.as_ref().map(|lifetime_spend_cap| {
                [
                    "lifetime_spend_cap".to_string(),
                    lifetime_spend_cap.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.daily_spend_cap.as_ref().map(|daily_spend_cap| {
                [
                    "daily_spend_cap".to_string(),
                    daily_spend_cap.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.order_line_id.as_ref().map(|order_line_id| {
                [
                    "order_line_id".to_string(),
                    order_line_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping tracking_urls in query parameter serialization


            self.start_time.as_ref().map(|start_time| {
                [
                    "start_time".to_string(),
                    start_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.end_time.as_ref().map(|end_time| {
                [
                    "end_time".to_string(),
                    end_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping summary_status in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignCommon value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignCommon {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_account_id: Vec<String>,
            pub name: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub lifetime_spend_cap: Vec<i32>,
            pub daily_spend_cap: Vec<i32>,
            pub order_line_id: Vec<String>,
            pub tracking_urls: Vec<models::AdCommonTrackingUrls>,
            pub start_time: Vec<i32>,
            pub end_time: Vec<i32>,
            pub summary_status: Vec<models::CampaignSummaryStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignCommon".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "lifetime_spend_cap" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCommon".to_string()),
                    "daily_spend_cap" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCommon".to_string()),
                    "order_line_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCommon".to_string()),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCommon".to_string()),
                    "start_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCommon".to_string()),
                    "end_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCommon".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "summary_status" => intermediate_rep.summary_status.push(<models::CampaignSummaryStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignCommon".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignCommon {
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            lifetime_spend_cap: std::result::Result::Err("Nullable types not supported in CampaignCommon".to_string())?,
            daily_spend_cap: std::result::Result::Err("Nullable types not supported in CampaignCommon".to_string())?,
            order_line_id: std::result::Result::Err("Nullable types not supported in CampaignCommon".to_string())?,
            tracking_urls: std::result::Result::Err("Nullable types not supported in CampaignCommon".to_string())?,
            start_time: std::result::Result::Err("Nullable types not supported in CampaignCommon".to_string())?,
            end_time: std::result::Result::Err("Nullable types not supported in CampaignCommon".to_string())?,
            summary_status: intermediate_rep.summary_status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignCommon> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignCommon>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignCommon>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignCommon - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CampaignCommon> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignCommon as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignCommon - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignCreateCommon {
/// Campaign's Advertiser ID. If you want to create a campaign in a Business Account shared account you need to specify the Business Access advertiser ID in both the query path param as well as the request body schema.
    #[serde(rename = "ad_account_id")]
    #[validate(
           regex = "RE_CAMPAIGNCREATECOMMON_AD_ACCOUNT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// Campaign name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

/// Campaign total spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"daily_spend_cap\" cannot be set at the same time.
    #[serde(rename = "lifetime_spend_cap")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifetime_spend_cap: Option<Nullable<i32>>,

/// Campaign daily spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"lifetime_spend_cap\" cannot be set at the same time.
    #[serde(rename = "daily_spend_cap")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub daily_spend_cap: Option<Nullable<i32>>,

/// Order line ID that appears on the invoice.
    #[serde(rename = "order_line_id")]
    #[validate(
           regex = "RE_CAMPAIGNCREATECOMMON_ORDER_LINE_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_line_id: Option<Nullable<String>>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<Nullable<models::AdCommonTrackingUrls>>,

/// Campaign start time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
    #[serde(rename = "start_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<Nullable<i32>>,

/// Campaign end time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
    #[serde(rename = "end_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<Nullable<i32>>,

    #[serde(rename = "summary_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary_status: Option<models::CampaignSummaryStatus>,

/// Determine if a campaign has flexible daily budgets setup.
    #[serde(rename = "is_flexible_daily_budgets")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_flexible_daily_budgets: Option<bool>,

/// When transitioning from campaign budget optimization to non-campaign budget optimization, the default_ad_group_budget_in_micro_currency will propagate to each child ad groups daily budget. Unit is micro currency of the associated advertiser account.
    #[serde(rename = "default_ad_group_budget_in_micro_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_ad_group_budget_in_micro_currency: Option<Nullable<i32>>,

/// Specifies whether the campaign was created in the automated campaign flow
    #[serde(rename = "is_automated_campaign")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_automated_campaign: Option<bool>,

}

lazy_static::lazy_static! {
    static ref RE_CAMPAIGNCREATECOMMON_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_CAMPAIGNCREATECOMMON_ORDER_LINE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CampaignCreateCommon {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CampaignCreateCommon {
        CampaignCreateCommon {
            ad_account_id: None,
            name: None,
            status: Some("ACTIVE".to_string()),
            lifetime_spend_cap: None,
            daily_spend_cap: None,
            order_line_id: None,
            tracking_urls: None,
            start_time: None,
            end_time: None,
            summary_status: None,
            is_flexible_daily_budgets: Some(false),
            default_ad_group_budget_in_micro_currency: None,
            is_automated_campaign: Some(false),
        }
    }
}

/// Converts the CampaignCreateCommon value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CampaignCreateCommon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.lifetime_spend_cap.as_ref().map(|lifetime_spend_cap| {
                [
                    "lifetime_spend_cap".to_string(),
                    lifetime_spend_cap.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.daily_spend_cap.as_ref().map(|daily_spend_cap| {
                [
                    "daily_spend_cap".to_string(),
                    daily_spend_cap.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.order_line_id.as_ref().map(|order_line_id| {
                [
                    "order_line_id".to_string(),
                    order_line_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping tracking_urls in query parameter serialization


            self.start_time.as_ref().map(|start_time| {
                [
                    "start_time".to_string(),
                    start_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.end_time.as_ref().map(|end_time| {
                [
                    "end_time".to_string(),
                    end_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping summary_status in query parameter serialization


            self.is_flexible_daily_budgets.as_ref().map(|is_flexible_daily_budgets| {
                [
                    "is_flexible_daily_budgets".to_string(),
                    is_flexible_daily_budgets.to_string(),
                ].join(",")
            }),


            self.default_ad_group_budget_in_micro_currency.as_ref().map(|default_ad_group_budget_in_micro_currency| {
                [
                    "default_ad_group_budget_in_micro_currency".to_string(),
                    default_ad_group_budget_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_automated_campaign.as_ref().map(|is_automated_campaign| {
                [
                    "is_automated_campaign".to_string(),
                    is_automated_campaign.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignCreateCommon value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignCreateCommon {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_account_id: Vec<String>,
            pub name: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub lifetime_spend_cap: Vec<i32>,
            pub daily_spend_cap: Vec<i32>,
            pub order_line_id: Vec<String>,
            pub tracking_urls: Vec<models::AdCommonTrackingUrls>,
            pub start_time: Vec<i32>,
            pub end_time: Vec<i32>,
            pub summary_status: Vec<models::CampaignSummaryStatus>,
            pub is_flexible_daily_budgets: Vec<bool>,
            pub default_ad_group_budget_in_micro_currency: Vec<i32>,
            pub is_automated_campaign: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignCreateCommon".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "lifetime_spend_cap" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateCommon".to_string()),
                    "daily_spend_cap" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateCommon".to_string()),
                    "order_line_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateCommon".to_string()),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateCommon".to_string()),
                    "start_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateCommon".to_string()),
                    "end_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateCommon".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "summary_status" => intermediate_rep.summary_status.push(<models::CampaignSummaryStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_flexible_daily_budgets" => intermediate_rep.is_flexible_daily_budgets.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "default_ad_group_budget_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateCommon".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "is_automated_campaign" => intermediate_rep.is_automated_campaign.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignCreateCommon".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignCreateCommon {
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            lifetime_spend_cap: std::result::Result::Err("Nullable types not supported in CampaignCreateCommon".to_string())?,
            daily_spend_cap: std::result::Result::Err("Nullable types not supported in CampaignCreateCommon".to_string())?,
            order_line_id: std::result::Result::Err("Nullable types not supported in CampaignCreateCommon".to_string())?,
            tracking_urls: std::result::Result::Err("Nullable types not supported in CampaignCreateCommon".to_string())?,
            start_time: std::result::Result::Err("Nullable types not supported in CampaignCreateCommon".to_string())?,
            end_time: std::result::Result::Err("Nullable types not supported in CampaignCreateCommon".to_string())?,
            summary_status: intermediate_rep.summary_status.into_iter().next(),
            is_flexible_daily_budgets: intermediate_rep.is_flexible_daily_budgets.into_iter().next(),
            default_ad_group_budget_in_micro_currency: std::result::Result::Err("Nullable types not supported in CampaignCreateCommon".to_string())?,
            is_automated_campaign: intermediate_rep.is_automated_campaign.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignCreateCommon> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignCreateCommon>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignCreateCommon>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignCreateCommon - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CampaignCreateCommon> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignCreateCommon as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignCreateCommon - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignCreateRequest {
/// Campaign's Advertiser ID. If you want to create a campaign in a Business Account shared account you need to specify the Business Access advertiser ID in both the query path param as well as the request body schema.
    #[serde(rename = "ad_account_id")]
    #[validate(
           regex = "RE_CAMPAIGNCREATEREQUEST_AD_ACCOUNT_ID",
        )]
    pub ad_account_id: String,

/// Campaign name.
    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

/// Campaign total spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"daily_spend_cap\" cannot be set at the same time.
    #[serde(rename = "lifetime_spend_cap")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifetime_spend_cap: Option<Nullable<i32>>,

/// Campaign daily spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"lifetime_spend_cap\" cannot be set at the same time.
    #[serde(rename = "daily_spend_cap")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub daily_spend_cap: Option<Nullable<i32>>,

/// Order line ID that appears on the invoice.
    #[serde(rename = "order_line_id")]
    #[validate(
           regex = "RE_CAMPAIGNCREATEREQUEST_ORDER_LINE_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_line_id: Option<Nullable<String>>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<Nullable<models::AdCommonTrackingUrls>>,

/// Campaign start time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
    #[serde(rename = "start_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<Nullable<i32>>,

/// Campaign end time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
    #[serde(rename = "end_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<Nullable<i32>>,

    #[serde(rename = "summary_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary_status: Option<models::CampaignSummaryStatus>,

/// Determine if a campaign has flexible daily budgets setup.
    #[serde(rename = "is_flexible_daily_budgets")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_flexible_daily_budgets: Option<bool>,

/// When transitioning from campaign budget optimization to non-campaign budget optimization, the default_ad_group_budget_in_micro_currency will propagate to each child ad groups daily budget. Unit is micro currency of the associated advertiser account.
    #[serde(rename = "default_ad_group_budget_in_micro_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_ad_group_budget_in_micro_currency: Option<Nullable<i32>>,

/// Specifies whether the campaign was created in the automated campaign flow
    #[serde(rename = "is_automated_campaign")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_automated_campaign: Option<bool>,

    #[serde(rename = "objective_type")]
    pub objective_type: models::ObjectiveType,

}

lazy_static::lazy_static! {
    static ref RE_CAMPAIGNCREATEREQUEST_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_CAMPAIGNCREATEREQUEST_ORDER_LINE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CampaignCreateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(ad_account_id: String, name: String, objective_type: models::ObjectiveType, ) -> CampaignCreateRequest {
        CampaignCreateRequest {
            ad_account_id,
            name,
            status: Some("ACTIVE".to_string()),
            lifetime_spend_cap: None,
            daily_spend_cap: None,
            order_line_id: None,
            tracking_urls: None,
            start_time: None,
            end_time: None,
            summary_status: None,
            is_flexible_daily_budgets: Some(false),
            default_ad_group_budget_in_micro_currency: None,
            is_automated_campaign: Some(false),
            objective_type,
        }
    }
}

/// Converts the CampaignCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CampaignCreateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("ad_account_id".to_string()),
            Some(self.ad_account_id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping status in query parameter serialization


            self.lifetime_spend_cap.as_ref().map(|lifetime_spend_cap| {
                [
                    "lifetime_spend_cap".to_string(),
                    lifetime_spend_cap.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.daily_spend_cap.as_ref().map(|daily_spend_cap| {
                [
                    "daily_spend_cap".to_string(),
                    daily_spend_cap.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.order_line_id.as_ref().map(|order_line_id| {
                [
                    "order_line_id".to_string(),
                    order_line_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping tracking_urls in query parameter serialization


            self.start_time.as_ref().map(|start_time| {
                [
                    "start_time".to_string(),
                    start_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.end_time.as_ref().map(|end_time| {
                [
                    "end_time".to_string(),
                    end_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping summary_status in query parameter serialization


            self.is_flexible_daily_budgets.as_ref().map(|is_flexible_daily_budgets| {
                [
                    "is_flexible_daily_budgets".to_string(),
                    is_flexible_daily_budgets.to_string(),
                ].join(",")
            }),


            self.default_ad_group_budget_in_micro_currency.as_ref().map(|default_ad_group_budget_in_micro_currency| {
                [
                    "default_ad_group_budget_in_micro_currency".to_string(),
                    default_ad_group_budget_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_automated_campaign.as_ref().map(|is_automated_campaign| {
                [
                    "is_automated_campaign".to_string(),
                    is_automated_campaign.to_string(),
                ].join(",")
            }),

            // Skipping objective_type in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_account_id: Vec<String>,
            pub name: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub lifetime_spend_cap: Vec<i32>,
            pub daily_spend_cap: Vec<i32>,
            pub order_line_id: Vec<String>,
            pub tracking_urls: Vec<models::AdCommonTrackingUrls>,
            pub start_time: Vec<i32>,
            pub end_time: Vec<i32>,
            pub summary_status: Vec<models::CampaignSummaryStatus>,
            pub is_flexible_daily_budgets: Vec<bool>,
            pub default_ad_group_budget_in_micro_currency: Vec<i32>,
            pub is_automated_campaign: Vec<bool>,
            pub objective_type: Vec<models::ObjectiveType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "lifetime_spend_cap" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateRequest".to_string()),
                    "daily_spend_cap" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateRequest".to_string()),
                    "order_line_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateRequest".to_string()),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateRequest".to_string()),
                    "start_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateRequest".to_string()),
                    "end_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "summary_status" => intermediate_rep.summary_status.push(<models::CampaignSummaryStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_flexible_daily_budgets" => intermediate_rep.is_flexible_daily_budgets.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "default_ad_group_budget_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "is_automated_campaign" => intermediate_rep.is_automated_campaign.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "objective_type" => intermediate_rep.objective_type.push(<models::ObjectiveType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignCreateRequest {
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next().ok_or_else(|| "ad_account_id missing in CampaignCreateRequest".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in CampaignCreateRequest".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
            lifetime_spend_cap: std::result::Result::Err("Nullable types not supported in CampaignCreateRequest".to_string())?,
            daily_spend_cap: std::result::Result::Err("Nullable types not supported in CampaignCreateRequest".to_string())?,
            order_line_id: std::result::Result::Err("Nullable types not supported in CampaignCreateRequest".to_string())?,
            tracking_urls: std::result::Result::Err("Nullable types not supported in CampaignCreateRequest".to_string())?,
            start_time: std::result::Result::Err("Nullable types not supported in CampaignCreateRequest".to_string())?,
            end_time: std::result::Result::Err("Nullable types not supported in CampaignCreateRequest".to_string())?,
            summary_status: intermediate_rep.summary_status.into_iter().next(),
            is_flexible_daily_budgets: intermediate_rep.is_flexible_daily_budgets.into_iter().next(),
            default_ad_group_budget_in_micro_currency: std::result::Result::Err("Nullable types not supported in CampaignCreateRequest".to_string())?,
            is_automated_campaign: intermediate_rep.is_automated_campaign.into_iter().next(),
            objective_type: intermediate_rep.objective_type.into_iter().next().ok_or_else(|| "objective_type missing in CampaignCreateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignCreateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignCreateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignCreateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CampaignCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignCreateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignCreateResponse {
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::CampaignCreateResponseItem>>,

}


impl CampaignCreateResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CampaignCreateResponse {
        CampaignCreateResponse {
            items: None,
        }
    }
}

/// Converts the CampaignCreateResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CampaignCreateResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignCreateResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignCreateResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::CampaignCreateResponseItem>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignCreateResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CampaignCreateResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignCreateResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignCreateResponse {
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignCreateResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignCreateResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignCreateResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignCreateResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CampaignCreateResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignCreateResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignCreateResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignCreateResponseData {
/// Campaign's Advertiser ID. If you want to create a campaign in a Business Account shared account you need to specify the Business Access advertiser ID in both the query path param as well as the request body schema.
    #[serde(rename = "ad_account_id")]
    #[validate(
           regex = "RE_CAMPAIGNCREATERESPONSEDATA_AD_ACCOUNT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// Campaign name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

/// Campaign total spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"daily_spend_cap\" cannot be set at the same time.
    #[serde(rename = "lifetime_spend_cap")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifetime_spend_cap: Option<Nullable<i32>>,

/// Campaign daily spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"lifetime_spend_cap\" cannot be set at the same time.
    #[serde(rename = "daily_spend_cap")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub daily_spend_cap: Option<Nullable<i32>>,

/// Order line ID that appears on the invoice.
    #[serde(rename = "order_line_id")]
    #[validate(
           regex = "RE_CAMPAIGNCREATERESPONSEDATA_ORDER_LINE_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_line_id: Option<Nullable<String>>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<Nullable<models::AdCommonTrackingUrls>>,

/// Campaign start time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
    #[serde(rename = "start_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<Nullable<i32>>,

/// Campaign end time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
    #[serde(rename = "end_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<Nullable<i32>>,

    #[serde(rename = "summary_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary_status: Option<models::CampaignSummaryStatus>,

/// Determines if a campaign has flexible daily budgets setup.
    #[serde(rename = "is_flexible_daily_budgets")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_flexible_daily_budgets: Option<Nullable<bool>>,

/// When transitioning from campaign budget optimization to non-campaign budget optimization, the default_ad_group_budget_in_micro_currency will propagate to each child ad groups daily budget. Unit is micro currency of the associated advertiser account.
    #[serde(rename = "default_ad_group_budget_in_micro_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_ad_group_budget_in_micro_currency: Option<Nullable<i32>>,

/// Specifies whether the campaign was created in the automated campaign flow
    #[serde(rename = "is_automated_campaign")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_automated_campaign: Option<bool>,

/// Campaign ID.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_CAMPAIGNCREATERESPONSEDATA_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "objective_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub objective_type: Option<models::ObjectiveType>,

/// Campaign creation time. Unix timestamp in seconds.
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<i32>,

/// UTC timestamp. Last update time.
    #[serde(rename = "updated_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_time: Option<i32>,

/// Always \"campaign\".
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

/// Determines if a campaign automatically generate ad-group level budgets given a campaign budget to maximize campaign outcome. When transitioning from non-cbo to cbo, all previous child ad group budget will be cleared.
    #[serde(rename = "is_campaign_budget_optimization")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_campaign_budget_optimization: Option<Nullable<bool>>,

}

lazy_static::lazy_static! {
    static ref RE_CAMPAIGNCREATERESPONSEDATA_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_CAMPAIGNCREATERESPONSEDATA_ORDER_LINE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_CAMPAIGNCREATERESPONSEDATA_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CampaignCreateResponseData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CampaignCreateResponseData {
        CampaignCreateResponseData {
            ad_account_id: None,
            name: None,
            status: None,
            lifetime_spend_cap: None,
            daily_spend_cap: None,
            order_line_id: None,
            tracking_urls: None,
            start_time: None,
            end_time: None,
            summary_status: None,
            is_flexible_daily_budgets: None,
            default_ad_group_budget_in_micro_currency: None,
            is_automated_campaign: Some(false),
            id: None,
            objective_type: None,
            created_time: None,
            updated_time: None,
            r#type: None,
            is_campaign_budget_optimization: None,
        }
    }
}

/// Converts the CampaignCreateResponseData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CampaignCreateResponseData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.lifetime_spend_cap.as_ref().map(|lifetime_spend_cap| {
                [
                    "lifetime_spend_cap".to_string(),
                    lifetime_spend_cap.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.daily_spend_cap.as_ref().map(|daily_spend_cap| {
                [
                    "daily_spend_cap".to_string(),
                    daily_spend_cap.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.order_line_id.as_ref().map(|order_line_id| {
                [
                    "order_line_id".to_string(),
                    order_line_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping tracking_urls in query parameter serialization


            self.start_time.as_ref().map(|start_time| {
                [
                    "start_time".to_string(),
                    start_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.end_time.as_ref().map(|end_time| {
                [
                    "end_time".to_string(),
                    end_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping summary_status in query parameter serialization


            self.is_flexible_daily_budgets.as_ref().map(|is_flexible_daily_budgets| {
                [
                    "is_flexible_daily_budgets".to_string(),
                    is_flexible_daily_budgets.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.default_ad_group_budget_in_micro_currency.as_ref().map(|default_ad_group_budget_in_micro_currency| {
                [
                    "default_ad_group_budget_in_micro_currency".to_string(),
                    default_ad_group_budget_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_automated_campaign.as_ref().map(|is_automated_campaign| {
                [
                    "is_automated_campaign".to_string(),
                    is_automated_campaign.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping objective_type in query parameter serialization


            self.created_time.as_ref().map(|created_time| {
                [
                    "created_time".to_string(),
                    created_time.to_string(),
                ].join(",")
            }),


            self.updated_time.as_ref().map(|updated_time| {
                [
                    "updated_time".to_string(),
                    updated_time.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.is_campaign_budget_optimization.as_ref().map(|is_campaign_budget_optimization| {
                [
                    "is_campaign_budget_optimization".to_string(),
                    is_campaign_budget_optimization.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignCreateResponseData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignCreateResponseData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_account_id: Vec<String>,
            pub name: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub lifetime_spend_cap: Vec<i32>,
            pub daily_spend_cap: Vec<i32>,
            pub order_line_id: Vec<String>,
            pub tracking_urls: Vec<models::AdCommonTrackingUrls>,
            pub start_time: Vec<i32>,
            pub end_time: Vec<i32>,
            pub summary_status: Vec<models::CampaignSummaryStatus>,
            pub is_flexible_daily_budgets: Vec<bool>,
            pub default_ad_group_budget_in_micro_currency: Vec<i32>,
            pub is_automated_campaign: Vec<bool>,
            pub id: Vec<String>,
            pub objective_type: Vec<models::ObjectiveType>,
            pub created_time: Vec<i32>,
            pub updated_time: Vec<i32>,
            pub r#type: Vec<String>,
            pub is_campaign_budget_optimization: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignCreateResponseData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "lifetime_spend_cap" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateResponseData".to_string()),
                    "daily_spend_cap" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateResponseData".to_string()),
                    "order_line_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateResponseData".to_string()),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateResponseData".to_string()),
                    "start_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateResponseData".to_string()),
                    "end_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateResponseData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "summary_status" => intermediate_rep.summary_status.push(<models::CampaignSummaryStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "is_flexible_daily_budgets" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateResponseData".to_string()),
                    "default_ad_group_budget_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateResponseData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "is_automated_campaign" => intermediate_rep.is_automated_campaign.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "objective_type" => intermediate_rep.objective_type.push(<models::ObjectiveType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_time" => intermediate_rep.created_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updated_time" => intermediate_rep.updated_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "is_campaign_budget_optimization" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCreateResponseData".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignCreateResponseData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignCreateResponseData {
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            lifetime_spend_cap: std::result::Result::Err("Nullable types not supported in CampaignCreateResponseData".to_string())?,
            daily_spend_cap: std::result::Result::Err("Nullable types not supported in CampaignCreateResponseData".to_string())?,
            order_line_id: std::result::Result::Err("Nullable types not supported in CampaignCreateResponseData".to_string())?,
            tracking_urls: std::result::Result::Err("Nullable types not supported in CampaignCreateResponseData".to_string())?,
            start_time: std::result::Result::Err("Nullable types not supported in CampaignCreateResponseData".to_string())?,
            end_time: std::result::Result::Err("Nullable types not supported in CampaignCreateResponseData".to_string())?,
            summary_status: intermediate_rep.summary_status.into_iter().next(),
            is_flexible_daily_budgets: std::result::Result::Err("Nullable types not supported in CampaignCreateResponseData".to_string())?,
            default_ad_group_budget_in_micro_currency: std::result::Result::Err("Nullable types not supported in CampaignCreateResponseData".to_string())?,
            is_automated_campaign: intermediate_rep.is_automated_campaign.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            objective_type: intermediate_rep.objective_type.into_iter().next(),
            created_time: intermediate_rep.created_time.into_iter().next(),
            updated_time: intermediate_rep.updated_time.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            is_campaign_budget_optimization: std::result::Result::Err("Nullable types not supported in CampaignCreateResponseData".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignCreateResponseData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignCreateResponseData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignCreateResponseData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignCreateResponseData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CampaignCreateResponseData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignCreateResponseData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignCreateResponseData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignCreateResponseItem {
    #[serde(rename = "data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<models::CampaignCreateResponseData>,

    #[serde(rename = "exceptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exceptions: Option<Vec<models::Exception>>,

}


impl CampaignCreateResponseItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CampaignCreateResponseItem {
        CampaignCreateResponseItem {
            data: None,
            exceptions: None,
        }
    }
}

/// Converts the CampaignCreateResponseItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CampaignCreateResponseItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization

            // Skipping exceptions in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignCreateResponseItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignCreateResponseItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<models::CampaignCreateResponseData>,
            pub exceptions: Vec<Vec<models::Exception>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignCreateResponseItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::CampaignCreateResponseData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "exceptions" => return std::result::Result::Err("Parsing a container in this style is not supported in CampaignCreateResponseItem".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignCreateResponseItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignCreateResponseItem {
            data: intermediate_rep.data.into_iter().next(),
            exceptions: intermediate_rep.exceptions.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignCreateResponseItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignCreateResponseItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignCreateResponseItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignCreateResponseItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CampaignCreateResponseItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignCreateResponseItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignCreateResponseItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignId {
/// Campaign ID.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_CAMPAIGNID_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_CAMPAIGNID_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CampaignId {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CampaignId {
        CampaignId {
            id: None,
        }
    }
}

/// Converts the CampaignId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CampaignId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignId".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignId".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignId {
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignId> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignId>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignId>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignId - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CampaignId> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignId as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignId - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Specifies whether the campaign was created in the automated campaign flow
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignIsAutomatedCampaign(bool);

impl validator::Validate for CampaignIsAutomatedCampaign {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<bool> for CampaignIsAutomatedCampaign {
    fn from(x: bool) -> Self {
        CampaignIsAutomatedCampaign(x)
    }
}

impl std::convert::From<CampaignIsAutomatedCampaign> for bool {
    fn from(x: CampaignIsAutomatedCampaign) -> Self {
        x.0
    }
}

impl std::ops::Deref for CampaignIsAutomatedCampaign {
    type Target = bool;
    fn deref(&self) -> &bool {
        &self.0
    }
}

impl std::ops::DerefMut for CampaignIsAutomatedCampaign {
    fn deref_mut(&mut self) -> &mut bool {
        &mut self.0
    }
}



/// Determines if a campaign automatically generate ad-group level budgets given a campaign budget to maximize campaign outcome. When transitioning from non-cbo to cbo, all previous child ad group budget will be cleared.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignIsCampaignBudgetOptimization(bool);

impl validator::Validate for CampaignIsCampaignBudgetOptimization {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<bool> for CampaignIsCampaignBudgetOptimization {
    fn from(x: bool) -> Self {
        CampaignIsCampaignBudgetOptimization(x)
    }
}

impl std::convert::From<CampaignIsCampaignBudgetOptimization> for bool {
    fn from(x: CampaignIsCampaignBudgetOptimization) -> Self {
        x.0
    }
}

impl std::ops::Deref for CampaignIsCampaignBudgetOptimization {
    type Target = bool;
    fn deref(&self) -> &bool {
        &self.0
    }
}

impl std::ops::DerefMut for CampaignIsCampaignBudgetOptimization {
    fn deref_mut(&mut self) -> &mut bool {
        &mut self.0
    }
}



/// Determine if a campaign has flexible daily budgets setup.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignIsFlexibleDailyBudgets(bool);

impl validator::Validate for CampaignIsFlexibleDailyBudgets {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<bool> for CampaignIsFlexibleDailyBudgets {
    fn from(x: bool) -> Self {
        CampaignIsFlexibleDailyBudgets(x)
    }
}

impl std::convert::From<CampaignIsFlexibleDailyBudgets> for bool {
    fn from(x: CampaignIsFlexibleDailyBudgets) -> Self {
        x.0
    }
}

impl std::ops::Deref for CampaignIsFlexibleDailyBudgets {
    type Target = bool;
    fn deref(&self) -> &bool {
        &self.0
    }
}

impl std::ops::DerefMut for CampaignIsFlexibleDailyBudgets {
    fn deref_mut(&mut self) -> &mut bool {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignResponse {
/// Campaign ID.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_CAMPAIGNRESPONSE_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Campaign's Advertiser ID. If you want to create a campaign in a Business Account shared account you need to specify the Business Access advertiser ID in both the query path param as well as the request body schema.
    #[serde(rename = "ad_account_id")]
    #[validate(
           regex = "RE_CAMPAIGNRESPONSE_AD_ACCOUNT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// Campaign name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

/// Campaign total spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"daily_spend_cap\" cannot be set at the same time.
    #[serde(rename = "lifetime_spend_cap")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifetime_spend_cap: Option<Nullable<i32>>,

/// Campaign daily spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"lifetime_spend_cap\" cannot be set at the same time.
    #[serde(rename = "daily_spend_cap")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub daily_spend_cap: Option<Nullable<i32>>,

/// Order line ID that appears on the invoice.
    #[serde(rename = "order_line_id")]
    #[validate(
           regex = "RE_CAMPAIGNRESPONSE_ORDER_LINE_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_line_id: Option<Nullable<String>>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<Nullable<models::AdCommonTrackingUrls>>,

/// Campaign start time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
    #[serde(rename = "start_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<Nullable<i32>>,

/// Campaign end time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
    #[serde(rename = "end_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<Nullable<i32>>,

    #[serde(rename = "summary_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary_status: Option<models::CampaignSummaryStatus>,

    #[serde(rename = "objective_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub objective_type: Option<models::ObjectiveType>,

/// Campaign creation time. Unix timestamp in seconds.
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<i32>,

/// UTC timestamp. Last update time.
    #[serde(rename = "updated_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_time: Option<i32>,

/// Always \"campaign\".
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

/// Determines if a campaign has flexible daily budgets setup.
    #[serde(rename = "is_flexible_daily_budgets")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_flexible_daily_budgets: Option<Nullable<bool>>,

/// Determines if a campaign automatically generate ad-group level budgets given a campaign budget to maximize campaign outcome. When transitioning from non-cbo to cbo, all previous child ad group budget will be cleared.
    #[serde(rename = "is_campaign_budget_optimization")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_campaign_budget_optimization: Option<Nullable<bool>>,

}

lazy_static::lazy_static! {
    static ref RE_CAMPAIGNRESPONSE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_CAMPAIGNRESPONSE_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_CAMPAIGNRESPONSE_ORDER_LINE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CampaignResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CampaignResponse {
        CampaignResponse {
            id: None,
            ad_account_id: None,
            name: None,
            status: None,
            lifetime_spend_cap: None,
            daily_spend_cap: None,
            order_line_id: None,
            tracking_urls: None,
            start_time: None,
            end_time: None,
            summary_status: None,
            objective_type: None,
            created_time: None,
            updated_time: None,
            r#type: None,
            is_flexible_daily_budgets: None,
            is_campaign_budget_optimization: None,
        }
    }
}

/// Converts the CampaignResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CampaignResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.lifetime_spend_cap.as_ref().map(|lifetime_spend_cap| {
                [
                    "lifetime_spend_cap".to_string(),
                    lifetime_spend_cap.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.daily_spend_cap.as_ref().map(|daily_spend_cap| {
                [
                    "daily_spend_cap".to_string(),
                    daily_spend_cap.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.order_line_id.as_ref().map(|order_line_id| {
                [
                    "order_line_id".to_string(),
                    order_line_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping tracking_urls in query parameter serialization


            self.start_time.as_ref().map(|start_time| {
                [
                    "start_time".to_string(),
                    start_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.end_time.as_ref().map(|end_time| {
                [
                    "end_time".to_string(),
                    end_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping summary_status in query parameter serialization

            // Skipping objective_type in query parameter serialization


            self.created_time.as_ref().map(|created_time| {
                [
                    "created_time".to_string(),
                    created_time.to_string(),
                ].join(",")
            }),


            self.updated_time.as_ref().map(|updated_time| {
                [
                    "updated_time".to_string(),
                    updated_time.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.is_flexible_daily_budgets.as_ref().map(|is_flexible_daily_budgets| {
                [
                    "is_flexible_daily_budgets".to_string(),
                    is_flexible_daily_budgets.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_campaign_budget_optimization.as_ref().map(|is_campaign_budget_optimization| {
                [
                    "is_campaign_budget_optimization".to_string(),
                    is_campaign_budget_optimization.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub ad_account_id: Vec<String>,
            pub name: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub lifetime_spend_cap: Vec<i32>,
            pub daily_spend_cap: Vec<i32>,
            pub order_line_id: Vec<String>,
            pub tracking_urls: Vec<models::AdCommonTrackingUrls>,
            pub start_time: Vec<i32>,
            pub end_time: Vec<i32>,
            pub summary_status: Vec<models::CampaignSummaryStatus>,
            pub objective_type: Vec<models::ObjectiveType>,
            pub created_time: Vec<i32>,
            pub updated_time: Vec<i32>,
            pub r#type: Vec<String>,
            pub is_flexible_daily_budgets: Vec<bool>,
            pub is_campaign_budget_optimization: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "lifetime_spend_cap" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignResponse".to_string()),
                    "daily_spend_cap" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignResponse".to_string()),
                    "order_line_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignResponse".to_string()),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignResponse".to_string()),
                    "start_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignResponse".to_string()),
                    "end_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "summary_status" => intermediate_rep.summary_status.push(<models::CampaignSummaryStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "objective_type" => intermediate_rep.objective_type.push(<models::ObjectiveType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_time" => intermediate_rep.created_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updated_time" => intermediate_rep.updated_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "is_flexible_daily_budgets" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignResponse".to_string()),
                    "is_campaign_budget_optimization" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignResponse {
            id: intermediate_rep.id.into_iter().next(),
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            lifetime_spend_cap: std::result::Result::Err("Nullable types not supported in CampaignResponse".to_string())?,
            daily_spend_cap: std::result::Result::Err("Nullable types not supported in CampaignResponse".to_string())?,
            order_line_id: std::result::Result::Err("Nullable types not supported in CampaignResponse".to_string())?,
            tracking_urls: std::result::Result::Err("Nullable types not supported in CampaignResponse".to_string())?,
            start_time: std::result::Result::Err("Nullable types not supported in CampaignResponse".to_string())?,
            end_time: std::result::Result::Err("Nullable types not supported in CampaignResponse".to_string())?,
            summary_status: intermediate_rep.summary_status.into_iter().next(),
            objective_type: intermediate_rep.objective_type.into_iter().next(),
            created_time: intermediate_rep.created_time.into_iter().next(),
            updated_time: intermediate_rep.updated_time.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            is_flexible_daily_budgets: std::result::Result::Err("Nullable types not supported in CampaignResponse".to_string())?,
            is_campaign_budget_optimization: std::result::Result::Err("Nullable types not supported in CampaignResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CampaignResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Summary status for campaign
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CampaignSummaryStatus {
    #[serde(rename = "RUNNING")]
    Running,
    #[serde(rename = "PAUSED")]
    Paused,
    #[serde(rename = "NOT_STARTED")]
    NotStarted,
    #[serde(rename = "COMPLETED")]
    Completed,
    #[serde(rename = "ADVERTISER_DISABLED")]
    AdvertiserDisabled,
    #[serde(rename = "ARCHIVED")]
    Archived,
    #[serde(rename = "DRAFT")]
    Draft,
    #[serde(rename = "DELETED_DRAFT")]
    DeletedDraft,
}

impl std::fmt::Display for CampaignSummaryStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CampaignSummaryStatus::Running => write!(f, "RUNNING"),
            CampaignSummaryStatus::Paused => write!(f, "PAUSED"),
            CampaignSummaryStatus::NotStarted => write!(f, "NOT_STARTED"),
            CampaignSummaryStatus::Completed => write!(f, "COMPLETED"),
            CampaignSummaryStatus::AdvertiserDisabled => write!(f, "ADVERTISER_DISABLED"),
            CampaignSummaryStatus::Archived => write!(f, "ARCHIVED"),
            CampaignSummaryStatus::Draft => write!(f, "DRAFT"),
            CampaignSummaryStatus::DeletedDraft => write!(f, "DELETED_DRAFT"),
        }
    }
}

impl std::str::FromStr for CampaignSummaryStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "RUNNING" => std::result::Result::Ok(CampaignSummaryStatus::Running),
            "PAUSED" => std::result::Result::Ok(CampaignSummaryStatus::Paused),
            "NOT_STARTED" => std::result::Result::Ok(CampaignSummaryStatus::NotStarted),
            "COMPLETED" => std::result::Result::Ok(CampaignSummaryStatus::Completed),
            "ADVERTISER_DISABLED" => std::result::Result::Ok(CampaignSummaryStatus::AdvertiserDisabled),
            "ARCHIVED" => std::result::Result::Ok(CampaignSummaryStatus::Archived),
            "DRAFT" => std::result::Result::Ok(CampaignSummaryStatus::Draft),
            "DELETED_DRAFT" => std::result::Result::Ok(CampaignSummaryStatus::DeletedDraft),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignUpdateRequest {
/// Campaign ID.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_CAMPAIGNUPDATEREQUEST_ID",
        )]
    pub id: String,

/// Campaign's Advertiser ID. If you want to create a campaign in a Business Account shared account you need to specify the Business Access advertiser ID in both the query path param as well as the request body schema.
    #[serde(rename = "ad_account_id")]
    #[validate(
           regex = "RE_CAMPAIGNUPDATEREQUEST_AD_ACCOUNT_ID",
        )]
    pub ad_account_id: String,

/// Campaign name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "status")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<Nullable<models::EntityStatus>>,

/// Campaign total spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"daily_spend_cap\" cannot be set at the same time.
    #[serde(rename = "lifetime_spend_cap")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifetime_spend_cap: Option<Nullable<i32>>,

/// Campaign daily spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"lifetime_spend_cap\" cannot be set at the same time.
    #[serde(rename = "daily_spend_cap")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub daily_spend_cap: Option<Nullable<i32>>,

/// Order line ID that appears on the invoice.
    #[serde(rename = "order_line_id")]
    #[validate(
           regex = "RE_CAMPAIGNUPDATEREQUEST_ORDER_LINE_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_line_id: Option<Nullable<String>>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<Nullable<models::AdCommonTrackingUrls>>,

/// Campaign start time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
    #[serde(rename = "start_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<Nullable<i32>>,

/// Campaign end time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
    #[serde(rename = "end_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<Nullable<i32>>,

    #[serde(rename = "summary_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary_status: Option<models::CampaignSummaryStatus>,

/// Determine if a campaign has flexible daily budgets setup.
    #[serde(rename = "is_flexible_daily_budgets")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_flexible_daily_budgets: Option<Nullable<bool>>,

/// When transitioning from campaign budget optimization to non-campaign budget optimization, the default_ad_group_budget_in_micro_currency will propagate to each child ad groups daily budget. Unit is micro currency of the associated advertiser account.
    #[serde(rename = "default_ad_group_budget_in_micro_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_ad_group_budget_in_micro_currency: Option<Nullable<i32>>,

/// Specifies whether the campaign was created in the automated campaign flow
    #[serde(rename = "is_automated_campaign")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_automated_campaign: Option<Nullable<bool>>,

/// Determines if a campaign automatically generate ad-group level budgets given a campaign budget to maximize campaign outcome. When transitioning from non-cbo to cbo, all previous child ad group budget will be cleared.
    #[serde(rename = "is_campaign_budget_optimization")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_campaign_budget_optimization: Option<Nullable<bool>>,

    #[serde(rename = "objective_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub objective_type: Option<Nullable<models::ObjectiveType>>,

}

lazy_static::lazy_static! {
    static ref RE_CAMPAIGNUPDATEREQUEST_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_CAMPAIGNUPDATEREQUEST_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_CAMPAIGNUPDATEREQUEST_ORDER_LINE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CampaignUpdateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, ad_account_id: String, ) -> CampaignUpdateRequest {
        CampaignUpdateRequest {
            id,
            ad_account_id,
            name: None,
            status: None,
            lifetime_spend_cap: None,
            daily_spend_cap: None,
            order_line_id: None,
            tracking_urls: None,
            start_time: None,
            end_time: None,
            summary_status: None,
            is_flexible_daily_budgets: None,
            default_ad_group_budget_in_micro_currency: None,
            is_automated_campaign: None,
            is_campaign_budget_optimization: None,
            objective_type: None,
        }
    }
}

/// Converts the CampaignUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CampaignUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("ad_account_id".to_string()),
            Some(self.ad_account_id.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.lifetime_spend_cap.as_ref().map(|lifetime_spend_cap| {
                [
                    "lifetime_spend_cap".to_string(),
                    lifetime_spend_cap.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.daily_spend_cap.as_ref().map(|daily_spend_cap| {
                [
                    "daily_spend_cap".to_string(),
                    daily_spend_cap.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.order_line_id.as_ref().map(|order_line_id| {
                [
                    "order_line_id".to_string(),
                    order_line_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping tracking_urls in query parameter serialization


            self.start_time.as_ref().map(|start_time| {
                [
                    "start_time".to_string(),
                    start_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.end_time.as_ref().map(|end_time| {
                [
                    "end_time".to_string(),
                    end_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping summary_status in query parameter serialization


            self.is_flexible_daily_budgets.as_ref().map(|is_flexible_daily_budgets| {
                [
                    "is_flexible_daily_budgets".to_string(),
                    is_flexible_daily_budgets.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.default_ad_group_budget_in_micro_currency.as_ref().map(|default_ad_group_budget_in_micro_currency| {
                [
                    "default_ad_group_budget_in_micro_currency".to_string(),
                    default_ad_group_budget_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_automated_campaign.as_ref().map(|is_automated_campaign| {
                [
                    "is_automated_campaign".to_string(),
                    is_automated_campaign.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_campaign_budget_optimization.as_ref().map(|is_campaign_budget_optimization| {
                [
                    "is_campaign_budget_optimization".to_string(),
                    is_campaign_budget_optimization.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping objective_type in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub ad_account_id: Vec<String>,
            pub name: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub lifetime_spend_cap: Vec<i32>,
            pub daily_spend_cap: Vec<i32>,
            pub order_line_id: Vec<String>,
            pub tracking_urls: Vec<models::AdCommonTrackingUrls>,
            pub start_time: Vec<i32>,
            pub end_time: Vec<i32>,
            pub summary_status: Vec<models::CampaignSummaryStatus>,
            pub is_flexible_daily_budgets: Vec<bool>,
            pub default_ad_group_budget_in_micro_currency: Vec<i32>,
            pub is_automated_campaign: Vec<bool>,
            pub is_campaign_budget_optimization: Vec<bool>,
            pub objective_type: Vec<models::ObjectiveType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "status" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignUpdateRequest".to_string()),
                    "lifetime_spend_cap" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignUpdateRequest".to_string()),
                    "daily_spend_cap" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignUpdateRequest".to_string()),
                    "order_line_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignUpdateRequest".to_string()),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignUpdateRequest".to_string()),
                    "start_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignUpdateRequest".to_string()),
                    "end_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "summary_status" => intermediate_rep.summary_status.push(<models::CampaignSummaryStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "is_flexible_daily_budgets" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignUpdateRequest".to_string()),
                    "default_ad_group_budget_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignUpdateRequest".to_string()),
                    "is_automated_campaign" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignUpdateRequest".to_string()),
                    "is_campaign_budget_optimization" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignUpdateRequest".to_string()),
                    "objective_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignUpdateRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignUpdateRequest {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in CampaignUpdateRequest".to_string())?,
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next().ok_or_else(|| "ad_account_id missing in CampaignUpdateRequest".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            status: std::result::Result::Err("Nullable types not supported in CampaignUpdateRequest".to_string())?,
            lifetime_spend_cap: std::result::Result::Err("Nullable types not supported in CampaignUpdateRequest".to_string())?,
            daily_spend_cap: std::result::Result::Err("Nullable types not supported in CampaignUpdateRequest".to_string())?,
            order_line_id: std::result::Result::Err("Nullable types not supported in CampaignUpdateRequest".to_string())?,
            tracking_urls: std::result::Result::Err("Nullable types not supported in CampaignUpdateRequest".to_string())?,
            start_time: std::result::Result::Err("Nullable types not supported in CampaignUpdateRequest".to_string())?,
            end_time: std::result::Result::Err("Nullable types not supported in CampaignUpdateRequest".to_string())?,
            summary_status: intermediate_rep.summary_status.into_iter().next(),
            is_flexible_daily_budgets: std::result::Result::Err("Nullable types not supported in CampaignUpdateRequest".to_string())?,
            default_ad_group_budget_in_micro_currency: std::result::Result::Err("Nullable types not supported in CampaignUpdateRequest".to_string())?,
            is_automated_campaign: std::result::Result::Err("Nullable types not supported in CampaignUpdateRequest".to_string())?,
            is_campaign_budget_optimization: std::result::Result::Err("Nullable types not supported in CampaignUpdateRequest".to_string())?,
            objective_type: std::result::Result::Err("Nullable types not supported in CampaignUpdateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignUpdateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignUpdateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignUpdateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CampaignUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignUpdateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignUpdateResponse {
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::CampaignCreateResponseItem>>,

}


impl CampaignUpdateResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CampaignUpdateResponse {
        CampaignUpdateResponse {
            items: None,
        }
    }
}

/// Converts the CampaignUpdateResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CampaignUpdateResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignUpdateResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignUpdateResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::CampaignCreateResponseItem>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignUpdateResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CampaignUpdateResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignUpdateResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignUpdateResponse {
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignUpdateResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignUpdateResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignUpdateResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignUpdateResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CampaignUpdateResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignUpdateResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignUpdateResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignsAnalyticsResponseInner {
/// The ID of the campaing that this metrics belongs to.
    #[serde(rename = "CAMPAIGN_ID")]
    #[validate(
           regex = "RE_CAMPAIGNSANALYTICSRESPONSEINNER_CAMPAIGN_ID",
        )]
    pub campaign_id: String,

/// Current metrics date. Only returned when granularity is a time-based value (`DAY`, `HOUR`, `WEEK`, `MONTH`)
    #[serde(rename = "DATE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::naive::NaiveDate>,

}

lazy_static::lazy_static! {
    static ref RE_CAMPAIGNSANALYTICSRESPONSEINNER_CAMPAIGN_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CampaignsAnalyticsResponseInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(campaign_id: String, ) -> CampaignsAnalyticsResponseInner {
        CampaignsAnalyticsResponseInner {
            campaign_id,
            date: None,
        }
    }
}

/// Converts the CampaignsAnalyticsResponseInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CampaignsAnalyticsResponseInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("CAMPAIGN_ID".to_string()),
            Some(self.campaign_id.to_string()),

            // Skipping DATE in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignsAnalyticsResponseInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignsAnalyticsResponseInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub campaign_id: Vec<String>,
            pub date: Vec<chrono::naive::NaiveDate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignsAnalyticsResponseInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CAMPAIGN_ID" => intermediate_rep.campaign_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DATE" => intermediate_rep.date.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignsAnalyticsResponseInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignsAnalyticsResponseInner {
            campaign_id: intermediate_rep.campaign_id.into_iter().next().ok_or_else(|| "CAMPAIGN_ID missing in CampaignsAnalyticsResponseInner".to_string())?,
            date: intermediate_rep.date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignsAnalyticsResponseInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignsAnalyticsResponseInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignsAnalyticsResponseInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignsAnalyticsResponseInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CampaignsAnalyticsResponseInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignsAnalyticsResponseInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignsAnalyticsResponseInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignsList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::CampaignResponse>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl CampaignsList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::CampaignResponse>, ) -> CampaignsList200Response {
        CampaignsList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the CampaignsList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CampaignsList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignsList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignsList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::CampaignResponse>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignsList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CampaignsList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignsList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignsList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignsList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in CampaignsList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in CampaignsList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignsList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignsList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignsList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignsList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CampaignsList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignsList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignsList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Catalog entity



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Catalog {
    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

/// ID of the catalog entity.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_CATALOG_ID",
        )]
    pub id: String,

    #[serde(rename = "updated_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

/// A human-friendly name associated to a catalog entity.
    #[serde(rename = "name")]
    pub name: Nullable<String>,

    #[serde(rename = "catalog_type")]
    pub catalog_type: models::CatalogsType,

}

lazy_static::lazy_static! {
    static ref RE_CATALOG_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl Catalog {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, name: Nullable<String>, catalog_type: models::CatalogsType, ) -> Catalog {
        Catalog {
            created_at: None,
            id,
            updated_at: None,
            name,
            catalog_type,
        }
    }
}

/// Converts the Catalog value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Catalog {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping created_at in query parameter serialization


            Some("id".to_string()),
            Some(self.id.to_string()),

            // Skipping updated_at in query parameter serialization


            Some("name".to_string()),
            Some(self.name.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping catalog_type in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Catalog value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Catalog {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub id: Vec<String>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub name: Vec<String>,
            pub catalog_type: Vec<models::CatalogsType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Catalog".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updated_at" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Catalog".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<models::CatalogsType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Catalog".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Catalog {
            created_at: intermediate_rep.created_at.into_iter().next(),
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in Catalog".to_string())?,
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            name: std::result::Result::Err("Nullable types not supported in Catalog".to_string())?,
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in Catalog".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Catalog> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Catalog>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Catalog>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Catalog - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Catalog> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Catalog as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Catalog - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// non-promoted catalog product group entity



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogProductGroup {
/// ID of the catalog product group.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Merchant ID pertaining to the owner of the catalog product group.
    #[serde(rename = "merchant_id")]
    #[validate(
           regex = "RE_CATALOGPRODUCTGROUP_MERCHANT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub merchant_id: Option<String>,

/// Name of catalog product group
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Object holding a list of filters
    #[serde(rename = "filters")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub filters: Option<crate::types::Object>,

/// Object holding a list of filters
    #[serde(rename = "filter_v2")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub filter_v2: Option<crate::types::Object>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::Board>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

/// id of the feed profile belonging to this catalog product group
    #[serde(rename = "feed_profile_id")]
    #[validate(
           regex = "RE_CATALOGPRODUCTGROUP_FEED_PROFILE_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feed_profile_id: Option<String>,

/// Unix timestamp in seconds of when catalog product group was created.
    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<i32>,

/// Unix timestamp in seconds of last time catalog product group was updated.
    #[serde(rename = "last_update")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_update: Option<i32>,

/// Amount of products in the catalog product group
    #[serde(rename = "product_count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_count: Option<i32>,

/// index of the featured position of the catalog product group
    #[serde(rename = "featured_position")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub featured_position: Option<i32>,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGPRODUCTGROUP_MERCHANT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_CATALOGPRODUCTGROUP_FEED_PROFILE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CatalogProductGroup {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogProductGroup {
        CatalogProductGroup {
            id: None,
            merchant_id: None,
            name: None,
            filters: None,
            filter_v2: None,
            r#type: None,
            status: None,
            feed_profile_id: None,
            created_at: None,
            last_update: None,
            product_count: None,
            featured_position: None,
        }
    }
}

/// Converts the CatalogProductGroup value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogProductGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.merchant_id.as_ref().map(|merchant_id| {
                [
                    "merchant_id".to_string(),
                    merchant_id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping filters in query parameter serialization

            // Skipping filter_v2 in query parameter serialization

            // Skipping type in query parameter serialization

            // Skipping status in query parameter serialization


            self.feed_profile_id.as_ref().map(|feed_profile_id| {
                [
                    "feed_profile_id".to_string(),
                    feed_profile_id.to_string(),
                ].join(",")
            }),


            self.created_at.as_ref().map(|created_at| {
                [
                    "created_at".to_string(),
                    created_at.to_string(),
                ].join(",")
            }),


            self.last_update.as_ref().map(|last_update| {
                [
                    "last_update".to_string(),
                    last_update.to_string(),
                ].join(",")
            }),


            self.product_count.as_ref().map(|product_count| {
                [
                    "product_count".to_string(),
                    product_count.to_string(),
                ].join(",")
            }),


            self.featured_position.as_ref().map(|featured_position| {
                [
                    "featured_position".to_string(),
                    featured_position.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogProductGroup value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogProductGroup {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub merchant_id: Vec<String>,
            pub name: Vec<String>,
            pub filters: Vec<crate::types::Object>,
            pub filter_v2: Vec<crate::types::Object>,
            pub r#type: Vec<models::Board>,
            pub status: Vec<models::EntityStatus>,
            pub feed_profile_id: Vec<String>,
            pub created_at: Vec<i32>,
            pub last_update: Vec<i32>,
            pub product_count: Vec<i32>,
            pub featured_position: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogProductGroup".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "merchant_id" => intermediate_rep.merchant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "filters" => intermediate_rep.filters.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "filter_v2" => intermediate_rep.filter_v2.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::Board as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "feed_profile_id" => intermediate_rep.feed_profile_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_update" => intermediate_rep.last_update.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "product_count" => intermediate_rep.product_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "featured_position" => intermediate_rep.featured_position.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogProductGroup".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogProductGroup {
            id: intermediate_rep.id.into_iter().next(),
            merchant_id: intermediate_rep.merchant_id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            filters: intermediate_rep.filters.into_iter().next(),
            filter_v2: intermediate_rep.filter_v2.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            feed_profile_id: intermediate_rep.feed_profile_id.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            last_update: intermediate_rep.last_update.into_iter().next(),
            product_count: intermediate_rep.product_count.into_iter().next(),
            featured_position: intermediate_rep.featured_position.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogProductGroup> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogProductGroup>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogProductGroup>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogProductGroup - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogProductGroup> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogProductGroup as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogProductGroup - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A hotel item to be created.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsCreateHotelItem {
/// The catalog hotel id in the merchant namespace
    #[serde(rename = "hotel_id")]
    pub hotel_id: String,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "operation")]
    pub operation: String,

    #[serde(rename = "attributes")]
    pub attributes: models::CatalogsHotelAttributes,

}


impl CatalogsCreateHotelItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(hotel_id: String, operation: String, attributes: models::CatalogsHotelAttributes, ) -> CatalogsCreateHotelItem {
        CatalogsCreateHotelItem {
            hotel_id,
            operation,
            attributes,
        }
    }
}

/// Converts the CatalogsCreateHotelItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsCreateHotelItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("hotel_id".to_string()),
            Some(self.hotel_id.to_string()),


            Some("operation".to_string()),
            Some(self.operation.to_string()),

            // Skipping attributes in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsCreateHotelItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsCreateHotelItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hotel_id: Vec<String>,
            pub operation: Vec<String>,
            pub attributes: Vec<models::CatalogsHotelAttributes>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsCreateHotelItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "hotel_id" => intermediate_rep.hotel_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operation" => intermediate_rep.operation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "attributes" => intermediate_rep.attributes.push(<models::CatalogsHotelAttributes as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsCreateHotelItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsCreateHotelItem {
            hotel_id: intermediate_rep.hotel_id.into_iter().next().ok_or_else(|| "hotel_id missing in CatalogsCreateHotelItem".to_string())?,
            operation: intermediate_rep.operation.into_iter().next().ok_or_else(|| "operation missing in CatalogsCreateHotelItem".to_string())?,
            attributes: intermediate_rep.attributes.into_iter().next().ok_or_else(|| "attributes missing in CatalogsCreateHotelItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsCreateHotelItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsCreateHotelItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsCreateHotelItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsCreateHotelItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsCreateHotelItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsCreateHotelItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsCreateHotelItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// An item to be created



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsCreateRetailItem {
/// The catalog item id in the merchant namespace
    #[serde(rename = "item_id")]
    pub item_id: String,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "operation")]
    pub operation: String,

    #[serde(rename = "attributes")]
    pub attributes: models::ItemAttributes,

}


impl CatalogsCreateRetailItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(item_id: String, operation: String, attributes: models::ItemAttributes, ) -> CatalogsCreateRetailItem {
        CatalogsCreateRetailItem {
            item_id,
            operation,
            attributes,
        }
    }
}

/// Converts the CatalogsCreateRetailItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsCreateRetailItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("operation".to_string()),
            Some(self.operation.to_string()),

            // Skipping attributes in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsCreateRetailItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsCreateRetailItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_id: Vec<String>,
            pub operation: Vec<String>,
            pub attributes: Vec<models::ItemAttributes>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsCreateRetailItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operation" => intermediate_rep.operation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "attributes" => intermediate_rep.attributes.push(<models::ItemAttributes as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsCreateRetailItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsCreateRetailItem {
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in CatalogsCreateRetailItem".to_string())?,
            operation: intermediate_rep.operation.into_iter().next().ok_or_else(|| "operation missing in CatalogsCreateRetailItem".to_string())?,
            attributes: intermediate_rep.attributes.into_iter().next().ok_or_else(|| "attributes missing in CatalogsCreateRetailItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsCreateRetailItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsCreateRetailItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsCreateRetailItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsCreateRetailItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsCreateRetailItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsCreateRetailItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsCreateRetailItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsDbItem {
    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "updated_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl CatalogsDbItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsDbItem {
        CatalogsDbItem {
            created_at: None,
            id: None,
            updated_at: None,
        }
    }
}

/// Converts the CatalogsDbItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsDbItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping created_at in query parameter serialization


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping updated_at in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsDbItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsDbItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub id: Vec<String>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsDbItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updated_at" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsDbItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsDbItem {
            created_at: intermediate_rep.created_at.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsDbItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsDbItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsDbItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsDbItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsDbItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsDbItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsDbItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A hotel item to be deleted



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsDeleteHotelItem {
/// The catalog hotel id in the merchant namespace
    #[serde(rename = "hotel_id")]
    pub hotel_id: String,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "operation")]
    pub operation: String,

}


impl CatalogsDeleteHotelItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(hotel_id: String, operation: String, ) -> CatalogsDeleteHotelItem {
        CatalogsDeleteHotelItem {
            hotel_id,
            operation,
        }
    }
}

/// Converts the CatalogsDeleteHotelItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsDeleteHotelItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("hotel_id".to_string()),
            Some(self.hotel_id.to_string()),


            Some("operation".to_string()),
            Some(self.operation.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsDeleteHotelItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsDeleteHotelItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hotel_id: Vec<String>,
            pub operation: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsDeleteHotelItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "hotel_id" => intermediate_rep.hotel_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operation" => intermediate_rep.operation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsDeleteHotelItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsDeleteHotelItem {
            hotel_id: intermediate_rep.hotel_id.into_iter().next().ok_or_else(|| "hotel_id missing in CatalogsDeleteHotelItem".to_string())?,
            operation: intermediate_rep.operation.into_iter().next().ok_or_else(|| "operation missing in CatalogsDeleteHotelItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsDeleteHotelItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsDeleteHotelItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsDeleteHotelItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsDeleteHotelItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsDeleteHotelItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsDeleteHotelItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsDeleteHotelItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// An item to be deleted



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsDeleteRetailItem {
/// The catalog item id in the merchant namespace
    #[serde(rename = "item_id")]
    pub item_id: String,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "operation")]
    pub operation: String,

}


impl CatalogsDeleteRetailItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(item_id: String, operation: String, ) -> CatalogsDeleteRetailItem {
        CatalogsDeleteRetailItem {
            item_id,
            operation,
        }
    }
}

/// Converts the CatalogsDeleteRetailItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsDeleteRetailItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("operation".to_string()),
            Some(self.operation.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsDeleteRetailItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsDeleteRetailItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_id: Vec<String>,
            pub operation: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsDeleteRetailItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operation" => intermediate_rep.operation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsDeleteRetailItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsDeleteRetailItem {
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in CatalogsDeleteRetailItem".to_string())?,
            operation: intermediate_rep.operation.into_iter().next().ok_or_else(|| "operation missing in CatalogsDeleteRetailItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsDeleteRetailItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsDeleteRetailItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsDeleteRetailItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsDeleteRetailItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsDeleteRetailItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsDeleteRetailItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsDeleteRetailItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Catalogs Feed object


/// One of:
/// - CatalogsHotelFeed
/// - CatalogsRetailFeed
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsFeed(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsFeed
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeed value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeed {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsFeed {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// This field is **OPTIONAL**. Use this if your feed file requires username and password.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedCredentials {
/// The required password for downloading a feed.
    #[serde(rename = "password")]
    pub password: String,

/// The required username for downloading a feed.
    #[serde(rename = "username")]
    pub username: String,

}


impl CatalogsFeedCredentials {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(password: String, username: String, ) -> CatalogsFeedCredentials {
        CatalogsFeedCredentials {
            password,
            username,
        }
    }
}

/// Converts the CatalogsFeedCredentials value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsFeedCredentials {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("password".to_string()),
            Some(self.password.to_string()),


            Some("username".to_string()),
            Some(self.username.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedCredentials value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedCredentials {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub password: Vec<String>,
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedCredentials".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "password" => intermediate_rep.password.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedCredentials".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedCredentials {
            password: intermediate_rep.password.into_iter().next().ok_or_else(|| "password missing in CatalogsFeedCredentials".to_string())?,
            username: intermediate_rep.username.into_iter().next().ok_or_else(|| "username missing in CatalogsFeedCredentials".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedCredentials> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedCredentials>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedCredentials>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedCredentials - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsFeedCredentials> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedCredentials as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedCredentials - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedIngestionDetails {
    #[serde(rename = "errors")]
    pub errors: models::CatalogsFeedIngestionErrors,

    #[serde(rename = "info")]
    pub info: models::CatalogsFeedIngestionInfo,

    #[serde(rename = "warnings")]
    pub warnings: models::CatalogsFeedIngestionWarnings,

}


impl CatalogsFeedIngestionDetails {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(errors: models::CatalogsFeedIngestionErrors, info: models::CatalogsFeedIngestionInfo, warnings: models::CatalogsFeedIngestionWarnings, ) -> CatalogsFeedIngestionDetails {
        CatalogsFeedIngestionDetails {
            errors,
            info,
            warnings,
        }
    }
}

/// Converts the CatalogsFeedIngestionDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsFeedIngestionDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping errors in query parameter serialization

            // Skipping info in query parameter serialization

            // Skipping warnings in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedIngestionDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedIngestionDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub errors: Vec<models::CatalogsFeedIngestionErrors>,
            pub info: Vec<models::CatalogsFeedIngestionInfo>,
            pub warnings: Vec<models::CatalogsFeedIngestionWarnings>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedIngestionDetails".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "errors" => intermediate_rep.errors.push(<models::CatalogsFeedIngestionErrors as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "info" => intermediate_rep.info.push(<models::CatalogsFeedIngestionInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "warnings" => intermediate_rep.warnings.push(<models::CatalogsFeedIngestionWarnings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedIngestionDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedIngestionDetails {
            errors: intermediate_rep.errors.into_iter().next().ok_or_else(|| "errors missing in CatalogsFeedIngestionDetails".to_string())?,
            info: intermediate_rep.info.into_iter().next().ok_or_else(|| "info missing in CatalogsFeedIngestionDetails".to_string())?,
            warnings: intermediate_rep.warnings.into_iter().next().ok_or_else(|| "warnings missing in CatalogsFeedIngestionDetails".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedIngestionDetails> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedIngestionDetails>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedIngestionDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedIngestionDetails - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsFeedIngestionDetails> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedIngestionDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedIngestionDetails - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedIngestionErrors {
/// We experienced a technical difficulty and were unable to ingest this some items. The next ingestion will happen in 24 hours.
    #[serde(rename = "LINE_LEVEL_INTERNAL_ERROR")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub line_level_internal_error: Option<i32>,

/// The product count has decreased by more than 99% compared to the last successful ingestion.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "LARGE_PRODUCT_COUNT_DECREASE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub large_product_count_decrease: Option<i32>,

/// We detected an issue with your account and are not currently ingesting your items. Please review our policies at policy.pinterest.com/community-guidelines#section-spam or contact us at help.pinterest.com/contact for more information.
    #[serde(rename = "ACCOUNT_FLAGGED")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account_flagged: Option<i32>,

/// We experienced a technical difficulty and were unable to download some images. The next download attempt will happen in 24 hours.
    #[serde(rename = "IMAGE_LEVEL_INTERNAL_ERROR")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_level_internal_error: Option<i32>,

/// Image files are unreadable. Please upload new files to continue.
    #[serde(rename = "IMAGE_FILE_NOT_ACCESSIBLE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_file_not_accessible: Option<i32>,

/// Image files are unreadable. Please check your link and upload new files to continue.
    #[serde(rename = "IMAGE_MALFORMED_URL")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_malformed_url: Option<i32>,

/// Image files are unreadable. Please upload new files to continue.
    #[serde(rename = "IMAGE_FILE_NOT_FOUND")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_file_not_found: Option<i32>,

/// Image files are unreadable. Please upload new files to continue.
    #[serde(rename = "IMAGE_INVALID_FILE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_invalid_file: Option<i32>,

}


impl CatalogsFeedIngestionErrors {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsFeedIngestionErrors {
        CatalogsFeedIngestionErrors {
            line_level_internal_error: None,
            large_product_count_decrease: None,
            account_flagged: None,
            image_level_internal_error: None,
            image_file_not_accessible: None,
            image_malformed_url: None,
            image_file_not_found: None,
            image_invalid_file: None,
        }
    }
}

/// Converts the CatalogsFeedIngestionErrors value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsFeedIngestionErrors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.line_level_internal_error.as_ref().map(|line_level_internal_error| {
                [
                    "LINE_LEVEL_INTERNAL_ERROR".to_string(),
                    line_level_internal_error.to_string(),
                ].join(",")
            }),


            self.large_product_count_decrease.as_ref().map(|large_product_count_decrease| {
                [
                    "LARGE_PRODUCT_COUNT_DECREASE".to_string(),
                    large_product_count_decrease.to_string(),
                ].join(",")
            }),


            self.account_flagged.as_ref().map(|account_flagged| {
                [
                    "ACCOUNT_FLAGGED".to_string(),
                    account_flagged.to_string(),
                ].join(",")
            }),


            self.image_level_internal_error.as_ref().map(|image_level_internal_error| {
                [
                    "IMAGE_LEVEL_INTERNAL_ERROR".to_string(),
                    image_level_internal_error.to_string(),
                ].join(",")
            }),


            self.image_file_not_accessible.as_ref().map(|image_file_not_accessible| {
                [
                    "IMAGE_FILE_NOT_ACCESSIBLE".to_string(),
                    image_file_not_accessible.to_string(),
                ].join(",")
            }),


            self.image_malformed_url.as_ref().map(|image_malformed_url| {
                [
                    "IMAGE_MALFORMED_URL".to_string(),
                    image_malformed_url.to_string(),
                ].join(",")
            }),


            self.image_file_not_found.as_ref().map(|image_file_not_found| {
                [
                    "IMAGE_FILE_NOT_FOUND".to_string(),
                    image_file_not_found.to_string(),
                ].join(",")
            }),


            self.image_invalid_file.as_ref().map(|image_invalid_file| {
                [
                    "IMAGE_INVALID_FILE".to_string(),
                    image_invalid_file.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedIngestionErrors value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedIngestionErrors {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub line_level_internal_error: Vec<i32>,
            pub large_product_count_decrease: Vec<i32>,
            pub account_flagged: Vec<i32>,
            pub image_level_internal_error: Vec<i32>,
            pub image_file_not_accessible: Vec<i32>,
            pub image_malformed_url: Vec<i32>,
            pub image_file_not_found: Vec<i32>,
            pub image_invalid_file: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedIngestionErrors".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "LINE_LEVEL_INTERNAL_ERROR" => intermediate_rep.line_level_internal_error.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "LARGE_PRODUCT_COUNT_DECREASE" => intermediate_rep.large_product_count_decrease.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ACCOUNT_FLAGGED" => intermediate_rep.account_flagged.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IMAGE_LEVEL_INTERNAL_ERROR" => intermediate_rep.image_level_internal_error.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IMAGE_FILE_NOT_ACCESSIBLE" => intermediate_rep.image_file_not_accessible.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IMAGE_MALFORMED_URL" => intermediate_rep.image_malformed_url.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IMAGE_FILE_NOT_FOUND" => intermediate_rep.image_file_not_found.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IMAGE_INVALID_FILE" => intermediate_rep.image_invalid_file.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedIngestionErrors".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedIngestionErrors {
            line_level_internal_error: intermediate_rep.line_level_internal_error.into_iter().next(),
            large_product_count_decrease: intermediate_rep.large_product_count_decrease.into_iter().next(),
            account_flagged: intermediate_rep.account_flagged.into_iter().next(),
            image_level_internal_error: intermediate_rep.image_level_internal_error.into_iter().next(),
            image_file_not_accessible: intermediate_rep.image_file_not_accessible.into_iter().next(),
            image_malformed_url: intermediate_rep.image_malformed_url.into_iter().next(),
            image_file_not_found: intermediate_rep.image_file_not_found.into_iter().next(),
            image_invalid_file: intermediate_rep.image_invalid_file.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedIngestionErrors> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedIngestionErrors>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedIngestionErrors>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedIngestionErrors - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsFeedIngestionErrors> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedIngestionErrors as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedIngestionErrors - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedIngestionInfo {
/// The number of ingested products that are in stock.
    #[serde(rename = "IN_STOCK")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub in_stock: Option<i32>,

/// The number of ingested products that are in out of stock.
    #[serde(rename = "OUT_OF_STOCK")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub out_of_stock: Option<i32>,

/// The number of ingested products that are in preorder.
    #[serde(rename = "PREORDER")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preorder: Option<i32>,

}


impl CatalogsFeedIngestionInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsFeedIngestionInfo {
        CatalogsFeedIngestionInfo {
            in_stock: None,
            out_of_stock: None,
            preorder: None,
        }
    }
}

/// Converts the CatalogsFeedIngestionInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsFeedIngestionInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.in_stock.as_ref().map(|in_stock| {
                [
                    "IN_STOCK".to_string(),
                    in_stock.to_string(),
                ].join(",")
            }),


            self.out_of_stock.as_ref().map(|out_of_stock| {
                [
                    "OUT_OF_STOCK".to_string(),
                    out_of_stock.to_string(),
                ].join(",")
            }),


            self.preorder.as_ref().map(|preorder| {
                [
                    "PREORDER".to_string(),
                    preorder.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedIngestionInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedIngestionInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub in_stock: Vec<i32>,
            pub out_of_stock: Vec<i32>,
            pub preorder: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedIngestionInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "IN_STOCK" => intermediate_rep.in_stock.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OUT_OF_STOCK" => intermediate_rep.out_of_stock.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PREORDER" => intermediate_rep.preorder.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedIngestionInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedIngestionInfo {
            in_stock: intermediate_rep.in_stock.into_iter().next(),
            out_of_stock: intermediate_rep.out_of_stock.into_iter().next(),
            preorder: intermediate_rep.preorder.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedIngestionInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedIngestionInfo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedIngestionInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedIngestionInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsFeedIngestionInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedIngestionInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedIngestionInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedIngestionWarnings {
/// We experienced a technical difficulty and were unable to download some additional images. The next download attempt will happen in 24 hours.
    #[serde(rename = "ADDITIONAL_IMAGE_LEVEL_INTERNAL_ERROR")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_image_level_internal_error: Option<i32>,

/// Additional image files are unreadable. Please upload new files to continue.
    #[serde(rename = "ADDITIONAL_IMAGE_FILE_NOT_ACCESSIBLE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_image_file_not_accessible: Option<i32>,

/// Additional image files are unreadable. Please check your link and upload new files to continue.
    #[serde(rename = "ADDITIONAL_IMAGE_MALFORMED_URL")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_image_malformed_url: Option<i32>,

/// Additional image files are unreadable. Please upload new files to continue.
    #[serde(rename = "ADDITIONAL_IMAGE_FILE_NOT_FOUND")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_image_file_not_found: Option<i32>,

/// Additional image files are unreadable. Please upload new files to continue.
    #[serde(rename = "ADDITIONAL_IMAGE_INVALID_FILE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_image_invalid_file: Option<i32>,

/// price is not a supported column. Use base_price and sale_price instead.
    #[serde(rename = "HOTEL_PRICE_HEADER_IS_PRESENT")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hotel_price_header_is_present: Option<i32>,

}


impl CatalogsFeedIngestionWarnings {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsFeedIngestionWarnings {
        CatalogsFeedIngestionWarnings {
            additional_image_level_internal_error: None,
            additional_image_file_not_accessible: None,
            additional_image_malformed_url: None,
            additional_image_file_not_found: None,
            additional_image_invalid_file: None,
            hotel_price_header_is_present: None,
        }
    }
}

/// Converts the CatalogsFeedIngestionWarnings value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsFeedIngestionWarnings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.additional_image_level_internal_error.as_ref().map(|additional_image_level_internal_error| {
                [
                    "ADDITIONAL_IMAGE_LEVEL_INTERNAL_ERROR".to_string(),
                    additional_image_level_internal_error.to_string(),
                ].join(",")
            }),


            self.additional_image_file_not_accessible.as_ref().map(|additional_image_file_not_accessible| {
                [
                    "ADDITIONAL_IMAGE_FILE_NOT_ACCESSIBLE".to_string(),
                    additional_image_file_not_accessible.to_string(),
                ].join(",")
            }),


            self.additional_image_malformed_url.as_ref().map(|additional_image_malformed_url| {
                [
                    "ADDITIONAL_IMAGE_MALFORMED_URL".to_string(),
                    additional_image_malformed_url.to_string(),
                ].join(",")
            }),


            self.additional_image_file_not_found.as_ref().map(|additional_image_file_not_found| {
                [
                    "ADDITIONAL_IMAGE_FILE_NOT_FOUND".to_string(),
                    additional_image_file_not_found.to_string(),
                ].join(",")
            }),


            self.additional_image_invalid_file.as_ref().map(|additional_image_invalid_file| {
                [
                    "ADDITIONAL_IMAGE_INVALID_FILE".to_string(),
                    additional_image_invalid_file.to_string(),
                ].join(",")
            }),


            self.hotel_price_header_is_present.as_ref().map(|hotel_price_header_is_present| {
                [
                    "HOTEL_PRICE_HEADER_IS_PRESENT".to_string(),
                    hotel_price_header_is_present.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedIngestionWarnings value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedIngestionWarnings {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub additional_image_level_internal_error: Vec<i32>,
            pub additional_image_file_not_accessible: Vec<i32>,
            pub additional_image_malformed_url: Vec<i32>,
            pub additional_image_file_not_found: Vec<i32>,
            pub additional_image_invalid_file: Vec<i32>,
            pub hotel_price_header_is_present: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedIngestionWarnings".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ADDITIONAL_IMAGE_LEVEL_INTERNAL_ERROR" => intermediate_rep.additional_image_level_internal_error.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ADDITIONAL_IMAGE_FILE_NOT_ACCESSIBLE" => intermediate_rep.additional_image_file_not_accessible.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ADDITIONAL_IMAGE_MALFORMED_URL" => intermediate_rep.additional_image_malformed_url.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ADDITIONAL_IMAGE_FILE_NOT_FOUND" => intermediate_rep.additional_image_file_not_found.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ADDITIONAL_IMAGE_INVALID_FILE" => intermediate_rep.additional_image_invalid_file.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "HOTEL_PRICE_HEADER_IS_PRESENT" => intermediate_rep.hotel_price_header_is_present.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedIngestionWarnings".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedIngestionWarnings {
            additional_image_level_internal_error: intermediate_rep.additional_image_level_internal_error.into_iter().next(),
            additional_image_file_not_accessible: intermediate_rep.additional_image_file_not_accessible.into_iter().next(),
            additional_image_malformed_url: intermediate_rep.additional_image_malformed_url.into_iter().next(),
            additional_image_file_not_found: intermediate_rep.additional_image_file_not_found.into_iter().next(),
            additional_image_invalid_file: intermediate_rep.additional_image_invalid_file.into_iter().next(),
            hotel_price_header_is_present: intermediate_rep.hotel_price_header_is_present.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedIngestionWarnings> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedIngestionWarnings>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedIngestionWarnings>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedIngestionWarnings - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsFeedIngestionWarnings> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedIngestionWarnings as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedIngestionWarnings - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedProcessingResult {
    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "updated_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "ingestion_details")]
    pub ingestion_details: models::CatalogsFeedIngestionDetails,

    #[serde(rename = "status")]
    pub status: models::CatalogsFeedProcessingStatus,

    #[serde(rename = "product_counts")]
    pub product_counts: Nullable<models::CatalogsFeedProductCounts>,

    #[serde(rename = "validation_details")]
    pub validation_details: models::CatalogsFeedValidationDetails,

}


impl CatalogsFeedProcessingResult {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(ingestion_details: models::CatalogsFeedIngestionDetails, status: models::CatalogsFeedProcessingStatus, product_counts: Nullable<models::CatalogsFeedProductCounts>, validation_details: models::CatalogsFeedValidationDetails, ) -> CatalogsFeedProcessingResult {
        CatalogsFeedProcessingResult {
            created_at: None,
            id: None,
            updated_at: None,
            ingestion_details,
            status,
            product_counts,
            validation_details,
        }
    }
}

/// Converts the CatalogsFeedProcessingResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsFeedProcessingResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping created_at in query parameter serialization


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping updated_at in query parameter serialization

            // Skipping ingestion_details in query parameter serialization

            // Skipping status in query parameter serialization

            // Skipping product_counts in query parameter serialization

            // Skipping validation_details in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedProcessingResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedProcessingResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub id: Vec<String>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub ingestion_details: Vec<models::CatalogsFeedIngestionDetails>,
            pub status: Vec<models::CatalogsFeedProcessingStatus>,
            pub product_counts: Vec<models::CatalogsFeedProductCounts>,
            pub validation_details: Vec<models::CatalogsFeedValidationDetails>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedProcessingResult".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updated_at" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ingestion_details" => intermediate_rep.ingestion_details.push(<models::CatalogsFeedIngestionDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::CatalogsFeedProcessingStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "product_counts" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedProcessingResult".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "validation_details" => intermediate_rep.validation_details.push(<models::CatalogsFeedValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedProcessingResult".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedProcessingResult {
            created_at: intermediate_rep.created_at.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            ingestion_details: intermediate_rep.ingestion_details.into_iter().next().ok_or_else(|| "ingestion_details missing in CatalogsFeedProcessingResult".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in CatalogsFeedProcessingResult".to_string())?,
            product_counts: std::result::Result::Err("Nullable types not supported in CatalogsFeedProcessingResult".to_string())?,
            validation_details: intermediate_rep.validation_details.into_iter().next().ok_or_else(|| "validation_details missing in CatalogsFeedProcessingResult".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedProcessingResult> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedProcessingResult>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedProcessingResult>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedProcessingResult - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsFeedProcessingResult> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedProcessingResult as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedProcessingResult - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Daily processing schedule. This field is **OPTIONAL**. Use this to configure the preferred time for processing a feed (otherwise random).



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedProcessingSchedule {
/// A time in format HH:MM with leading 0 (zero)
    #[serde(rename = "time")]
    #[validate(
           regex = "RE_CATALOGSFEEDPROCESSINGSCHEDULE_TIME",
        )]
    pub time: String,

/// The timezone considered for the processing schedule time.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "timezone")]
    pub timezone: Nullable<String>,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGSFEEDPROCESSINGSCHEDULE_TIME: regex::Regex = regex::Regex::new(r"^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$").unwrap();
}

impl CatalogsFeedProcessingSchedule {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(time: String, timezone: Nullable<String>, ) -> CatalogsFeedProcessingSchedule {
        CatalogsFeedProcessingSchedule {
            time,
            timezone,
        }
    }
}

/// Converts the CatalogsFeedProcessingSchedule value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsFeedProcessingSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("time".to_string()),
            Some(self.time.to_string()),


            Some("timezone".to_string()),
            Some(self.timezone.as_ref().map_or("null".to_string(), |x| x.to_string())),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedProcessingSchedule value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedProcessingSchedule {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub time: Vec<String>,
            pub timezone: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedProcessingSchedule".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "time" => intermediate_rep.time.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "timezone" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedProcessingSchedule".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedProcessingSchedule".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedProcessingSchedule {
            time: intermediate_rep.time.into_iter().next().ok_or_else(|| "time missing in CatalogsFeedProcessingSchedule".to_string())?,
            timezone: std::result::Result::Err("Nullable types not supported in CatalogsFeedProcessingSchedule".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedProcessingSchedule> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedProcessingSchedule>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedProcessingSchedule>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedProcessingSchedule - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsFeedProcessingSchedule> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedProcessingSchedule as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedProcessingSchedule - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CatalogsFeedProcessingStatus {
    #[serde(rename = "COMPLETED")]
    Completed,
    #[serde(rename = "COMPLETED_EARLY")]
    CompletedEarly,
    #[serde(rename = "DISAPPROVED")]
    Disapproved,
    #[serde(rename = "FAILED")]
    Failed,
    #[serde(rename = "PROCESSING")]
    Processing,
    #[serde(rename = "QUEUED_FOR_PROCESSING")]
    QueuedForProcessing,
    #[serde(rename = "UNDER_APPEAL")]
    UnderAppeal,
    #[serde(rename = "UNDER_REVIEW")]
    UnderReview,
}

impl std::fmt::Display for CatalogsFeedProcessingStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CatalogsFeedProcessingStatus::Completed => write!(f, "COMPLETED"),
            CatalogsFeedProcessingStatus::CompletedEarly => write!(f, "COMPLETED_EARLY"),
            CatalogsFeedProcessingStatus::Disapproved => write!(f, "DISAPPROVED"),
            CatalogsFeedProcessingStatus::Failed => write!(f, "FAILED"),
            CatalogsFeedProcessingStatus::Processing => write!(f, "PROCESSING"),
            CatalogsFeedProcessingStatus::QueuedForProcessing => write!(f, "QUEUED_FOR_PROCESSING"),
            CatalogsFeedProcessingStatus::UnderAppeal => write!(f, "UNDER_APPEAL"),
            CatalogsFeedProcessingStatus::UnderReview => write!(f, "UNDER_REVIEW"),
        }
    }
}

impl std::str::FromStr for CatalogsFeedProcessingStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "COMPLETED" => std::result::Result::Ok(CatalogsFeedProcessingStatus::Completed),
            "COMPLETED_EARLY" => std::result::Result::Ok(CatalogsFeedProcessingStatus::CompletedEarly),
            "DISAPPROVED" => std::result::Result::Ok(CatalogsFeedProcessingStatus::Disapproved),
            "FAILED" => std::result::Result::Ok(CatalogsFeedProcessingStatus::Failed),
            "PROCESSING" => std::result::Result::Ok(CatalogsFeedProcessingStatus::Processing),
            "QUEUED_FOR_PROCESSING" => std::result::Result::Ok(CatalogsFeedProcessingStatus::QueuedForProcessing),
            "UNDER_APPEAL" => std::result::Result::Ok(CatalogsFeedProcessingStatus::UnderAppeal),
            "UNDER_REVIEW" => std::result::Result::Ok(CatalogsFeedProcessingStatus::UnderReview),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// The counts can be null early in the process.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedProductCounts {
/// The number of products in the feed file.
    #[serde(rename = "original")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub original: Option<i32>,

/// The number of products successfully ingested from the feed file.
    #[serde(rename = "ingested")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ingested: Option<i32>,

}


impl CatalogsFeedProductCounts {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsFeedProductCounts {
        CatalogsFeedProductCounts {
            original: None,
            ingested: None,
        }
    }
}

/// Converts the CatalogsFeedProductCounts value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsFeedProductCounts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.original.as_ref().map(|original| {
                [
                    "original".to_string(),
                    original.to_string(),
                ].join(",")
            }),


            self.ingested.as_ref().map(|ingested| {
                [
                    "ingested".to_string(),
                    ingested.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedProductCounts value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedProductCounts {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub original: Vec<i32>,
            pub ingested: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedProductCounts".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "original" => intermediate_rep.original.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ingested" => intermediate_rep.ingested.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedProductCounts".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedProductCounts {
            original: intermediate_rep.original.into_iter().next(),
            ingested: intermediate_rep.ingested.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedProductCounts> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedProductCounts>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedProductCounts>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedProductCounts - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsFeedProductCounts> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedProductCounts as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedProductCounts - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedValidationDetails {
    #[serde(rename = "errors")]
    pub errors: models::CatalogsFeedValidationErrors,

    #[serde(rename = "warnings")]
    pub warnings: models::CatalogsFeedValidationWarnings,

}


impl CatalogsFeedValidationDetails {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(errors: models::CatalogsFeedValidationErrors, warnings: models::CatalogsFeedValidationWarnings, ) -> CatalogsFeedValidationDetails {
        CatalogsFeedValidationDetails {
            errors,
            warnings,
        }
    }
}

/// Converts the CatalogsFeedValidationDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsFeedValidationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping errors in query parameter serialization

            // Skipping warnings in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedValidationDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedValidationDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub errors: Vec<models::CatalogsFeedValidationErrors>,
            pub warnings: Vec<models::CatalogsFeedValidationWarnings>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedValidationDetails".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "errors" => intermediate_rep.errors.push(<models::CatalogsFeedValidationErrors as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "warnings" => intermediate_rep.warnings.push(<models::CatalogsFeedValidationWarnings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedValidationDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedValidationDetails {
            errors: intermediate_rep.errors.into_iter().next().ok_or_else(|| "errors missing in CatalogsFeedValidationDetails".to_string())?,
            warnings: intermediate_rep.warnings.into_iter().next().ok_or_else(|| "warnings missing in CatalogsFeedValidationDetails".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedValidationDetails> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedValidationDetails>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedValidationDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedValidationDetails - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsFeedValidationDetails> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedValidationDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedValidationDetails - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedValidationErrors {
/// Pinterest couldn't download your feed.
    #[serde(rename = "FETCH_ERROR")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fetch_error: Option<i32>,

/// Your feed wasn't ingested because it hasn’t changed in the previous 90 days.
    #[serde(rename = "FETCH_INACTIVE_FEED_ERROR")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fetch_inactive_feed_error: Option<i32>,

/// Your feed includes data with an unsupported encoding format.
    #[serde(rename = "ENCODING_ERROR")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub encoding_error: Option<i32>,

/// Your feed includes data with formatting errors.
    #[serde(rename = "DELIMITER_ERROR")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delimiter_error: Option<i32>,

/// Your feed is missing some required column headers.
    #[serde(rename = "REQUIRED_COLUMNS_MISSING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_columns_missing: Option<i32>,

/// Some products are duplicated.
    #[serde(rename = "DUPLICATE_PRODUCTS")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub duplicate_products: Option<i32>,

/// Some image links are formatted incorrectly.
    #[serde(rename = "IMAGE_LINK_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_link_invalid: Option<i32>,

/// Some items are missing an item id in their product metadata, those items will not be published.
    #[serde(rename = "ITEMID_MISSING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub itemid_missing: Option<i32>,

/// Some items are missing a title in their product metadata, those items will not be published.
    #[serde(rename = "TITLE_MISSING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title_missing: Option<i32>,

/// Some items are missing a description in their product metadata, those items will not be published.
    #[serde(rename = "DESCRIPTION_MISSING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description_missing: Option<i32>,

/// Some items are missing a link URL in their product metadata, those items will not be published.
    #[serde(rename = "PRODUCT_LINK_MISSING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_link_missing: Option<i32>,

/// Some items are missing an image link URL in their product metadata, those items will not be published.
    #[serde(rename = "IMAGE_LINK_MISSING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_link_missing: Option<i32>,

/// Some items are missing an availability value in their product metadata, those items will not be published.
    #[serde(rename = "AVAILABILITY_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub availability_invalid: Option<i32>,

/// Some items have price formatting errors in their product metadata, those items will not be published.
    #[serde(rename = "PRODUCT_PRICE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_price_invalid: Option<i32>,

/// Some link values are formatted incorrectly.
    #[serde(rename = "LINK_FORMAT_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link_format_invalid: Option<i32>,

/// Your feed contains formatting errors for some items.
    #[serde(rename = "PARSE_LINE_ERROR")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parse_line_error: Option<i32>,

/// Some adwords links contain too many characters.
    #[serde(rename = "ADWORDS_FORMAT_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adwords_format_invalid: Option<i32>,

/// We experienced a technical difficulty and were unable to ingest your feed. The next ingestion will happen in 24 hours.
    #[serde(rename = "INTERNAL_SERVICE_ERROR")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub internal_service_error: Option<i32>,

/// Your merchant domain needs to be claimed.
    #[serde(rename = "NO_VERIFIED_DOMAIN")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub no_verified_domain: Option<i32>,

/// Some items have invalid adult values.
    #[serde(rename = "ADULT_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adult_invalid: Option<i32>,

/// Some items have image_link URLs that contain too many characters, so those items will not be published.
    #[serde(rename = "IMAGE_LINK_LENGTH_TOO_LONG")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_link_length_too_long: Option<i32>,

/// Some of your product link values don't match the verified domain associated with this account.
    #[serde(rename = "INVALID_DOMAIN")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub invalid_domain: Option<i32>,

/// Your feed contains too many items, some items will not be published.
    #[serde(rename = "FEED_LENGTH_TOO_LONG")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feed_length_too_long: Option<i32>,

/// Some product links contain too many characters, those items will not be published.
    #[serde(rename = "LINK_LENGTH_TOO_LONG")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link_length_too_long: Option<i32>,

/// Your feed couldn't be validated because the xml file is formatted incorrectly.
    #[serde(rename = "MALFORMED_XML")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub malformed_xml: Option<i32>,

/// Some products are missing a price, those items will not be published.
    #[serde(rename = "PRICE_MISSING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price_missing: Option<i32>,

/// Your feed couldn't be validated because the file doesn't contain the minimum number of lines required.
    #[serde(rename = "FEED_TOO_SMALL")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feed_too_small: Option<i32>,

/// Some items exceed the maximum number of items per item group, those items will not be published.
    #[serde(rename = "MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_items_per_item_group_exceeded: Option<i32>,

/// Some items' main images can't be found.
    #[serde(rename = "ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_main_image_download_failure: Option<i32>,

/// Some items were not published because they don't meet Pinterest's Merchant Guidelines.
    #[serde(rename = "PINJOIN_CONTENT_UNSAFE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pinjoin_content_unsafe: Option<i32>,

/// Some items were not published because they don't meet Pinterest's Merchant Guidelines.
    #[serde(rename = "BLOCKLISTED_IMAGE_SIGNATURE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blocklisted_image_signature: Option<i32>,

/// Some items have list price formatting errors in their product metadata, those items will not be published.
    #[serde(rename = "LIST_PRICE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub list_price_invalid: Option<i32>,

/// Some items were not published because price cannot be determined. The price, list price, and sale price are all different, so those items will not be published.
    #[serde(rename = "PRICE_CANNOT_BE_DETERMINED")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price_cannot_be_determined: Option<i32>,

}


impl CatalogsFeedValidationErrors {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsFeedValidationErrors {
        CatalogsFeedValidationErrors {
            fetch_error: None,
            fetch_inactive_feed_error: None,
            encoding_error: None,
            delimiter_error: None,
            required_columns_missing: None,
            duplicate_products: None,
            image_link_invalid: None,
            itemid_missing: None,
            title_missing: None,
            description_missing: None,
            product_link_missing: None,
            image_link_missing: None,
            availability_invalid: None,
            product_price_invalid: None,
            link_format_invalid: None,
            parse_line_error: None,
            adwords_format_invalid: None,
            internal_service_error: None,
            no_verified_domain: None,
            adult_invalid: None,
            image_link_length_too_long: None,
            invalid_domain: None,
            feed_length_too_long: None,
            link_length_too_long: None,
            malformed_xml: None,
            price_missing: None,
            feed_too_small: None,
            max_items_per_item_group_exceeded: None,
            item_main_image_download_failure: None,
            pinjoin_content_unsafe: None,
            blocklisted_image_signature: None,
            list_price_invalid: None,
            price_cannot_be_determined: None,
        }
    }
}

/// Converts the CatalogsFeedValidationErrors value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsFeedValidationErrors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.fetch_error.as_ref().map(|fetch_error| {
                [
                    "FETCH_ERROR".to_string(),
                    fetch_error.to_string(),
                ].join(",")
            }),


            self.fetch_inactive_feed_error.as_ref().map(|fetch_inactive_feed_error| {
                [
                    "FETCH_INACTIVE_FEED_ERROR".to_string(),
                    fetch_inactive_feed_error.to_string(),
                ].join(",")
            }),


            self.encoding_error.as_ref().map(|encoding_error| {
                [
                    "ENCODING_ERROR".to_string(),
                    encoding_error.to_string(),
                ].join(",")
            }),


            self.delimiter_error.as_ref().map(|delimiter_error| {
                [
                    "DELIMITER_ERROR".to_string(),
                    delimiter_error.to_string(),
                ].join(",")
            }),


            self.required_columns_missing.as_ref().map(|required_columns_missing| {
                [
                    "REQUIRED_COLUMNS_MISSING".to_string(),
                    required_columns_missing.to_string(),
                ].join(",")
            }),


            self.duplicate_products.as_ref().map(|duplicate_products| {
                [
                    "DUPLICATE_PRODUCTS".to_string(),
                    duplicate_products.to_string(),
                ].join(",")
            }),


            self.image_link_invalid.as_ref().map(|image_link_invalid| {
                [
                    "IMAGE_LINK_INVALID".to_string(),
                    image_link_invalid.to_string(),
                ].join(",")
            }),


            self.itemid_missing.as_ref().map(|itemid_missing| {
                [
                    "ITEMID_MISSING".to_string(),
                    itemid_missing.to_string(),
                ].join(",")
            }),


            self.title_missing.as_ref().map(|title_missing| {
                [
                    "TITLE_MISSING".to_string(),
                    title_missing.to_string(),
                ].join(",")
            }),


            self.description_missing.as_ref().map(|description_missing| {
                [
                    "DESCRIPTION_MISSING".to_string(),
                    description_missing.to_string(),
                ].join(",")
            }),


            self.product_link_missing.as_ref().map(|product_link_missing| {
                [
                    "PRODUCT_LINK_MISSING".to_string(),
                    product_link_missing.to_string(),
                ].join(",")
            }),


            self.image_link_missing.as_ref().map(|image_link_missing| {
                [
                    "IMAGE_LINK_MISSING".to_string(),
                    image_link_missing.to_string(),
                ].join(",")
            }),


            self.availability_invalid.as_ref().map(|availability_invalid| {
                [
                    "AVAILABILITY_INVALID".to_string(),
                    availability_invalid.to_string(),
                ].join(",")
            }),


            self.product_price_invalid.as_ref().map(|product_price_invalid| {
                [
                    "PRODUCT_PRICE_INVALID".to_string(),
                    product_price_invalid.to_string(),
                ].join(",")
            }),


            self.link_format_invalid.as_ref().map(|link_format_invalid| {
                [
                    "LINK_FORMAT_INVALID".to_string(),
                    link_format_invalid.to_string(),
                ].join(",")
            }),


            self.parse_line_error.as_ref().map(|parse_line_error| {
                [
                    "PARSE_LINE_ERROR".to_string(),
                    parse_line_error.to_string(),
                ].join(",")
            }),


            self.adwords_format_invalid.as_ref().map(|adwords_format_invalid| {
                [
                    "ADWORDS_FORMAT_INVALID".to_string(),
                    adwords_format_invalid.to_string(),
                ].join(",")
            }),


            self.internal_service_error.as_ref().map(|internal_service_error| {
                [
                    "INTERNAL_SERVICE_ERROR".to_string(),
                    internal_service_error.to_string(),
                ].join(",")
            }),


            self.no_verified_domain.as_ref().map(|no_verified_domain| {
                [
                    "NO_VERIFIED_DOMAIN".to_string(),
                    no_verified_domain.to_string(),
                ].join(",")
            }),


            self.adult_invalid.as_ref().map(|adult_invalid| {
                [
                    "ADULT_INVALID".to_string(),
                    adult_invalid.to_string(),
                ].join(",")
            }),


            self.image_link_length_too_long.as_ref().map(|image_link_length_too_long| {
                [
                    "IMAGE_LINK_LENGTH_TOO_LONG".to_string(),
                    image_link_length_too_long.to_string(),
                ].join(",")
            }),


            self.invalid_domain.as_ref().map(|invalid_domain| {
                [
                    "INVALID_DOMAIN".to_string(),
                    invalid_domain.to_string(),
                ].join(",")
            }),


            self.feed_length_too_long.as_ref().map(|feed_length_too_long| {
                [
                    "FEED_LENGTH_TOO_LONG".to_string(),
                    feed_length_too_long.to_string(),
                ].join(",")
            }),


            self.link_length_too_long.as_ref().map(|link_length_too_long| {
                [
                    "LINK_LENGTH_TOO_LONG".to_string(),
                    link_length_too_long.to_string(),
                ].join(",")
            }),


            self.malformed_xml.as_ref().map(|malformed_xml| {
                [
                    "MALFORMED_XML".to_string(),
                    malformed_xml.to_string(),
                ].join(",")
            }),


            self.price_missing.as_ref().map(|price_missing| {
                [
                    "PRICE_MISSING".to_string(),
                    price_missing.to_string(),
                ].join(",")
            }),


            self.feed_too_small.as_ref().map(|feed_too_small| {
                [
                    "FEED_TOO_SMALL".to_string(),
                    feed_too_small.to_string(),
                ].join(",")
            }),


            self.max_items_per_item_group_exceeded.as_ref().map(|max_items_per_item_group_exceeded| {
                [
                    "MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED".to_string(),
                    max_items_per_item_group_exceeded.to_string(),
                ].join(",")
            }),


            self.item_main_image_download_failure.as_ref().map(|item_main_image_download_failure| {
                [
                    "ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE".to_string(),
                    item_main_image_download_failure.to_string(),
                ].join(",")
            }),


            self.pinjoin_content_unsafe.as_ref().map(|pinjoin_content_unsafe| {
                [
                    "PINJOIN_CONTENT_UNSAFE".to_string(),
                    pinjoin_content_unsafe.to_string(),
                ].join(",")
            }),


            self.blocklisted_image_signature.as_ref().map(|blocklisted_image_signature| {
                [
                    "BLOCKLISTED_IMAGE_SIGNATURE".to_string(),
                    blocklisted_image_signature.to_string(),
                ].join(",")
            }),


            self.list_price_invalid.as_ref().map(|list_price_invalid| {
                [
                    "LIST_PRICE_INVALID".to_string(),
                    list_price_invalid.to_string(),
                ].join(",")
            }),


            self.price_cannot_be_determined.as_ref().map(|price_cannot_be_determined| {
                [
                    "PRICE_CANNOT_BE_DETERMINED".to_string(),
                    price_cannot_be_determined.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedValidationErrors value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedValidationErrors {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub fetch_error: Vec<i32>,
            pub fetch_inactive_feed_error: Vec<i32>,
            pub encoding_error: Vec<i32>,
            pub delimiter_error: Vec<i32>,
            pub required_columns_missing: Vec<i32>,
            pub duplicate_products: Vec<i32>,
            pub image_link_invalid: Vec<i32>,
            pub itemid_missing: Vec<i32>,
            pub title_missing: Vec<i32>,
            pub description_missing: Vec<i32>,
            pub product_link_missing: Vec<i32>,
            pub image_link_missing: Vec<i32>,
            pub availability_invalid: Vec<i32>,
            pub product_price_invalid: Vec<i32>,
            pub link_format_invalid: Vec<i32>,
            pub parse_line_error: Vec<i32>,
            pub adwords_format_invalid: Vec<i32>,
            pub internal_service_error: Vec<i32>,
            pub no_verified_domain: Vec<i32>,
            pub adult_invalid: Vec<i32>,
            pub image_link_length_too_long: Vec<i32>,
            pub invalid_domain: Vec<i32>,
            pub feed_length_too_long: Vec<i32>,
            pub link_length_too_long: Vec<i32>,
            pub malformed_xml: Vec<i32>,
            pub price_missing: Vec<i32>,
            pub feed_too_small: Vec<i32>,
            pub max_items_per_item_group_exceeded: Vec<i32>,
            pub item_main_image_download_failure: Vec<i32>,
            pub pinjoin_content_unsafe: Vec<i32>,
            pub blocklisted_image_signature: Vec<i32>,
            pub list_price_invalid: Vec<i32>,
            pub price_cannot_be_determined: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedValidationErrors".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "FETCH_ERROR" => intermediate_rep.fetch_error.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "FETCH_INACTIVE_FEED_ERROR" => intermediate_rep.fetch_inactive_feed_error.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ENCODING_ERROR" => intermediate_rep.encoding_error.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DELIMITER_ERROR" => intermediate_rep.delimiter_error.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "REQUIRED_COLUMNS_MISSING" => intermediate_rep.required_columns_missing.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DUPLICATE_PRODUCTS" => intermediate_rep.duplicate_products.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IMAGE_LINK_INVALID" => intermediate_rep.image_link_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ITEMID_MISSING" => intermediate_rep.itemid_missing.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "TITLE_MISSING" => intermediate_rep.title_missing.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DESCRIPTION_MISSING" => intermediate_rep.description_missing.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PRODUCT_LINK_MISSING" => intermediate_rep.product_link_missing.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IMAGE_LINK_MISSING" => intermediate_rep.image_link_missing.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AVAILABILITY_INVALID" => intermediate_rep.availability_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PRODUCT_PRICE_INVALID" => intermediate_rep.product_price_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "LINK_FORMAT_INVALID" => intermediate_rep.link_format_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PARSE_LINE_ERROR" => intermediate_rep.parse_line_error.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ADWORDS_FORMAT_INVALID" => intermediate_rep.adwords_format_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "INTERNAL_SERVICE_ERROR" => intermediate_rep.internal_service_error.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NO_VERIFIED_DOMAIN" => intermediate_rep.no_verified_domain.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ADULT_INVALID" => intermediate_rep.adult_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IMAGE_LINK_LENGTH_TOO_LONG" => intermediate_rep.image_link_length_too_long.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "INVALID_DOMAIN" => intermediate_rep.invalid_domain.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "FEED_LENGTH_TOO_LONG" => intermediate_rep.feed_length_too_long.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "LINK_LENGTH_TOO_LONG" => intermediate_rep.link_length_too_long.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MALFORMED_XML" => intermediate_rep.malformed_xml.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PRICE_MISSING" => intermediate_rep.price_missing.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "FEED_TOO_SMALL" => intermediate_rep.feed_too_small.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED" => intermediate_rep.max_items_per_item_group_exceeded.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE" => intermediate_rep.item_main_image_download_failure.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PINJOIN_CONTENT_UNSAFE" => intermediate_rep.pinjoin_content_unsafe.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "BLOCKLISTED_IMAGE_SIGNATURE" => intermediate_rep.blocklisted_image_signature.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "LIST_PRICE_INVALID" => intermediate_rep.list_price_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PRICE_CANNOT_BE_DETERMINED" => intermediate_rep.price_cannot_be_determined.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedValidationErrors".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedValidationErrors {
            fetch_error: intermediate_rep.fetch_error.into_iter().next(),
            fetch_inactive_feed_error: intermediate_rep.fetch_inactive_feed_error.into_iter().next(),
            encoding_error: intermediate_rep.encoding_error.into_iter().next(),
            delimiter_error: intermediate_rep.delimiter_error.into_iter().next(),
            required_columns_missing: intermediate_rep.required_columns_missing.into_iter().next(),
            duplicate_products: intermediate_rep.duplicate_products.into_iter().next(),
            image_link_invalid: intermediate_rep.image_link_invalid.into_iter().next(),
            itemid_missing: intermediate_rep.itemid_missing.into_iter().next(),
            title_missing: intermediate_rep.title_missing.into_iter().next(),
            description_missing: intermediate_rep.description_missing.into_iter().next(),
            product_link_missing: intermediate_rep.product_link_missing.into_iter().next(),
            image_link_missing: intermediate_rep.image_link_missing.into_iter().next(),
            availability_invalid: intermediate_rep.availability_invalid.into_iter().next(),
            product_price_invalid: intermediate_rep.product_price_invalid.into_iter().next(),
            link_format_invalid: intermediate_rep.link_format_invalid.into_iter().next(),
            parse_line_error: intermediate_rep.parse_line_error.into_iter().next(),
            adwords_format_invalid: intermediate_rep.adwords_format_invalid.into_iter().next(),
            internal_service_error: intermediate_rep.internal_service_error.into_iter().next(),
            no_verified_domain: intermediate_rep.no_verified_domain.into_iter().next(),
            adult_invalid: intermediate_rep.adult_invalid.into_iter().next(),
            image_link_length_too_long: intermediate_rep.image_link_length_too_long.into_iter().next(),
            invalid_domain: intermediate_rep.invalid_domain.into_iter().next(),
            feed_length_too_long: intermediate_rep.feed_length_too_long.into_iter().next(),
            link_length_too_long: intermediate_rep.link_length_too_long.into_iter().next(),
            malformed_xml: intermediate_rep.malformed_xml.into_iter().next(),
            price_missing: intermediate_rep.price_missing.into_iter().next(),
            feed_too_small: intermediate_rep.feed_too_small.into_iter().next(),
            max_items_per_item_group_exceeded: intermediate_rep.max_items_per_item_group_exceeded.into_iter().next(),
            item_main_image_download_failure: intermediate_rep.item_main_image_download_failure.into_iter().next(),
            pinjoin_content_unsafe: intermediate_rep.pinjoin_content_unsafe.into_iter().next(),
            blocklisted_image_signature: intermediate_rep.blocklisted_image_signature.into_iter().next(),
            list_price_invalid: intermediate_rep.list_price_invalid.into_iter().next(),
            price_cannot_be_determined: intermediate_rep.price_cannot_be_determined.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedValidationErrors> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedValidationErrors>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedValidationErrors>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedValidationErrors - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsFeedValidationErrors> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedValidationErrors as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedValidationErrors - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedValidationWarnings {
/// Some items have ad links that are formatted incorrectly.
    #[serde(rename = "AD_LINK_FORMAT_WARNING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_link_format_warning: Option<i32>,

/// Some items have ad link URLs that are duplicates of the link URLs for those items.
    #[serde(rename = "AD_LINK_SAME_AS_LINK")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_link_same_as_link: Option<i32>,

/// The title for some items were truncated because they contain too many characters.
    #[serde(rename = "TITLE_LENGTH_TOO_LONG")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title_length_too_long: Option<i32>,

/// The description for some items were truncated because they contain too many characters.
    #[serde(rename = "DESCRIPTION_LENGTH_TOO_LONG")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description_length_too_long: Option<i32>,

/// Some items have gender values that are formatted incorrectly, which may limit visibility in recommendations, search results and shopping experiences.
    #[serde(rename = "GENDER_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gender_invalid: Option<i32>,

/// Some items have age group values that are formatted incorrectly, which may limit visibility in recommendations, search results and shopping experiences.
    #[serde(rename = "AGE_GROUP_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub age_group_invalid: Option<i32>,

/// Some items have size type values that are formatted incorrectly, which may limit visibility in recommendations, search results and shopping experiences.
    #[serde(rename = "SIZE_TYPE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_type_invalid: Option<i32>,

/// Some items have size system values which are not one of the supported size systems.
    #[serde(rename = "SIZE_SYSTEM_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_system_invalid: Option<i32>,

/// Some items have an invalid product link which contains invalid UTM tracking paramaters.
    #[serde(rename = "LINK_FORMAT_WARNING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link_format_warning: Option<i32>,

/// Some items have sale price values that are higher than the original price of the item.
    #[serde(rename = "SALES_PRICE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sales_price_invalid: Option<i32>,

/// Some items only have 1 or 2 levels of google_product_category values, which may limit visibility in recommendations, search results and shopping experiences.
    #[serde(rename = "PRODUCT_CATEGORY_DEPTH_WARNING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_category_depth_warning: Option<i32>,

/// Some items have adwords_redirect links that are formatted incorrectly.
    #[serde(rename = "ADWORDS_FORMAT_WARNING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adwords_format_warning: Option<i32>,

/// Some items have adwords_redirect URLs that are duplicates of the link URLs for those items.
    #[serde(rename = "ADWORDS_SAME_AS_LINK")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adwords_same_as_link: Option<i32>,

/// Your feed contains duplicate headers.
    #[serde(rename = "DUPLICATE_HEADERS")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub duplicate_headers: Option<i32>,

/// Ingestion completed early because there are no changes to your feed since the last successful update.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "FETCH_SAME_SIGNATURE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fetch_same_signature: Option<i32>,

/// Some items have additional_image_link URLs that contain too many characters, so those items will not be published.
    #[serde(rename = "ADDITIONAL_IMAGE_LINK_LENGTH_TOO_LONG")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_image_link_length_too_long: Option<i32>,

/// Some items have additional_image_link URLs that are formatted incorrectly and will not be published with your items.
    #[serde(rename = "ADDITIONAL_IMAGE_LINK_WARNING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_image_link_warning: Option<i32>,

/// Some items have image_link URLs that are formatted incorrectly and will not be published with those items.
    #[serde(rename = "IMAGE_LINK_WARNING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_link_warning: Option<i32>,

/// Some items have shipping values that are formatted incorrectly.
    #[serde(rename = "SHIPPING_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_invalid: Option<i32>,

/// Some items have tax values that are formatted incorrectly.
    #[serde(rename = "TAX_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tax_invalid: Option<i32>,

/// Some items have invalid shipping_weight values.
    #[serde(rename = "SHIPPING_WEIGHT_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_weight_invalid: Option<i32>,

/// Some items have expiration_date values that are formatted incorrectly, those items will be published without an expiration date.
    #[serde(rename = "EXPIRATION_DATE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expiration_date_invalid: Option<i32>,

/// Some items have availability_date values that are formatted incorrectly, those items will be published without an availability date.
    #[serde(rename = "AVAILABILITY_DATE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub availability_date_invalid: Option<i32>,

/// Some items have sale_price_effective_date values that are formatted incorrectly, those items will be published without a sale date.
    #[serde(rename = "SALE_DATE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sale_date_invalid: Option<i32>,

/// Some items have weight_unit values that are formatted incorrectly, those items will be published without a weight unit.
    #[serde(rename = "WEIGHT_UNIT_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight_unit_invalid: Option<i32>,

/// Some items have is_bundle values that are formatted incorrectly, those items will be published without being bundled with other products.
    #[serde(rename = "IS_BUNDLE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_bundle_invalid: Option<i32>,

/// Some items have updated_time values thate are formatted incorrectly, those items will be published without an updated time.
    #[serde(rename = "UPDATED_TIME_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_time_invalid: Option<i32>,

/// Some items have custom_label values that are too long, those items will be published without that custom label.
    #[serde(rename = "CUSTOM_LABEL_LENGTH_TOO_LONG")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_length_too_long: Option<i32>,

/// Some items have product_type values that are too long, those items will be published without that product type.
    #[serde(rename = "PRODUCT_TYPE_LENGTH_TOO_LONG")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_type_length_too_long: Option<i32>,

/// Some items have additional_image_link values that exceed the limit for additional images, those items will be published without some of your images.
    #[serde(rename = "TOO_MANY_ADDITIONAL_IMAGE_LINKS")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub too_many_additional_image_links: Option<i32>,

/// Some items have invalid multipack values.
    #[serde(rename = "MULTIPACK_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub multipack_invalid: Option<i32>,

/// The product count has increased or decreased significantly compared to the last successful ingestion.
    #[serde(rename = "INDEXED_PRODUCT_COUNT_LARGE_DELTA")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub indexed_product_count_large_delta: Option<i32>,

/// Some items include additional_image_links that can't be found.
    #[serde(rename = "ITEM_ADDITIONAL_IMAGE_DOWNLOAD_FAILURE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_additional_image_download_failure: Option<i32>,

/// Some items are missing a google_product_category.
    #[serde(rename = "OPTIONAL_PRODUCT_CATEGORY_MISSING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional_product_category_missing: Option<i32>,

/// Some items include google_product_category values that are not formatted correctly according to the GPC taxonomy.
    #[serde(rename = "OPTIONAL_PRODUCT_CATEGORY_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional_product_category_invalid: Option<i32>,

/// Some items are missing a condition value, which may limit visibility in recommendations, search results and shopping experiences.
    #[serde(rename = "OPTIONAL_CONDITION_MISSING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional_condition_missing: Option<i32>,

/// Some items include condition values that are formatted incorrectly, which may limit visibility in recommendations, search results and shopping experiences.
    #[serde(rename = "OPTIONAL_CONDITION_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional_condition_invalid: Option<i32>,

/// Some items include invalid ios_deep_link values.
    #[serde(rename = "IOS_DEEP_LINK_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ios_deep_link_invalid: Option<i32>,

/// Some items include invalid android_deep_link.
    #[serde(rename = "ANDROID_DEEP_LINK_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub android_deep_link_invalid: Option<i32>,

/// Some items include utm_source values that are formatted incorrectly and have been automatically corrected.
    #[serde(rename = "UTM_SOURCE_AUTO_CORRECTED")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub utm_source_auto_corrected: Option<i32>,

/// Some items include a currency that doesn't match the usual currency for the location where that product is sold or shipped.
    #[serde(rename = "COUNTRY_DOES_NOT_MAP_TO_CURRENCY")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub country_does_not_map_to_currency: Option<i32>,

/// Some items include min_ad_price values that are formatted incorrectly.
    #[serde(rename = "MIN_AD_PRICE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_ad_price_invalid: Option<i32>,

/// Some items include incorrectly formatted GTINs.
    #[serde(rename = "GTIN_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gtin_invalid: Option<i32>,

/// Some items include inconsistent currencies in price fields.
    #[serde(rename = "INCONSISTENT_CURRENCY_VALUES")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub inconsistent_currency_values: Option<i32>,

/// Some items include sales price that is much lower than the list price.
    #[serde(rename = "SALES_PRICE_TOO_LOW")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sales_price_too_low: Option<i32>,

/// Some items include incorrectly formatted shipping_width.
    #[serde(rename = "SHIPPING_WIDTH_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_width_invalid: Option<i32>,

/// Some items include incorrectly formatted shipping_height.
    #[serde(rename = "SHIPPING_HEIGHT_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_height_invalid: Option<i32>,

/// Some items include a sales price that is higher than the list price. The sales price has been defaulted to the list price.
    #[serde(rename = "SALES_PRICE_TOO_HIGH")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sales_price_too_high: Option<i32>,

/// Some items include incorrectly formatted MPNs.
    #[serde(rename = "MPN_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mpn_invalid: Option<i32>,

}


impl CatalogsFeedValidationWarnings {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsFeedValidationWarnings {
        CatalogsFeedValidationWarnings {
            ad_link_format_warning: None,
            ad_link_same_as_link: None,
            title_length_too_long: None,
            description_length_too_long: None,
            gender_invalid: None,
            age_group_invalid: None,
            size_type_invalid: None,
            size_system_invalid: None,
            link_format_warning: None,
            sales_price_invalid: None,
            product_category_depth_warning: None,
            adwords_format_warning: None,
            adwords_same_as_link: None,
            duplicate_headers: None,
            fetch_same_signature: None,
            additional_image_link_length_too_long: None,
            additional_image_link_warning: None,
            image_link_warning: None,
            shipping_invalid: None,
            tax_invalid: None,
            shipping_weight_invalid: None,
            expiration_date_invalid: None,
            availability_date_invalid: None,
            sale_date_invalid: None,
            weight_unit_invalid: None,
            is_bundle_invalid: None,
            updated_time_invalid: None,
            custom_label_length_too_long: None,
            product_type_length_too_long: None,
            too_many_additional_image_links: None,
            multipack_invalid: None,
            indexed_product_count_large_delta: None,
            item_additional_image_download_failure: None,
            optional_product_category_missing: None,
            optional_product_category_invalid: None,
            optional_condition_missing: None,
            optional_condition_invalid: None,
            ios_deep_link_invalid: None,
            android_deep_link_invalid: None,
            utm_source_auto_corrected: None,
            country_does_not_map_to_currency: None,
            min_ad_price_invalid: None,
            gtin_invalid: None,
            inconsistent_currency_values: None,
            sales_price_too_low: None,
            shipping_width_invalid: None,
            shipping_height_invalid: None,
            sales_price_too_high: None,
            mpn_invalid: None,
        }
    }
}

/// Converts the CatalogsFeedValidationWarnings value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsFeedValidationWarnings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ad_link_format_warning.as_ref().map(|ad_link_format_warning| {
                [
                    "AD_LINK_FORMAT_WARNING".to_string(),
                    ad_link_format_warning.to_string(),
                ].join(",")
            }),


            self.ad_link_same_as_link.as_ref().map(|ad_link_same_as_link| {
                [
                    "AD_LINK_SAME_AS_LINK".to_string(),
                    ad_link_same_as_link.to_string(),
                ].join(",")
            }),


            self.title_length_too_long.as_ref().map(|title_length_too_long| {
                [
                    "TITLE_LENGTH_TOO_LONG".to_string(),
                    title_length_too_long.to_string(),
                ].join(",")
            }),


            self.description_length_too_long.as_ref().map(|description_length_too_long| {
                [
                    "DESCRIPTION_LENGTH_TOO_LONG".to_string(),
                    description_length_too_long.to_string(),
                ].join(",")
            }),


            self.gender_invalid.as_ref().map(|gender_invalid| {
                [
                    "GENDER_INVALID".to_string(),
                    gender_invalid.to_string(),
                ].join(",")
            }),


            self.age_group_invalid.as_ref().map(|age_group_invalid| {
                [
                    "AGE_GROUP_INVALID".to_string(),
                    age_group_invalid.to_string(),
                ].join(",")
            }),


            self.size_type_invalid.as_ref().map(|size_type_invalid| {
                [
                    "SIZE_TYPE_INVALID".to_string(),
                    size_type_invalid.to_string(),
                ].join(",")
            }),


            self.size_system_invalid.as_ref().map(|size_system_invalid| {
                [
                    "SIZE_SYSTEM_INVALID".to_string(),
                    size_system_invalid.to_string(),
                ].join(",")
            }),


            self.link_format_warning.as_ref().map(|link_format_warning| {
                [
                    "LINK_FORMAT_WARNING".to_string(),
                    link_format_warning.to_string(),
                ].join(",")
            }),


            self.sales_price_invalid.as_ref().map(|sales_price_invalid| {
                [
                    "SALES_PRICE_INVALID".to_string(),
                    sales_price_invalid.to_string(),
                ].join(",")
            }),


            self.product_category_depth_warning.as_ref().map(|product_category_depth_warning| {
                [
                    "PRODUCT_CATEGORY_DEPTH_WARNING".to_string(),
                    product_category_depth_warning.to_string(),
                ].join(",")
            }),


            self.adwords_format_warning.as_ref().map(|adwords_format_warning| {
                [
                    "ADWORDS_FORMAT_WARNING".to_string(),
                    adwords_format_warning.to_string(),
                ].join(",")
            }),


            self.adwords_same_as_link.as_ref().map(|adwords_same_as_link| {
                [
                    "ADWORDS_SAME_AS_LINK".to_string(),
                    adwords_same_as_link.to_string(),
                ].join(",")
            }),


            self.duplicate_headers.as_ref().map(|duplicate_headers| {
                [
                    "DUPLICATE_HEADERS".to_string(),
                    duplicate_headers.to_string(),
                ].join(",")
            }),


            self.fetch_same_signature.as_ref().map(|fetch_same_signature| {
                [
                    "FETCH_SAME_SIGNATURE".to_string(),
                    fetch_same_signature.to_string(),
                ].join(",")
            }),


            self.additional_image_link_length_too_long.as_ref().map(|additional_image_link_length_too_long| {
                [
                    "ADDITIONAL_IMAGE_LINK_LENGTH_TOO_LONG".to_string(),
                    additional_image_link_length_too_long.to_string(),
                ].join(",")
            }),


            self.additional_image_link_warning.as_ref().map(|additional_image_link_warning| {
                [
                    "ADDITIONAL_IMAGE_LINK_WARNING".to_string(),
                    additional_image_link_warning.to_string(),
                ].join(",")
            }),


            self.image_link_warning.as_ref().map(|image_link_warning| {
                [
                    "IMAGE_LINK_WARNING".to_string(),
                    image_link_warning.to_string(),
                ].join(",")
            }),


            self.shipping_invalid.as_ref().map(|shipping_invalid| {
                [
                    "SHIPPING_INVALID".to_string(),
                    shipping_invalid.to_string(),
                ].join(",")
            }),


            self.tax_invalid.as_ref().map(|tax_invalid| {
                [
                    "TAX_INVALID".to_string(),
                    tax_invalid.to_string(),
                ].join(",")
            }),


            self.shipping_weight_invalid.as_ref().map(|shipping_weight_invalid| {
                [
                    "SHIPPING_WEIGHT_INVALID".to_string(),
                    shipping_weight_invalid.to_string(),
                ].join(",")
            }),


            self.expiration_date_invalid.as_ref().map(|expiration_date_invalid| {
                [
                    "EXPIRATION_DATE_INVALID".to_string(),
                    expiration_date_invalid.to_string(),
                ].join(",")
            }),


            self.availability_date_invalid.as_ref().map(|availability_date_invalid| {
                [
                    "AVAILABILITY_DATE_INVALID".to_string(),
                    availability_date_invalid.to_string(),
                ].join(",")
            }),


            self.sale_date_invalid.as_ref().map(|sale_date_invalid| {
                [
                    "SALE_DATE_INVALID".to_string(),
                    sale_date_invalid.to_string(),
                ].join(",")
            }),


            self.weight_unit_invalid.as_ref().map(|weight_unit_invalid| {
                [
                    "WEIGHT_UNIT_INVALID".to_string(),
                    weight_unit_invalid.to_string(),
                ].join(",")
            }),


            self.is_bundle_invalid.as_ref().map(|is_bundle_invalid| {
                [
                    "IS_BUNDLE_INVALID".to_string(),
                    is_bundle_invalid.to_string(),
                ].join(",")
            }),


            self.updated_time_invalid.as_ref().map(|updated_time_invalid| {
                [
                    "UPDATED_TIME_INVALID".to_string(),
                    updated_time_invalid.to_string(),
                ].join(",")
            }),


            self.custom_label_length_too_long.as_ref().map(|custom_label_length_too_long| {
                [
                    "CUSTOM_LABEL_LENGTH_TOO_LONG".to_string(),
                    custom_label_length_too_long.to_string(),
                ].join(",")
            }),


            self.product_type_length_too_long.as_ref().map(|product_type_length_too_long| {
                [
                    "PRODUCT_TYPE_LENGTH_TOO_LONG".to_string(),
                    product_type_length_too_long.to_string(),
                ].join(",")
            }),


            self.too_many_additional_image_links.as_ref().map(|too_many_additional_image_links| {
                [
                    "TOO_MANY_ADDITIONAL_IMAGE_LINKS".to_string(),
                    too_many_additional_image_links.to_string(),
                ].join(",")
            }),


            self.multipack_invalid.as_ref().map(|multipack_invalid| {
                [
                    "MULTIPACK_INVALID".to_string(),
                    multipack_invalid.to_string(),
                ].join(",")
            }),


            self.indexed_product_count_large_delta.as_ref().map(|indexed_product_count_large_delta| {
                [
                    "INDEXED_PRODUCT_COUNT_LARGE_DELTA".to_string(),
                    indexed_product_count_large_delta.to_string(),
                ].join(",")
            }),


            self.item_additional_image_download_failure.as_ref().map(|item_additional_image_download_failure| {
                [
                    "ITEM_ADDITIONAL_IMAGE_DOWNLOAD_FAILURE".to_string(),
                    item_additional_image_download_failure.to_string(),
                ].join(",")
            }),


            self.optional_product_category_missing.as_ref().map(|optional_product_category_missing| {
                [
                    "OPTIONAL_PRODUCT_CATEGORY_MISSING".to_string(),
                    optional_product_category_missing.to_string(),
                ].join(",")
            }),


            self.optional_product_category_invalid.as_ref().map(|optional_product_category_invalid| {
                [
                    "OPTIONAL_PRODUCT_CATEGORY_INVALID".to_string(),
                    optional_product_category_invalid.to_string(),
                ].join(",")
            }),


            self.optional_condition_missing.as_ref().map(|optional_condition_missing| {
                [
                    "OPTIONAL_CONDITION_MISSING".to_string(),
                    optional_condition_missing.to_string(),
                ].join(",")
            }),


            self.optional_condition_invalid.as_ref().map(|optional_condition_invalid| {
                [
                    "OPTIONAL_CONDITION_INVALID".to_string(),
                    optional_condition_invalid.to_string(),
                ].join(",")
            }),


            self.ios_deep_link_invalid.as_ref().map(|ios_deep_link_invalid| {
                [
                    "IOS_DEEP_LINK_INVALID".to_string(),
                    ios_deep_link_invalid.to_string(),
                ].join(",")
            }),


            self.android_deep_link_invalid.as_ref().map(|android_deep_link_invalid| {
                [
                    "ANDROID_DEEP_LINK_INVALID".to_string(),
                    android_deep_link_invalid.to_string(),
                ].join(",")
            }),


            self.utm_source_auto_corrected.as_ref().map(|utm_source_auto_corrected| {
                [
                    "UTM_SOURCE_AUTO_CORRECTED".to_string(),
                    utm_source_auto_corrected.to_string(),
                ].join(",")
            }),


            self.country_does_not_map_to_currency.as_ref().map(|country_does_not_map_to_currency| {
                [
                    "COUNTRY_DOES_NOT_MAP_TO_CURRENCY".to_string(),
                    country_does_not_map_to_currency.to_string(),
                ].join(",")
            }),


            self.min_ad_price_invalid.as_ref().map(|min_ad_price_invalid| {
                [
                    "MIN_AD_PRICE_INVALID".to_string(),
                    min_ad_price_invalid.to_string(),
                ].join(",")
            }),


            self.gtin_invalid.as_ref().map(|gtin_invalid| {
                [
                    "GTIN_INVALID".to_string(),
                    gtin_invalid.to_string(),
                ].join(",")
            }),


            self.inconsistent_currency_values.as_ref().map(|inconsistent_currency_values| {
                [
                    "INCONSISTENT_CURRENCY_VALUES".to_string(),
                    inconsistent_currency_values.to_string(),
                ].join(",")
            }),


            self.sales_price_too_low.as_ref().map(|sales_price_too_low| {
                [
                    "SALES_PRICE_TOO_LOW".to_string(),
                    sales_price_too_low.to_string(),
                ].join(",")
            }),


            self.shipping_width_invalid.as_ref().map(|shipping_width_invalid| {
                [
                    "SHIPPING_WIDTH_INVALID".to_string(),
                    shipping_width_invalid.to_string(),
                ].join(",")
            }),


            self.shipping_height_invalid.as_ref().map(|shipping_height_invalid| {
                [
                    "SHIPPING_HEIGHT_INVALID".to_string(),
                    shipping_height_invalid.to_string(),
                ].join(",")
            }),


            self.sales_price_too_high.as_ref().map(|sales_price_too_high| {
                [
                    "SALES_PRICE_TOO_HIGH".to_string(),
                    sales_price_too_high.to_string(),
                ].join(",")
            }),


            self.mpn_invalid.as_ref().map(|mpn_invalid| {
                [
                    "MPN_INVALID".to_string(),
                    mpn_invalid.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedValidationWarnings value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedValidationWarnings {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_link_format_warning: Vec<i32>,
            pub ad_link_same_as_link: Vec<i32>,
            pub title_length_too_long: Vec<i32>,
            pub description_length_too_long: Vec<i32>,
            pub gender_invalid: Vec<i32>,
            pub age_group_invalid: Vec<i32>,
            pub size_type_invalid: Vec<i32>,
            pub size_system_invalid: Vec<i32>,
            pub link_format_warning: Vec<i32>,
            pub sales_price_invalid: Vec<i32>,
            pub product_category_depth_warning: Vec<i32>,
            pub adwords_format_warning: Vec<i32>,
            pub adwords_same_as_link: Vec<i32>,
            pub duplicate_headers: Vec<i32>,
            pub fetch_same_signature: Vec<i32>,
            pub additional_image_link_length_too_long: Vec<i32>,
            pub additional_image_link_warning: Vec<i32>,
            pub image_link_warning: Vec<i32>,
            pub shipping_invalid: Vec<i32>,
            pub tax_invalid: Vec<i32>,
            pub shipping_weight_invalid: Vec<i32>,
            pub expiration_date_invalid: Vec<i32>,
            pub availability_date_invalid: Vec<i32>,
            pub sale_date_invalid: Vec<i32>,
            pub weight_unit_invalid: Vec<i32>,
            pub is_bundle_invalid: Vec<i32>,
            pub updated_time_invalid: Vec<i32>,
            pub custom_label_length_too_long: Vec<i32>,
            pub product_type_length_too_long: Vec<i32>,
            pub too_many_additional_image_links: Vec<i32>,
            pub multipack_invalid: Vec<i32>,
            pub indexed_product_count_large_delta: Vec<i32>,
            pub item_additional_image_download_failure: Vec<i32>,
            pub optional_product_category_missing: Vec<i32>,
            pub optional_product_category_invalid: Vec<i32>,
            pub optional_condition_missing: Vec<i32>,
            pub optional_condition_invalid: Vec<i32>,
            pub ios_deep_link_invalid: Vec<i32>,
            pub android_deep_link_invalid: Vec<i32>,
            pub utm_source_auto_corrected: Vec<i32>,
            pub country_does_not_map_to_currency: Vec<i32>,
            pub min_ad_price_invalid: Vec<i32>,
            pub gtin_invalid: Vec<i32>,
            pub inconsistent_currency_values: Vec<i32>,
            pub sales_price_too_low: Vec<i32>,
            pub shipping_width_invalid: Vec<i32>,
            pub shipping_height_invalid: Vec<i32>,
            pub sales_price_too_high: Vec<i32>,
            pub mpn_invalid: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedValidationWarnings".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "AD_LINK_FORMAT_WARNING" => intermediate_rep.ad_link_format_warning.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AD_LINK_SAME_AS_LINK" => intermediate_rep.ad_link_same_as_link.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "TITLE_LENGTH_TOO_LONG" => intermediate_rep.title_length_too_long.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DESCRIPTION_LENGTH_TOO_LONG" => intermediate_rep.description_length_too_long.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GENDER_INVALID" => intermediate_rep.gender_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AGE_GROUP_INVALID" => intermediate_rep.age_group_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SIZE_TYPE_INVALID" => intermediate_rep.size_type_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SIZE_SYSTEM_INVALID" => intermediate_rep.size_system_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "LINK_FORMAT_WARNING" => intermediate_rep.link_format_warning.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SALES_PRICE_INVALID" => intermediate_rep.sales_price_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PRODUCT_CATEGORY_DEPTH_WARNING" => intermediate_rep.product_category_depth_warning.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ADWORDS_FORMAT_WARNING" => intermediate_rep.adwords_format_warning.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ADWORDS_SAME_AS_LINK" => intermediate_rep.adwords_same_as_link.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DUPLICATE_HEADERS" => intermediate_rep.duplicate_headers.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "FETCH_SAME_SIGNATURE" => intermediate_rep.fetch_same_signature.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ADDITIONAL_IMAGE_LINK_LENGTH_TOO_LONG" => intermediate_rep.additional_image_link_length_too_long.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ADDITIONAL_IMAGE_LINK_WARNING" => intermediate_rep.additional_image_link_warning.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IMAGE_LINK_WARNING" => intermediate_rep.image_link_warning.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SHIPPING_INVALID" => intermediate_rep.shipping_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "TAX_INVALID" => intermediate_rep.tax_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SHIPPING_WEIGHT_INVALID" => intermediate_rep.shipping_weight_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "EXPIRATION_DATE_INVALID" => intermediate_rep.expiration_date_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AVAILABILITY_DATE_INVALID" => intermediate_rep.availability_date_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SALE_DATE_INVALID" => intermediate_rep.sale_date_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "WEIGHT_UNIT_INVALID" => intermediate_rep.weight_unit_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IS_BUNDLE_INVALID" => intermediate_rep.is_bundle_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "UPDATED_TIME_INVALID" => intermediate_rep.updated_time_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CUSTOM_LABEL_LENGTH_TOO_LONG" => intermediate_rep.custom_label_length_too_long.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PRODUCT_TYPE_LENGTH_TOO_LONG" => intermediate_rep.product_type_length_too_long.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "TOO_MANY_ADDITIONAL_IMAGE_LINKS" => intermediate_rep.too_many_additional_image_links.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MULTIPACK_INVALID" => intermediate_rep.multipack_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "INDEXED_PRODUCT_COUNT_LARGE_DELTA" => intermediate_rep.indexed_product_count_large_delta.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ITEM_ADDITIONAL_IMAGE_DOWNLOAD_FAILURE" => intermediate_rep.item_additional_image_download_failure.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OPTIONAL_PRODUCT_CATEGORY_MISSING" => intermediate_rep.optional_product_category_missing.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OPTIONAL_PRODUCT_CATEGORY_INVALID" => intermediate_rep.optional_product_category_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OPTIONAL_CONDITION_MISSING" => intermediate_rep.optional_condition_missing.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OPTIONAL_CONDITION_INVALID" => intermediate_rep.optional_condition_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IOS_DEEP_LINK_INVALID" => intermediate_rep.ios_deep_link_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ANDROID_DEEP_LINK_INVALID" => intermediate_rep.android_deep_link_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "UTM_SOURCE_AUTO_CORRECTED" => intermediate_rep.utm_source_auto_corrected.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "COUNTRY_DOES_NOT_MAP_TO_CURRENCY" => intermediate_rep.country_does_not_map_to_currency.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MIN_AD_PRICE_INVALID" => intermediate_rep.min_ad_price_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GTIN_INVALID" => intermediate_rep.gtin_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "INCONSISTENT_CURRENCY_VALUES" => intermediate_rep.inconsistent_currency_values.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SALES_PRICE_TOO_LOW" => intermediate_rep.sales_price_too_low.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SHIPPING_WIDTH_INVALID" => intermediate_rep.shipping_width_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SHIPPING_HEIGHT_INVALID" => intermediate_rep.shipping_height_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SALES_PRICE_TOO_HIGH" => intermediate_rep.sales_price_too_high.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MPN_INVALID" => intermediate_rep.mpn_invalid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedValidationWarnings".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedValidationWarnings {
            ad_link_format_warning: intermediate_rep.ad_link_format_warning.into_iter().next(),
            ad_link_same_as_link: intermediate_rep.ad_link_same_as_link.into_iter().next(),
            title_length_too_long: intermediate_rep.title_length_too_long.into_iter().next(),
            description_length_too_long: intermediate_rep.description_length_too_long.into_iter().next(),
            gender_invalid: intermediate_rep.gender_invalid.into_iter().next(),
            age_group_invalid: intermediate_rep.age_group_invalid.into_iter().next(),
            size_type_invalid: intermediate_rep.size_type_invalid.into_iter().next(),
            size_system_invalid: intermediate_rep.size_system_invalid.into_iter().next(),
            link_format_warning: intermediate_rep.link_format_warning.into_iter().next(),
            sales_price_invalid: intermediate_rep.sales_price_invalid.into_iter().next(),
            product_category_depth_warning: intermediate_rep.product_category_depth_warning.into_iter().next(),
            adwords_format_warning: intermediate_rep.adwords_format_warning.into_iter().next(),
            adwords_same_as_link: intermediate_rep.adwords_same_as_link.into_iter().next(),
            duplicate_headers: intermediate_rep.duplicate_headers.into_iter().next(),
            fetch_same_signature: intermediate_rep.fetch_same_signature.into_iter().next(),
            additional_image_link_length_too_long: intermediate_rep.additional_image_link_length_too_long.into_iter().next(),
            additional_image_link_warning: intermediate_rep.additional_image_link_warning.into_iter().next(),
            image_link_warning: intermediate_rep.image_link_warning.into_iter().next(),
            shipping_invalid: intermediate_rep.shipping_invalid.into_iter().next(),
            tax_invalid: intermediate_rep.tax_invalid.into_iter().next(),
            shipping_weight_invalid: intermediate_rep.shipping_weight_invalid.into_iter().next(),
            expiration_date_invalid: intermediate_rep.expiration_date_invalid.into_iter().next(),
            availability_date_invalid: intermediate_rep.availability_date_invalid.into_iter().next(),
            sale_date_invalid: intermediate_rep.sale_date_invalid.into_iter().next(),
            weight_unit_invalid: intermediate_rep.weight_unit_invalid.into_iter().next(),
            is_bundle_invalid: intermediate_rep.is_bundle_invalid.into_iter().next(),
            updated_time_invalid: intermediate_rep.updated_time_invalid.into_iter().next(),
            custom_label_length_too_long: intermediate_rep.custom_label_length_too_long.into_iter().next(),
            product_type_length_too_long: intermediate_rep.product_type_length_too_long.into_iter().next(),
            too_many_additional_image_links: intermediate_rep.too_many_additional_image_links.into_iter().next(),
            multipack_invalid: intermediate_rep.multipack_invalid.into_iter().next(),
            indexed_product_count_large_delta: intermediate_rep.indexed_product_count_large_delta.into_iter().next(),
            item_additional_image_download_failure: intermediate_rep.item_additional_image_download_failure.into_iter().next(),
            optional_product_category_missing: intermediate_rep.optional_product_category_missing.into_iter().next(),
            optional_product_category_invalid: intermediate_rep.optional_product_category_invalid.into_iter().next(),
            optional_condition_missing: intermediate_rep.optional_condition_missing.into_iter().next(),
            optional_condition_invalid: intermediate_rep.optional_condition_invalid.into_iter().next(),
            ios_deep_link_invalid: intermediate_rep.ios_deep_link_invalid.into_iter().next(),
            android_deep_link_invalid: intermediate_rep.android_deep_link_invalid.into_iter().next(),
            utm_source_auto_corrected: intermediate_rep.utm_source_auto_corrected.into_iter().next(),
            country_does_not_map_to_currency: intermediate_rep.country_does_not_map_to_currency.into_iter().next(),
            min_ad_price_invalid: intermediate_rep.min_ad_price_invalid.into_iter().next(),
            gtin_invalid: intermediate_rep.gtin_invalid.into_iter().next(),
            inconsistent_currency_values: intermediate_rep.inconsistent_currency_values.into_iter().next(),
            sales_price_too_low: intermediate_rep.sales_price_too_low.into_iter().next(),
            shipping_width_invalid: intermediate_rep.shipping_width_invalid.into_iter().next(),
            shipping_height_invalid: intermediate_rep.shipping_height_invalid.into_iter().next(),
            sales_price_too_high: intermediate_rep.sales_price_too_high.into_iter().next(),
            mpn_invalid: intermediate_rep.mpn_invalid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedValidationWarnings> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedValidationWarnings>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedValidationWarnings>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedValidationWarnings - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsFeedValidationWarnings> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedValidationWarnings as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedValidationWarnings - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Request object for creating a feed. Please, be aware that \"default_country\" and \"default_locale\" are not required in the spec for forward compatibility but for now the API will not accept requests without those fields.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedsCreateRequest {
    #[serde(rename = "default_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_currency: Option<Nullable<models::NullableCurrency>>,

/// A human-friendly name associated to a given feed.
    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "format")]
    pub format: models::CatalogsFormat,

    #[serde(rename = "default_locale")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_locale: Option<models::CatalogsFeedsCreateRequestDefaultLocale>,

    #[serde(rename = "credentials")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub credentials: Option<Nullable<models::CatalogsFeedCredentials>>,

/// The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
    #[serde(rename = "location")]
    #[validate(
           regex = "RE_CATALOGSFEEDSCREATEREQUEST_LOCATION",
        )]
    pub location: String,

    #[serde(rename = "preferred_processing_schedule")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preferred_processing_schedule: Option<Nullable<models::CatalogsFeedProcessingSchedule>>,

    #[serde(rename = "default_country")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_country: Option<models::Country>,

    #[serde(rename = "default_availability")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_availability: Option<Nullable<models::ProductAvailabilityType>>,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGSFEEDSCREATEREQUEST_LOCATION: regex::Regex = regex::Regex::new(r"^(http|https|ftp|sftp)://").unwrap();
}

impl CatalogsFeedsCreateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, format: models::CatalogsFormat, location: String, ) -> CatalogsFeedsCreateRequest {
        CatalogsFeedsCreateRequest {
            default_currency: None,
            name,
            format,
            default_locale: None,
            credentials: None,
            location,
            preferred_processing_schedule: None,
            default_country: None,
            default_availability: None,
        }
    }
}

/// Converts the CatalogsFeedsCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsFeedsCreateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping default_currency in query parameter serialization


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping format in query parameter serialization

            // Skipping default_locale in query parameter serialization

            // Skipping credentials in query parameter serialization


            Some("location".to_string()),
            Some(self.location.to_string()),

            // Skipping preferred_processing_schedule in query parameter serialization

            // Skipping default_country in query parameter serialization

            // Skipping default_availability in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedsCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedsCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub default_currency: Vec<models::NullableCurrency>,
            pub name: Vec<String>,
            pub format: Vec<models::CatalogsFormat>,
            pub default_locale: Vec<models::CatalogsFeedsCreateRequestDefaultLocale>,
            pub credentials: Vec<models::CatalogsFeedCredentials>,
            pub location: Vec<String>,
            pub preferred_processing_schedule: Vec<models::CatalogsFeedProcessingSchedule>,
            pub default_country: Vec<models::Country>,
            pub default_availability: Vec<models::ProductAvailabilityType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedsCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "default_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedsCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "format" => intermediate_rep.format.push(<models::CatalogsFormat as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "default_locale" => intermediate_rep.default_locale.push(<models::CatalogsFeedsCreateRequestDefaultLocale as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "credentials" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedsCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "location" => intermediate_rep.location.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "preferred_processing_schedule" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedsCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "default_country" => intermediate_rep.default_country.push(<models::Country as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "default_availability" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedsCreateRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedsCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedsCreateRequest {
            default_currency: std::result::Result::Err("Nullable types not supported in CatalogsFeedsCreateRequest".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in CatalogsFeedsCreateRequest".to_string())?,
            format: intermediate_rep.format.into_iter().next().ok_or_else(|| "format missing in CatalogsFeedsCreateRequest".to_string())?,
            default_locale: intermediate_rep.default_locale.into_iter().next(),
            credentials: std::result::Result::Err("Nullable types not supported in CatalogsFeedsCreateRequest".to_string())?,
            location: intermediate_rep.location.into_iter().next().ok_or_else(|| "location missing in CatalogsFeedsCreateRequest".to_string())?,
            preferred_processing_schedule: std::result::Result::Err("Nullable types not supported in CatalogsFeedsCreateRequest".to_string())?,
            default_country: intermediate_rep.default_country.into_iter().next(),
            default_availability: std::result::Result::Err("Nullable types not supported in CatalogsFeedsCreateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedsCreateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedsCreateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedsCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedsCreateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsFeedsCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedsCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedsCreateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The locale used within a feed for product descriptions.

/// Any of:
/// - CatalogsLocale
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsFeedsCreateRequestDefaultLocale(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsFeedsCreateRequestDefaultLocale
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedsCreateRequestDefaultLocale value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedsCreateRequestDefaultLocale {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsFeedsCreateRequestDefaultLocale {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}






/// Request object for updating a feed.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedsUpdateRequest {
    #[serde(rename = "default_availability")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_availability: Option<Nullable<models::ProductAvailabilityType>>,

    #[serde(rename = "default_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_currency: Option<Nullable<models::NullableCurrency>>,

/// A human-friendly name associated to a given feed.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "format")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub format: Option<models::CatalogsFormat>,

    #[serde(rename = "credentials")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub credentials: Option<Nullable<models::CatalogsFeedCredentials>>,

/// The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
    #[serde(rename = "location")]
    #[validate(
           regex = "RE_CATALOGSFEEDSUPDATEREQUEST_LOCATION",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<String>,

    #[serde(rename = "preferred_processing_schedule")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preferred_processing_schedule: Option<Nullable<models::CatalogsFeedProcessingSchedule>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::CatalogsStatus>,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGSFEEDSUPDATEREQUEST_LOCATION: regex::Regex = regex::Regex::new(r"^(http|https|ftp|sftp)://").unwrap();
}

impl CatalogsFeedsUpdateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsFeedsUpdateRequest {
        CatalogsFeedsUpdateRequest {
            default_availability: None,
            default_currency: None,
            name: None,
            format: None,
            credentials: None,
            location: None,
            preferred_processing_schedule: None,
            status: None,
        }
    }
}

/// Converts the CatalogsFeedsUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsFeedsUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping default_availability in query parameter serialization

            // Skipping default_currency in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping format in query parameter serialization

            // Skipping credentials in query parameter serialization


            self.location.as_ref().map(|location| {
                [
                    "location".to_string(),
                    location.to_string(),
                ].join(",")
            }),

            // Skipping preferred_processing_schedule in query parameter serialization

            // Skipping status in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedsUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedsUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub default_availability: Vec<models::ProductAvailabilityType>,
            pub default_currency: Vec<models::NullableCurrency>,
            pub name: Vec<String>,
            pub format: Vec<models::CatalogsFormat>,
            pub credentials: Vec<models::CatalogsFeedCredentials>,
            pub location: Vec<String>,
            pub preferred_processing_schedule: Vec<models::CatalogsFeedProcessingSchedule>,
            pub status: Vec<models::CatalogsStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedsUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "default_availability" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedsUpdateRequest".to_string()),
                    "default_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedsUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "format" => intermediate_rep.format.push(<models::CatalogsFormat as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "credentials" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedsUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "location" => intermediate_rep.location.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "preferred_processing_schedule" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedsUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::CatalogsStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedsUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedsUpdateRequest {
            default_availability: std::result::Result::Err("Nullable types not supported in CatalogsFeedsUpdateRequest".to_string())?,
            default_currency: std::result::Result::Err("Nullable types not supported in CatalogsFeedsUpdateRequest".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            format: intermediate_rep.format.into_iter().next(),
            credentials: std::result::Result::Err("Nullable types not supported in CatalogsFeedsUpdateRequest".to_string())?,
            location: intermediate_rep.location.into_iter().next(),
            preferred_processing_schedule: std::result::Result::Err("Nullable types not supported in CatalogsFeedsUpdateRequest".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedsUpdateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedsUpdateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedsUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedsUpdateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsFeedsUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedsUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedsUpdateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The file format of a feed.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CatalogsFormat {
    #[serde(rename = "TSV")]
    Tsv,
    #[serde(rename = "CSV")]
    Csv,
    #[serde(rename = "XML")]
    Xml,
}

impl std::fmt::Display for CatalogsFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CatalogsFormat::Tsv => write!(f, "TSV"),
            CatalogsFormat::Csv => write!(f, "CSV"),
            CatalogsFormat::Xml => write!(f, "XML"),
        }
    }
}

impl std::str::FromStr for CatalogsFormat {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "TSV" => std::result::Result::Ok(CatalogsFormat::Tsv),
            "CSV" => std::result::Result::Ok(CatalogsFormat::Csv),
            "XML" => std::result::Result::Ok(CatalogsFormat::Xml),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsHotelAddress {
/// Primary street address of hotel.
    #[serde(rename = "addr1")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub addr1: Option<String>,

/// City where the hotel is located.
    #[serde(rename = "city")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub city: Option<String>,

/// State, county, province, where the hotel is located.
    #[serde(rename = "region")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub region: Option<String>,

/// Country where the hotel is located.
    #[serde(rename = "country")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub country: Option<String>,

/// Required for countries with a postal code system. Postal or zip code of the hotel.
    #[serde(rename = "postal_code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub postal_code: Option<String>,

}


impl CatalogsHotelAddress {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsHotelAddress {
        CatalogsHotelAddress {
            addr1: None,
            city: None,
            region: None,
            country: None,
            postal_code: None,
        }
    }
}

/// Converts the CatalogsHotelAddress value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsHotelAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.addr1.as_ref().map(|addr1| {
                [
                    "addr1".to_string(),
                    addr1.to_string(),
                ].join(",")
            }),


            self.city.as_ref().map(|city| {
                [
                    "city".to_string(),
                    city.to_string(),
                ].join(",")
            }),


            self.region.as_ref().map(|region| {
                [
                    "region".to_string(),
                    region.to_string(),
                ].join(",")
            }),


            self.country.as_ref().map(|country| {
                [
                    "country".to_string(),
                    country.to_string(),
                ].join(",")
            }),


            self.postal_code.as_ref().map(|postal_code| {
                [
                    "postal_code".to_string(),
                    postal_code.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelAddress value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelAddress {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub addr1: Vec<String>,
            pub city: Vec<String>,
            pub region: Vec<String>,
            pub country: Vec<String>,
            pub postal_code: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsHotelAddress".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "addr1" => intermediate_rep.addr1.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "city" => intermediate_rep.city.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "region" => intermediate_rep.region.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "country" => intermediate_rep.country.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "postal_code" => intermediate_rep.postal_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsHotelAddress".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsHotelAddress {
            addr1: intermediate_rep.addr1.into_iter().next(),
            city: intermediate_rep.city.into_iter().next(),
            region: intermediate_rep.region.into_iter().next(),
            country: intermediate_rep.country.into_iter().next(),
            postal_code: intermediate_rep.postal_code.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsHotelAddress> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsHotelAddress>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsHotelAddress>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsHotelAddress - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsHotelAddress> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsHotelAddress as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsHotelAddress - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsHotelAttributes {
/// The hotel's name.
    #[serde(rename = "name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

/// Link to the product page
    #[serde(rename = "link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link: Option<Nullable<String>>,

/// Brief description of the hotel.
    #[serde(rename = "description")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

/// The brand to which this hotel belongs to.
    #[serde(rename = "brand")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub brand: Option<Nullable<String>>,

/// Latitude of the hotel.
    #[serde(rename = "latitude")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub latitude: Option<f64>,

/// Longitude of the hotel.
    #[serde(rename = "longitude")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub longitude: Option<Nullable<f64>>,

/// A list of neighborhoods where the hotel is located
    #[serde(rename = "neighborhood")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub neighborhood: Option<Nullable<Vec<String>>>,

    #[serde(rename = "address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub address: Option<models::CatalogsHotelAddress>,

/// Custom grouping of hotels
    #[serde(rename = "custom_label_0")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_0: Option<Nullable<String>>,

/// Custom grouping of hotels
    #[serde(rename = "custom_label_1")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_1: Option<Nullable<String>>,

/// Custom grouping of hotels
    #[serde(rename = "custom_label_2")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_2: Option<Nullable<String>>,

/// Custom grouping of hotels
    #[serde(rename = "custom_label_3")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_3: Option<Nullable<String>>,

/// Custom grouping of hotels
    #[serde(rename = "custom_label_4")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_4: Option<Nullable<String>>,

/// The type of property. The category can be any type of internal description desired.
    #[serde(rename = "category")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<Nullable<String>>,

/// Base price of the hotel room per night followed by the ISO currency code
    #[serde(rename = "base_price")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_price: Option<Nullable<String>>,

/// Sale price of a hotel room per night. Used to advertise discounts off the regular price of the hotel.
    #[serde(rename = "sale_price")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sale_price: Option<Nullable<String>>,

    #[serde(rename = "guest_ratings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub guest_ratings: Option<models::CatalogsHotelGuestRatings>,

    #[serde(rename = "main_image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub main_image: Option<models::CatalogsHotelAttributesAllOfMainImage>,

/// <p><= 2000 characters</p> <p>The links to additional images for your hotel. Up to ten additional images can be used to show a hotel from different angles. Must begin with http:// or https://.</p>
    #[serde(rename = "additional_image_link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_image_link: Option<Nullable<Vec<String>>>,

}


impl CatalogsHotelAttributes {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsHotelAttributes {
        CatalogsHotelAttributes {
            name: None,
            link: None,
            description: None,
            brand: None,
            latitude: None,
            longitude: None,
            neighborhood: None,
            address: None,
            custom_label_0: None,
            custom_label_1: None,
            custom_label_2: None,
            custom_label_3: None,
            custom_label_4: None,
            category: None,
            base_price: None,
            sale_price: None,
            guest_ratings: None,
            main_image: None,
            additional_image_link: None,
        }
    }
}

/// Converts the CatalogsHotelAttributes value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsHotelAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.link.as_ref().map(|link| {
                [
                    "link".to_string(),
                    link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.brand.as_ref().map(|brand| {
                [
                    "brand".to_string(),
                    brand.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.latitude.as_ref().map(|latitude| {
                [
                    "latitude".to_string(),
                    latitude.to_string(),
                ].join(",")
            }),


            self.longitude.as_ref().map(|longitude| {
                [
                    "longitude".to_string(),
                    longitude.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.neighborhood.as_ref().map(|neighborhood| {
                [
                    "neighborhood".to_string(),
                    neighborhood.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping address in query parameter serialization


            self.custom_label_0.as_ref().map(|custom_label_0| {
                [
                    "custom_label_0".to_string(),
                    custom_label_0.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_1.as_ref().map(|custom_label_1| {
                [
                    "custom_label_1".to_string(),
                    custom_label_1.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_2.as_ref().map(|custom_label_2| {
                [
                    "custom_label_2".to_string(),
                    custom_label_2.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_3.as_ref().map(|custom_label_3| {
                [
                    "custom_label_3".to_string(),
                    custom_label_3.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_4.as_ref().map(|custom_label_4| {
                [
                    "custom_label_4".to_string(),
                    custom_label_4.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.category.as_ref().map(|category| {
                [
                    "category".to_string(),
                    category.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.base_price.as_ref().map(|base_price| {
                [
                    "base_price".to_string(),
                    base_price.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.sale_price.as_ref().map(|sale_price| {
                [
                    "sale_price".to_string(),
                    sale_price.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping guest_ratings in query parameter serialization

            // Skipping main_image in query parameter serialization


            self.additional_image_link.as_ref().map(|additional_image_link| {
                [
                    "additional_image_link".to_string(),
                    additional_image_link.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelAttributes value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelAttributes {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub link: Vec<String>,
            pub description: Vec<String>,
            pub brand: Vec<String>,
            pub latitude: Vec<f64>,
            pub longitude: Vec<f64>,
            pub neighborhood: Vec<Vec<String>>,
            pub address: Vec<models::CatalogsHotelAddress>,
            pub custom_label_0: Vec<String>,
            pub custom_label_1: Vec<String>,
            pub custom_label_2: Vec<String>,
            pub custom_label_3: Vec<String>,
            pub custom_label_4: Vec<String>,
            pub category: Vec<String>,
            pub base_price: Vec<String>,
            pub sale_price: Vec<String>,
            pub guest_ratings: Vec<models::CatalogsHotelGuestRatings>,
            pub main_image: Vec<models::CatalogsHotelAttributesAllOfMainImage>,
            pub additional_image_link: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsHotelAttributes".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelAttributes".to_string()),
                    "link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelAttributes".to_string()),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelAttributes".to_string()),
                    "brand" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "latitude" => intermediate_rep.latitude.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "longitude" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelAttributes".to_string()),
                    "neighborhood" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsHotelAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "address" => intermediate_rep.address.push(<models::CatalogsHotelAddress as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "custom_label_0" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelAttributes".to_string()),
                    "custom_label_1" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelAttributes".to_string()),
                    "custom_label_2" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelAttributes".to_string()),
                    "custom_label_3" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelAttributes".to_string()),
                    "custom_label_4" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelAttributes".to_string()),
                    "category" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelAttributes".to_string()),
                    "base_price" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelAttributes".to_string()),
                    "sale_price" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "guest_ratings" => intermediate_rep.guest_ratings.push(<models::CatalogsHotelGuestRatings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "main_image" => intermediate_rep.main_image.push(<models::CatalogsHotelAttributesAllOfMainImage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "additional_image_link" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsHotelAttributes".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsHotelAttributes".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsHotelAttributes {
            name: std::result::Result::Err("Nullable types not supported in CatalogsHotelAttributes".to_string())?,
            link: std::result::Result::Err("Nullable types not supported in CatalogsHotelAttributes".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in CatalogsHotelAttributes".to_string())?,
            brand: std::result::Result::Err("Nullable types not supported in CatalogsHotelAttributes".to_string())?,
            latitude: intermediate_rep.latitude.into_iter().next(),
            longitude: std::result::Result::Err("Nullable types not supported in CatalogsHotelAttributes".to_string())?,
            neighborhood: std::result::Result::Err("Nullable types not supported in CatalogsHotelAttributes".to_string())?,
            address: intermediate_rep.address.into_iter().next(),
            custom_label_0: std::result::Result::Err("Nullable types not supported in CatalogsHotelAttributes".to_string())?,
            custom_label_1: std::result::Result::Err("Nullable types not supported in CatalogsHotelAttributes".to_string())?,
            custom_label_2: std::result::Result::Err("Nullable types not supported in CatalogsHotelAttributes".to_string())?,
            custom_label_3: std::result::Result::Err("Nullable types not supported in CatalogsHotelAttributes".to_string())?,
            custom_label_4: std::result::Result::Err("Nullable types not supported in CatalogsHotelAttributes".to_string())?,
            category: std::result::Result::Err("Nullable types not supported in CatalogsHotelAttributes".to_string())?,
            base_price: std::result::Result::Err("Nullable types not supported in CatalogsHotelAttributes".to_string())?,
            sale_price: std::result::Result::Err("Nullable types not supported in CatalogsHotelAttributes".to_string())?,
            guest_ratings: intermediate_rep.guest_ratings.into_iter().next(),
            main_image: intermediate_rep.main_image.into_iter().next(),
            additional_image_link: std::result::Result::Err("Nullable types not supported in CatalogsHotelAttributes".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsHotelAttributes> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsHotelAttributes>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsHotelAttributes>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsHotelAttributes - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsHotelAttributes> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsHotelAttributes as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsHotelAttributes - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The main hotel image



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsHotelAttributesAllOfMainImage {
/// <p><= 2000 characters</p> <p>The link to the main hotel image. Image should be at least 75x75 pixels to avoid errors. Use the additional_image_link field to add more images of your hotel. The URL of your main_image.link must be accessible by the Pinterest user-agent, and send the accurate image. Please make sure there is no template or placeholder image at the link. Must start with http:// or https://.</p>
    #[serde(rename = "link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link: Option<String>,

/// Tag appended to the image that identifies image category or details. There can be multiple tags associated with an image
    #[serde(rename = "tag")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag: Option<Nullable<Vec<String>>>,

}


impl CatalogsHotelAttributesAllOfMainImage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsHotelAttributesAllOfMainImage {
        CatalogsHotelAttributesAllOfMainImage {
            link: None,
            tag: None,
        }
    }
}

/// Converts the CatalogsHotelAttributesAllOfMainImage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsHotelAttributesAllOfMainImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.link.as_ref().map(|link| {
                [
                    "link".to_string(),
                    link.to_string(),
                ].join(",")
            }),


            self.tag.as_ref().map(|tag| {
                [
                    "tag".to_string(),
                    tag.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelAttributesAllOfMainImage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelAttributesAllOfMainImage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub link: Vec<String>,
            pub tag: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsHotelAttributesAllOfMainImage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "link" => intermediate_rep.link.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tag" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsHotelAttributesAllOfMainImage".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsHotelAttributesAllOfMainImage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsHotelAttributesAllOfMainImage {
            link: intermediate_rep.link.into_iter().next(),
            tag: std::result::Result::Err("Nullable types not supported in CatalogsHotelAttributesAllOfMainImage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsHotelAttributesAllOfMainImage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsHotelAttributesAllOfMainImage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsHotelAttributesAllOfMainImage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsHotelAttributesAllOfMainImage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsHotelAttributesAllOfMainImage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsHotelAttributesAllOfMainImage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsHotelAttributesAllOfMainImage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Hotel batch item

/// Any of:
/// - CatalogsCreateHotelItem
/// - CatalogsDeleteHotelItem
/// - CatalogsUpdateHotelItem
/// - CatalogsUpsertHotelItem
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsHotelBatchItem(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsHotelBatchItem
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelBatchItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelBatchItem {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsHotelBatchItem {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}






/// Request object to update catalogs hotel items



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsHotelBatchRequest {
    #[serde(rename = "catalog_type")]
    pub catalog_type: models::CatalogsType,

    #[serde(rename = "country")]
    pub country: models::Country,

    #[serde(rename = "language")]
    pub language: models::Language,

/// Array with catalogs item operations
    #[serde(rename = "items")]
    #[validate(
            length(min = 1, max = 1000),
        )]
    pub items: Vec<models::CatalogsHotelBatchItem>,

/// Catalog id pertaining to the hotel item. If not provided, default to oldest hotel catalog
    #[serde(rename = "catalog_id")]
    #[validate(
           regex = "RE_CATALOGSHOTELBATCHREQUEST_CATALOG_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub catalog_id: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGSHOTELBATCHREQUEST_CATALOG_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CatalogsHotelBatchRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(catalog_type: models::CatalogsType, country: models::Country, language: models::Language, items: Vec<models::CatalogsHotelBatchItem>, ) -> CatalogsHotelBatchRequest {
        CatalogsHotelBatchRequest {
            catalog_type,
            country,
            language,
            items,
            catalog_id: None,
        }
    }
}

/// Converts the CatalogsHotelBatchRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsHotelBatchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping catalog_type in query parameter serialization

            // Skipping country in query parameter serialization

            // Skipping language in query parameter serialization

            // Skipping items in query parameter serialization


            self.catalog_id.as_ref().map(|catalog_id| {
                [
                    "catalog_id".to_string(),
                    catalog_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelBatchRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelBatchRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub catalog_type: Vec<models::CatalogsType>,
            pub country: Vec<models::Country>,
            pub language: Vec<models::Language>,
            pub items: Vec<Vec<models::CatalogsHotelBatchItem>>,
            pub catalog_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsHotelBatchRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<models::CatalogsType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "country" => intermediate_rep.country.push(<models::Country as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::Language as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsHotelBatchRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "catalog_id" => intermediate_rep.catalog_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsHotelBatchRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsHotelBatchRequest {
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsHotelBatchRequest".to_string())?,
            country: intermediate_rep.country.into_iter().next().ok_or_else(|| "country missing in CatalogsHotelBatchRequest".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in CatalogsHotelBatchRequest".to_string())?,
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in CatalogsHotelBatchRequest".to_string())?,
            catalog_id: intermediate_rep.catalog_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsHotelBatchRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsHotelBatchRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsHotelBatchRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsHotelBatchRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsHotelBatchRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsHotelBatchRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsHotelBatchRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Catalogs Hotel Feed object



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsHotelFeed {
    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "updated_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

/// A human-friendly name associated to a given feed. This value is currently nullable due to historical reasons. It is expected to become non-nullable in the future.
    #[serde(rename = "name")]
    pub name: Nullable<String>,

    #[serde(rename = "format")]
    pub format: models::CatalogsFormat,

    #[serde(rename = "catalog_type")]
    pub catalog_type: models::CatalogsType,

    #[serde(rename = "credentials")]
    pub credentials: Nullable<models::CatalogsFeedCredentials>,

/// The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
    #[serde(rename = "location")]
    pub location: String,

    #[serde(rename = "preferred_processing_schedule")]
    pub preferred_processing_schedule: Nullable<models::CatalogsFeedProcessingSchedule>,

    #[serde(rename = "status")]
    pub status: models::CatalogsStatus,

    #[serde(rename = "default_currency")]
    pub default_currency: Nullable<models::NullableCurrency>,

/// The locale used within a feed for product descriptions.
    #[serde(rename = "default_locale")]
    pub default_locale: String,

/// Catalog id pertaining to the feed. If not provided, feed will use a default catalog based on type.
    #[serde(rename = "catalog_id")]
    #[validate(
           regex = "RE_CATALOGSHOTELFEED_CATALOG_ID",
        )]
    pub catalog_id: Nullable<String>,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGSHOTELFEED_CATALOG_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CatalogsHotelFeed {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: Nullable<String>, format: models::CatalogsFormat, catalog_type: models::CatalogsType, credentials: Nullable<models::CatalogsFeedCredentials>, location: String, preferred_processing_schedule: Nullable<models::CatalogsFeedProcessingSchedule>, status: models::CatalogsStatus, default_currency: Nullable<models::NullableCurrency>, default_locale: String, catalog_id: Nullable<String>, ) -> CatalogsHotelFeed {
        CatalogsHotelFeed {
            created_at: None,
            id: None,
            updated_at: None,
            name,
            format,
            catalog_type,
            credentials,
            location,
            preferred_processing_schedule,
            status,
            default_currency,
            default_locale,
            catalog_id,
        }
    }
}

/// Converts the CatalogsHotelFeed value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsHotelFeed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping created_at in query parameter serialization


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping updated_at in query parameter serialization


            Some("name".to_string()),
            Some(self.name.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping format in query parameter serialization

            // Skipping catalog_type in query parameter serialization

            // Skipping credentials in query parameter serialization


            Some("location".to_string()),
            Some(self.location.to_string()),

            // Skipping preferred_processing_schedule in query parameter serialization

            // Skipping status in query parameter serialization

            // Skipping default_currency in query parameter serialization


            Some("default_locale".to_string()),
            Some(self.default_locale.to_string()),


            Some("catalog_id".to_string()),
            Some(self.catalog_id.as_ref().map_or("null".to_string(), |x| x.to_string())),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelFeed value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelFeed {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub id: Vec<String>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub name: Vec<String>,
            pub format: Vec<models::CatalogsFormat>,
            pub catalog_type: Vec<models::CatalogsType>,
            pub credentials: Vec<models::CatalogsFeedCredentials>,
            pub location: Vec<String>,
            pub preferred_processing_schedule: Vec<models::CatalogsFeedProcessingSchedule>,
            pub status: Vec<models::CatalogsStatus>,
            pub default_currency: Vec<models::NullableCurrency>,
            pub default_locale: Vec<String>,
            pub catalog_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsHotelFeed".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updated_at" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelFeed".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "format" => intermediate_rep.format.push(<models::CatalogsFormat as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<models::CatalogsType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "credentials" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelFeed".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "location" => intermediate_rep.location.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "preferred_processing_schedule" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelFeed".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::CatalogsStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "default_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelFeed".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "default_locale" => intermediate_rep.default_locale.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "catalog_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelFeed".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsHotelFeed".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsHotelFeed {
            created_at: intermediate_rep.created_at.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            name: std::result::Result::Err("Nullable types not supported in CatalogsHotelFeed".to_string())?,
            format: intermediate_rep.format.into_iter().next().ok_or_else(|| "format missing in CatalogsHotelFeed".to_string())?,
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsHotelFeed".to_string())?,
            credentials: std::result::Result::Err("Nullable types not supported in CatalogsHotelFeed".to_string())?,
            location: intermediate_rep.location.into_iter().next().ok_or_else(|| "location missing in CatalogsHotelFeed".to_string())?,
            preferred_processing_schedule: std::result::Result::Err("Nullable types not supported in CatalogsHotelFeed".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in CatalogsHotelFeed".to_string())?,
            default_currency: std::result::Result::Err("Nullable types not supported in CatalogsHotelFeed".to_string())?,
            default_locale: intermediate_rep.default_locale.into_iter().next().ok_or_else(|| "default_locale missing in CatalogsHotelFeed".to_string())?,
            catalog_id: std::result::Result::Err("Nullable types not supported in CatalogsHotelFeed".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsHotelFeed> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsHotelFeed>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsHotelFeed>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsHotelFeed - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsHotelFeed> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsHotelFeed as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsHotelFeed - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Request object for creating a feed. Please, be aware that \"default_country\" and \"default_locale\" are not required in the spec for forward compatibility but for now the API will not accept requests without those fields.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsHotelFeedsCreateRequest {
    #[serde(rename = "default_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_currency: Option<Nullable<models::NullableCurrency>>,

/// A human-friendly name associated to a given feed.
    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "format")]
    pub format: models::CatalogsFormat,

    #[serde(rename = "default_locale")]
    pub default_locale: models::CatalogsFeedsCreateRequestDefaultLocale,

    #[serde(rename = "credentials")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub credentials: Option<Nullable<models::CatalogsFeedCredentials>>,

/// The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
    #[serde(rename = "location")]
    #[validate(
           regex = "RE_CATALOGSHOTELFEEDSCREATEREQUEST_LOCATION",
        )]
    pub location: String,

    #[serde(rename = "preferred_processing_schedule")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preferred_processing_schedule: Option<Nullable<models::CatalogsFeedProcessingSchedule>>,

    #[serde(rename = "catalog_type")]
    pub catalog_type: models::CatalogsType,

/// Catalog id pertaining to the feed. If not provided, feed will use a default catalog based on type. At the moment a catalog can not have multiple hotel feeds but this will change in the future.
    #[serde(rename = "catalog_id")]
    #[validate(
           regex = "RE_CATALOGSHOTELFEEDSCREATEREQUEST_CATALOG_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub catalog_id: Option<Nullable<String>>,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGSHOTELFEEDSCREATEREQUEST_LOCATION: regex::Regex = regex::Regex::new(r"^(http|https|ftp|sftp)://").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_CATALOGSHOTELFEEDSCREATEREQUEST_CATALOG_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CatalogsHotelFeedsCreateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, format: models::CatalogsFormat, default_locale: models::CatalogsFeedsCreateRequestDefaultLocale, location: String, catalog_type: models::CatalogsType, ) -> CatalogsHotelFeedsCreateRequest {
        CatalogsHotelFeedsCreateRequest {
            default_currency: None,
            name,
            format,
            default_locale,
            credentials: None,
            location,
            preferred_processing_schedule: None,
            catalog_type,
            catalog_id: None,
        }
    }
}

/// Converts the CatalogsHotelFeedsCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsHotelFeedsCreateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping default_currency in query parameter serialization


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping format in query parameter serialization

            // Skipping default_locale in query parameter serialization

            // Skipping credentials in query parameter serialization


            Some("location".to_string()),
            Some(self.location.to_string()),

            // Skipping preferred_processing_schedule in query parameter serialization

            // Skipping catalog_type in query parameter serialization


            self.catalog_id.as_ref().map(|catalog_id| {
                [
                    "catalog_id".to_string(),
                    catalog_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelFeedsCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelFeedsCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub default_currency: Vec<models::NullableCurrency>,
            pub name: Vec<String>,
            pub format: Vec<models::CatalogsFormat>,
            pub default_locale: Vec<models::CatalogsFeedsCreateRequestDefaultLocale>,
            pub credentials: Vec<models::CatalogsFeedCredentials>,
            pub location: Vec<String>,
            pub preferred_processing_schedule: Vec<models::CatalogsFeedProcessingSchedule>,
            pub catalog_type: Vec<models::CatalogsType>,
            pub catalog_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsHotelFeedsCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "default_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelFeedsCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "format" => intermediate_rep.format.push(<models::CatalogsFormat as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "default_locale" => intermediate_rep.default_locale.push(<models::CatalogsFeedsCreateRequestDefaultLocale as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "credentials" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelFeedsCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "location" => intermediate_rep.location.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "preferred_processing_schedule" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelFeedsCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<models::CatalogsType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "catalog_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelFeedsCreateRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsHotelFeedsCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsHotelFeedsCreateRequest {
            default_currency: std::result::Result::Err("Nullable types not supported in CatalogsHotelFeedsCreateRequest".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in CatalogsHotelFeedsCreateRequest".to_string())?,
            format: intermediate_rep.format.into_iter().next().ok_or_else(|| "format missing in CatalogsHotelFeedsCreateRequest".to_string())?,
            default_locale: intermediate_rep.default_locale.into_iter().next().ok_or_else(|| "default_locale missing in CatalogsHotelFeedsCreateRequest".to_string())?,
            credentials: std::result::Result::Err("Nullable types not supported in CatalogsHotelFeedsCreateRequest".to_string())?,
            location: intermediate_rep.location.into_iter().next().ok_or_else(|| "location missing in CatalogsHotelFeedsCreateRequest".to_string())?,
            preferred_processing_schedule: std::result::Result::Err("Nullable types not supported in CatalogsHotelFeedsCreateRequest".to_string())?,
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsHotelFeedsCreateRequest".to_string())?,
            catalog_id: std::result::Result::Err("Nullable types not supported in CatalogsHotelFeedsCreateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsHotelFeedsCreateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsHotelFeedsCreateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsHotelFeedsCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsHotelFeedsCreateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsHotelFeedsCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsHotelFeedsCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsHotelFeedsCreateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Request object for updating a feed.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsHotelFeedsUpdateRequest {
    #[serde(rename = "default_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_currency: Option<Nullable<models::NullableCurrency>>,

/// A human-friendly name associated to a given feed.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "format")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub format: Option<models::CatalogsFormat>,

    #[serde(rename = "credentials")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub credentials: Option<Nullable<models::CatalogsFeedCredentials>>,

/// The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
    #[serde(rename = "location")]
    #[validate(
           regex = "RE_CATALOGSHOTELFEEDSUPDATEREQUEST_LOCATION",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<String>,

    #[serde(rename = "preferred_processing_schedule")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preferred_processing_schedule: Option<Nullable<models::CatalogsFeedProcessingSchedule>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::CatalogsStatus>,

    #[serde(rename = "catalog_type")]
    pub catalog_type: models::CatalogsType,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGSHOTELFEEDSUPDATEREQUEST_LOCATION: regex::Regex = regex::Regex::new(r"^(http|https|ftp|sftp)://").unwrap();
}

impl CatalogsHotelFeedsUpdateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(catalog_type: models::CatalogsType, ) -> CatalogsHotelFeedsUpdateRequest {
        CatalogsHotelFeedsUpdateRequest {
            default_currency: None,
            name: None,
            format: None,
            credentials: None,
            location: None,
            preferred_processing_schedule: None,
            status: None,
            catalog_type,
        }
    }
}

/// Converts the CatalogsHotelFeedsUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsHotelFeedsUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping default_currency in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping format in query parameter serialization

            // Skipping credentials in query parameter serialization


            self.location.as_ref().map(|location| {
                [
                    "location".to_string(),
                    location.to_string(),
                ].join(",")
            }),

            // Skipping preferred_processing_schedule in query parameter serialization

            // Skipping status in query parameter serialization

            // Skipping catalog_type in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelFeedsUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelFeedsUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub default_currency: Vec<models::NullableCurrency>,
            pub name: Vec<String>,
            pub format: Vec<models::CatalogsFormat>,
            pub credentials: Vec<models::CatalogsFeedCredentials>,
            pub location: Vec<String>,
            pub preferred_processing_schedule: Vec<models::CatalogsFeedProcessingSchedule>,
            pub status: Vec<models::CatalogsStatus>,
            pub catalog_type: Vec<models::CatalogsType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsHotelFeedsUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "default_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelFeedsUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "format" => intermediate_rep.format.push(<models::CatalogsFormat as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "credentials" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelFeedsUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "location" => intermediate_rep.location.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "preferred_processing_schedule" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelFeedsUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::CatalogsStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<models::CatalogsType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsHotelFeedsUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsHotelFeedsUpdateRequest {
            default_currency: std::result::Result::Err("Nullable types not supported in CatalogsHotelFeedsUpdateRequest".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            format: intermediate_rep.format.into_iter().next(),
            credentials: std::result::Result::Err("Nullable types not supported in CatalogsHotelFeedsUpdateRequest".to_string())?,
            location: intermediate_rep.location.into_iter().next(),
            preferred_processing_schedule: std::result::Result::Err("Nullable types not supported in CatalogsHotelFeedsUpdateRequest".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsHotelFeedsUpdateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsHotelFeedsUpdateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsHotelFeedsUpdateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsHotelFeedsUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsHotelFeedsUpdateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsHotelFeedsUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsHotelFeedsUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsHotelFeedsUpdateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// If specified, you must provide all properties



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsHotelGuestRatings {
/// Your hotel's rating.
    #[serde(rename = "score")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub score: Option<f64>,

/// Total number of people who have rated this hotel.
    #[serde(rename = "number_of_reviewers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub number_of_reviewers: Option<i32>,

/// Max value for the hotel rating score.
    #[serde(rename = "max_score")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_score: Option<f64>,

/// System you use for guest reviews.
    #[serde(rename = "rating_system")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rating_system: Option<String>,

}


impl CatalogsHotelGuestRatings {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsHotelGuestRatings {
        CatalogsHotelGuestRatings {
            score: None,
            number_of_reviewers: None,
            max_score: None,
            rating_system: None,
        }
    }
}

/// Converts the CatalogsHotelGuestRatings value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsHotelGuestRatings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.score.as_ref().map(|score| {
                [
                    "score".to_string(),
                    score.to_string(),
                ].join(",")
            }),


            self.number_of_reviewers.as_ref().map(|number_of_reviewers| {
                [
                    "number_of_reviewers".to_string(),
                    number_of_reviewers.to_string(),
                ].join(",")
            }),


            self.max_score.as_ref().map(|max_score| {
                [
                    "max_score".to_string(),
                    max_score.to_string(),
                ].join(",")
            }),


            self.rating_system.as_ref().map(|rating_system| {
                [
                    "rating_system".to_string(),
                    rating_system.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelGuestRatings value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelGuestRatings {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub score: Vec<f64>,
            pub number_of_reviewers: Vec<i32>,
            pub max_score: Vec<f64>,
            pub rating_system: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsHotelGuestRatings".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "score" => intermediate_rep.score.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "number_of_reviewers" => intermediate_rep.number_of_reviewers.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_score" => intermediate_rep.max_score.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rating_system" => intermediate_rep.rating_system.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsHotelGuestRatings".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsHotelGuestRatings {
            score: intermediate_rep.score.into_iter().next(),
            number_of_reviewers: intermediate_rep.number_of_reviewers.into_iter().next(),
            max_score: intermediate_rep.max_score.into_iter().next(),
            rating_system: intermediate_rep.rating_system.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsHotelGuestRatings> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsHotelGuestRatings>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsHotelGuestRatings>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsHotelGuestRatings - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsHotelGuestRatings> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsHotelGuestRatings as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsHotelGuestRatings - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object describing a hotel item error



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsHotelItemErrorResponse {
    #[serde(rename = "catalog_type")]
    pub catalog_type: models::CatalogsType,

/// The catalog hotel id in the merchant namespace
    #[serde(rename = "hotel_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hotel_id: Option<String>,

/// Array with the errors for the item id requested
    #[serde(rename = "errors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<models::ItemValidationEvent>>,

}


impl CatalogsHotelItemErrorResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(catalog_type: models::CatalogsType, ) -> CatalogsHotelItemErrorResponse {
        CatalogsHotelItemErrorResponse {
            catalog_type,
            hotel_id: None,
            errors: None,
        }
    }
}

/// Converts the CatalogsHotelItemErrorResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsHotelItemErrorResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping catalog_type in query parameter serialization


            self.hotel_id.as_ref().map(|hotel_id| {
                [
                    "hotel_id".to_string(),
                    hotel_id.to_string(),
                ].join(",")
            }),

            // Skipping errors in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelItemErrorResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelItemErrorResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub catalog_type: Vec<models::CatalogsType>,
            pub hotel_id: Vec<String>,
            pub errors: Vec<Vec<models::ItemValidationEvent>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsHotelItemErrorResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<models::CatalogsType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hotel_id" => intermediate_rep.hotel_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsHotelItemErrorResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsHotelItemErrorResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsHotelItemErrorResponse {
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsHotelItemErrorResponse".to_string())?,
            hotel_id: intermediate_rep.hotel_id.into_iter().next(),
            errors: intermediate_rep.errors.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsHotelItemErrorResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsHotelItemErrorResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsHotelItemErrorResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsHotelItemErrorResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsHotelItemErrorResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsHotelItemErrorResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsHotelItemErrorResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object describing a hotel record



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsHotelItemResponse {
    #[serde(rename = "catalog_type")]
    pub catalog_type: models::CatalogsType,

/// The catalog hotel id in the merchant namespace
    #[serde(rename = "hotel_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hotel_id: Option<String>,

/// The pins mapped to the item
    #[serde(rename = "pins")]
    #[validate(
            length(max = 11),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pins: Option<Nullable<Vec<models::Pin>>>,

    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attributes: Option<models::CatalogsHotelAttributes>,

}


impl CatalogsHotelItemResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(catalog_type: models::CatalogsType, ) -> CatalogsHotelItemResponse {
        CatalogsHotelItemResponse {
            catalog_type,
            hotel_id: None,
            pins: None,
            attributes: None,
        }
    }
}

/// Converts the CatalogsHotelItemResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsHotelItemResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping catalog_type in query parameter serialization


            self.hotel_id.as_ref().map(|hotel_id| {
                [
                    "hotel_id".to_string(),
                    hotel_id.to_string(),
                ].join(",")
            }),

            // Skipping pins in query parameter serialization

            // Skipping attributes in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelItemResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelItemResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub catalog_type: Vec<models::CatalogsType>,
            pub hotel_id: Vec<String>,
            pub pins: Vec<Vec<models::Pin>>,
            pub attributes: Vec<models::CatalogsHotelAttributes>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsHotelItemResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<models::CatalogsType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hotel_id" => intermediate_rep.hotel_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pins" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsHotelItemResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "attributes" => intermediate_rep.attributes.push(<models::CatalogsHotelAttributes as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsHotelItemResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsHotelItemResponse {
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsHotelItemResponse".to_string())?,
            hotel_id: intermediate_rep.hotel_id.into_iter().next(),
            pins: std::result::Result::Err("Nullable types not supported in CatalogsHotelItemResponse".to_string())?,
            attributes: intermediate_rep.attributes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsHotelItemResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsHotelItemResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsHotelItemResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsHotelItemResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsHotelItemResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsHotelItemResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsHotelItemResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object describing the catalogs hotel items batch



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsHotelItemsBatch {
/// Id of the catalogs items batch
    #[serde(rename = "batch_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub batch_id: Option<String>,

/// Time of the batch creation: YYYY-MM-DD'T'hh:mm:ssTZD
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<chrono::DateTime::<chrono::Utc>>,

/// Time of the batch completion: YYYY-MM-DD'T'hh:mm:ssTZD
    #[serde(rename = "completed_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_time: Option<Nullable<chrono::DateTime::<chrono::Utc>>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::BatchOperationStatus>,

    #[serde(rename = "catalog_type")]
    pub catalog_type: models::CatalogsType,

/// Array with the catalogs items processing records part of the catalogs items batch
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::HotelProcessingRecord>>,

}


impl CatalogsHotelItemsBatch {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(catalog_type: models::CatalogsType, ) -> CatalogsHotelItemsBatch {
        CatalogsHotelItemsBatch {
            batch_id: None,
            created_time: None,
            completed_time: None,
            status: None,
            catalog_type,
            items: None,
        }
    }
}

/// Converts the CatalogsHotelItemsBatch value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsHotelItemsBatch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.batch_id.as_ref().map(|batch_id| {
                [
                    "batch_id".to_string(),
                    batch_id.to_string(),
                ].join(",")
            }),

            // Skipping created_time in query parameter serialization

            // Skipping completed_time in query parameter serialization

            // Skipping status in query parameter serialization

            // Skipping catalog_type in query parameter serialization

            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelItemsBatch value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelItemsBatch {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub batch_id: Vec<String>,
            pub created_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub completed_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub status: Vec<models::BatchOperationStatus>,
            pub catalog_type: Vec<models::CatalogsType>,
            pub items: Vec<Vec<models::HotelProcessingRecord>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsHotelItemsBatch".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "batch_id" => intermediate_rep.batch_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_time" => intermediate_rep.created_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "completed_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelItemsBatch".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::BatchOperationStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<models::CatalogsType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsHotelItemsBatch".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsHotelItemsBatch".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsHotelItemsBatch {
            batch_id: intermediate_rep.batch_id.into_iter().next(),
            created_time: intermediate_rep.created_time.into_iter().next(),
            completed_time: std::result::Result::Err("Nullable types not supported in CatalogsHotelItemsBatch".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsHotelItemsBatch".to_string())?,
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsHotelItemsBatch> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsHotelItemsBatch>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsHotelItemsBatch>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsHotelItemsBatch - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsHotelItemsBatch> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsHotelItemsBatch as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsHotelItemsBatch - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsHotelItemsFilter {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "catalog_type")]
    pub catalog_type: String,

    #[serde(rename = "hotel_ids")]
    #[validate(
            length(min = 1, max = 100),
        )]
    pub hotel_ids: Vec<String>,

/// Catalog id pertaining to the hotel item. If not provided, default to oldest hotel catalog
    #[serde(rename = "catalog_id")]
    #[validate(
           regex = "RE_CATALOGSHOTELITEMSFILTER_CATALOG_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub catalog_id: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGSHOTELITEMSFILTER_CATALOG_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CatalogsHotelItemsFilter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(catalog_type: String, hotel_ids: Vec<String>, ) -> CatalogsHotelItemsFilter {
        CatalogsHotelItemsFilter {
            catalog_type,
            hotel_ids,
            catalog_id: None,
        }
    }
}

/// Converts the CatalogsHotelItemsFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsHotelItemsFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("catalog_type".to_string()),
            Some(self.catalog_type.to_string()),


            Some("hotel_ids".to_string()),
            Some(self.hotel_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            self.catalog_id.as_ref().map(|catalog_id| {
                [
                    "catalog_id".to_string(),
                    catalog_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelItemsFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelItemsFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub catalog_type: Vec<String>,
            pub hotel_ids: Vec<Vec<String>>,
            pub catalog_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsHotelItemsFilter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "hotel_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsHotelItemsFilter".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "catalog_id" => intermediate_rep.catalog_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsHotelItemsFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsHotelItemsFilter {
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsHotelItemsFilter".to_string())?,
            hotel_ids: intermediate_rep.hotel_ids.into_iter().next().ok_or_else(|| "hotel_ids missing in CatalogsHotelItemsFilter".to_string())?,
            catalog_id: intermediate_rep.catalog_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsHotelItemsFilter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsHotelItemsFilter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsHotelItemsFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsHotelItemsFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsHotelItemsFilter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsHotelItemsFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsHotelItemsFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsHotelProductGroup {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "catalog_type")]
    pub catalog_type: String,

/// ID of the hotel product group.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_CATALOGSHOTELPRODUCTGROUP_ID",
        )]
    pub id: String,

/// Name of hotel product group
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

    #[serde(rename = "filters")]
    pub filters: models::CatalogsHotelProductGroupFilters,

/// Unix timestamp in seconds of when catalog product group was created.
    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<i32>,

/// Unix timestamp in seconds of last time catalog product group was updated.
    #[serde(rename = "updated_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<i32>,

    #[serde(rename = "catalog_id")]
    #[validate(
           regex = "RE_CATALOGSHOTELPRODUCTGROUP_CATALOG_ID",
        )]
    pub catalog_id: String,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGSHOTELPRODUCTGROUP_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_CATALOGSHOTELPRODUCTGROUP_CATALOG_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CatalogsHotelProductGroup {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(catalog_type: String, id: String, filters: models::CatalogsHotelProductGroupFilters, catalog_id: String, ) -> CatalogsHotelProductGroup {
        CatalogsHotelProductGroup {
            catalog_type,
            id,
            name: None,
            description: None,
            filters,
            created_at: None,
            updated_at: None,
            catalog_id,
        }
    }
}

/// Converts the CatalogsHotelProductGroup value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsHotelProductGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("catalog_type".to_string()),
            Some(self.catalog_type.to_string()),


            Some("id".to_string()),
            Some(self.id.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping filters in query parameter serialization


            self.created_at.as_ref().map(|created_at| {
                [
                    "created_at".to_string(),
                    created_at.to_string(),
                ].join(",")
            }),


            self.updated_at.as_ref().map(|updated_at| {
                [
                    "updated_at".to_string(),
                    updated_at.to_string(),
                ].join(",")
            }),


            Some("catalog_id".to_string()),
            Some(self.catalog_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelProductGroup value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelProductGroup {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub catalog_type: Vec<String>,
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub filters: Vec<models::CatalogsHotelProductGroupFilters>,
            pub created_at: Vec<i32>,
            pub updated_at: Vec<i32>,
            pub catalog_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsHotelProductGroup".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelProductGroup".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "filters" => intermediate_rep.filters.push(<models::CatalogsHotelProductGroupFilters as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updated_at" => intermediate_rep.updated_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "catalog_id" => intermediate_rep.catalog_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsHotelProductGroup".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsHotelProductGroup {
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsHotelProductGroup".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in CatalogsHotelProductGroup".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            description: std::result::Result::Err("Nullable types not supported in CatalogsHotelProductGroup".to_string())?,
            filters: intermediate_rep.filters.into_iter().next().ok_or_else(|| "filters missing in CatalogsHotelProductGroup".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            catalog_id: intermediate_rep.catalog_id.into_iter().next().ok_or_else(|| "catalog_id missing in CatalogsHotelProductGroup".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsHotelProductGroup> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsHotelProductGroup>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsHotelProductGroup>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsHotelProductGroup - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsHotelProductGroup> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsHotelProductGroup as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsHotelProductGroup - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Request object for creating a hotel product group.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsHotelProductGroupCreateRequest {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "catalog_type")]
    pub catalog_type: String,

    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

    #[serde(rename = "filters")]
    pub filters: models::CatalogsHotelProductGroupFilters,

/// Catalog id pertaining to the hotel product group.
    #[serde(rename = "catalog_id")]
    #[validate(
           regex = "RE_CATALOGSHOTELPRODUCTGROUPCREATEREQUEST_CATALOG_ID",
        )]
    pub catalog_id: String,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGSHOTELPRODUCTGROUPCREATEREQUEST_CATALOG_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CatalogsHotelProductGroupCreateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(catalog_type: String, name: String, filters: models::CatalogsHotelProductGroupFilters, catalog_id: String, ) -> CatalogsHotelProductGroupCreateRequest {
        CatalogsHotelProductGroupCreateRequest {
            catalog_type,
            name,
            description: None,
            filters,
            catalog_id,
        }
    }
}

/// Converts the CatalogsHotelProductGroupCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsHotelProductGroupCreateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("catalog_type".to_string()),
            Some(self.catalog_type.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping filters in query parameter serialization


            Some("catalog_id".to_string()),
            Some(self.catalog_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelProductGroupCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelProductGroupCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub catalog_type: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub filters: Vec<models::CatalogsHotelProductGroupFilters>,
            pub catalog_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsHotelProductGroupCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelProductGroupCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "filters" => intermediate_rep.filters.push(<models::CatalogsHotelProductGroupFilters as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "catalog_id" => intermediate_rep.catalog_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsHotelProductGroupCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsHotelProductGroupCreateRequest {
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsHotelProductGroupCreateRequest".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in CatalogsHotelProductGroupCreateRequest".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in CatalogsHotelProductGroupCreateRequest".to_string())?,
            filters: intermediate_rep.filters.into_iter().next().ok_or_else(|| "filters missing in CatalogsHotelProductGroupCreateRequest".to_string())?,
            catalog_id: intermediate_rep.catalog_id.into_iter().next().ok_or_else(|| "catalog_id missing in CatalogsHotelProductGroupCreateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsHotelProductGroupCreateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsHotelProductGroupCreateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsHotelProductGroupCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsHotelProductGroupCreateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsHotelProductGroupCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsHotelProductGroupCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsHotelProductGroupCreateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}





/// Any of:
/// - BrandFilter
/// - CountryFilter
/// - CustomLabel0Filter
/// - CustomLabel1Filter
/// - CustomLabel2Filter
/// - CustomLabel3Filter
/// - CustomLabel4Filter
/// - HotelIdFilter
/// - PriceFilter
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsHotelProductGroupFilterKeys(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsHotelProductGroupFilterKeys
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelProductGroupFilterKeys value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelProductGroupFilterKeys {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsHotelProductGroupFilterKeys {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}






/// Object holding a group of filters for a hotel product group

/// Any of:
/// - CatalogsHotelProductGroupFiltersAllOf
/// - CatalogsHotelProductGroupFiltersAnyOf
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsHotelProductGroupFilters(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsHotelProductGroupFilters
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelProductGroupFilters value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelProductGroupFilters {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsHotelProductGroupFilters {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}









#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsHotelProductGroupFiltersAllOf {
    #[serde(rename = "all_of")]
    pub all_of: Vec<models::CatalogsHotelProductGroupFilterKeys>,

}


impl CatalogsHotelProductGroupFiltersAllOf {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(all_of: Vec<models::CatalogsHotelProductGroupFilterKeys>, ) -> CatalogsHotelProductGroupFiltersAllOf {
        CatalogsHotelProductGroupFiltersAllOf {
            all_of,
        }
    }
}

/// Converts the CatalogsHotelProductGroupFiltersAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsHotelProductGroupFiltersAllOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping all_of in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelProductGroupFiltersAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelProductGroupFiltersAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub all_of: Vec<Vec<models::CatalogsHotelProductGroupFilterKeys>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsHotelProductGroupFiltersAllOf".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "all_of" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsHotelProductGroupFiltersAllOf".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsHotelProductGroupFiltersAllOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsHotelProductGroupFiltersAllOf {
            all_of: intermediate_rep.all_of.into_iter().next().ok_or_else(|| "all_of missing in CatalogsHotelProductGroupFiltersAllOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsHotelProductGroupFiltersAllOf> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsHotelProductGroupFiltersAllOf>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsHotelProductGroupFiltersAllOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsHotelProductGroupFiltersAllOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsHotelProductGroupFiltersAllOf> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsHotelProductGroupFiltersAllOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsHotelProductGroupFiltersAllOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsHotelProductGroupFiltersAnyOf {
    #[serde(rename = "any_of")]
    pub any_of: Vec<models::CatalogsHotelProductGroupFilterKeys>,

}


impl CatalogsHotelProductGroupFiltersAnyOf {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(any_of: Vec<models::CatalogsHotelProductGroupFilterKeys>, ) -> CatalogsHotelProductGroupFiltersAnyOf {
        CatalogsHotelProductGroupFiltersAnyOf {
            any_of,
        }
    }
}

/// Converts the CatalogsHotelProductGroupFiltersAnyOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsHotelProductGroupFiltersAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping any_of in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelProductGroupFiltersAnyOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelProductGroupFiltersAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub any_of: Vec<Vec<models::CatalogsHotelProductGroupFilterKeys>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsHotelProductGroupFiltersAnyOf".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "any_of" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsHotelProductGroupFiltersAnyOf".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsHotelProductGroupFiltersAnyOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsHotelProductGroupFiltersAnyOf {
            any_of: intermediate_rep.any_of.into_iter().next().ok_or_else(|| "any_of missing in CatalogsHotelProductGroupFiltersAnyOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsHotelProductGroupFiltersAnyOf> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsHotelProductGroupFiltersAnyOf>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsHotelProductGroupFiltersAnyOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsHotelProductGroupFiltersAnyOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsHotelProductGroupFiltersAnyOf> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsHotelProductGroupFiltersAnyOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsHotelProductGroupFiltersAnyOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Request object for updating a hotel product group.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsHotelProductGroupUpdateRequest {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "catalog_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub catalog_type: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

    #[serde(rename = "filters")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub filters: Option<models::CatalogsHotelProductGroupFilters>,

}


impl CatalogsHotelProductGroupUpdateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsHotelProductGroupUpdateRequest {
        CatalogsHotelProductGroupUpdateRequest {
            catalog_type: None,
            name: None,
            description: None,
            filters: None,
        }
    }
}

/// Converts the CatalogsHotelProductGroupUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsHotelProductGroupUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.catalog_type.as_ref().map(|catalog_type| {
                [
                    "catalog_type".to_string(),
                    catalog_type.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping filters in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsHotelProductGroupUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsHotelProductGroupUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub catalog_type: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub filters: Vec<models::CatalogsHotelProductGroupFilters>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsHotelProductGroupUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsHotelProductGroupUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "filters" => intermediate_rep.filters.push(<models::CatalogsHotelProductGroupFilters as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsHotelProductGroupUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsHotelProductGroupUpdateRequest {
            catalog_type: intermediate_rep.catalog_type.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            description: std::result::Result::Err("Nullable types not supported in CatalogsHotelProductGroupUpdateRequest".to_string())?,
            filters: intermediate_rep.filters.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsHotelProductGroupUpdateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsHotelProductGroupUpdateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsHotelProductGroupUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsHotelProductGroupUpdateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsHotelProductGroupUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsHotelProductGroupUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsHotelProductGroupUpdateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsItemValidationDetails {
    #[serde(rename = "attribute_name")]
    pub attribute_name: Nullable<models::NullableCatalogsItemFieldType>,

/// Provided value that caused the validation issue.
    #[serde(rename = "provided_value")]
    pub provided_value: Nullable<String>,

}


impl CatalogsItemValidationDetails {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(attribute_name: Nullable<models::NullableCatalogsItemFieldType>, provided_value: Nullable<String>, ) -> CatalogsItemValidationDetails {
        CatalogsItemValidationDetails {
            attribute_name,
            provided_value,
        }
    }
}

/// Converts the CatalogsItemValidationDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsItemValidationDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping attribute_name in query parameter serialization


            Some("provided_value".to_string()),
            Some(self.provided_value.as_ref().map_or("null".to_string(), |x| x.to_string())),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsItemValidationDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsItemValidationDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub attribute_name: Vec<models::NullableCatalogsItemFieldType>,
            pub provided_value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsItemValidationDetails".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "attribute_name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsItemValidationDetails".to_string()),
                    "provided_value" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsItemValidationDetails".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsItemValidationDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsItemValidationDetails {
            attribute_name: std::result::Result::Err("Nullable types not supported in CatalogsItemValidationDetails".to_string())?,
            provided_value: std::result::Result::Err("Nullable types not supported in CatalogsItemValidationDetails".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsItemValidationDetails> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsItemValidationDetails>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsItemValidationDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsItemValidationDetails - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsItemValidationDetails> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsItemValidationDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsItemValidationDetails - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsItemValidationErrors {
    #[serde(rename = "ADULT_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adult_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "ADWORDS_FORMAT_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adwords_format_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "AVAILABILITY_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub availability_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "BLOCKLISTED_IMAGE_SIGNATURE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blocklisted_image_signature: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "DESCRIPTION_MISSING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description_missing: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "DUPLICATE_PRODUCTS")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub duplicate_products: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "IMAGE_LINK_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_link_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "IMAGE_LINK_LENGTH_TOO_LONG")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_link_length_too_long: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "IMAGE_LINK_MISSING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_link_missing: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "INVALID_DOMAIN")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub invalid_domain: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "ITEMID_MISSING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub itemid_missing: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_main_image_download_failure: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "LINK_FORMAT_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link_format_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "LINK_LENGTH_TOO_LONG")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link_length_too_long: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "LIST_PRICE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub list_price_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_items_per_item_group_exceeded: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "PARSE_LINE_ERROR")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parse_line_error: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "PINJOIN_CONTENT_UNSAFE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pinjoin_content_unsafe: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "PRICE_CANNOT_BE_DETERMINED")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price_cannot_be_determined: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "PRICE_MISSING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price_missing: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "PRODUCT_LINK_MISSING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_link_missing: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "PRODUCT_PRICE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_price_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "TITLE_MISSING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title_missing: Option<models::CatalogsItemValidationDetails>,

}


impl CatalogsItemValidationErrors {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsItemValidationErrors {
        CatalogsItemValidationErrors {
            adult_invalid: None,
            adwords_format_invalid: None,
            availability_invalid: None,
            blocklisted_image_signature: None,
            description_missing: None,
            duplicate_products: None,
            image_link_invalid: None,
            image_link_length_too_long: None,
            image_link_missing: None,
            invalid_domain: None,
            itemid_missing: None,
            item_main_image_download_failure: None,
            link_format_invalid: None,
            link_length_too_long: None,
            list_price_invalid: None,
            max_items_per_item_group_exceeded: None,
            parse_line_error: None,
            pinjoin_content_unsafe: None,
            price_cannot_be_determined: None,
            price_missing: None,
            product_link_missing: None,
            product_price_invalid: None,
            title_missing: None,
        }
    }
}

/// Converts the CatalogsItemValidationErrors value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsItemValidationErrors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping ADULT_INVALID in query parameter serialization

            // Skipping ADWORDS_FORMAT_INVALID in query parameter serialization

            // Skipping AVAILABILITY_INVALID in query parameter serialization

            // Skipping BLOCKLISTED_IMAGE_SIGNATURE in query parameter serialization

            // Skipping DESCRIPTION_MISSING in query parameter serialization

            // Skipping DUPLICATE_PRODUCTS in query parameter serialization

            // Skipping IMAGE_LINK_INVALID in query parameter serialization

            // Skipping IMAGE_LINK_LENGTH_TOO_LONG in query parameter serialization

            // Skipping IMAGE_LINK_MISSING in query parameter serialization

            // Skipping INVALID_DOMAIN in query parameter serialization

            // Skipping ITEMID_MISSING in query parameter serialization

            // Skipping ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE in query parameter serialization

            // Skipping LINK_FORMAT_INVALID in query parameter serialization

            // Skipping LINK_LENGTH_TOO_LONG in query parameter serialization

            // Skipping LIST_PRICE_INVALID in query parameter serialization

            // Skipping MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED in query parameter serialization

            // Skipping PARSE_LINE_ERROR in query parameter serialization

            // Skipping PINJOIN_CONTENT_UNSAFE in query parameter serialization

            // Skipping PRICE_CANNOT_BE_DETERMINED in query parameter serialization

            // Skipping PRICE_MISSING in query parameter serialization

            // Skipping PRODUCT_LINK_MISSING in query parameter serialization

            // Skipping PRODUCT_PRICE_INVALID in query parameter serialization

            // Skipping TITLE_MISSING in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsItemValidationErrors value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsItemValidationErrors {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub adult_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub adwords_format_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub availability_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub blocklisted_image_signature: Vec<models::CatalogsItemValidationDetails>,
            pub description_missing: Vec<models::CatalogsItemValidationDetails>,
            pub duplicate_products: Vec<models::CatalogsItemValidationDetails>,
            pub image_link_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub image_link_length_too_long: Vec<models::CatalogsItemValidationDetails>,
            pub image_link_missing: Vec<models::CatalogsItemValidationDetails>,
            pub invalid_domain: Vec<models::CatalogsItemValidationDetails>,
            pub itemid_missing: Vec<models::CatalogsItemValidationDetails>,
            pub item_main_image_download_failure: Vec<models::CatalogsItemValidationDetails>,
            pub link_format_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub link_length_too_long: Vec<models::CatalogsItemValidationDetails>,
            pub list_price_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub max_items_per_item_group_exceeded: Vec<models::CatalogsItemValidationDetails>,
            pub parse_line_error: Vec<models::CatalogsItemValidationDetails>,
            pub pinjoin_content_unsafe: Vec<models::CatalogsItemValidationDetails>,
            pub price_cannot_be_determined: Vec<models::CatalogsItemValidationDetails>,
            pub price_missing: Vec<models::CatalogsItemValidationDetails>,
            pub product_link_missing: Vec<models::CatalogsItemValidationDetails>,
            pub product_price_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub title_missing: Vec<models::CatalogsItemValidationDetails>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsItemValidationErrors".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ADULT_INVALID" => intermediate_rep.adult_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ADWORDS_FORMAT_INVALID" => intermediate_rep.adwords_format_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AVAILABILITY_INVALID" => intermediate_rep.availability_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "BLOCKLISTED_IMAGE_SIGNATURE" => intermediate_rep.blocklisted_image_signature.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DESCRIPTION_MISSING" => intermediate_rep.description_missing.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DUPLICATE_PRODUCTS" => intermediate_rep.duplicate_products.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IMAGE_LINK_INVALID" => intermediate_rep.image_link_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IMAGE_LINK_LENGTH_TOO_LONG" => intermediate_rep.image_link_length_too_long.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IMAGE_LINK_MISSING" => intermediate_rep.image_link_missing.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "INVALID_DOMAIN" => intermediate_rep.invalid_domain.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ITEMID_MISSING" => intermediate_rep.itemid_missing.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE" => intermediate_rep.item_main_image_download_failure.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "LINK_FORMAT_INVALID" => intermediate_rep.link_format_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "LINK_LENGTH_TOO_LONG" => intermediate_rep.link_length_too_long.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "LIST_PRICE_INVALID" => intermediate_rep.list_price_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED" => intermediate_rep.max_items_per_item_group_exceeded.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PARSE_LINE_ERROR" => intermediate_rep.parse_line_error.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PINJOIN_CONTENT_UNSAFE" => intermediate_rep.pinjoin_content_unsafe.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PRICE_CANNOT_BE_DETERMINED" => intermediate_rep.price_cannot_be_determined.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PRICE_MISSING" => intermediate_rep.price_missing.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PRODUCT_LINK_MISSING" => intermediate_rep.product_link_missing.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PRODUCT_PRICE_INVALID" => intermediate_rep.product_price_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "TITLE_MISSING" => intermediate_rep.title_missing.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsItemValidationErrors".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsItemValidationErrors {
            adult_invalid: intermediate_rep.adult_invalid.into_iter().next(),
            adwords_format_invalid: intermediate_rep.adwords_format_invalid.into_iter().next(),
            availability_invalid: intermediate_rep.availability_invalid.into_iter().next(),
            blocklisted_image_signature: intermediate_rep.blocklisted_image_signature.into_iter().next(),
            description_missing: intermediate_rep.description_missing.into_iter().next(),
            duplicate_products: intermediate_rep.duplicate_products.into_iter().next(),
            image_link_invalid: intermediate_rep.image_link_invalid.into_iter().next(),
            image_link_length_too_long: intermediate_rep.image_link_length_too_long.into_iter().next(),
            image_link_missing: intermediate_rep.image_link_missing.into_iter().next(),
            invalid_domain: intermediate_rep.invalid_domain.into_iter().next(),
            itemid_missing: intermediate_rep.itemid_missing.into_iter().next(),
            item_main_image_download_failure: intermediate_rep.item_main_image_download_failure.into_iter().next(),
            link_format_invalid: intermediate_rep.link_format_invalid.into_iter().next(),
            link_length_too_long: intermediate_rep.link_length_too_long.into_iter().next(),
            list_price_invalid: intermediate_rep.list_price_invalid.into_iter().next(),
            max_items_per_item_group_exceeded: intermediate_rep.max_items_per_item_group_exceeded.into_iter().next(),
            parse_line_error: intermediate_rep.parse_line_error.into_iter().next(),
            pinjoin_content_unsafe: intermediate_rep.pinjoin_content_unsafe.into_iter().next(),
            price_cannot_be_determined: intermediate_rep.price_cannot_be_determined.into_iter().next(),
            price_missing: intermediate_rep.price_missing.into_iter().next(),
            product_link_missing: intermediate_rep.product_link_missing.into_iter().next(),
            product_price_invalid: intermediate_rep.product_price_invalid.into_iter().next(),
            title_missing: intermediate_rep.title_missing.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsItemValidationErrors> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsItemValidationErrors>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsItemValidationErrors>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsItemValidationErrors - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsItemValidationErrors> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsItemValidationErrors as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsItemValidationErrors - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CatalogsItemValidationIssue {
    #[serde(rename = "AD_LINK_FORMAT_WARNING")]
    AdLinkFormatWarning,
    #[serde(rename = "AD_LINK_SAME_AS_LINK")]
    AdLinkSameAsLink,
    #[serde(rename = "ADDITIONAL_IMAGE_LINK_LENGTH_TOO_LONG")]
    AdditionalImageLinkLengthTooLong,
    #[serde(rename = "ADDITIONAL_IMAGE_LINK_WARNING")]
    AdditionalImageLinkWarning,
    #[serde(rename = "ADULT_INVALID")]
    AdultInvalid,
    #[serde(rename = "ADWORDS_FORMAT_INVALID")]
    AdwordsFormatInvalid,
    #[serde(rename = "ADWORDS_FORMAT_WARNING")]
    AdwordsFormatWarning,
    #[serde(rename = "ADWORDS_SAME_AS_LINK")]
    AdwordsSameAsLink,
    #[serde(rename = "AGE_GROUP_INVALID")]
    AgeGroupInvalid,
    #[serde(rename = "ANDROID_DEEP_LINK_INVALID")]
    AndroidDeepLinkInvalid,
    #[serde(rename = "AVAILABILITY_DATE_INVALID")]
    AvailabilityDateInvalid,
    #[serde(rename = "AVAILABILITY_INVALID")]
    AvailabilityInvalid,
    #[serde(rename = "BLOCKLISTED_IMAGE_SIGNATURE")]
    BlocklistedImageSignature,
    #[serde(rename = "COUNTRY_DOES_NOT_MAP_TO_CURRENCY")]
    CountryDoesNotMapToCurrency,
    #[serde(rename = "CUSTOM_LABEL_LENGTH_TOO_LONG")]
    CustomLabelLengthTooLong,
    #[serde(rename = "DESCRIPTION_LENGTH_TOO_LONG")]
    DescriptionLengthTooLong,
    #[serde(rename = "DESCRIPTION_MISSING")]
    DescriptionMissing,
    #[serde(rename = "DUPLICATE_PRODUCTS")]
    DuplicateProducts,
    #[serde(rename = "EXPIRATION_DATE_INVALID")]
    ExpirationDateInvalid,
    #[serde(rename = "GENDER_INVALID")]
    GenderInvalid,
    #[serde(rename = "GTIN_INVALID")]
    GtinInvalid,
    #[serde(rename = "IMAGE_LINK_INVALID")]
    ImageLinkInvalid,
    #[serde(rename = "IMAGE_LINK_LENGTH_TOO_LONG")]
    ImageLinkLengthTooLong,
    #[serde(rename = "IMAGE_LINK_MISSING")]
    ImageLinkMissing,
    #[serde(rename = "IMAGE_LINK_WARNING")]
    ImageLinkWarning,
    #[serde(rename = "INVALID_DOMAIN")]
    InvalidDomain,
    #[serde(rename = "IOS_DEEP_LINK_INVALID")]
    IosDeepLinkInvalid,
    #[serde(rename = "IS_BUNDLE_INVALID")]
    IsBundleInvalid,
    #[serde(rename = "ITEM_ADDITIONAL_IMAGE_DOWNLOAD_FAILURE")]
    ItemAdditionalImageDownloadFailure,
    #[serde(rename = "ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE")]
    ItemMainImageDownloadFailure,
    #[serde(rename = "ITEMID_MISSING")]
    ItemidMissing,
    #[serde(rename = "LINK_FORMAT_INVALID")]
    LinkFormatInvalid,
    #[serde(rename = "LINK_FORMAT_WARNING")]
    LinkFormatWarning,
    #[serde(rename = "LINK_LENGTH_TOO_LONG")]
    LinkLengthTooLong,
    #[serde(rename = "LIST_PRICE_INVALID")]
    ListPriceInvalid,
    #[serde(rename = "MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED")]
    MaxItemsPerItemGroupExceeded,
    #[serde(rename = "MIN_AD_PRICE_INVALID")]
    MinAdPriceInvalid,
    #[serde(rename = "MPN_INVALID")]
    MpnInvalid,
    #[serde(rename = "MULTIPACK_INVALID")]
    MultipackInvalid,
    #[serde(rename = "OPTIONAL_CONDITION_INVALID")]
    OptionalConditionInvalid,
    #[serde(rename = "OPTIONAL_CONDITION_MISSING")]
    OptionalConditionMissing,
    #[serde(rename = "OPTIONAL_PRODUCT_CATEGORY_INVALID")]
    OptionalProductCategoryInvalid,
    #[serde(rename = "OPTIONAL_PRODUCT_CATEGORY_MISSING")]
    OptionalProductCategoryMissing,
    #[serde(rename = "PARSE_LINE_ERROR")]
    ParseLineError,
    #[serde(rename = "PINJOIN_CONTENT_UNSAFE")]
    PinjoinContentUnsafe,
    #[serde(rename = "PRICE_CANNOT_BE_DETERMINED")]
    PriceCannotBeDetermined,
    #[serde(rename = "PRICE_MISSING")]
    PriceMissing,
    #[serde(rename = "PRODUCT_CATEGORY_DEPTH_WARNING")]
    ProductCategoryDepthWarning,
    #[serde(rename = "PRODUCT_LINK_MISSING")]
    ProductLinkMissing,
    #[serde(rename = "PRODUCT_PRICE_INVALID")]
    ProductPriceInvalid,
    #[serde(rename = "PRODUCT_TYPE_LENGTH_TOO_LONG")]
    ProductTypeLengthTooLong,
    #[serde(rename = "SALE_DATE_INVALID")]
    SaleDateInvalid,
    #[serde(rename = "SALES_PRICE_INVALID")]
    SalesPriceInvalid,
    #[serde(rename = "SALES_PRICE_TOO_HIGH")]
    SalesPriceTooHigh,
    #[serde(rename = "SALES_PRICE_TOO_LOW")]
    SalesPriceTooLow,
    #[serde(rename = "SHIPPING_INVALID")]
    ShippingInvalid,
    #[serde(rename = "SHIPPING_HEIGHT_INVALID")]
    ShippingHeightInvalid,
    #[serde(rename = "SHIPPING_WEIGHT_INVALID")]
    ShippingWeightInvalid,
    #[serde(rename = "SHIPPING_WIDTH_INVALID")]
    ShippingWidthInvalid,
    #[serde(rename = "SIZE_SYSTEM_INVALID")]
    SizeSystemInvalid,
    #[serde(rename = "SIZE_TYPE_INVALID")]
    SizeTypeInvalid,
    #[serde(rename = "TAX_INVALID")]
    TaxInvalid,
    #[serde(rename = "TITLE_LENGTH_TOO_LONG")]
    TitleLengthTooLong,
    #[serde(rename = "TITLE_MISSING")]
    TitleMissing,
    #[serde(rename = "TOO_MANY_ADDITIONAL_IMAGE_LINKS")]
    TooManyAdditionalImageLinks,
    #[serde(rename = "UTM_SOURCE_AUTO_CORRECTED")]
    UtmSourceAutoCorrected,
    #[serde(rename = "WEIGHT_UNIT_INVALID")]
    WeightUnitInvalid,
}

impl std::fmt::Display for CatalogsItemValidationIssue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CatalogsItemValidationIssue::AdLinkFormatWarning => write!(f, "AD_LINK_FORMAT_WARNING"),
            CatalogsItemValidationIssue::AdLinkSameAsLink => write!(f, "AD_LINK_SAME_AS_LINK"),
            CatalogsItemValidationIssue::AdditionalImageLinkLengthTooLong => write!(f, "ADDITIONAL_IMAGE_LINK_LENGTH_TOO_LONG"),
            CatalogsItemValidationIssue::AdditionalImageLinkWarning => write!(f, "ADDITIONAL_IMAGE_LINK_WARNING"),
            CatalogsItemValidationIssue::AdultInvalid => write!(f, "ADULT_INVALID"),
            CatalogsItemValidationIssue::AdwordsFormatInvalid => write!(f, "ADWORDS_FORMAT_INVALID"),
            CatalogsItemValidationIssue::AdwordsFormatWarning => write!(f, "ADWORDS_FORMAT_WARNING"),
            CatalogsItemValidationIssue::AdwordsSameAsLink => write!(f, "ADWORDS_SAME_AS_LINK"),
            CatalogsItemValidationIssue::AgeGroupInvalid => write!(f, "AGE_GROUP_INVALID"),
            CatalogsItemValidationIssue::AndroidDeepLinkInvalid => write!(f, "ANDROID_DEEP_LINK_INVALID"),
            CatalogsItemValidationIssue::AvailabilityDateInvalid => write!(f, "AVAILABILITY_DATE_INVALID"),
            CatalogsItemValidationIssue::AvailabilityInvalid => write!(f, "AVAILABILITY_INVALID"),
            CatalogsItemValidationIssue::BlocklistedImageSignature => write!(f, "BLOCKLISTED_IMAGE_SIGNATURE"),
            CatalogsItemValidationIssue::CountryDoesNotMapToCurrency => write!(f, "COUNTRY_DOES_NOT_MAP_TO_CURRENCY"),
            CatalogsItemValidationIssue::CustomLabelLengthTooLong => write!(f, "CUSTOM_LABEL_LENGTH_TOO_LONG"),
            CatalogsItemValidationIssue::DescriptionLengthTooLong => write!(f, "DESCRIPTION_LENGTH_TOO_LONG"),
            CatalogsItemValidationIssue::DescriptionMissing => write!(f, "DESCRIPTION_MISSING"),
            CatalogsItemValidationIssue::DuplicateProducts => write!(f, "DUPLICATE_PRODUCTS"),
            CatalogsItemValidationIssue::ExpirationDateInvalid => write!(f, "EXPIRATION_DATE_INVALID"),
            CatalogsItemValidationIssue::GenderInvalid => write!(f, "GENDER_INVALID"),
            CatalogsItemValidationIssue::GtinInvalid => write!(f, "GTIN_INVALID"),
            CatalogsItemValidationIssue::ImageLinkInvalid => write!(f, "IMAGE_LINK_INVALID"),
            CatalogsItemValidationIssue::ImageLinkLengthTooLong => write!(f, "IMAGE_LINK_LENGTH_TOO_LONG"),
            CatalogsItemValidationIssue::ImageLinkMissing => write!(f, "IMAGE_LINK_MISSING"),
            CatalogsItemValidationIssue::ImageLinkWarning => write!(f, "IMAGE_LINK_WARNING"),
            CatalogsItemValidationIssue::InvalidDomain => write!(f, "INVALID_DOMAIN"),
            CatalogsItemValidationIssue::IosDeepLinkInvalid => write!(f, "IOS_DEEP_LINK_INVALID"),
            CatalogsItemValidationIssue::IsBundleInvalid => write!(f, "IS_BUNDLE_INVALID"),
            CatalogsItemValidationIssue::ItemAdditionalImageDownloadFailure => write!(f, "ITEM_ADDITIONAL_IMAGE_DOWNLOAD_FAILURE"),
            CatalogsItemValidationIssue::ItemMainImageDownloadFailure => write!(f, "ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE"),
            CatalogsItemValidationIssue::ItemidMissing => write!(f, "ITEMID_MISSING"),
            CatalogsItemValidationIssue::LinkFormatInvalid => write!(f, "LINK_FORMAT_INVALID"),
            CatalogsItemValidationIssue::LinkFormatWarning => write!(f, "LINK_FORMAT_WARNING"),
            CatalogsItemValidationIssue::LinkLengthTooLong => write!(f, "LINK_LENGTH_TOO_LONG"),
            CatalogsItemValidationIssue::ListPriceInvalid => write!(f, "LIST_PRICE_INVALID"),
            CatalogsItemValidationIssue::MaxItemsPerItemGroupExceeded => write!(f, "MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED"),
            CatalogsItemValidationIssue::MinAdPriceInvalid => write!(f, "MIN_AD_PRICE_INVALID"),
            CatalogsItemValidationIssue::MpnInvalid => write!(f, "MPN_INVALID"),
            CatalogsItemValidationIssue::MultipackInvalid => write!(f, "MULTIPACK_INVALID"),
            CatalogsItemValidationIssue::OptionalConditionInvalid => write!(f, "OPTIONAL_CONDITION_INVALID"),
            CatalogsItemValidationIssue::OptionalConditionMissing => write!(f, "OPTIONAL_CONDITION_MISSING"),
            CatalogsItemValidationIssue::OptionalProductCategoryInvalid => write!(f, "OPTIONAL_PRODUCT_CATEGORY_INVALID"),
            CatalogsItemValidationIssue::OptionalProductCategoryMissing => write!(f, "OPTIONAL_PRODUCT_CATEGORY_MISSING"),
            CatalogsItemValidationIssue::ParseLineError => write!(f, "PARSE_LINE_ERROR"),
            CatalogsItemValidationIssue::PinjoinContentUnsafe => write!(f, "PINJOIN_CONTENT_UNSAFE"),
            CatalogsItemValidationIssue::PriceCannotBeDetermined => write!(f, "PRICE_CANNOT_BE_DETERMINED"),
            CatalogsItemValidationIssue::PriceMissing => write!(f, "PRICE_MISSING"),
            CatalogsItemValidationIssue::ProductCategoryDepthWarning => write!(f, "PRODUCT_CATEGORY_DEPTH_WARNING"),
            CatalogsItemValidationIssue::ProductLinkMissing => write!(f, "PRODUCT_LINK_MISSING"),
            CatalogsItemValidationIssue::ProductPriceInvalid => write!(f, "PRODUCT_PRICE_INVALID"),
            CatalogsItemValidationIssue::ProductTypeLengthTooLong => write!(f, "PRODUCT_TYPE_LENGTH_TOO_LONG"),
            CatalogsItemValidationIssue::SaleDateInvalid => write!(f, "SALE_DATE_INVALID"),
            CatalogsItemValidationIssue::SalesPriceInvalid => write!(f, "SALES_PRICE_INVALID"),
            CatalogsItemValidationIssue::SalesPriceTooHigh => write!(f, "SALES_PRICE_TOO_HIGH"),
            CatalogsItemValidationIssue::SalesPriceTooLow => write!(f, "SALES_PRICE_TOO_LOW"),
            CatalogsItemValidationIssue::ShippingInvalid => write!(f, "SHIPPING_INVALID"),
            CatalogsItemValidationIssue::ShippingHeightInvalid => write!(f, "SHIPPING_HEIGHT_INVALID"),
            CatalogsItemValidationIssue::ShippingWeightInvalid => write!(f, "SHIPPING_WEIGHT_INVALID"),
            CatalogsItemValidationIssue::ShippingWidthInvalid => write!(f, "SHIPPING_WIDTH_INVALID"),
            CatalogsItemValidationIssue::SizeSystemInvalid => write!(f, "SIZE_SYSTEM_INVALID"),
            CatalogsItemValidationIssue::SizeTypeInvalid => write!(f, "SIZE_TYPE_INVALID"),
            CatalogsItemValidationIssue::TaxInvalid => write!(f, "TAX_INVALID"),
            CatalogsItemValidationIssue::TitleLengthTooLong => write!(f, "TITLE_LENGTH_TOO_LONG"),
            CatalogsItemValidationIssue::TitleMissing => write!(f, "TITLE_MISSING"),
            CatalogsItemValidationIssue::TooManyAdditionalImageLinks => write!(f, "TOO_MANY_ADDITIONAL_IMAGE_LINKS"),
            CatalogsItemValidationIssue::UtmSourceAutoCorrected => write!(f, "UTM_SOURCE_AUTO_CORRECTED"),
            CatalogsItemValidationIssue::WeightUnitInvalid => write!(f, "WEIGHT_UNIT_INVALID"),
        }
    }
}

impl std::str::FromStr for CatalogsItemValidationIssue {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AD_LINK_FORMAT_WARNING" => std::result::Result::Ok(CatalogsItemValidationIssue::AdLinkFormatWarning),
            "AD_LINK_SAME_AS_LINK" => std::result::Result::Ok(CatalogsItemValidationIssue::AdLinkSameAsLink),
            "ADDITIONAL_IMAGE_LINK_LENGTH_TOO_LONG" => std::result::Result::Ok(CatalogsItemValidationIssue::AdditionalImageLinkLengthTooLong),
            "ADDITIONAL_IMAGE_LINK_WARNING" => std::result::Result::Ok(CatalogsItemValidationIssue::AdditionalImageLinkWarning),
            "ADULT_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::AdultInvalid),
            "ADWORDS_FORMAT_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::AdwordsFormatInvalid),
            "ADWORDS_FORMAT_WARNING" => std::result::Result::Ok(CatalogsItemValidationIssue::AdwordsFormatWarning),
            "ADWORDS_SAME_AS_LINK" => std::result::Result::Ok(CatalogsItemValidationIssue::AdwordsSameAsLink),
            "AGE_GROUP_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::AgeGroupInvalid),
            "ANDROID_DEEP_LINK_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::AndroidDeepLinkInvalid),
            "AVAILABILITY_DATE_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::AvailabilityDateInvalid),
            "AVAILABILITY_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::AvailabilityInvalid),
            "BLOCKLISTED_IMAGE_SIGNATURE" => std::result::Result::Ok(CatalogsItemValidationIssue::BlocklistedImageSignature),
            "COUNTRY_DOES_NOT_MAP_TO_CURRENCY" => std::result::Result::Ok(CatalogsItemValidationIssue::CountryDoesNotMapToCurrency),
            "CUSTOM_LABEL_LENGTH_TOO_LONG" => std::result::Result::Ok(CatalogsItemValidationIssue::CustomLabelLengthTooLong),
            "DESCRIPTION_LENGTH_TOO_LONG" => std::result::Result::Ok(CatalogsItemValidationIssue::DescriptionLengthTooLong),
            "DESCRIPTION_MISSING" => std::result::Result::Ok(CatalogsItemValidationIssue::DescriptionMissing),
            "DUPLICATE_PRODUCTS" => std::result::Result::Ok(CatalogsItemValidationIssue::DuplicateProducts),
            "EXPIRATION_DATE_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::ExpirationDateInvalid),
            "GENDER_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::GenderInvalid),
            "GTIN_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::GtinInvalid),
            "IMAGE_LINK_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::ImageLinkInvalid),
            "IMAGE_LINK_LENGTH_TOO_LONG" => std::result::Result::Ok(CatalogsItemValidationIssue::ImageLinkLengthTooLong),
            "IMAGE_LINK_MISSING" => std::result::Result::Ok(CatalogsItemValidationIssue::ImageLinkMissing),
            "IMAGE_LINK_WARNING" => std::result::Result::Ok(CatalogsItemValidationIssue::ImageLinkWarning),
            "INVALID_DOMAIN" => std::result::Result::Ok(CatalogsItemValidationIssue::InvalidDomain),
            "IOS_DEEP_LINK_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::IosDeepLinkInvalid),
            "IS_BUNDLE_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::IsBundleInvalid),
            "ITEM_ADDITIONAL_IMAGE_DOWNLOAD_FAILURE" => std::result::Result::Ok(CatalogsItemValidationIssue::ItemAdditionalImageDownloadFailure),
            "ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE" => std::result::Result::Ok(CatalogsItemValidationIssue::ItemMainImageDownloadFailure),
            "ITEMID_MISSING" => std::result::Result::Ok(CatalogsItemValidationIssue::ItemidMissing),
            "LINK_FORMAT_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::LinkFormatInvalid),
            "LINK_FORMAT_WARNING" => std::result::Result::Ok(CatalogsItemValidationIssue::LinkFormatWarning),
            "LINK_LENGTH_TOO_LONG" => std::result::Result::Ok(CatalogsItemValidationIssue::LinkLengthTooLong),
            "LIST_PRICE_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::ListPriceInvalid),
            "MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED" => std::result::Result::Ok(CatalogsItemValidationIssue::MaxItemsPerItemGroupExceeded),
            "MIN_AD_PRICE_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::MinAdPriceInvalid),
            "MPN_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::MpnInvalid),
            "MULTIPACK_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::MultipackInvalid),
            "OPTIONAL_CONDITION_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::OptionalConditionInvalid),
            "OPTIONAL_CONDITION_MISSING" => std::result::Result::Ok(CatalogsItemValidationIssue::OptionalConditionMissing),
            "OPTIONAL_PRODUCT_CATEGORY_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::OptionalProductCategoryInvalid),
            "OPTIONAL_PRODUCT_CATEGORY_MISSING" => std::result::Result::Ok(CatalogsItemValidationIssue::OptionalProductCategoryMissing),
            "PARSE_LINE_ERROR" => std::result::Result::Ok(CatalogsItemValidationIssue::ParseLineError),
            "PINJOIN_CONTENT_UNSAFE" => std::result::Result::Ok(CatalogsItemValidationIssue::PinjoinContentUnsafe),
            "PRICE_CANNOT_BE_DETERMINED" => std::result::Result::Ok(CatalogsItemValidationIssue::PriceCannotBeDetermined),
            "PRICE_MISSING" => std::result::Result::Ok(CatalogsItemValidationIssue::PriceMissing),
            "PRODUCT_CATEGORY_DEPTH_WARNING" => std::result::Result::Ok(CatalogsItemValidationIssue::ProductCategoryDepthWarning),
            "PRODUCT_LINK_MISSING" => std::result::Result::Ok(CatalogsItemValidationIssue::ProductLinkMissing),
            "PRODUCT_PRICE_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::ProductPriceInvalid),
            "PRODUCT_TYPE_LENGTH_TOO_LONG" => std::result::Result::Ok(CatalogsItemValidationIssue::ProductTypeLengthTooLong),
            "SALE_DATE_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::SaleDateInvalid),
            "SALES_PRICE_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::SalesPriceInvalid),
            "SALES_PRICE_TOO_HIGH" => std::result::Result::Ok(CatalogsItemValidationIssue::SalesPriceTooHigh),
            "SALES_PRICE_TOO_LOW" => std::result::Result::Ok(CatalogsItemValidationIssue::SalesPriceTooLow),
            "SHIPPING_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::ShippingInvalid),
            "SHIPPING_HEIGHT_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::ShippingHeightInvalid),
            "SHIPPING_WEIGHT_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::ShippingWeightInvalid),
            "SHIPPING_WIDTH_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::ShippingWidthInvalid),
            "SIZE_SYSTEM_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::SizeSystemInvalid),
            "SIZE_TYPE_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::SizeTypeInvalid),
            "TAX_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::TaxInvalid),
            "TITLE_LENGTH_TOO_LONG" => std::result::Result::Ok(CatalogsItemValidationIssue::TitleLengthTooLong),
            "TITLE_MISSING" => std::result::Result::Ok(CatalogsItemValidationIssue::TitleMissing),
            "TOO_MANY_ADDITIONAL_IMAGE_LINKS" => std::result::Result::Ok(CatalogsItemValidationIssue::TooManyAdditionalImageLinks),
            "UTM_SOURCE_AUTO_CORRECTED" => std::result::Result::Ok(CatalogsItemValidationIssue::UtmSourceAutoCorrected),
            "WEIGHT_UNIT_INVALID" => std::result::Result::Ok(CatalogsItemValidationIssue::WeightUnitInvalid),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsItemValidationIssues {
/// Item number based on order of appearance in the Catalogs Feed. For example, '0' refers to first item found in a feed that was downloaded from a 'location' specified during feed creation.
    #[serde(rename = "item_number")]
    pub item_number: i32,

/// The merchant-created unique ID that represents the product.
    #[serde(rename = "item_id")]
    pub item_id: Nullable<String>,

    #[serde(rename = "errors")]
    pub errors: models::CatalogsItemValidationErrors,

    #[serde(rename = "warnings")]
    pub warnings: models::CatalogsItemValidationWarnings,

}


impl CatalogsItemValidationIssues {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(item_number: i32, item_id: Nullable<String>, errors: models::CatalogsItemValidationErrors, warnings: models::CatalogsItemValidationWarnings, ) -> CatalogsItemValidationIssues {
        CatalogsItemValidationIssues {
            item_number,
            item_id,
            errors,
            warnings,
        }
    }
}

/// Converts the CatalogsItemValidationIssues value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsItemValidationIssues {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("item_number".to_string()),
            Some(self.item_number.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping errors in query parameter serialization

            // Skipping warnings in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsItemValidationIssues value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsItemValidationIssues {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_number: Vec<i32>,
            pub item_id: Vec<String>,
            pub errors: Vec<models::CatalogsItemValidationErrors>,
            pub warnings: Vec<models::CatalogsItemValidationWarnings>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsItemValidationIssues".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "item_number" => intermediate_rep.item_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "item_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsItemValidationIssues".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "errors" => intermediate_rep.errors.push(<models::CatalogsItemValidationErrors as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "warnings" => intermediate_rep.warnings.push(<models::CatalogsItemValidationWarnings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsItemValidationIssues".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsItemValidationIssues {
            item_number: intermediate_rep.item_number.into_iter().next().ok_or_else(|| "item_number missing in CatalogsItemValidationIssues".to_string())?,
            item_id: std::result::Result::Err("Nullable types not supported in CatalogsItemValidationIssues".to_string())?,
            errors: intermediate_rep.errors.into_iter().next().ok_or_else(|| "errors missing in CatalogsItemValidationIssues".to_string())?,
            warnings: intermediate_rep.warnings.into_iter().next().ok_or_else(|| "warnings missing in CatalogsItemValidationIssues".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsItemValidationIssues> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsItemValidationIssues>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsItemValidationIssues>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsItemValidationIssues - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsItemValidationIssues> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsItemValidationIssues as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsItemValidationIssues - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsItemValidationWarnings {
    #[serde(rename = "AD_LINK_FORMAT_WARNING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_link_format_warning: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "AD_LINK_SAME_AS_LINK")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_link_same_as_link: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "ADDITIONAL_IMAGE_LINK_LENGTH_TOO_LONG")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_image_link_length_too_long: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "ADDITIONAL_IMAGE_LINK_WARNING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_image_link_warning: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "ADWORDS_FORMAT_WARNING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adwords_format_warning: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "ADWORDS_SAME_AS_LINK")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adwords_same_as_link: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "AGE_GROUP_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub age_group_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "SIZE_SYSTEM_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_system_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "ANDROID_DEEP_LINK_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub android_deep_link_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "AVAILABILITY_DATE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub availability_date_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "COUNTRY_DOES_NOT_MAP_TO_CURRENCY")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub country_does_not_map_to_currency: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "CUSTOM_LABEL_LENGTH_TOO_LONG")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_length_too_long: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "DESCRIPTION_LENGTH_TOO_LONG")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description_length_too_long: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "EXPIRATION_DATE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expiration_date_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "GENDER_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gender_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "GTIN_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gtin_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "IMAGE_LINK_WARNING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_link_warning: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "IOS_DEEP_LINK_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ios_deep_link_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "IS_BUNDLE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_bundle_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "ITEM_ADDITIONAL_IMAGE_DOWNLOAD_FAILURE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_additional_image_download_failure: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "LINK_FORMAT_WARNING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link_format_warning: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "MIN_AD_PRICE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_ad_price_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "MPN_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mpn_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "MULTIPACK_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub multipack_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "OPTIONAL_CONDITION_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional_condition_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "OPTIONAL_CONDITION_MISSING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional_condition_missing: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "OPTIONAL_PRODUCT_CATEGORY_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional_product_category_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "OPTIONAL_PRODUCT_CATEGORY_MISSING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional_product_category_missing: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "PRODUCT_CATEGORY_DEPTH_WARNING")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_category_depth_warning: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "PRODUCT_TYPE_LENGTH_TOO_LONG")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_type_length_too_long: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "SALES_PRICE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sales_price_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "SALES_PRICE_TOO_LOW")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sales_price_too_low: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "SALES_PRICE_TOO_HIGH")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sales_price_too_high: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "SALE_DATE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sale_date_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "SHIPPING_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "SHIPPING_HEIGHT_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_height_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "SHIPPING_WEIGHT_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_weight_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "SHIPPING_WIDTH_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_width_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "SIZE_TYPE_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_type_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "TAX_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tax_invalid: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "TITLE_LENGTH_TOO_LONG")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title_length_too_long: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "TOO_MANY_ADDITIONAL_IMAGE_LINKS")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub too_many_additional_image_links: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "UTM_SOURCE_AUTO_CORRECTED")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub utm_source_auto_corrected: Option<models::CatalogsItemValidationDetails>,

    #[serde(rename = "WEIGHT_UNIT_INVALID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight_unit_invalid: Option<models::CatalogsItemValidationDetails>,

}


impl CatalogsItemValidationWarnings {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsItemValidationWarnings {
        CatalogsItemValidationWarnings {
            ad_link_format_warning: None,
            ad_link_same_as_link: None,
            additional_image_link_length_too_long: None,
            additional_image_link_warning: None,
            adwords_format_warning: None,
            adwords_same_as_link: None,
            age_group_invalid: None,
            size_system_invalid: None,
            android_deep_link_invalid: None,
            availability_date_invalid: None,
            country_does_not_map_to_currency: None,
            custom_label_length_too_long: None,
            description_length_too_long: None,
            expiration_date_invalid: None,
            gender_invalid: None,
            gtin_invalid: None,
            image_link_warning: None,
            ios_deep_link_invalid: None,
            is_bundle_invalid: None,
            item_additional_image_download_failure: None,
            link_format_warning: None,
            min_ad_price_invalid: None,
            mpn_invalid: None,
            multipack_invalid: None,
            optional_condition_invalid: None,
            optional_condition_missing: None,
            optional_product_category_invalid: None,
            optional_product_category_missing: None,
            product_category_depth_warning: None,
            product_type_length_too_long: None,
            sales_price_invalid: None,
            sales_price_too_low: None,
            sales_price_too_high: None,
            sale_date_invalid: None,
            shipping_invalid: None,
            shipping_height_invalid: None,
            shipping_weight_invalid: None,
            shipping_width_invalid: None,
            size_type_invalid: None,
            tax_invalid: None,
            title_length_too_long: None,
            too_many_additional_image_links: None,
            utm_source_auto_corrected: None,
            weight_unit_invalid: None,
        }
    }
}

/// Converts the CatalogsItemValidationWarnings value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsItemValidationWarnings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping AD_LINK_FORMAT_WARNING in query parameter serialization

            // Skipping AD_LINK_SAME_AS_LINK in query parameter serialization

            // Skipping ADDITIONAL_IMAGE_LINK_LENGTH_TOO_LONG in query parameter serialization

            // Skipping ADDITIONAL_IMAGE_LINK_WARNING in query parameter serialization

            // Skipping ADWORDS_FORMAT_WARNING in query parameter serialization

            // Skipping ADWORDS_SAME_AS_LINK in query parameter serialization

            // Skipping AGE_GROUP_INVALID in query parameter serialization

            // Skipping SIZE_SYSTEM_INVALID in query parameter serialization

            // Skipping ANDROID_DEEP_LINK_INVALID in query parameter serialization

            // Skipping AVAILABILITY_DATE_INVALID in query parameter serialization

            // Skipping COUNTRY_DOES_NOT_MAP_TO_CURRENCY in query parameter serialization

            // Skipping CUSTOM_LABEL_LENGTH_TOO_LONG in query parameter serialization

            // Skipping DESCRIPTION_LENGTH_TOO_LONG in query parameter serialization

            // Skipping EXPIRATION_DATE_INVALID in query parameter serialization

            // Skipping GENDER_INVALID in query parameter serialization

            // Skipping GTIN_INVALID in query parameter serialization

            // Skipping IMAGE_LINK_WARNING in query parameter serialization

            // Skipping IOS_DEEP_LINK_INVALID in query parameter serialization

            // Skipping IS_BUNDLE_INVALID in query parameter serialization

            // Skipping ITEM_ADDITIONAL_IMAGE_DOWNLOAD_FAILURE in query parameter serialization

            // Skipping LINK_FORMAT_WARNING in query parameter serialization

            // Skipping MIN_AD_PRICE_INVALID in query parameter serialization

            // Skipping MPN_INVALID in query parameter serialization

            // Skipping MULTIPACK_INVALID in query parameter serialization

            // Skipping OPTIONAL_CONDITION_INVALID in query parameter serialization

            // Skipping OPTIONAL_CONDITION_MISSING in query parameter serialization

            // Skipping OPTIONAL_PRODUCT_CATEGORY_INVALID in query parameter serialization

            // Skipping OPTIONAL_PRODUCT_CATEGORY_MISSING in query parameter serialization

            // Skipping PRODUCT_CATEGORY_DEPTH_WARNING in query parameter serialization

            // Skipping PRODUCT_TYPE_LENGTH_TOO_LONG in query parameter serialization

            // Skipping SALES_PRICE_INVALID in query parameter serialization

            // Skipping SALES_PRICE_TOO_LOW in query parameter serialization

            // Skipping SALES_PRICE_TOO_HIGH in query parameter serialization

            // Skipping SALE_DATE_INVALID in query parameter serialization

            // Skipping SHIPPING_INVALID in query parameter serialization

            // Skipping SHIPPING_HEIGHT_INVALID in query parameter serialization

            // Skipping SHIPPING_WEIGHT_INVALID in query parameter serialization

            // Skipping SHIPPING_WIDTH_INVALID in query parameter serialization

            // Skipping SIZE_TYPE_INVALID in query parameter serialization

            // Skipping TAX_INVALID in query parameter serialization

            // Skipping TITLE_LENGTH_TOO_LONG in query parameter serialization

            // Skipping TOO_MANY_ADDITIONAL_IMAGE_LINKS in query parameter serialization

            // Skipping UTM_SOURCE_AUTO_CORRECTED in query parameter serialization

            // Skipping WEIGHT_UNIT_INVALID in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsItemValidationWarnings value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsItemValidationWarnings {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_link_format_warning: Vec<models::CatalogsItemValidationDetails>,
            pub ad_link_same_as_link: Vec<models::CatalogsItemValidationDetails>,
            pub additional_image_link_length_too_long: Vec<models::CatalogsItemValidationDetails>,
            pub additional_image_link_warning: Vec<models::CatalogsItemValidationDetails>,
            pub adwords_format_warning: Vec<models::CatalogsItemValidationDetails>,
            pub adwords_same_as_link: Vec<models::CatalogsItemValidationDetails>,
            pub age_group_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub size_system_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub android_deep_link_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub availability_date_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub country_does_not_map_to_currency: Vec<models::CatalogsItemValidationDetails>,
            pub custom_label_length_too_long: Vec<models::CatalogsItemValidationDetails>,
            pub description_length_too_long: Vec<models::CatalogsItemValidationDetails>,
            pub expiration_date_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub gender_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub gtin_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub image_link_warning: Vec<models::CatalogsItemValidationDetails>,
            pub ios_deep_link_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub is_bundle_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub item_additional_image_download_failure: Vec<models::CatalogsItemValidationDetails>,
            pub link_format_warning: Vec<models::CatalogsItemValidationDetails>,
            pub min_ad_price_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub mpn_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub multipack_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub optional_condition_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub optional_condition_missing: Vec<models::CatalogsItemValidationDetails>,
            pub optional_product_category_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub optional_product_category_missing: Vec<models::CatalogsItemValidationDetails>,
            pub product_category_depth_warning: Vec<models::CatalogsItemValidationDetails>,
            pub product_type_length_too_long: Vec<models::CatalogsItemValidationDetails>,
            pub sales_price_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub sales_price_too_low: Vec<models::CatalogsItemValidationDetails>,
            pub sales_price_too_high: Vec<models::CatalogsItemValidationDetails>,
            pub sale_date_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub shipping_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub shipping_height_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub shipping_weight_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub shipping_width_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub size_type_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub tax_invalid: Vec<models::CatalogsItemValidationDetails>,
            pub title_length_too_long: Vec<models::CatalogsItemValidationDetails>,
            pub too_many_additional_image_links: Vec<models::CatalogsItemValidationDetails>,
            pub utm_source_auto_corrected: Vec<models::CatalogsItemValidationDetails>,
            pub weight_unit_invalid: Vec<models::CatalogsItemValidationDetails>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsItemValidationWarnings".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "AD_LINK_FORMAT_WARNING" => intermediate_rep.ad_link_format_warning.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AD_LINK_SAME_AS_LINK" => intermediate_rep.ad_link_same_as_link.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ADDITIONAL_IMAGE_LINK_LENGTH_TOO_LONG" => intermediate_rep.additional_image_link_length_too_long.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ADDITIONAL_IMAGE_LINK_WARNING" => intermediate_rep.additional_image_link_warning.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ADWORDS_FORMAT_WARNING" => intermediate_rep.adwords_format_warning.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ADWORDS_SAME_AS_LINK" => intermediate_rep.adwords_same_as_link.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AGE_GROUP_INVALID" => intermediate_rep.age_group_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SIZE_SYSTEM_INVALID" => intermediate_rep.size_system_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ANDROID_DEEP_LINK_INVALID" => intermediate_rep.android_deep_link_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AVAILABILITY_DATE_INVALID" => intermediate_rep.availability_date_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "COUNTRY_DOES_NOT_MAP_TO_CURRENCY" => intermediate_rep.country_does_not_map_to_currency.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CUSTOM_LABEL_LENGTH_TOO_LONG" => intermediate_rep.custom_label_length_too_long.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DESCRIPTION_LENGTH_TOO_LONG" => intermediate_rep.description_length_too_long.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "EXPIRATION_DATE_INVALID" => intermediate_rep.expiration_date_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GENDER_INVALID" => intermediate_rep.gender_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GTIN_INVALID" => intermediate_rep.gtin_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IMAGE_LINK_WARNING" => intermediate_rep.image_link_warning.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IOS_DEEP_LINK_INVALID" => intermediate_rep.ios_deep_link_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IS_BUNDLE_INVALID" => intermediate_rep.is_bundle_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ITEM_ADDITIONAL_IMAGE_DOWNLOAD_FAILURE" => intermediate_rep.item_additional_image_download_failure.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "LINK_FORMAT_WARNING" => intermediate_rep.link_format_warning.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MIN_AD_PRICE_INVALID" => intermediate_rep.min_ad_price_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MPN_INVALID" => intermediate_rep.mpn_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MULTIPACK_INVALID" => intermediate_rep.multipack_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OPTIONAL_CONDITION_INVALID" => intermediate_rep.optional_condition_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OPTIONAL_CONDITION_MISSING" => intermediate_rep.optional_condition_missing.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OPTIONAL_PRODUCT_CATEGORY_INVALID" => intermediate_rep.optional_product_category_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OPTIONAL_PRODUCT_CATEGORY_MISSING" => intermediate_rep.optional_product_category_missing.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PRODUCT_CATEGORY_DEPTH_WARNING" => intermediate_rep.product_category_depth_warning.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PRODUCT_TYPE_LENGTH_TOO_LONG" => intermediate_rep.product_type_length_too_long.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SALES_PRICE_INVALID" => intermediate_rep.sales_price_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SALES_PRICE_TOO_LOW" => intermediate_rep.sales_price_too_low.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SALES_PRICE_TOO_HIGH" => intermediate_rep.sales_price_too_high.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SALE_DATE_INVALID" => intermediate_rep.sale_date_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SHIPPING_INVALID" => intermediate_rep.shipping_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SHIPPING_HEIGHT_INVALID" => intermediate_rep.shipping_height_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SHIPPING_WEIGHT_INVALID" => intermediate_rep.shipping_weight_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SHIPPING_WIDTH_INVALID" => intermediate_rep.shipping_width_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SIZE_TYPE_INVALID" => intermediate_rep.size_type_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "TAX_INVALID" => intermediate_rep.tax_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "TITLE_LENGTH_TOO_LONG" => intermediate_rep.title_length_too_long.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "TOO_MANY_ADDITIONAL_IMAGE_LINKS" => intermediate_rep.too_many_additional_image_links.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "UTM_SOURCE_AUTO_CORRECTED" => intermediate_rep.utm_source_auto_corrected.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "WEIGHT_UNIT_INVALID" => intermediate_rep.weight_unit_invalid.push(<models::CatalogsItemValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsItemValidationWarnings".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsItemValidationWarnings {
            ad_link_format_warning: intermediate_rep.ad_link_format_warning.into_iter().next(),
            ad_link_same_as_link: intermediate_rep.ad_link_same_as_link.into_iter().next(),
            additional_image_link_length_too_long: intermediate_rep.additional_image_link_length_too_long.into_iter().next(),
            additional_image_link_warning: intermediate_rep.additional_image_link_warning.into_iter().next(),
            adwords_format_warning: intermediate_rep.adwords_format_warning.into_iter().next(),
            adwords_same_as_link: intermediate_rep.adwords_same_as_link.into_iter().next(),
            age_group_invalid: intermediate_rep.age_group_invalid.into_iter().next(),
            size_system_invalid: intermediate_rep.size_system_invalid.into_iter().next(),
            android_deep_link_invalid: intermediate_rep.android_deep_link_invalid.into_iter().next(),
            availability_date_invalid: intermediate_rep.availability_date_invalid.into_iter().next(),
            country_does_not_map_to_currency: intermediate_rep.country_does_not_map_to_currency.into_iter().next(),
            custom_label_length_too_long: intermediate_rep.custom_label_length_too_long.into_iter().next(),
            description_length_too_long: intermediate_rep.description_length_too_long.into_iter().next(),
            expiration_date_invalid: intermediate_rep.expiration_date_invalid.into_iter().next(),
            gender_invalid: intermediate_rep.gender_invalid.into_iter().next(),
            gtin_invalid: intermediate_rep.gtin_invalid.into_iter().next(),
            image_link_warning: intermediate_rep.image_link_warning.into_iter().next(),
            ios_deep_link_invalid: intermediate_rep.ios_deep_link_invalid.into_iter().next(),
            is_bundle_invalid: intermediate_rep.is_bundle_invalid.into_iter().next(),
            item_additional_image_download_failure: intermediate_rep.item_additional_image_download_failure.into_iter().next(),
            link_format_warning: intermediate_rep.link_format_warning.into_iter().next(),
            min_ad_price_invalid: intermediate_rep.min_ad_price_invalid.into_iter().next(),
            mpn_invalid: intermediate_rep.mpn_invalid.into_iter().next(),
            multipack_invalid: intermediate_rep.multipack_invalid.into_iter().next(),
            optional_condition_invalid: intermediate_rep.optional_condition_invalid.into_iter().next(),
            optional_condition_missing: intermediate_rep.optional_condition_missing.into_iter().next(),
            optional_product_category_invalid: intermediate_rep.optional_product_category_invalid.into_iter().next(),
            optional_product_category_missing: intermediate_rep.optional_product_category_missing.into_iter().next(),
            product_category_depth_warning: intermediate_rep.product_category_depth_warning.into_iter().next(),
            product_type_length_too_long: intermediate_rep.product_type_length_too_long.into_iter().next(),
            sales_price_invalid: intermediate_rep.sales_price_invalid.into_iter().next(),
            sales_price_too_low: intermediate_rep.sales_price_too_low.into_iter().next(),
            sales_price_too_high: intermediate_rep.sales_price_too_high.into_iter().next(),
            sale_date_invalid: intermediate_rep.sale_date_invalid.into_iter().next(),
            shipping_invalid: intermediate_rep.shipping_invalid.into_iter().next(),
            shipping_height_invalid: intermediate_rep.shipping_height_invalid.into_iter().next(),
            shipping_weight_invalid: intermediate_rep.shipping_weight_invalid.into_iter().next(),
            shipping_width_invalid: intermediate_rep.shipping_width_invalid.into_iter().next(),
            size_type_invalid: intermediate_rep.size_type_invalid.into_iter().next(),
            tax_invalid: intermediate_rep.tax_invalid.into_iter().next(),
            title_length_too_long: intermediate_rep.title_length_too_long.into_iter().next(),
            too_many_additional_image_links: intermediate_rep.too_many_additional_image_links.into_iter().next(),
            utm_source_auto_corrected: intermediate_rep.utm_source_auto_corrected.into_iter().next(),
            weight_unit_invalid: intermediate_rep.weight_unit_invalid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsItemValidationWarnings> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsItemValidationWarnings>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsItemValidationWarnings>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsItemValidationWarnings - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsItemValidationWarnings> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsItemValidationWarnings as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsItemValidationWarnings - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Response object of catalogs items



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsItems {
/// Array with catalogs items
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::ItemResponse>>,

}


impl CatalogsItems {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsItems {
        CatalogsItems {
            items: None,
        }
    }
}

/// Converts the CatalogsItems value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsItems {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsItems value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsItems {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::ItemResponse>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsItems".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsItems".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsItems".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsItems {
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsItems> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsItems>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsItems>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsItems - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsItems> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsItems as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsItems - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object describing the catalogs items batch


/// One of:
/// - CatalogsHotelItemsBatch
/// - CatalogsRetailItemsBatch
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsItemsBatch(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsItemsBatch
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsItemsBatch value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsItemsBatch {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsItemsBatch {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Request object of catalogs items batch


/// One of:
/// - CatalogsItemsCreateBatchRequest
/// - CatalogsItemsDeleteBatchRequest
/// - CatalogsItemsDeleteDiscontinuedBatchRequest
/// - CatalogsItemsUpdateBatchRequest
/// - CatalogsItemsUpsertBatchRequest
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsItemsBatchRequest(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsItemsBatchRequest
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsItemsBatchRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsItemsBatchRequest {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsItemsBatchRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Request object to create catalogs items



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsItemsCreateBatchRequest {
    #[serde(rename = "country")]
    pub country: models::Country,

    #[serde(rename = "language")]
    pub language: models::Language,

    #[serde(rename = "operation")]
    pub operation: models::BatchOperation,

/// Array with catalogs items
    #[serde(rename = "items")]
    #[validate(
            length(min = 1, max = 1000),
        )]
    pub items: Vec<models::ItemCreateBatchRecord>,

}


impl CatalogsItemsCreateBatchRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(country: models::Country, language: models::Language, operation: models::BatchOperation, items: Vec<models::ItemCreateBatchRecord>, ) -> CatalogsItemsCreateBatchRequest {
        CatalogsItemsCreateBatchRequest {
            country,
            language,
            operation,
            items,
        }
    }
}

/// Converts the CatalogsItemsCreateBatchRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsItemsCreateBatchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping country in query parameter serialization

            // Skipping language in query parameter serialization

            // Skipping operation in query parameter serialization

            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsItemsCreateBatchRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsItemsCreateBatchRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub country: Vec<models::Country>,
            pub language: Vec<models::Language>,
            pub operation: Vec<models::BatchOperation>,
            pub items: Vec<Vec<models::ItemCreateBatchRecord>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsItemsCreateBatchRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "country" => intermediate_rep.country.push(<models::Country as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::Language as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operation" => intermediate_rep.operation.push(<models::BatchOperation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsItemsCreateBatchRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsItemsCreateBatchRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsItemsCreateBatchRequest {
            country: intermediate_rep.country.into_iter().next().ok_or_else(|| "country missing in CatalogsItemsCreateBatchRequest".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in CatalogsItemsCreateBatchRequest".to_string())?,
            operation: intermediate_rep.operation.into_iter().next().ok_or_else(|| "operation missing in CatalogsItemsCreateBatchRequest".to_string())?,
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in CatalogsItemsCreateBatchRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsItemsCreateBatchRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsItemsCreateBatchRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsItemsCreateBatchRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsItemsCreateBatchRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsItemsCreateBatchRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsItemsCreateBatchRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsItemsCreateBatchRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Request object to delete catalogs items



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsItemsDeleteBatchRequest {
    #[serde(rename = "country")]
    pub country: models::Country,

    #[serde(rename = "language")]
    pub language: models::Language,

    #[serde(rename = "operation")]
    pub operation: models::BatchOperation,

/// Array with catalogs items
    #[serde(rename = "items")]
    pub items: Vec<models::ItemDeleteBatchRecord>,

}


impl CatalogsItemsDeleteBatchRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(country: models::Country, language: models::Language, operation: models::BatchOperation, items: Vec<models::ItemDeleteBatchRecord>, ) -> CatalogsItemsDeleteBatchRequest {
        CatalogsItemsDeleteBatchRequest {
            country,
            language,
            operation,
            items,
        }
    }
}

/// Converts the CatalogsItemsDeleteBatchRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsItemsDeleteBatchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping country in query parameter serialization

            // Skipping language in query parameter serialization

            // Skipping operation in query parameter serialization

            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsItemsDeleteBatchRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsItemsDeleteBatchRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub country: Vec<models::Country>,
            pub language: Vec<models::Language>,
            pub operation: Vec<models::BatchOperation>,
            pub items: Vec<Vec<models::ItemDeleteBatchRecord>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsItemsDeleteBatchRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "country" => intermediate_rep.country.push(<models::Country as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::Language as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operation" => intermediate_rep.operation.push(<models::BatchOperation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsItemsDeleteBatchRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsItemsDeleteBatchRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsItemsDeleteBatchRequest {
            country: intermediate_rep.country.into_iter().next().ok_or_else(|| "country missing in CatalogsItemsDeleteBatchRequest".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in CatalogsItemsDeleteBatchRequest".to_string())?,
            operation: intermediate_rep.operation.into_iter().next().ok_or_else(|| "operation missing in CatalogsItemsDeleteBatchRequest".to_string())?,
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in CatalogsItemsDeleteBatchRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsItemsDeleteBatchRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsItemsDeleteBatchRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsItemsDeleteBatchRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsItemsDeleteBatchRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsItemsDeleteBatchRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsItemsDeleteBatchRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsItemsDeleteBatchRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Request object to discontinue catalogs items



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsItemsDeleteDiscontinuedBatchRequest {
    #[serde(rename = "country")]
    pub country: models::Country,

    #[serde(rename = "language")]
    pub language: models::Language,

    #[serde(rename = "operation")]
    pub operation: models::BatchOperation,

/// Array with catalogs items
    #[serde(rename = "items")]
    pub items: Vec<models::ItemDeleteDiscontinuedBatchRecord>,

}


impl CatalogsItemsDeleteDiscontinuedBatchRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(country: models::Country, language: models::Language, operation: models::BatchOperation, items: Vec<models::ItemDeleteDiscontinuedBatchRecord>, ) -> CatalogsItemsDeleteDiscontinuedBatchRequest {
        CatalogsItemsDeleteDiscontinuedBatchRequest {
            country,
            language,
            operation,
            items,
        }
    }
}

/// Converts the CatalogsItemsDeleteDiscontinuedBatchRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsItemsDeleteDiscontinuedBatchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping country in query parameter serialization

            // Skipping language in query parameter serialization

            // Skipping operation in query parameter serialization

            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsItemsDeleteDiscontinuedBatchRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsItemsDeleteDiscontinuedBatchRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub country: Vec<models::Country>,
            pub language: Vec<models::Language>,
            pub operation: Vec<models::BatchOperation>,
            pub items: Vec<Vec<models::ItemDeleteDiscontinuedBatchRecord>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsItemsDeleteDiscontinuedBatchRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "country" => intermediate_rep.country.push(<models::Country as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::Language as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operation" => intermediate_rep.operation.push(<models::BatchOperation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsItemsDeleteDiscontinuedBatchRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsItemsDeleteDiscontinuedBatchRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsItemsDeleteDiscontinuedBatchRequest {
            country: intermediate_rep.country.into_iter().next().ok_or_else(|| "country missing in CatalogsItemsDeleteDiscontinuedBatchRequest".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in CatalogsItemsDeleteDiscontinuedBatchRequest".to_string())?,
            operation: intermediate_rep.operation.into_iter().next().ok_or_else(|| "operation missing in CatalogsItemsDeleteDiscontinuedBatchRequest".to_string())?,
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in CatalogsItemsDeleteDiscontinuedBatchRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsItemsDeleteDiscontinuedBatchRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsItemsDeleteDiscontinuedBatchRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsItemsDeleteDiscontinuedBatchRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsItemsDeleteDiscontinuedBatchRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsItemsDeleteDiscontinuedBatchRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsItemsDeleteDiscontinuedBatchRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsItemsDeleteDiscontinuedBatchRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - CatalogsHotelItemsFilter
/// - CatalogsRetailItemsFilter
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsItemsFilters(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsItemsFilters
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsItemsFilters value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsItemsFilters {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsItemsFilters {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Request object to update catalogs items



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsItemsUpdateBatchRequest {
    #[serde(rename = "country")]
    pub country: models::Country,

    #[serde(rename = "language")]
    pub language: models::Language,

    #[serde(rename = "operation")]
    pub operation: models::BatchOperation,

/// Array with catalogs items
    #[serde(rename = "items")]
    #[validate(
            length(min = 1, max = 1000),
        )]
    pub items: Vec<models::ItemUpdateBatchRecord>,

}


impl CatalogsItemsUpdateBatchRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(country: models::Country, language: models::Language, operation: models::BatchOperation, items: Vec<models::ItemUpdateBatchRecord>, ) -> CatalogsItemsUpdateBatchRequest {
        CatalogsItemsUpdateBatchRequest {
            country,
            language,
            operation,
            items,
        }
    }
}

/// Converts the CatalogsItemsUpdateBatchRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsItemsUpdateBatchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping country in query parameter serialization

            // Skipping language in query parameter serialization

            // Skipping operation in query parameter serialization

            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsItemsUpdateBatchRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsItemsUpdateBatchRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub country: Vec<models::Country>,
            pub language: Vec<models::Language>,
            pub operation: Vec<models::BatchOperation>,
            pub items: Vec<Vec<models::ItemUpdateBatchRecord>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsItemsUpdateBatchRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "country" => intermediate_rep.country.push(<models::Country as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::Language as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operation" => intermediate_rep.operation.push(<models::BatchOperation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsItemsUpdateBatchRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsItemsUpdateBatchRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsItemsUpdateBatchRequest {
            country: intermediate_rep.country.into_iter().next().ok_or_else(|| "country missing in CatalogsItemsUpdateBatchRequest".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in CatalogsItemsUpdateBatchRequest".to_string())?,
            operation: intermediate_rep.operation.into_iter().next().ok_or_else(|| "operation missing in CatalogsItemsUpdateBatchRequest".to_string())?,
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in CatalogsItemsUpdateBatchRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsItemsUpdateBatchRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsItemsUpdateBatchRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsItemsUpdateBatchRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsItemsUpdateBatchRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsItemsUpdateBatchRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsItemsUpdateBatchRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsItemsUpdateBatchRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Request object to upsert catalogs items



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsItemsUpsertBatchRequest {
    #[serde(rename = "country")]
    pub country: models::Country,

    #[serde(rename = "language")]
    pub language: models::Language,

    #[serde(rename = "operation")]
    pub operation: models::BatchOperation,

/// Array with catalogs items
    #[serde(rename = "items")]
    #[validate(
            length(min = 1, max = 1000),
        )]
    pub items: Vec<models::ItemUpsertBatchRecord>,

}


impl CatalogsItemsUpsertBatchRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(country: models::Country, language: models::Language, operation: models::BatchOperation, items: Vec<models::ItemUpsertBatchRecord>, ) -> CatalogsItemsUpsertBatchRequest {
        CatalogsItemsUpsertBatchRequest {
            country,
            language,
            operation,
            items,
        }
    }
}

/// Converts the CatalogsItemsUpsertBatchRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsItemsUpsertBatchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping country in query parameter serialization

            // Skipping language in query parameter serialization

            // Skipping operation in query parameter serialization

            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsItemsUpsertBatchRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsItemsUpsertBatchRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub country: Vec<models::Country>,
            pub language: Vec<models::Language>,
            pub operation: Vec<models::BatchOperation>,
            pub items: Vec<Vec<models::ItemUpsertBatchRecord>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsItemsUpsertBatchRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "country" => intermediate_rep.country.push(<models::Country as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::Language as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operation" => intermediate_rep.operation.push(<models::BatchOperation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsItemsUpsertBatchRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsItemsUpsertBatchRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsItemsUpsertBatchRequest {
            country: intermediate_rep.country.into_iter().next().ok_or_else(|| "country missing in CatalogsItemsUpsertBatchRequest".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in CatalogsItemsUpsertBatchRequest".to_string())?,
            operation: intermediate_rep.operation.into_iter().next().ok_or_else(|| "operation missing in CatalogsItemsUpsertBatchRequest".to_string())?,
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in CatalogsItemsUpsertBatchRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsItemsUpsertBatchRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsItemsUpsertBatchRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsItemsUpsertBatchRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsItemsUpsertBatchRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsItemsUpsertBatchRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsItemsUpsertBatchRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsItemsUpsertBatchRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::Catalog>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl CatalogsList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::Catalog>, ) -> CatalogsList200Response {
        CatalogsList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the CatalogsList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::Catalog>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in CatalogsList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in CatalogsList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Request object to list products for a given product group filter.


/// One of:
/// - CatalogsListProductsByFilterRequestOneOf
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsListProductsByFilterRequest(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsListProductsByFilterRequest
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsListProductsByFilterRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsListProductsByFilterRequest {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsListProductsByFilterRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Request object to list products for a given feed_id and product group filter.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsListProductsByFilterRequestOneOf {
/// Catalog Feed id pertaining to the catalog product group filter.
    #[serde(rename = "feed_id")]
    #[validate(
           regex = "RE_CATALOGSLISTPRODUCTSBYFILTERREQUESTONEOF_FEED_ID",
        )]
    pub feed_id: String,

    #[serde(rename = "filters")]
    pub filters: models::CatalogsProductGroupFilters,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGSLISTPRODUCTSBYFILTERREQUESTONEOF_FEED_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CatalogsListProductsByFilterRequestOneOf {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(feed_id: String, filters: models::CatalogsProductGroupFilters, ) -> CatalogsListProductsByFilterRequestOneOf {
        CatalogsListProductsByFilterRequestOneOf {
            feed_id,
            filters,
        }
    }
}

/// Converts the CatalogsListProductsByFilterRequestOneOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsListProductsByFilterRequestOneOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("feed_id".to_string()),
            Some(self.feed_id.to_string()),

            // Skipping filters in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsListProductsByFilterRequestOneOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsListProductsByFilterRequestOneOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub feed_id: Vec<String>,
            pub filters: Vec<models::CatalogsProductGroupFilters>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsListProductsByFilterRequestOneOf".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "feed_id" => intermediate_rep.feed_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "filters" => intermediate_rep.filters.push(<models::CatalogsProductGroupFilters as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsListProductsByFilterRequestOneOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsListProductsByFilterRequestOneOf {
            feed_id: intermediate_rep.feed_id.into_iter().next().ok_or_else(|| "feed_id missing in CatalogsListProductsByFilterRequestOneOf".to_string())?,
            filters: intermediate_rep.filters.into_iter().next().ok_or_else(|| "filters missing in CatalogsListProductsByFilterRequestOneOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsListProductsByFilterRequestOneOf> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsListProductsByFilterRequestOneOf>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsListProductsByFilterRequestOneOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsListProductsByFilterRequestOneOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsListProductsByFilterRequestOneOf> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsListProductsByFilterRequestOneOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsListProductsByFilterRequestOneOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CatalogsLocale {
    #[serde(rename = "af-ZA")]
    AfZa,
    #[serde(rename = "ar-SA")]
    ArSa,
    #[serde(rename = "bg-BG")]
    BgBg,
    #[serde(rename = "bn-IN")]
    BnIn,
    #[serde(rename = "cs-CZ")]
    CsCz,
    #[serde(rename = "da-DK")]
    DaDk,
    #[serde(rename = "de")]
    De,
    #[serde(rename = "el-GR")]
    ElGr,
    #[serde(rename = "en-AU")]
    EnAu,
    #[serde(rename = "en-CA")]
    EnCa,
    #[serde(rename = "en-GB")]
    EnGb,
    #[serde(rename = "en-IN")]
    EnIn,
    #[serde(rename = "en-US")]
    EnUs,
    #[serde(rename = "es-419")]
    Es419,
    #[serde(rename = "es-AR")]
    EsAr,
    #[serde(rename = "es-ES")]
    EsEs,
    #[serde(rename = "es-MX")]
    EsMx,
    #[serde(rename = "fi-FI")]
    FiFi,
    #[serde(rename = "fr")]
    Fr,
    #[serde(rename = "fr-CA")]
    FrCa,
    #[serde(rename = "he-IL")]
    HeIl,
    #[serde(rename = "hi-IN")]
    HiIn,
    #[serde(rename = "hr-HR")]
    HrHr,
    #[serde(rename = "hu-HU")]
    HuHu,
    #[serde(rename = "id-ID")]
    IdId,
    #[serde(rename = "it")]
    It,
    #[serde(rename = "ja")]
    Ja,
    #[serde(rename = "ko-KR")]
    KoKr,
    #[serde(rename = "ms-MY")]
    MsMy,
    #[serde(rename = "nb-NO")]
    NbNo,
    #[serde(rename = "nl")]
    Nl,
    #[serde(rename = "pl-PL")]
    PlPl,
    #[serde(rename = "pt-BR")]
    PtBr,
    #[serde(rename = "pt-PT")]
    PtPt,
    #[serde(rename = "ro-RO")]
    RoRo,
    #[serde(rename = "ru-RU")]
    RuRu,
    #[serde(rename = "sk-SK")]
    SkSk,
    #[serde(rename = "sv-SE")]
    SvSe,
    #[serde(rename = "te-IN")]
    TeIn,
    #[serde(rename = "th-TH")]
    ThTh,
    #[serde(rename = "tl-PH")]
    TlPh,
    #[serde(rename = "tr")]
    Tr,
    #[serde(rename = "uk-UA")]
    UkUa,
    #[serde(rename = "vi-VN")]
    ViVn,
    #[serde(rename = "zh-CN")]
    ZhCn,
    #[serde(rename = "zh-TW")]
    ZhTw,
}

impl std::fmt::Display for CatalogsLocale {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CatalogsLocale::AfZa => write!(f, "af-ZA"),
            CatalogsLocale::ArSa => write!(f, "ar-SA"),
            CatalogsLocale::BgBg => write!(f, "bg-BG"),
            CatalogsLocale::BnIn => write!(f, "bn-IN"),
            CatalogsLocale::CsCz => write!(f, "cs-CZ"),
            CatalogsLocale::DaDk => write!(f, "da-DK"),
            CatalogsLocale::De => write!(f, "de"),
            CatalogsLocale::ElGr => write!(f, "el-GR"),
            CatalogsLocale::EnAu => write!(f, "en-AU"),
            CatalogsLocale::EnCa => write!(f, "en-CA"),
            CatalogsLocale::EnGb => write!(f, "en-GB"),
            CatalogsLocale::EnIn => write!(f, "en-IN"),
            CatalogsLocale::EnUs => write!(f, "en-US"),
            CatalogsLocale::Es419 => write!(f, "es-419"),
            CatalogsLocale::EsAr => write!(f, "es-AR"),
            CatalogsLocale::EsEs => write!(f, "es-ES"),
            CatalogsLocale::EsMx => write!(f, "es-MX"),
            CatalogsLocale::FiFi => write!(f, "fi-FI"),
            CatalogsLocale::Fr => write!(f, "fr"),
            CatalogsLocale::FrCa => write!(f, "fr-CA"),
            CatalogsLocale::HeIl => write!(f, "he-IL"),
            CatalogsLocale::HiIn => write!(f, "hi-IN"),
            CatalogsLocale::HrHr => write!(f, "hr-HR"),
            CatalogsLocale::HuHu => write!(f, "hu-HU"),
            CatalogsLocale::IdId => write!(f, "id-ID"),
            CatalogsLocale::It => write!(f, "it"),
            CatalogsLocale::Ja => write!(f, "ja"),
            CatalogsLocale::KoKr => write!(f, "ko-KR"),
            CatalogsLocale::MsMy => write!(f, "ms-MY"),
            CatalogsLocale::NbNo => write!(f, "nb-NO"),
            CatalogsLocale::Nl => write!(f, "nl"),
            CatalogsLocale::PlPl => write!(f, "pl-PL"),
            CatalogsLocale::PtBr => write!(f, "pt-BR"),
            CatalogsLocale::PtPt => write!(f, "pt-PT"),
            CatalogsLocale::RoRo => write!(f, "ro-RO"),
            CatalogsLocale::RuRu => write!(f, "ru-RU"),
            CatalogsLocale::SkSk => write!(f, "sk-SK"),
            CatalogsLocale::SvSe => write!(f, "sv-SE"),
            CatalogsLocale::TeIn => write!(f, "te-IN"),
            CatalogsLocale::ThTh => write!(f, "th-TH"),
            CatalogsLocale::TlPh => write!(f, "tl-PH"),
            CatalogsLocale::Tr => write!(f, "tr"),
            CatalogsLocale::UkUa => write!(f, "uk-UA"),
            CatalogsLocale::ViVn => write!(f, "vi-VN"),
            CatalogsLocale::ZhCn => write!(f, "zh-CN"),
            CatalogsLocale::ZhTw => write!(f, "zh-TW"),
        }
    }
}

impl std::str::FromStr for CatalogsLocale {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "af-ZA" => std::result::Result::Ok(CatalogsLocale::AfZa),
            "ar-SA" => std::result::Result::Ok(CatalogsLocale::ArSa),
            "bg-BG" => std::result::Result::Ok(CatalogsLocale::BgBg),
            "bn-IN" => std::result::Result::Ok(CatalogsLocale::BnIn),
            "cs-CZ" => std::result::Result::Ok(CatalogsLocale::CsCz),
            "da-DK" => std::result::Result::Ok(CatalogsLocale::DaDk),
            "de" => std::result::Result::Ok(CatalogsLocale::De),
            "el-GR" => std::result::Result::Ok(CatalogsLocale::ElGr),
            "en-AU" => std::result::Result::Ok(CatalogsLocale::EnAu),
            "en-CA" => std::result::Result::Ok(CatalogsLocale::EnCa),
            "en-GB" => std::result::Result::Ok(CatalogsLocale::EnGb),
            "en-IN" => std::result::Result::Ok(CatalogsLocale::EnIn),
            "en-US" => std::result::Result::Ok(CatalogsLocale::EnUs),
            "es-419" => std::result::Result::Ok(CatalogsLocale::Es419),
            "es-AR" => std::result::Result::Ok(CatalogsLocale::EsAr),
            "es-ES" => std::result::Result::Ok(CatalogsLocale::EsEs),
            "es-MX" => std::result::Result::Ok(CatalogsLocale::EsMx),
            "fi-FI" => std::result::Result::Ok(CatalogsLocale::FiFi),
            "fr" => std::result::Result::Ok(CatalogsLocale::Fr),
            "fr-CA" => std::result::Result::Ok(CatalogsLocale::FrCa),
            "he-IL" => std::result::Result::Ok(CatalogsLocale::HeIl),
            "hi-IN" => std::result::Result::Ok(CatalogsLocale::HiIn),
            "hr-HR" => std::result::Result::Ok(CatalogsLocale::HrHr),
            "hu-HU" => std::result::Result::Ok(CatalogsLocale::HuHu),
            "id-ID" => std::result::Result::Ok(CatalogsLocale::IdId),
            "it" => std::result::Result::Ok(CatalogsLocale::It),
            "ja" => std::result::Result::Ok(CatalogsLocale::Ja),
            "ko-KR" => std::result::Result::Ok(CatalogsLocale::KoKr),
            "ms-MY" => std::result::Result::Ok(CatalogsLocale::MsMy),
            "nb-NO" => std::result::Result::Ok(CatalogsLocale::NbNo),
            "nl" => std::result::Result::Ok(CatalogsLocale::Nl),
            "pl-PL" => std::result::Result::Ok(CatalogsLocale::PlPl),
            "pt-BR" => std::result::Result::Ok(CatalogsLocale::PtBr),
            "pt-PT" => std::result::Result::Ok(CatalogsLocale::PtPt),
            "ro-RO" => std::result::Result::Ok(CatalogsLocale::RoRo),
            "ru-RU" => std::result::Result::Ok(CatalogsLocale::RuRu),
            "sk-SK" => std::result::Result::Ok(CatalogsLocale::SkSk),
            "sv-SE" => std::result::Result::Ok(CatalogsLocale::SvSe),
            "te-IN" => std::result::Result::Ok(CatalogsLocale::TeIn),
            "th-TH" => std::result::Result::Ok(CatalogsLocale::ThTh),
            "tl-PH" => std::result::Result::Ok(CatalogsLocale::TlPh),
            "tr" => std::result::Result::Ok(CatalogsLocale::Tr),
            "uk-UA" => std::result::Result::Ok(CatalogsLocale::UkUa),
            "vi-VN" => std::result::Result::Ok(CatalogsLocale::ViVn),
            "zh-CN" => std::result::Result::Ok(CatalogsLocale::ZhCn),
            "zh-TW" => std::result::Result::Ok(CatalogsLocale::ZhTw),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProduct {
    #[serde(rename = "metadata")]
    pub metadata: models::CatalogsProductMetadata,

    #[serde(rename = "pin")]
    pub pin: Nullable<models::Pin>,

}


impl CatalogsProduct {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(metadata: models::CatalogsProductMetadata, pin: Nullable<models::Pin>, ) -> CatalogsProduct {
        CatalogsProduct {
            metadata,
            pin,
        }
    }
}

/// Converts the CatalogsProduct value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProduct {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping metadata in query parameter serialization

            // Skipping pin in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProduct value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProduct {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub metadata: Vec<models::CatalogsProductMetadata>,
            pub pin: Vec<models::Pin>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProduct".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<models::CatalogsProductMetadata as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pin" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsProduct".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProduct".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProduct {
            metadata: intermediate_rep.metadata.into_iter().next().ok_or_else(|| "metadata missing in CatalogsProduct".to_string())?,
            pin: std::result::Result::Err("Nullable types not supported in CatalogsProduct".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProduct> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProduct>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProduct>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProduct - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProduct> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProduct as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProduct - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// catalog product group entity



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroup {
/// ID of the catalog product group.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_CATALOGSPRODUCTGROUP_ID",
        )]
    pub id: String,

/// Name of catalog product group
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

    #[serde(rename = "filters")]
    pub filters: models::CatalogsProductGroupFilters,

/// boolean indicator of whether the product group is being featured or not
    #[serde(rename = "is_featured")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_featured: Option<bool>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::CatalogsProductGroupType>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::CatalogsProductGroupStatus>,

/// Unix timestamp in seconds of when catalog product group was created.
    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<i32>,

/// Unix timestamp in seconds of last time catalog product group was updated.
    #[serde(rename = "updated_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<i32>,

/// id of the catalogs feed belonging to this catalog product group
    #[serde(rename = "feed_id")]
    #[validate(
           regex = "RE_CATALOGSPRODUCTGROUP_FEED_ID",
        )]
    pub feed_id: String,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "catalog_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub catalog_type: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGSPRODUCTGROUP_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_CATALOGSPRODUCTGROUP_FEED_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CatalogsProductGroup {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, filters: models::CatalogsProductGroupFilters, feed_id: String, ) -> CatalogsProductGroup {
        CatalogsProductGroup {
            id,
            name: None,
            description: None,
            filters,
            is_featured: None,
            r#type: None,
            status: None,
            created_at: None,
            updated_at: None,
            feed_id,
            catalog_type: None,
        }
    }
}

/// Converts the CatalogsProductGroup value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping filters in query parameter serialization


            self.is_featured.as_ref().map(|is_featured| {
                [
                    "is_featured".to_string(),
                    is_featured.to_string(),
                ].join(",")
            }),

            // Skipping type in query parameter serialization

            // Skipping status in query parameter serialization


            self.created_at.as_ref().map(|created_at| {
                [
                    "created_at".to_string(),
                    created_at.to_string(),
                ].join(",")
            }),


            self.updated_at.as_ref().map(|updated_at| {
                [
                    "updated_at".to_string(),
                    updated_at.to_string(),
                ].join(",")
            }),


            Some("feed_id".to_string()),
            Some(self.feed_id.to_string()),


            self.catalog_type.as_ref().map(|catalog_type| {
                [
                    "catalog_type".to_string(),
                    catalog_type.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroup value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroup {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub filters: Vec<models::CatalogsProductGroupFilters>,
            pub is_featured: Vec<bool>,
            pub r#type: Vec<models::CatalogsProductGroupType>,
            pub status: Vec<models::CatalogsProductGroupStatus>,
            pub created_at: Vec<i32>,
            pub updated_at: Vec<i32>,
            pub feed_id: Vec<String>,
            pub catalog_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroup".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsProductGroup".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "filters" => intermediate_rep.filters.push(<models::CatalogsProductGroupFilters as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_featured" => intermediate_rep.is_featured.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::CatalogsProductGroupType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::CatalogsProductGroupStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updated_at" => intermediate_rep.updated_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "feed_id" => intermediate_rep.feed_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroup".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroup {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in CatalogsProductGroup".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            description: std::result::Result::Err("Nullable types not supported in CatalogsProductGroup".to_string())?,
            filters: intermediate_rep.filters.into_iter().next().ok_or_else(|| "filters missing in CatalogsProductGroup".to_string())?,
            is_featured: intermediate_rep.is_featured.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            feed_id: intermediate_rep.feed_id.into_iter().next().ok_or_else(|| "feed_id missing in CatalogsProductGroup".to_string())?,
            catalog_type: intermediate_rep.catalog_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroup> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroup>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroup>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroup - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductGroup> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroup as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroup - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Request object for creating a product group.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupCreateRequest {
    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

/// boolean indicator of whether the product group is being featured or not
    #[serde(rename = "is_featured")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_featured: Option<bool>,

    #[serde(rename = "filters")]
    pub filters: models::CatalogsProductGroupFiltersRequest,

/// Catalog Feed id pertaining to the catalog product group.
    #[serde(rename = "feed_id")]
    #[validate(
           regex = "RE_CATALOGSPRODUCTGROUPCREATEREQUEST_FEED_ID",
        )]
    pub feed_id: String,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGSPRODUCTGROUPCREATEREQUEST_FEED_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CatalogsProductGroupCreateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, filters: models::CatalogsProductGroupFiltersRequest, feed_id: String, ) -> CatalogsProductGroupCreateRequest {
        CatalogsProductGroupCreateRequest {
            name,
            description: None,
            is_featured: Some(false),
            filters,
            feed_id,
        }
    }
}

/// Converts the CatalogsProductGroupCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductGroupCreateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_featured.as_ref().map(|is_featured| {
                [
                    "is_featured".to_string(),
                    is_featured.to_string(),
                ].join(",")
            }),

            // Skipping filters in query parameter serialization


            Some("feed_id".to_string()),
            Some(self.feed_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub is_featured: Vec<bool>,
            pub filters: Vec<models::CatalogsProductGroupFiltersRequest>,
            pub feed_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsProductGroupCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "is_featured" => intermediate_rep.is_featured.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "filters" => intermediate_rep.filters.push(<models::CatalogsProductGroupFiltersRequest as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "feed_id" => intermediate_rep.feed_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupCreateRequest {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in CatalogsProductGroupCreateRequest".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in CatalogsProductGroupCreateRequest".to_string())?,
            is_featured: intermediate_rep.is_featured.into_iter().next(),
            filters: intermediate_rep.filters.into_iter().next().ok_or_else(|| "filters missing in CatalogsProductGroupCreateRequest".to_string())?,
            feed_id: intermediate_rep.feed_id.into_iter().next().ok_or_else(|| "feed_id missing in CatalogsProductGroupCreateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupCreateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupCreateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupCreateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupCreateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A currency filter. This filter cannot be negated



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupCurrencyCriteria {
    #[serde(rename = "values")]
    pub values: models::NonNullableCatalogsCurrency,

    #[serde(rename = "negated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub negated: Option<bool>,

}


impl CatalogsProductGroupCurrencyCriteria {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(values: models::NonNullableCatalogsCurrency, ) -> CatalogsProductGroupCurrencyCriteria {
        CatalogsProductGroupCurrencyCriteria {
            values,
            negated: Some(false),
        }
    }
}

/// Converts the CatalogsProductGroupCurrencyCriteria value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductGroupCurrencyCriteria {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping values in query parameter serialization


            self.negated.as_ref().map(|negated| {
                [
                    "negated".to_string(),
                    negated.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupCurrencyCriteria value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupCurrencyCriteria {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub values: Vec<models::NonNullableCatalogsCurrency>,
            pub negated: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupCurrencyCriteria".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "values" => intermediate_rep.values.push(<models::NonNullableCatalogsCurrency as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "negated" => intermediate_rep.negated.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupCurrencyCriteria".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupCurrencyCriteria {
            values: intermediate_rep.values.into_iter().next().ok_or_else(|| "values missing in CatalogsProductGroupCurrencyCriteria".to_string())?,
            negated: intermediate_rep.negated.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupCurrencyCriteria> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupCurrencyCriteria>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupCurrencyCriteria>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupCurrencyCriteria - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupCurrencyCriteria> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupCurrencyCriteria as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupCurrencyCriteria - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}





/// Any of:
/// - AvailabilityFilter
/// - BrandFilter
/// - ConditionFilter
/// - CurrencyFilter
/// - CustomLabel0Filter
/// - CustomLabel1Filter
/// - CustomLabel2Filter
/// - CustomLabel3Filter
/// - CustomLabel4Filter
/// - GenderFilter
/// - GoogleProductCategory0Filter
/// - GoogleProductCategory1Filter
/// - GoogleProductCategory2Filter
/// - GoogleProductCategory3Filter
/// - GoogleProductCategory4Filter
/// - GoogleProductCategory5Filter
/// - GoogleProductCategory6Filter
/// - ItemGroupIdFilter
/// - ItemIdFilter
/// - MaxPriceFilter
/// - MinPriceFilter
/// - ProductType0Filter
/// - ProductType1Filter
/// - ProductType2Filter
/// - ProductType3Filter
/// - ProductType4Filter
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsProductGroupFilterKeys(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsProductGroupFilterKeys
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupFilterKeys value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupFilterKeys {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsProductGroupFilterKeys {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}






/// Object holding a group of filters for a catalog product group

/// Any of:
/// - CatalogsProductGroupFiltersAllOf
/// - CatalogsProductGroupFiltersAnyOf
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsProductGroupFilters(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsProductGroupFilters
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupFilters value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupFilters {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsProductGroupFilters {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}









#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupFiltersAllOf {
    #[serde(rename = "all_of")]
    pub all_of: Vec<models::CatalogsProductGroupFilterKeys>,

}


impl CatalogsProductGroupFiltersAllOf {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(all_of: Vec<models::CatalogsProductGroupFilterKeys>, ) -> CatalogsProductGroupFiltersAllOf {
        CatalogsProductGroupFiltersAllOf {
            all_of,
        }
    }
}

/// Converts the CatalogsProductGroupFiltersAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductGroupFiltersAllOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping all_of in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupFiltersAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupFiltersAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub all_of: Vec<Vec<models::CatalogsProductGroupFilterKeys>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupFiltersAllOf".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "all_of" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsProductGroupFiltersAllOf".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupFiltersAllOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupFiltersAllOf {
            all_of: intermediate_rep.all_of.into_iter().next().ok_or_else(|| "all_of missing in CatalogsProductGroupFiltersAllOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupFiltersAllOf> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupFiltersAllOf>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupFiltersAllOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupFiltersAllOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupFiltersAllOf> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupFiltersAllOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupFiltersAllOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupFiltersAnyOf {
    #[serde(rename = "any_of")]
    pub any_of: Vec<models::CatalogsProductGroupFilterKeys>,

}


impl CatalogsProductGroupFiltersAnyOf {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(any_of: Vec<models::CatalogsProductGroupFilterKeys>, ) -> CatalogsProductGroupFiltersAnyOf {
        CatalogsProductGroupFiltersAnyOf {
            any_of,
        }
    }
}

/// Converts the CatalogsProductGroupFiltersAnyOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductGroupFiltersAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping any_of in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupFiltersAnyOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupFiltersAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub any_of: Vec<Vec<models::CatalogsProductGroupFilterKeys>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupFiltersAnyOf".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "any_of" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsProductGroupFiltersAnyOf".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupFiltersAnyOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupFiltersAnyOf {
            any_of: intermediate_rep.any_of.into_iter().next().ok_or_else(|| "any_of missing in CatalogsProductGroupFiltersAnyOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupFiltersAnyOf> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupFiltersAnyOf>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupFiltersAnyOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupFiltersAnyOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupFiltersAnyOf> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupFiltersAnyOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupFiltersAnyOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object holding a group of filters for request on catalog product group. This is a distinct schema It is not possible to create or update a Product Group with empty filters. But some automatically generated Product Groups might have empty filters.

/// Any of:
/// - CatalogsProductGroupFiltersRequestAnyOf
/// - CatalogsProductGroupFiltersRequestAnyOf1
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsProductGroupFiltersRequest(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsProductGroupFiltersRequest
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupFiltersRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupFiltersRequest {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsProductGroupFiltersRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}









#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupFiltersRequestAnyOf {
    #[serde(rename = "any_of")]
    #[validate(
            length(min = 1),
        )]
    pub any_of: Vec<models::CatalogsProductGroupFilterKeys>,

}


impl CatalogsProductGroupFiltersRequestAnyOf {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(any_of: Vec<models::CatalogsProductGroupFilterKeys>, ) -> CatalogsProductGroupFiltersRequestAnyOf {
        CatalogsProductGroupFiltersRequestAnyOf {
            any_of,
        }
    }
}

/// Converts the CatalogsProductGroupFiltersRequestAnyOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductGroupFiltersRequestAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping any_of in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupFiltersRequestAnyOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupFiltersRequestAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub any_of: Vec<Vec<models::CatalogsProductGroupFilterKeys>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupFiltersRequestAnyOf".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "any_of" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsProductGroupFiltersRequestAnyOf".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupFiltersRequestAnyOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupFiltersRequestAnyOf {
            any_of: intermediate_rep.any_of.into_iter().next().ok_or_else(|| "any_of missing in CatalogsProductGroupFiltersRequestAnyOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupFiltersRequestAnyOf> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupFiltersRequestAnyOf>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupFiltersRequestAnyOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupFiltersRequestAnyOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupFiltersRequestAnyOf> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupFiltersRequestAnyOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupFiltersRequestAnyOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupFiltersRequestAnyOf1 {
    #[serde(rename = "all_of")]
    #[validate(
            length(min = 1),
        )]
    pub all_of: Vec<models::CatalogsProductGroupFilterKeys>,

}


impl CatalogsProductGroupFiltersRequestAnyOf1 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(all_of: Vec<models::CatalogsProductGroupFilterKeys>, ) -> CatalogsProductGroupFiltersRequestAnyOf1 {
        CatalogsProductGroupFiltersRequestAnyOf1 {
            all_of,
        }
    }
}

/// Converts the CatalogsProductGroupFiltersRequestAnyOf1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductGroupFiltersRequestAnyOf1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping all_of in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupFiltersRequestAnyOf1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupFiltersRequestAnyOf1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub all_of: Vec<Vec<models::CatalogsProductGroupFilterKeys>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupFiltersRequestAnyOf1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "all_of" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsProductGroupFiltersRequestAnyOf1".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupFiltersRequestAnyOf1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupFiltersRequestAnyOf1 {
            all_of: intermediate_rep.all_of.into_iter().next().ok_or_else(|| "all_of missing in CatalogsProductGroupFiltersRequestAnyOf1".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupFiltersRequestAnyOf1> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupFiltersRequestAnyOf1>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupFiltersRequestAnyOf1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupFiltersRequestAnyOf1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupFiltersRequestAnyOf1> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupFiltersRequestAnyOf1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupFiltersRequestAnyOf1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupMultipleCountriesCriteria {
    #[serde(rename = "values")]
    pub values: Vec<models::Country>,

    #[serde(rename = "negated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub negated: Option<bool>,

}


impl CatalogsProductGroupMultipleCountriesCriteria {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(values: Vec<models::Country>, ) -> CatalogsProductGroupMultipleCountriesCriteria {
        CatalogsProductGroupMultipleCountriesCriteria {
            values,
            negated: Some(false),
        }
    }
}

/// Converts the CatalogsProductGroupMultipleCountriesCriteria value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductGroupMultipleCountriesCriteria {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping values in query parameter serialization


            self.negated.as_ref().map(|negated| {
                [
                    "negated".to_string(),
                    negated.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupMultipleCountriesCriteria value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupMultipleCountriesCriteria {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub values: Vec<Vec<models::Country>>,
            pub negated: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupMultipleCountriesCriteria".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "values" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsProductGroupMultipleCountriesCriteria".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "negated" => intermediate_rep.negated.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupMultipleCountriesCriteria".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupMultipleCountriesCriteria {
            values: intermediate_rep.values.into_iter().next().ok_or_else(|| "values missing in CatalogsProductGroupMultipleCountriesCriteria".to_string())?,
            negated: intermediate_rep.negated.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupMultipleCountriesCriteria> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupMultipleCountriesCriteria>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupMultipleCountriesCriteria>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupMultipleCountriesCriteria - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupMultipleCountriesCriteria> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupMultipleCountriesCriteria as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupMultipleCountriesCriteria - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupMultipleGenderCriteria {
    #[serde(rename = "values")]
    pub values: Vec<models::Gender>,

    #[serde(rename = "negated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub negated: Option<bool>,

}


impl CatalogsProductGroupMultipleGenderCriteria {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(values: Vec<models::Gender>, ) -> CatalogsProductGroupMultipleGenderCriteria {
        CatalogsProductGroupMultipleGenderCriteria {
            values,
            negated: Some(false),
        }
    }
}

/// Converts the CatalogsProductGroupMultipleGenderCriteria value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductGroupMultipleGenderCriteria {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping values in query parameter serialization


            self.negated.as_ref().map(|negated| {
                [
                    "negated".to_string(),
                    negated.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupMultipleGenderCriteria value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupMultipleGenderCriteria {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub values: Vec<Vec<models::Gender>>,
            pub negated: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupMultipleGenderCriteria".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "values" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsProductGroupMultipleGenderCriteria".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "negated" => intermediate_rep.negated.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupMultipleGenderCriteria".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupMultipleGenderCriteria {
            values: intermediate_rep.values.into_iter().next().ok_or_else(|| "values missing in CatalogsProductGroupMultipleGenderCriteria".to_string())?,
            negated: intermediate_rep.negated.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupMultipleGenderCriteria> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupMultipleGenderCriteria>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupMultipleGenderCriteria>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupMultipleGenderCriteria - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupMultipleGenderCriteria> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupMultipleGenderCriteria as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupMultipleGenderCriteria - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupMultipleStringCriteria {
    #[serde(rename = "values")]
    pub values: Vec<String>,

    #[serde(rename = "negated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub negated: Option<bool>,

}


impl CatalogsProductGroupMultipleStringCriteria {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(values: Vec<String>, ) -> CatalogsProductGroupMultipleStringCriteria {
        CatalogsProductGroupMultipleStringCriteria {
            values,
            negated: Some(false),
        }
    }
}

/// Converts the CatalogsProductGroupMultipleStringCriteria value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductGroupMultipleStringCriteria {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("values".to_string()),
            Some(self.values.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            self.negated.as_ref().map(|negated| {
                [
                    "negated".to_string(),
                    negated.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupMultipleStringCriteria value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupMultipleStringCriteria {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub values: Vec<Vec<String>>,
            pub negated: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupMultipleStringCriteria".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "values" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsProductGroupMultipleStringCriteria".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "negated" => intermediate_rep.negated.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupMultipleStringCriteria".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupMultipleStringCriteria {
            values: intermediate_rep.values.into_iter().next().ok_or_else(|| "values missing in CatalogsProductGroupMultipleStringCriteria".to_string())?,
            negated: intermediate_rep.negated.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupMultipleStringCriteria> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupMultipleStringCriteria>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupMultipleStringCriteria>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupMultipleStringCriteria - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupMultipleStringCriteria> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupMultipleStringCriteria - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupMultipleStringListCriteria {
    #[serde(rename = "values")]
    pub values: Vec<Vec<String>>,

    #[serde(rename = "negated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub negated: Option<bool>,

}


impl CatalogsProductGroupMultipleStringListCriteria {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(values: Vec<Vec<String>>, ) -> CatalogsProductGroupMultipleStringListCriteria {
        CatalogsProductGroupMultipleStringListCriteria {
            values,
            negated: Some(false),
        }
    }
}

/// Converts the CatalogsProductGroupMultipleStringListCriteria value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductGroupMultipleStringListCriteria {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping values in query parameter serialization


            self.negated.as_ref().map(|negated| {
                [
                    "negated".to_string(),
                    negated.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupMultipleStringListCriteria value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupMultipleStringListCriteria {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub values: Vec<Vec<Vec<String>>>,
            pub negated: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupMultipleStringListCriteria".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "values" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsProductGroupMultipleStringListCriteria".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "negated" => intermediate_rep.negated.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupMultipleStringListCriteria".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupMultipleStringListCriteria {
            values: intermediate_rep.values.into_iter().next().ok_or_else(|| "values missing in CatalogsProductGroupMultipleStringListCriteria".to_string())?,
            negated: intermediate_rep.negated.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupMultipleStringListCriteria> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupMultipleStringListCriteria>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupMultipleStringListCriteria>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupMultipleStringListCriteria - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupMultipleStringListCriteria> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupMultipleStringListCriteria - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupPinsList200Response {
/// Pins
    #[serde(rename = "items")]
    pub items: Vec<models::CatalogsProduct>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl CatalogsProductGroupPinsList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::CatalogsProduct>, ) -> CatalogsProductGroupPinsList200Response {
        CatalogsProductGroupPinsList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the CatalogsProductGroupPinsList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductGroupPinsList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupPinsList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupPinsList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::CatalogsProduct>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupPinsList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsProductGroupPinsList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsProductGroupPinsList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupPinsList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupPinsList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in CatalogsProductGroupPinsList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in CatalogsProductGroupPinsList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupPinsList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupPinsList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupPinsList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupPinsList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupPinsList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupPinsList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupPinsList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupPricingCriteria {
    #[serde(rename = "inclusion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub inclusion: Option<bool>,

    #[serde(rename = "values")]
    #[validate(
            range(min = 0),
        )]
    pub values: f64,

    #[serde(rename = "negated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub negated: Option<bool>,

}


impl CatalogsProductGroupPricingCriteria {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(values: f64, ) -> CatalogsProductGroupPricingCriteria {
        CatalogsProductGroupPricingCriteria {
            inclusion: Some(true),
            values,
            negated: Some(false),
        }
    }
}

/// Converts the CatalogsProductGroupPricingCriteria value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductGroupPricingCriteria {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.inclusion.as_ref().map(|inclusion| {
                [
                    "inclusion".to_string(),
                    inclusion.to_string(),
                ].join(",")
            }),


            Some("values".to_string()),
            Some(self.values.to_string()),


            self.negated.as_ref().map(|negated| {
                [
                    "negated".to_string(),
                    negated.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupPricingCriteria value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupPricingCriteria {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub inclusion: Vec<bool>,
            pub values: Vec<f64>,
            pub negated: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupPricingCriteria".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "inclusion" => intermediate_rep.inclusion.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "values" => intermediate_rep.values.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "negated" => intermediate_rep.negated.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupPricingCriteria".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupPricingCriteria {
            inclusion: intermediate_rep.inclusion.into_iter().next(),
            values: intermediate_rep.values.into_iter().next().ok_or_else(|| "values missing in CatalogsProductGroupPricingCriteria".to_string())?,
            negated: intermediate_rep.negated.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupPricingCriteria> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupPricingCriteria>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupPricingCriteria>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupPricingCriteria - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupPricingCriteria> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupPricingCriteria as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupPricingCriteria - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupPricingCurrencyCriteria {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "operator")]
    pub operator: String,

    #[serde(rename = "value")]
    #[validate(
            range(min = 0),
        )]
    pub value: f64,

    #[serde(rename = "currency")]
    pub currency: models::NonNullableCatalogsCurrency,

    #[serde(rename = "negated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub negated: Option<bool>,

}


impl CatalogsProductGroupPricingCurrencyCriteria {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(operator: String, value: f64, currency: models::NonNullableCatalogsCurrency, ) -> CatalogsProductGroupPricingCurrencyCriteria {
        CatalogsProductGroupPricingCurrencyCriteria {
            operator,
            value,
            currency,
            negated: Some(false),
        }
    }
}

/// Converts the CatalogsProductGroupPricingCurrencyCriteria value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductGroupPricingCurrencyCriteria {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("operator".to_string()),
            Some(self.operator.to_string()),


            Some("value".to_string()),
            Some(self.value.to_string()),

            // Skipping currency in query parameter serialization


            self.negated.as_ref().map(|negated| {
                [
                    "negated".to_string(),
                    negated.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupPricingCurrencyCriteria value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupPricingCurrencyCriteria {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub operator: Vec<String>,
            pub value: Vec<f64>,
            pub currency: Vec<models::NonNullableCatalogsCurrency>,
            pub negated: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupPricingCurrencyCriteria".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "operator" => intermediate_rep.operator.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currency" => intermediate_rep.currency.push(<models::NonNullableCatalogsCurrency as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "negated" => intermediate_rep.negated.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupPricingCurrencyCriteria".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupPricingCurrencyCriteria {
            operator: intermediate_rep.operator.into_iter().next().ok_or_else(|| "operator missing in CatalogsProductGroupPricingCurrencyCriteria".to_string())?,
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in CatalogsProductGroupPricingCurrencyCriteria".to_string())?,
            currency: intermediate_rep.currency.into_iter().next().ok_or_else(|| "currency missing in CatalogsProductGroupPricingCurrencyCriteria".to_string())?,
            negated: intermediate_rep.negated.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupPricingCurrencyCriteria> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupPricingCurrencyCriteria>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupPricingCurrencyCriteria>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupPricingCurrencyCriteria - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupPricingCurrencyCriteria> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupPricingCurrencyCriteria as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupPricingCurrencyCriteria - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Product counts for a CatalogsProductGroup



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupProductCounts {
    #[serde(rename = "in_stock")]
    #[validate(
            range(min = 0),
        )]
    pub in_stock: f64,

    #[serde(rename = "out_of_stock")]
    #[validate(
            range(min = 0),
        )]
    pub out_of_stock: f64,

    #[serde(rename = "preorder")]
    #[validate(
            range(min = 0),
        )]
    pub preorder: f64,

    #[serde(rename = "total")]
    #[validate(
            range(min = 0),
        )]
    pub total: f64,

}


impl CatalogsProductGroupProductCounts {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(in_stock: f64, out_of_stock: f64, preorder: f64, total: f64, ) -> CatalogsProductGroupProductCounts {
        CatalogsProductGroupProductCounts {
            in_stock,
            out_of_stock,
            preorder,
            total,
        }
    }
}

/// Converts the CatalogsProductGroupProductCounts value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductGroupProductCounts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("in_stock".to_string()),
            Some(self.in_stock.to_string()),


            Some("out_of_stock".to_string()),
            Some(self.out_of_stock.to_string()),


            Some("preorder".to_string()),
            Some(self.preorder.to_string()),


            Some("total".to_string()),
            Some(self.total.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupProductCounts value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupProductCounts {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub in_stock: Vec<f64>,
            pub out_of_stock: Vec<f64>,
            pub preorder: Vec<f64>,
            pub total: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupProductCounts".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "in_stock" => intermediate_rep.in_stock.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "out_of_stock" => intermediate_rep.out_of_stock.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "preorder" => intermediate_rep.preorder.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "total" => intermediate_rep.total.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupProductCounts".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupProductCounts {
            in_stock: intermediate_rep.in_stock.into_iter().next().ok_or_else(|| "in_stock missing in CatalogsProductGroupProductCounts".to_string())?,
            out_of_stock: intermediate_rep.out_of_stock.into_iter().next().ok_or_else(|| "out_of_stock missing in CatalogsProductGroupProductCounts".to_string())?,
            preorder: intermediate_rep.preorder.into_iter().next().ok_or_else(|| "preorder missing in CatalogsProductGroupProductCounts".to_string())?,
            total: intermediate_rep.total.into_iter().next().ok_or_else(|| "total missing in CatalogsProductGroupProductCounts".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupProductCounts> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupProductCounts>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupProductCounts>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupProductCounts - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupProductCounts> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupProductCounts as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupProductCounts - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CatalogsProductGroupStatus {
    #[serde(rename = "ACTIVE")]
    Active,
    #[serde(rename = "INACTIVE")]
    Inactive,
}

impl std::fmt::Display for CatalogsProductGroupStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CatalogsProductGroupStatus::Active => write!(f, "ACTIVE"),
            CatalogsProductGroupStatus::Inactive => write!(f, "INACTIVE"),
        }
    }
}

impl std::str::FromStr for CatalogsProductGroupStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ACTIVE" => std::result::Result::Ok(CatalogsProductGroupStatus::Active),
            "INACTIVE" => std::result::Result::Ok(CatalogsProductGroupStatus::Inactive),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// <p>Catalog product group type</p> <p>MERCHANT_CREATED: Product groups created by merchants. <br>ALL_PRODUCTS: Consists of every product in your latest successful feed upload. <br>BEST_DEALS: Consists of products with the deepest drop in price. <br>PINNER_FAVORITES: Consists of products that are resonating most with people on Pinterest, based on engagement. <br>TOP_SELLERS: Consists of products with the highest conversion rate, if you have the conversion tag installed. <br>BACK_IN_STOCK: Consists of products that were previously out of stock and are now in stock. <br>NEW_ARRIVALS: Consists of products that are new to your Catalog. <br>SHOPIFY_COLLECTION: Product groups created based on Shopify Product Collections. <br>I2PC: Product groups created based on predicted product category.</p>
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CatalogsProductGroupType {
    #[serde(rename = "MERCHANT_CREATED")]
    MerchantCreated,
    #[serde(rename = "ALL_PRODUCTS")]
    AllProducts,
    #[serde(rename = "BEST_DEALS")]
    BestDeals,
    #[serde(rename = "PINNER_FAVORITES")]
    PinnerFavorites,
    #[serde(rename = "TOP_SELLERS")]
    TopSellers,
    #[serde(rename = "BACK_IN_STOCK")]
    BackInStock,
    #[serde(rename = "NEW_ARRIVALS")]
    NewArrivals,
    #[serde(rename = "SHOPIFY_COLLECTIONS")]
    ShopifyCollections,
    #[serde(rename = "I2PC")]
    I2Pc,
}

impl std::fmt::Display for CatalogsProductGroupType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CatalogsProductGroupType::MerchantCreated => write!(f, "MERCHANT_CREATED"),
            CatalogsProductGroupType::AllProducts => write!(f, "ALL_PRODUCTS"),
            CatalogsProductGroupType::BestDeals => write!(f, "BEST_DEALS"),
            CatalogsProductGroupType::PinnerFavorites => write!(f, "PINNER_FAVORITES"),
            CatalogsProductGroupType::TopSellers => write!(f, "TOP_SELLERS"),
            CatalogsProductGroupType::BackInStock => write!(f, "BACK_IN_STOCK"),
            CatalogsProductGroupType::NewArrivals => write!(f, "NEW_ARRIVALS"),
            CatalogsProductGroupType::ShopifyCollections => write!(f, "SHOPIFY_COLLECTIONS"),
            CatalogsProductGroupType::I2Pc => write!(f, "I2PC"),
        }
    }
}

impl std::str::FromStr for CatalogsProductGroupType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "MERCHANT_CREATED" => std::result::Result::Ok(CatalogsProductGroupType::MerchantCreated),
            "ALL_PRODUCTS" => std::result::Result::Ok(CatalogsProductGroupType::AllProducts),
            "BEST_DEALS" => std::result::Result::Ok(CatalogsProductGroupType::BestDeals),
            "PINNER_FAVORITES" => std::result::Result::Ok(CatalogsProductGroupType::PinnerFavorites),
            "TOP_SELLERS" => std::result::Result::Ok(CatalogsProductGroupType::TopSellers),
            "BACK_IN_STOCK" => std::result::Result::Ok(CatalogsProductGroupType::BackInStock),
            "NEW_ARRIVALS" => std::result::Result::Ok(CatalogsProductGroupType::NewArrivals),
            "SHOPIFY_COLLECTIONS" => std::result::Result::Ok(CatalogsProductGroupType::ShopifyCollections),
            "I2PC" => std::result::Result::Ok(CatalogsProductGroupType::I2Pc),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Request object for updating a product group.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupUpdateRequest {
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

/// boolean indicator of whether the product group is being featured or not
    #[serde(rename = "is_featured")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_featured: Option<bool>,

    #[serde(rename = "filters")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub filters: Option<models::CatalogsProductGroupFiltersRequest>,

}


impl CatalogsProductGroupUpdateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsProductGroupUpdateRequest {
        CatalogsProductGroupUpdateRequest {
            name: None,
            description: None,
            is_featured: None,
            filters: None,
        }
    }
}

/// Converts the CatalogsProductGroupUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductGroupUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_featured.as_ref().map(|is_featured| {
                [
                    "is_featured".to_string(),
                    is_featured.to_string(),
                ].join(",")
            }),

            // Skipping filters in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub is_featured: Vec<bool>,
            pub filters: Vec<models::CatalogsProductGroupFiltersRequest>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsProductGroupUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "is_featured" => intermediate_rep.is_featured.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "filters" => intermediate_rep.filters.push(<models::CatalogsProductGroupFiltersRequest as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupUpdateRequest {
            name: intermediate_rep.name.into_iter().next(),
            description: std::result::Result::Err("Nullable types not supported in CatalogsProductGroupUpdateRequest".to_string())?,
            is_featured: intermediate_rep.is_featured.into_iter().next(),
            filters: intermediate_rep.filters.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupUpdateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupUpdateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupUpdateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupUpdateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - CatalogsProductGroup
/// - CatalogsVerticalProductGroup
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsProductGroupsCreate201Response(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsProductGroupsCreate201Response
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupsCreate201Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupsCreate201Response {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsProductGroupsCreate201Response {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}







/// One of:
/// - CatalogsProductGroupCreateRequest
/// - CatalogsVerticalProductGroupCreateRequest
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsProductGroupsCreateRequest(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsProductGroupsCreateRequest
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupsCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupsCreateRequest {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsProductGroupsCreateRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupsList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::CatalogsProductGroupsList200ResponseAllOfItemsInner>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl CatalogsProductGroupsList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::CatalogsProductGroupsList200ResponseAllOfItemsInner>, ) -> CatalogsProductGroupsList200Response {
        CatalogsProductGroupsList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the CatalogsProductGroupsList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductGroupsList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupsList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupsList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::CatalogsProductGroupsList200ResponseAllOfItemsInner>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupsList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsProductGroupsList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsProductGroupsList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupsList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupsList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in CatalogsProductGroupsList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in CatalogsProductGroupsList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupsList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupsList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupsList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupsList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupsList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupsList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupsList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}





/// Any of:
/// - CatalogsProductGroup
/// - CatalogsVerticalProductGroup
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsProductGroupsList200ResponseAllOfItemsInner(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsProductGroupsList200ResponseAllOfItemsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupsList200ResponseAllOfItemsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupsList200ResponseAllOfItemsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsProductGroupsList200ResponseAllOfItemsInner {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








/// One of:
/// - CatalogsProductGroupUpdateRequest
/// - CatalogsVerticalProductGroupUpdateRequest
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsProductGroupsUpdateRequest(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsProductGroupsUpdateRequest
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupsUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupsUpdateRequest {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsProductGroupsUpdateRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Product metadata entity



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductMetadata {
/// The user-created unique ID that represents the product.
    #[serde(rename = "item_id")]
    pub item_id: String,

/// The parent ID of the product.
    #[serde(rename = "item_group_id")]
    pub item_group_id: Nullable<String>,

    #[serde(rename = "availability")]
    pub availability: models::NonNullableProductAvailabilityType,

/// The price of the product.
    #[serde(rename = "price")]
    pub price: f64,

/// The discounted price of the product.
    #[serde(rename = "sale_price")]
    pub sale_price: Nullable<f64>,

    #[serde(rename = "currency")]
    pub currency: models::NonNullableCatalogsCurrency,

}


impl CatalogsProductMetadata {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(item_id: String, item_group_id: Nullable<String>, availability: models::NonNullableProductAvailabilityType, price: f64, sale_price: Nullable<f64>, currency: models::NonNullableCatalogsCurrency, ) -> CatalogsProductMetadata {
        CatalogsProductMetadata {
            item_id,
            item_group_id,
            availability,
            price,
            sale_price,
            currency,
        }
    }
}

/// Converts the CatalogsProductMetadata value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsProductMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("item_group_id".to_string()),
            Some(self.item_group_id.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping availability in query parameter serialization


            Some("price".to_string()),
            Some(self.price.to_string()),


            Some("sale_price".to_string()),
            Some(self.sale_price.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping currency in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductMetadata value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductMetadata {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_id: Vec<String>,
            pub item_group_id: Vec<String>,
            pub availability: Vec<models::NonNullableProductAvailabilityType>,
            pub price: Vec<f64>,
            pub sale_price: Vec<f64>,
            pub currency: Vec<models::NonNullableCatalogsCurrency>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductMetadata".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "item_group_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsProductMetadata".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "availability" => intermediate_rep.availability.push(<models::NonNullableProductAvailabilityType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "sale_price" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsProductMetadata".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "currency" => intermediate_rep.currency.push(<models::NonNullableCatalogsCurrency as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductMetadata".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductMetadata {
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in CatalogsProductMetadata".to_string())?,
            item_group_id: std::result::Result::Err("Nullable types not supported in CatalogsProductMetadata".to_string())?,
            availability: intermediate_rep.availability.into_iter().next().ok_or_else(|| "availability missing in CatalogsProductMetadata".to_string())?,
            price: intermediate_rep.price.into_iter().next().ok_or_else(|| "price missing in CatalogsProductMetadata".to_string())?,
            sale_price: std::result::Result::Err("Nullable types not supported in CatalogsProductMetadata".to_string())?,
            currency: intermediate_rep.currency.into_iter().next().ok_or_else(|| "currency missing in CatalogsProductMetadata".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductMetadata> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductMetadata>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductMetadata>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductMetadata - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsProductMetadata> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductMetadata as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductMetadata - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A request object that can have multiple operations on a single retail batch



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsRetailBatchRequest {
    #[serde(rename = "catalog_type")]
    pub catalog_type: models::CatalogsType,

    #[serde(rename = "country")]
    pub country: models::Country,

    #[serde(rename = "language")]
    pub language: models::Language,

/// Array with catalogs item operations
    #[serde(rename = "items")]
    #[validate(
            length(min = 1, max = 1000),
        )]
    pub items: Vec<models::CatalogsRetailBatchRequestItemsInner>,

}


impl CatalogsRetailBatchRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(catalog_type: models::CatalogsType, country: models::Country, language: models::Language, items: Vec<models::CatalogsRetailBatchRequestItemsInner>, ) -> CatalogsRetailBatchRequest {
        CatalogsRetailBatchRequest {
            catalog_type,
            country,
            language,
            items,
        }
    }
}

/// Converts the CatalogsRetailBatchRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsRetailBatchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping catalog_type in query parameter serialization

            // Skipping country in query parameter serialization

            // Skipping language in query parameter serialization

            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsRetailBatchRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsRetailBatchRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub catalog_type: Vec<models::CatalogsType>,
            pub country: Vec<models::Country>,
            pub language: Vec<models::Language>,
            pub items: Vec<Vec<models::CatalogsRetailBatchRequestItemsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsRetailBatchRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<models::CatalogsType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "country" => intermediate_rep.country.push(<models::Country as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::Language as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsRetailBatchRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsRetailBatchRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsRetailBatchRequest {
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsRetailBatchRequest".to_string())?,
            country: intermediate_rep.country.into_iter().next().ok_or_else(|| "country missing in CatalogsRetailBatchRequest".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in CatalogsRetailBatchRequest".to_string())?,
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in CatalogsRetailBatchRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsRetailBatchRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsRetailBatchRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsRetailBatchRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsRetailBatchRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsRetailBatchRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsRetailBatchRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsRetailBatchRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}





/// Any of:
/// - CatalogsCreateRetailItem
/// - CatalogsDeleteRetailItem
/// - CatalogsUpdateRetailItem
/// - CatalogsUpsertRetailItem
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsRetailBatchRequestItemsInner(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsRetailBatchRequestItemsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsRetailBatchRequestItemsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsRetailBatchRequestItemsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsRetailBatchRequestItemsInner {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}






/// Catalogs Retail Feed object



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsRetailFeed {
    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "updated_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

/// A human-friendly name associated to a given feed. This value is currently nullable due to historical reasons. It is expected to become non-nullable in the future.
    #[serde(rename = "name")]
    pub name: Nullable<String>,

    #[serde(rename = "format")]
    pub format: models::CatalogsFormat,

    #[serde(rename = "catalog_type")]
    pub catalog_type: models::CatalogsType,

    #[serde(rename = "credentials")]
    pub credentials: Nullable<models::CatalogsFeedCredentials>,

/// The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
    #[serde(rename = "location")]
    pub location: String,

    #[serde(rename = "preferred_processing_schedule")]
    pub preferred_processing_schedule: Nullable<models::CatalogsFeedProcessingSchedule>,

    #[serde(rename = "status")]
    pub status: models::CatalogsStatus,

    #[serde(rename = "default_currency")]
    pub default_currency: Nullable<models::NullableCurrency>,

/// The locale used within a feed for product descriptions.
    #[serde(rename = "default_locale")]
    pub default_locale: String,

    #[serde(rename = "default_country")]
    pub default_country: models::Country,

    #[serde(rename = "default_availability")]
    pub default_availability: Nullable<models::ProductAvailabilityType>,

}


impl CatalogsRetailFeed {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: Nullable<String>, format: models::CatalogsFormat, catalog_type: models::CatalogsType, credentials: Nullable<models::CatalogsFeedCredentials>, location: String, preferred_processing_schedule: Nullable<models::CatalogsFeedProcessingSchedule>, status: models::CatalogsStatus, default_currency: Nullable<models::NullableCurrency>, default_locale: String, default_country: models::Country, default_availability: Nullable<models::ProductAvailabilityType>, ) -> CatalogsRetailFeed {
        CatalogsRetailFeed {
            created_at: None,
            id: None,
            updated_at: None,
            name,
            format,
            catalog_type,
            credentials,
            location,
            preferred_processing_schedule,
            status,
            default_currency,
            default_locale,
            default_country,
            default_availability,
        }
    }
}

/// Converts the CatalogsRetailFeed value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsRetailFeed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping created_at in query parameter serialization


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping updated_at in query parameter serialization


            Some("name".to_string()),
            Some(self.name.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping format in query parameter serialization

            // Skipping catalog_type in query parameter serialization

            // Skipping credentials in query parameter serialization


            Some("location".to_string()),
            Some(self.location.to_string()),

            // Skipping preferred_processing_schedule in query parameter serialization

            // Skipping status in query parameter serialization

            // Skipping default_currency in query parameter serialization


            Some("default_locale".to_string()),
            Some(self.default_locale.to_string()),

            // Skipping default_country in query parameter serialization

            // Skipping default_availability in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsRetailFeed value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsRetailFeed {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub id: Vec<String>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub name: Vec<String>,
            pub format: Vec<models::CatalogsFormat>,
            pub catalog_type: Vec<models::CatalogsType>,
            pub credentials: Vec<models::CatalogsFeedCredentials>,
            pub location: Vec<String>,
            pub preferred_processing_schedule: Vec<models::CatalogsFeedProcessingSchedule>,
            pub status: Vec<models::CatalogsStatus>,
            pub default_currency: Vec<models::NullableCurrency>,
            pub default_locale: Vec<String>,
            pub default_country: Vec<models::Country>,
            pub default_availability: Vec<models::ProductAvailabilityType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsRetailFeed".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updated_at" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsRetailFeed".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "format" => intermediate_rep.format.push(<models::CatalogsFormat as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<models::CatalogsType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "credentials" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsRetailFeed".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "location" => intermediate_rep.location.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "preferred_processing_schedule" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsRetailFeed".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::CatalogsStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "default_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsRetailFeed".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "default_locale" => intermediate_rep.default_locale.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "default_country" => intermediate_rep.default_country.push(<models::Country as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "default_availability" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsRetailFeed".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsRetailFeed".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsRetailFeed {
            created_at: intermediate_rep.created_at.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            name: std::result::Result::Err("Nullable types not supported in CatalogsRetailFeed".to_string())?,
            format: intermediate_rep.format.into_iter().next().ok_or_else(|| "format missing in CatalogsRetailFeed".to_string())?,
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsRetailFeed".to_string())?,
            credentials: std::result::Result::Err("Nullable types not supported in CatalogsRetailFeed".to_string())?,
            location: intermediate_rep.location.into_iter().next().ok_or_else(|| "location missing in CatalogsRetailFeed".to_string())?,
            preferred_processing_schedule: std::result::Result::Err("Nullable types not supported in CatalogsRetailFeed".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in CatalogsRetailFeed".to_string())?,
            default_currency: std::result::Result::Err("Nullable types not supported in CatalogsRetailFeed".to_string())?,
            default_locale: intermediate_rep.default_locale.into_iter().next().ok_or_else(|| "default_locale missing in CatalogsRetailFeed".to_string())?,
            default_country: intermediate_rep.default_country.into_iter().next().ok_or_else(|| "default_country missing in CatalogsRetailFeed".to_string())?,
            default_availability: std::result::Result::Err("Nullable types not supported in CatalogsRetailFeed".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsRetailFeed> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsRetailFeed>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsRetailFeed>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsRetailFeed - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsRetailFeed> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsRetailFeed as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsRetailFeed - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Request object for creating a retail feed.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsRetailFeedsCreateRequest {
    #[serde(rename = "default_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_currency: Option<Nullable<models::NullableCurrency>>,

/// A human-friendly name associated to a given feed.
    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "format")]
    pub format: models::CatalogsFormat,

    #[serde(rename = "default_locale")]
    pub default_locale: models::CatalogsFeedsCreateRequestDefaultLocale,

    #[serde(rename = "credentials")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub credentials: Option<Nullable<models::CatalogsFeedCredentials>>,

/// The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
    #[serde(rename = "location")]
    #[validate(
           regex = "RE_CATALOGSRETAILFEEDSCREATEREQUEST_LOCATION",
        )]
    pub location: String,

    #[serde(rename = "preferred_processing_schedule")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preferred_processing_schedule: Option<Nullable<models::CatalogsFeedProcessingSchedule>>,

    #[serde(rename = "catalog_type")]
    pub catalog_type: models::CatalogsType,

    #[serde(rename = "default_country")]
    pub default_country: models::Country,

    #[serde(rename = "default_availability")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_availability: Option<Nullable<models::ProductAvailabilityType>>,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGSRETAILFEEDSCREATEREQUEST_LOCATION: regex::Regex = regex::Regex::new(r"^(http|https|ftp|sftp)://").unwrap();
}

impl CatalogsRetailFeedsCreateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, format: models::CatalogsFormat, default_locale: models::CatalogsFeedsCreateRequestDefaultLocale, location: String, catalog_type: models::CatalogsType, default_country: models::Country, ) -> CatalogsRetailFeedsCreateRequest {
        CatalogsRetailFeedsCreateRequest {
            default_currency: None,
            name,
            format,
            default_locale,
            credentials: None,
            location,
            preferred_processing_schedule: None,
            catalog_type,
            default_country,
            default_availability: None,
        }
    }
}

/// Converts the CatalogsRetailFeedsCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsRetailFeedsCreateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping default_currency in query parameter serialization


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping format in query parameter serialization

            // Skipping default_locale in query parameter serialization

            // Skipping credentials in query parameter serialization


            Some("location".to_string()),
            Some(self.location.to_string()),

            // Skipping preferred_processing_schedule in query parameter serialization

            // Skipping catalog_type in query parameter serialization

            // Skipping default_country in query parameter serialization

            // Skipping default_availability in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsRetailFeedsCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsRetailFeedsCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub default_currency: Vec<models::NullableCurrency>,
            pub name: Vec<String>,
            pub format: Vec<models::CatalogsFormat>,
            pub default_locale: Vec<models::CatalogsFeedsCreateRequestDefaultLocale>,
            pub credentials: Vec<models::CatalogsFeedCredentials>,
            pub location: Vec<String>,
            pub preferred_processing_schedule: Vec<models::CatalogsFeedProcessingSchedule>,
            pub catalog_type: Vec<models::CatalogsType>,
            pub default_country: Vec<models::Country>,
            pub default_availability: Vec<models::ProductAvailabilityType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsRetailFeedsCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "default_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsRetailFeedsCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "format" => intermediate_rep.format.push(<models::CatalogsFormat as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "default_locale" => intermediate_rep.default_locale.push(<models::CatalogsFeedsCreateRequestDefaultLocale as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "credentials" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsRetailFeedsCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "location" => intermediate_rep.location.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "preferred_processing_schedule" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsRetailFeedsCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<models::CatalogsType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "default_country" => intermediate_rep.default_country.push(<models::Country as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "default_availability" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsRetailFeedsCreateRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsRetailFeedsCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsRetailFeedsCreateRequest {
            default_currency: std::result::Result::Err("Nullable types not supported in CatalogsRetailFeedsCreateRequest".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in CatalogsRetailFeedsCreateRequest".to_string())?,
            format: intermediate_rep.format.into_iter().next().ok_or_else(|| "format missing in CatalogsRetailFeedsCreateRequest".to_string())?,
            default_locale: intermediate_rep.default_locale.into_iter().next().ok_or_else(|| "default_locale missing in CatalogsRetailFeedsCreateRequest".to_string())?,
            credentials: std::result::Result::Err("Nullable types not supported in CatalogsRetailFeedsCreateRequest".to_string())?,
            location: intermediate_rep.location.into_iter().next().ok_or_else(|| "location missing in CatalogsRetailFeedsCreateRequest".to_string())?,
            preferred_processing_schedule: std::result::Result::Err("Nullable types not supported in CatalogsRetailFeedsCreateRequest".to_string())?,
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsRetailFeedsCreateRequest".to_string())?,
            default_country: intermediate_rep.default_country.into_iter().next().ok_or_else(|| "default_country missing in CatalogsRetailFeedsCreateRequest".to_string())?,
            default_availability: std::result::Result::Err("Nullable types not supported in CatalogsRetailFeedsCreateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsRetailFeedsCreateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsRetailFeedsCreateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsRetailFeedsCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsRetailFeedsCreateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsRetailFeedsCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsRetailFeedsCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsRetailFeedsCreateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Request object for updating a feed.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsRetailFeedsUpdateRequest {
    #[serde(rename = "default_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_currency: Option<Nullable<models::NullableCurrency>>,

/// A human-friendly name associated to a given feed.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "format")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub format: Option<models::CatalogsFormat>,

    #[serde(rename = "credentials")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub credentials: Option<Nullable<models::CatalogsFeedCredentials>>,

/// The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
    #[serde(rename = "location")]
    #[validate(
           regex = "RE_CATALOGSRETAILFEEDSUPDATEREQUEST_LOCATION",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<String>,

    #[serde(rename = "preferred_processing_schedule")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preferred_processing_schedule: Option<Nullable<models::CatalogsFeedProcessingSchedule>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::CatalogsStatus>,

    #[serde(rename = "catalog_type")]
    pub catalog_type: models::CatalogsType,

    #[serde(rename = "default_availability")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_availability: Option<Nullable<models::ProductAvailabilityType>>,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGSRETAILFEEDSUPDATEREQUEST_LOCATION: regex::Regex = regex::Regex::new(r"^(http|https|ftp|sftp)://").unwrap();
}

impl CatalogsRetailFeedsUpdateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(catalog_type: models::CatalogsType, ) -> CatalogsRetailFeedsUpdateRequest {
        CatalogsRetailFeedsUpdateRequest {
            default_currency: None,
            name: None,
            format: None,
            credentials: None,
            location: None,
            preferred_processing_schedule: None,
            status: None,
            catalog_type,
            default_availability: None,
        }
    }
}

/// Converts the CatalogsRetailFeedsUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsRetailFeedsUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping default_currency in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping format in query parameter serialization

            // Skipping credentials in query parameter serialization


            self.location.as_ref().map(|location| {
                [
                    "location".to_string(),
                    location.to_string(),
                ].join(",")
            }),

            // Skipping preferred_processing_schedule in query parameter serialization

            // Skipping status in query parameter serialization

            // Skipping catalog_type in query parameter serialization

            // Skipping default_availability in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsRetailFeedsUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsRetailFeedsUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub default_currency: Vec<models::NullableCurrency>,
            pub name: Vec<String>,
            pub format: Vec<models::CatalogsFormat>,
            pub credentials: Vec<models::CatalogsFeedCredentials>,
            pub location: Vec<String>,
            pub preferred_processing_schedule: Vec<models::CatalogsFeedProcessingSchedule>,
            pub status: Vec<models::CatalogsStatus>,
            pub catalog_type: Vec<models::CatalogsType>,
            pub default_availability: Vec<models::ProductAvailabilityType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsRetailFeedsUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "default_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsRetailFeedsUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "format" => intermediate_rep.format.push(<models::CatalogsFormat as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "credentials" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsRetailFeedsUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "location" => intermediate_rep.location.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "preferred_processing_schedule" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsRetailFeedsUpdateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::CatalogsStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<models::CatalogsType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "default_availability" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsRetailFeedsUpdateRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsRetailFeedsUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsRetailFeedsUpdateRequest {
            default_currency: std::result::Result::Err("Nullable types not supported in CatalogsRetailFeedsUpdateRequest".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            format: intermediate_rep.format.into_iter().next(),
            credentials: std::result::Result::Err("Nullable types not supported in CatalogsRetailFeedsUpdateRequest".to_string())?,
            location: intermediate_rep.location.into_iter().next(),
            preferred_processing_schedule: std::result::Result::Err("Nullable types not supported in CatalogsRetailFeedsUpdateRequest".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsRetailFeedsUpdateRequest".to_string())?,
            default_availability: std::result::Result::Err("Nullable types not supported in CatalogsRetailFeedsUpdateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsRetailFeedsUpdateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsRetailFeedsUpdateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsRetailFeedsUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsRetailFeedsUpdateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsRetailFeedsUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsRetailFeedsUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsRetailFeedsUpdateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object describing a retail item error



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsRetailItemErrorResponse {
    #[serde(rename = "catalog_type")]
    pub catalog_type: models::CatalogsType,

/// The catalog item id in the merchant namespace
    #[serde(rename = "item_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_id: Option<String>,

/// Array with the errors for the item id requested
    #[serde(rename = "errors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<models::ItemValidationEvent>>,

}


impl CatalogsRetailItemErrorResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(catalog_type: models::CatalogsType, ) -> CatalogsRetailItemErrorResponse {
        CatalogsRetailItemErrorResponse {
            catalog_type,
            item_id: None,
            errors: None,
        }
    }
}

/// Converts the CatalogsRetailItemErrorResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsRetailItemErrorResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping catalog_type in query parameter serialization


            self.item_id.as_ref().map(|item_id| {
                [
                    "item_id".to_string(),
                    item_id.to_string(),
                ].join(",")
            }),

            // Skipping errors in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsRetailItemErrorResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsRetailItemErrorResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub catalog_type: Vec<models::CatalogsType>,
            pub item_id: Vec<String>,
            pub errors: Vec<Vec<models::ItemValidationEvent>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsRetailItemErrorResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<models::CatalogsType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsRetailItemErrorResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsRetailItemErrorResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsRetailItemErrorResponse {
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsRetailItemErrorResponse".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next(),
            errors: intermediate_rep.errors.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsRetailItemErrorResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsRetailItemErrorResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsRetailItemErrorResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsRetailItemErrorResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsRetailItemErrorResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsRetailItemErrorResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsRetailItemErrorResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object describing a retail item record



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsRetailItemResponse {
    #[serde(rename = "catalog_type")]
    pub catalog_type: models::CatalogsType,

/// The catalog retail item id in the merchant namespace
    #[serde(rename = "item_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_id: Option<String>,

/// The pins mapped to the item
    #[serde(rename = "pins")]
    #[validate(
            length(max = 11),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pins: Option<Nullable<Vec<models::Pin>>>,

    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attributes: Option<models::ItemAttributes>,

}


impl CatalogsRetailItemResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(catalog_type: models::CatalogsType, ) -> CatalogsRetailItemResponse {
        CatalogsRetailItemResponse {
            catalog_type,
            item_id: None,
            pins: None,
            attributes: None,
        }
    }
}

/// Converts the CatalogsRetailItemResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsRetailItemResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping catalog_type in query parameter serialization


            self.item_id.as_ref().map(|item_id| {
                [
                    "item_id".to_string(),
                    item_id.to_string(),
                ].join(",")
            }),

            // Skipping pins in query parameter serialization

            // Skipping attributes in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsRetailItemResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsRetailItemResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub catalog_type: Vec<models::CatalogsType>,
            pub item_id: Vec<String>,
            pub pins: Vec<Vec<models::Pin>>,
            pub attributes: Vec<models::ItemAttributes>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsRetailItemResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<models::CatalogsType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pins" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsRetailItemResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "attributes" => intermediate_rep.attributes.push(<models::ItemAttributes as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsRetailItemResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsRetailItemResponse {
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsRetailItemResponse".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next(),
            pins: std::result::Result::Err("Nullable types not supported in CatalogsRetailItemResponse".to_string())?,
            attributes: intermediate_rep.attributes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsRetailItemResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsRetailItemResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsRetailItemResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsRetailItemResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsRetailItemResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsRetailItemResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsRetailItemResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object describing the catalogs retail items batch



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsRetailItemsBatch {
/// Id of the catalogs items batch
    #[serde(rename = "batch_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub batch_id: Option<String>,

/// Time of the batch creation: YYYY-MM-DD'T'hh:mm:ssTZD
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<chrono::DateTime::<chrono::Utc>>,

/// Time of the batch completion: YYYY-MM-DD'T'hh:mm:ssTZD
    #[serde(rename = "completed_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_time: Option<Nullable<chrono::DateTime::<chrono::Utc>>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::BatchOperationStatus>,

    #[serde(rename = "catalog_type")]
    pub catalog_type: models::CatalogsType,

/// Array with the catalogs items processing records part of the catalogs items batch
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::ItemProcessingRecord>>,

}


impl CatalogsRetailItemsBatch {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(catalog_type: models::CatalogsType, ) -> CatalogsRetailItemsBatch {
        CatalogsRetailItemsBatch {
            batch_id: None,
            created_time: None,
            completed_time: None,
            status: None,
            catalog_type,
            items: None,
        }
    }
}

/// Converts the CatalogsRetailItemsBatch value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsRetailItemsBatch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.batch_id.as_ref().map(|batch_id| {
                [
                    "batch_id".to_string(),
                    batch_id.to_string(),
                ].join(",")
            }),

            // Skipping created_time in query parameter serialization

            // Skipping completed_time in query parameter serialization

            // Skipping status in query parameter serialization

            // Skipping catalog_type in query parameter serialization

            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsRetailItemsBatch value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsRetailItemsBatch {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub batch_id: Vec<String>,
            pub created_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub completed_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub status: Vec<models::BatchOperationStatus>,
            pub catalog_type: Vec<models::CatalogsType>,
            pub items: Vec<Vec<models::ItemProcessingRecord>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsRetailItemsBatch".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "batch_id" => intermediate_rep.batch_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_time" => intermediate_rep.created_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "completed_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsRetailItemsBatch".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::BatchOperationStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<models::CatalogsType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsRetailItemsBatch".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsRetailItemsBatch".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsRetailItemsBatch {
            batch_id: intermediate_rep.batch_id.into_iter().next(),
            created_time: intermediate_rep.created_time.into_iter().next(),
            completed_time: std::result::Result::Err("Nullable types not supported in CatalogsRetailItemsBatch".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsRetailItemsBatch".to_string())?,
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsRetailItemsBatch> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsRetailItemsBatch>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsRetailItemsBatch>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsRetailItemsBatch - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsRetailItemsBatch> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsRetailItemsBatch as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsRetailItemsBatch - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsRetailItemsFilter {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "catalog_type")]
    pub catalog_type: String,

    #[serde(rename = "item_ids")]
    #[validate(
            length(min = 1, max = 100),
        )]
    pub item_ids: Vec<String>,

/// Catalog id pertaining to the retail item. If not provided, default to oldest retail catalog
    #[serde(rename = "catalog_id")]
    #[validate(
           regex = "RE_CATALOGSRETAILITEMSFILTER_CATALOG_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub catalog_id: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGSRETAILITEMSFILTER_CATALOG_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CatalogsRetailItemsFilter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(catalog_type: String, item_ids: Vec<String>, ) -> CatalogsRetailItemsFilter {
        CatalogsRetailItemsFilter {
            catalog_type,
            item_ids,
            catalog_id: None,
        }
    }
}

/// Converts the CatalogsRetailItemsFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsRetailItemsFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("catalog_type".to_string()),
            Some(self.catalog_type.to_string()),


            Some("item_ids".to_string()),
            Some(self.item_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            self.catalog_id.as_ref().map(|catalog_id| {
                [
                    "catalog_id".to_string(),
                    catalog_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsRetailItemsFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsRetailItemsFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub catalog_type: Vec<String>,
            pub item_ids: Vec<Vec<String>>,
            pub catalog_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsRetailItemsFilter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "item_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsRetailItemsFilter".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "catalog_id" => intermediate_rep.catalog_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsRetailItemsFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsRetailItemsFilter {
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsRetailItemsFilter".to_string())?,
            item_ids: intermediate_rep.item_ids.into_iter().next().ok_or_else(|| "item_ids missing in CatalogsRetailItemsFilter".to_string())?,
            catalog_id: intermediate_rep.catalog_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsRetailItemsFilter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsRetailItemsFilter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsRetailItemsFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsRetailItemsFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsRetailItemsFilter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsRetailItemsFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsRetailItemsFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsRetailProductGroup {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "catalog_type")]
    pub catalog_type: String,

/// ID of the catalog product group.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_CATALOGSRETAILPRODUCTGROUP_ID",
        )]
    pub id: String,

/// Name of catalog product group
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

    #[serde(rename = "filters")]
    pub filters: models::CatalogsProductGroupFilters,

/// boolean indicator of whether the product group is being featured or not
    #[serde(rename = "is_featured")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_featured: Option<bool>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<models::CatalogsProductGroupType>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::CatalogsProductGroupStatus>,

/// Unix timestamp in seconds of when catalog product group was created.
    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<i32>,

/// Unix timestamp in seconds of last time catalog product group was updated.
    #[serde(rename = "updated_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<i32>,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "feed_id")]
    pub feed_id: Nullable<String>,

}

lazy_static::lazy_static! {
    static ref RE_CATALOGSRETAILPRODUCTGROUP_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl CatalogsRetailProductGroup {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(catalog_type: String, id: String, filters: models::CatalogsProductGroupFilters, feed_id: Nullable<String>, ) -> CatalogsRetailProductGroup {
        CatalogsRetailProductGroup {
            catalog_type,
            id,
            name: None,
            description: None,
            filters,
            is_featured: None,
            r#type: None,
            status: None,
            created_at: None,
            updated_at: None,
            feed_id,
        }
    }
}

/// Converts the CatalogsRetailProductGroup value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsRetailProductGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("catalog_type".to_string()),
            Some(self.catalog_type.to_string()),


            Some("id".to_string()),
            Some(self.id.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping filters in query parameter serialization


            self.is_featured.as_ref().map(|is_featured| {
                [
                    "is_featured".to_string(),
                    is_featured.to_string(),
                ].join(",")
            }),

            // Skipping type in query parameter serialization

            // Skipping status in query parameter serialization


            self.created_at.as_ref().map(|created_at| {
                [
                    "created_at".to_string(),
                    created_at.to_string(),
                ].join(",")
            }),


            self.updated_at.as_ref().map(|updated_at| {
                [
                    "updated_at".to_string(),
                    updated_at.to_string(),
                ].join(",")
            }),


            Some("feed_id".to_string()),
            Some(self.feed_id.as_ref().map_or("null".to_string(), |x| x.to_string())),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsRetailProductGroup value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsRetailProductGroup {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub catalog_type: Vec<String>,
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub filters: Vec<models::CatalogsProductGroupFilters>,
            pub is_featured: Vec<bool>,
            pub r#type: Vec<models::CatalogsProductGroupType>,
            pub status: Vec<models::CatalogsProductGroupStatus>,
            pub created_at: Vec<i32>,
            pub updated_at: Vec<i32>,
            pub feed_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsRetailProductGroup".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "catalog_type" => intermediate_rep.catalog_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsRetailProductGroup".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "filters" => intermediate_rep.filters.push(<models::CatalogsProductGroupFilters as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_featured" => intermediate_rep.is_featured.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::CatalogsProductGroupType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::CatalogsProductGroupStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updated_at" => intermediate_rep.updated_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "feed_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsRetailProductGroup".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsRetailProductGroup".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsRetailProductGroup {
            catalog_type: intermediate_rep.catalog_type.into_iter().next().ok_or_else(|| "catalog_type missing in CatalogsRetailProductGroup".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in CatalogsRetailProductGroup".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            description: std::result::Result::Err("Nullable types not supported in CatalogsRetailProductGroup".to_string())?,
            filters: intermediate_rep.filters.into_iter().next().ok_or_else(|| "filters missing in CatalogsRetailProductGroup".to_string())?,
            is_featured: intermediate_rep.is_featured.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            feed_id: std::result::Result::Err("Nullable types not supported in CatalogsRetailProductGroup".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsRetailProductGroup> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsRetailProductGroup>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsRetailProductGroup>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsRetailProductGroup - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsRetailProductGroup> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsRetailProductGroup as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsRetailProductGroup - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Status for catalogs entities. Present in catalogs_feed values. When a feed is deleted, the response will inform DELETED as status.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CatalogsStatus {
    #[serde(rename = "ACTIVE")]
    Active,
    #[serde(rename = "INACTIVE")]
    Inactive,
}

impl std::fmt::Display for CatalogsStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CatalogsStatus::Active => write!(f, "ACTIVE"),
            CatalogsStatus::Inactive => write!(f, "INACTIVE"),
        }
    }
}

impl std::str::FromStr for CatalogsStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ACTIVE" => std::result::Result::Ok(CatalogsStatus::Active),
            "INACTIVE" => std::result::Result::Ok(CatalogsStatus::Inactive),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Type of the catalog entity.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CatalogsType {
    #[serde(rename = "RETAIL")]
    Retail,
    #[serde(rename = "HOTEL")]
    Hotel,
}

impl std::fmt::Display for CatalogsType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CatalogsType::Retail => write!(f, "RETAIL"),
            CatalogsType::Hotel => write!(f, "HOTEL"),
        }
    }
}

impl std::str::FromStr for CatalogsType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "RETAIL" => std::result::Result::Ok(CatalogsType::Retail),
            "HOTEL" => std::result::Result::Ok(CatalogsType::Hotel),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsUpdatableHotelAttributes {
/// The hotel's name.
    #[serde(rename = "name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

/// Link to the product page
    #[serde(rename = "link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link: Option<Nullable<String>>,

/// Brief description of the hotel.
    #[serde(rename = "description")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

/// The brand to which this hotel belongs to.
    #[serde(rename = "brand")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub brand: Option<Nullable<String>>,

/// Latitude of the hotel.
    #[serde(rename = "latitude")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub latitude: Option<f64>,

/// Longitude of the hotel.
    #[serde(rename = "longitude")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub longitude: Option<Nullable<f64>>,

/// A list of neighborhoods where the hotel is located
    #[serde(rename = "neighborhood")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub neighborhood: Option<Nullable<Vec<String>>>,

    #[serde(rename = "address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub address: Option<models::CatalogsHotelAddress>,

/// Custom grouping of hotels
    #[serde(rename = "custom_label_0")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_0: Option<Nullable<String>>,

/// Custom grouping of hotels
    #[serde(rename = "custom_label_1")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_1: Option<Nullable<String>>,

/// Custom grouping of hotels
    #[serde(rename = "custom_label_2")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_2: Option<Nullable<String>>,

/// Custom grouping of hotels
    #[serde(rename = "custom_label_3")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_3: Option<Nullable<String>>,

/// Custom grouping of hotels
    #[serde(rename = "custom_label_4")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_4: Option<Nullable<String>>,

/// The type of property. The category can be any type of internal description desired.
    #[serde(rename = "category")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<Nullable<String>>,

/// Base price of the hotel room per night followed by the ISO currency code
    #[serde(rename = "base_price")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_price: Option<Nullable<String>>,

/// Sale price of a hotel room per night. Used to advertise discounts off the regular price of the hotel.
    #[serde(rename = "sale_price")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sale_price: Option<Nullable<String>>,

    #[serde(rename = "guest_ratings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub guest_ratings: Option<models::CatalogsHotelGuestRatings>,

}


impl CatalogsUpdatableHotelAttributes {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CatalogsUpdatableHotelAttributes {
        CatalogsUpdatableHotelAttributes {
            name: None,
            link: None,
            description: None,
            brand: None,
            latitude: None,
            longitude: None,
            neighborhood: None,
            address: None,
            custom_label_0: None,
            custom_label_1: None,
            custom_label_2: None,
            custom_label_3: None,
            custom_label_4: None,
            category: None,
            base_price: None,
            sale_price: None,
            guest_ratings: None,
        }
    }
}

/// Converts the CatalogsUpdatableHotelAttributes value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsUpdatableHotelAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.link.as_ref().map(|link| {
                [
                    "link".to_string(),
                    link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.brand.as_ref().map(|brand| {
                [
                    "brand".to_string(),
                    brand.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.latitude.as_ref().map(|latitude| {
                [
                    "latitude".to_string(),
                    latitude.to_string(),
                ].join(",")
            }),


            self.longitude.as_ref().map(|longitude| {
                [
                    "longitude".to_string(),
                    longitude.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.neighborhood.as_ref().map(|neighborhood| {
                [
                    "neighborhood".to_string(),
                    neighborhood.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping address in query parameter serialization


            self.custom_label_0.as_ref().map(|custom_label_0| {
                [
                    "custom_label_0".to_string(),
                    custom_label_0.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_1.as_ref().map(|custom_label_1| {
                [
                    "custom_label_1".to_string(),
                    custom_label_1.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_2.as_ref().map(|custom_label_2| {
                [
                    "custom_label_2".to_string(),
                    custom_label_2.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_3.as_ref().map(|custom_label_3| {
                [
                    "custom_label_3".to_string(),
                    custom_label_3.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_4.as_ref().map(|custom_label_4| {
                [
                    "custom_label_4".to_string(),
                    custom_label_4.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.category.as_ref().map(|category| {
                [
                    "category".to_string(),
                    category.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.base_price.as_ref().map(|base_price| {
                [
                    "base_price".to_string(),
                    base_price.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.sale_price.as_ref().map(|sale_price| {
                [
                    "sale_price".to_string(),
                    sale_price.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping guest_ratings in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsUpdatableHotelAttributes value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsUpdatableHotelAttributes {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub link: Vec<String>,
            pub description: Vec<String>,
            pub brand: Vec<String>,
            pub latitude: Vec<f64>,
            pub longitude: Vec<f64>,
            pub neighborhood: Vec<Vec<String>>,
            pub address: Vec<models::CatalogsHotelAddress>,
            pub custom_label_0: Vec<String>,
            pub custom_label_1: Vec<String>,
            pub custom_label_2: Vec<String>,
            pub custom_label_3: Vec<String>,
            pub custom_label_4: Vec<String>,
            pub category: Vec<String>,
            pub base_price: Vec<String>,
            pub sale_price: Vec<String>,
            pub guest_ratings: Vec<models::CatalogsHotelGuestRatings>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsUpdatableHotelAttributes".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsUpdatableHotelAttributes".to_string()),
                    "link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsUpdatableHotelAttributes".to_string()),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsUpdatableHotelAttributes".to_string()),
                    "brand" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsUpdatableHotelAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "latitude" => intermediate_rep.latitude.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "longitude" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsUpdatableHotelAttributes".to_string()),
                    "neighborhood" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsUpdatableHotelAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "address" => intermediate_rep.address.push(<models::CatalogsHotelAddress as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "custom_label_0" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsUpdatableHotelAttributes".to_string()),
                    "custom_label_1" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsUpdatableHotelAttributes".to_string()),
                    "custom_label_2" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsUpdatableHotelAttributes".to_string()),
                    "custom_label_3" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsUpdatableHotelAttributes".to_string()),
                    "custom_label_4" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsUpdatableHotelAttributes".to_string()),
                    "category" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsUpdatableHotelAttributes".to_string()),
                    "base_price" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsUpdatableHotelAttributes".to_string()),
                    "sale_price" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsUpdatableHotelAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "guest_ratings" => intermediate_rep.guest_ratings.push(<models::CatalogsHotelGuestRatings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsUpdatableHotelAttributes".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsUpdatableHotelAttributes {
            name: std::result::Result::Err("Nullable types not supported in CatalogsUpdatableHotelAttributes".to_string())?,
            link: std::result::Result::Err("Nullable types not supported in CatalogsUpdatableHotelAttributes".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in CatalogsUpdatableHotelAttributes".to_string())?,
            brand: std::result::Result::Err("Nullable types not supported in CatalogsUpdatableHotelAttributes".to_string())?,
            latitude: intermediate_rep.latitude.into_iter().next(),
            longitude: std::result::Result::Err("Nullable types not supported in CatalogsUpdatableHotelAttributes".to_string())?,
            neighborhood: std::result::Result::Err("Nullable types not supported in CatalogsUpdatableHotelAttributes".to_string())?,
            address: intermediate_rep.address.into_iter().next(),
            custom_label_0: std::result::Result::Err("Nullable types not supported in CatalogsUpdatableHotelAttributes".to_string())?,
            custom_label_1: std::result::Result::Err("Nullable types not supported in CatalogsUpdatableHotelAttributes".to_string())?,
            custom_label_2: std::result::Result::Err("Nullable types not supported in CatalogsUpdatableHotelAttributes".to_string())?,
            custom_label_3: std::result::Result::Err("Nullable types not supported in CatalogsUpdatableHotelAttributes".to_string())?,
            custom_label_4: std::result::Result::Err("Nullable types not supported in CatalogsUpdatableHotelAttributes".to_string())?,
            category: std::result::Result::Err("Nullable types not supported in CatalogsUpdatableHotelAttributes".to_string())?,
            base_price: std::result::Result::Err("Nullable types not supported in CatalogsUpdatableHotelAttributes".to_string())?,
            sale_price: std::result::Result::Err("Nullable types not supported in CatalogsUpdatableHotelAttributes".to_string())?,
            guest_ratings: intermediate_rep.guest_ratings.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsUpdatableHotelAttributes> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsUpdatableHotelAttributes>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsUpdatableHotelAttributes>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsUpdatableHotelAttributes - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsUpdatableHotelAttributes> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsUpdatableHotelAttributes as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsUpdatableHotelAttributes - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object describing an hotel item batch record



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsUpdateHotelItem {
/// The catalog hotel item id in the merchant namespace
    #[serde(rename = "hotel_id")]
    pub hotel_id: String,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "operation")]
    pub operation: String,

    #[serde(rename = "attributes")]
    pub attributes: models::CatalogsUpdatableHotelAttributes,

}


impl CatalogsUpdateHotelItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(hotel_id: String, operation: String, attributes: models::CatalogsUpdatableHotelAttributes, ) -> CatalogsUpdateHotelItem {
        CatalogsUpdateHotelItem {
            hotel_id,
            operation,
            attributes,
        }
    }
}

/// Converts the CatalogsUpdateHotelItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsUpdateHotelItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("hotel_id".to_string()),
            Some(self.hotel_id.to_string()),


            Some("operation".to_string()),
            Some(self.operation.to_string()),

            // Skipping attributes in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsUpdateHotelItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsUpdateHotelItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hotel_id: Vec<String>,
            pub operation: Vec<String>,
            pub attributes: Vec<models::CatalogsUpdatableHotelAttributes>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsUpdateHotelItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "hotel_id" => intermediate_rep.hotel_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operation" => intermediate_rep.operation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "attributes" => intermediate_rep.attributes.push(<models::CatalogsUpdatableHotelAttributes as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsUpdateHotelItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsUpdateHotelItem {
            hotel_id: intermediate_rep.hotel_id.into_iter().next().ok_or_else(|| "hotel_id missing in CatalogsUpdateHotelItem".to_string())?,
            operation: intermediate_rep.operation.into_iter().next().ok_or_else(|| "operation missing in CatalogsUpdateHotelItem".to_string())?,
            attributes: intermediate_rep.attributes.into_iter().next().ok_or_else(|| "attributes missing in CatalogsUpdateHotelItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsUpdateHotelItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsUpdateHotelItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsUpdateHotelItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsUpdateHotelItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsUpdateHotelItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsUpdateHotelItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsUpdateHotelItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// An item to be updated



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsUpdateRetailItem {
/// The catalog item id in the merchant namespace
    #[serde(rename = "item_id")]
    pub item_id: String,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "operation")]
    pub operation: String,

    #[serde(rename = "attributes")]
    pub attributes: models::UpdatableItemAttributes,

/// The list of product attributes to be updated. Attributes specified in the update mask without a value specified in the body will be deleted from the product item.
    #[serde(rename = "update_mask")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub update_mask: Option<Nullable<Vec<models::UpdateMaskFieldType>>>,

}


impl CatalogsUpdateRetailItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(item_id: String, operation: String, attributes: models::UpdatableItemAttributes, ) -> CatalogsUpdateRetailItem {
        CatalogsUpdateRetailItem {
            item_id,
            operation,
            attributes,
            update_mask: None,
        }
    }
}

/// Converts the CatalogsUpdateRetailItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsUpdateRetailItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("operation".to_string()),
            Some(self.operation.to_string()),

            // Skipping attributes in query parameter serialization

            // Skipping update_mask in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsUpdateRetailItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsUpdateRetailItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_id: Vec<String>,
            pub operation: Vec<String>,
            pub attributes: Vec<models::UpdatableItemAttributes>,
            pub update_mask: Vec<Vec<models::UpdateMaskFieldType>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsUpdateRetailItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operation" => intermediate_rep.operation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "attributes" => intermediate_rep.attributes.push(<models::UpdatableItemAttributes as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "update_mask" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsUpdateRetailItem".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsUpdateRetailItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsUpdateRetailItem {
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in CatalogsUpdateRetailItem".to_string())?,
            operation: intermediate_rep.operation.into_iter().next().ok_or_else(|| "operation missing in CatalogsUpdateRetailItem".to_string())?,
            attributes: intermediate_rep.attributes.into_iter().next().ok_or_else(|| "attributes missing in CatalogsUpdateRetailItem".to_string())?,
            update_mask: std::result::Result::Err("Nullable types not supported in CatalogsUpdateRetailItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsUpdateRetailItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsUpdateRetailItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsUpdateRetailItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsUpdateRetailItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsUpdateRetailItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsUpdateRetailItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsUpdateRetailItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A hotel item to be upserted.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsUpsertHotelItem {
/// The catalog hotel id in the merchant namespace
    #[serde(rename = "hotel_id")]
    pub hotel_id: String,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "operation")]
    pub operation: String,

    #[serde(rename = "attributes")]
    pub attributes: models::CatalogsHotelAttributes,

}


impl CatalogsUpsertHotelItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(hotel_id: String, operation: String, attributes: models::CatalogsHotelAttributes, ) -> CatalogsUpsertHotelItem {
        CatalogsUpsertHotelItem {
            hotel_id,
            operation,
            attributes,
        }
    }
}

/// Converts the CatalogsUpsertHotelItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsUpsertHotelItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("hotel_id".to_string()),
            Some(self.hotel_id.to_string()),


            Some("operation".to_string()),
            Some(self.operation.to_string()),

            // Skipping attributes in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsUpsertHotelItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsUpsertHotelItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hotel_id: Vec<String>,
            pub operation: Vec<String>,
            pub attributes: Vec<models::CatalogsHotelAttributes>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsUpsertHotelItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "hotel_id" => intermediate_rep.hotel_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operation" => intermediate_rep.operation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "attributes" => intermediate_rep.attributes.push(<models::CatalogsHotelAttributes as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsUpsertHotelItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsUpsertHotelItem {
            hotel_id: intermediate_rep.hotel_id.into_iter().next().ok_or_else(|| "hotel_id missing in CatalogsUpsertHotelItem".to_string())?,
            operation: intermediate_rep.operation.into_iter().next().ok_or_else(|| "operation missing in CatalogsUpsertHotelItem".to_string())?,
            attributes: intermediate_rep.attributes.into_iter().next().ok_or_else(|| "attributes missing in CatalogsUpsertHotelItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsUpsertHotelItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsUpsertHotelItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsUpsertHotelItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsUpsertHotelItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsUpsertHotelItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsUpsertHotelItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsUpsertHotelItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// An item to be upserted



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsUpsertRetailItem {
/// The catalog item id in the merchant namespace
    #[serde(rename = "item_id")]
    pub item_id: String,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "operation")]
    pub operation: String,

    #[serde(rename = "attributes")]
    pub attributes: models::ItemAttributes,

}


impl CatalogsUpsertRetailItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(item_id: String, operation: String, attributes: models::ItemAttributes, ) -> CatalogsUpsertRetailItem {
        CatalogsUpsertRetailItem {
            item_id,
            operation,
            attributes,
        }
    }
}

/// Converts the CatalogsUpsertRetailItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CatalogsUpsertRetailItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("operation".to_string()),
            Some(self.operation.to_string()),

            // Skipping attributes in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsUpsertRetailItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsUpsertRetailItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_id: Vec<String>,
            pub operation: Vec<String>,
            pub attributes: Vec<models::ItemAttributes>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsUpsertRetailItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operation" => intermediate_rep.operation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "attributes" => intermediate_rep.attributes.push(<models::ItemAttributes as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsUpsertRetailItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsUpsertRetailItem {
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in CatalogsUpsertRetailItem".to_string())?,
            operation: intermediate_rep.operation.into_iter().next().ok_or_else(|| "operation missing in CatalogsUpsertRetailItem".to_string())?,
            attributes: intermediate_rep.attributes.into_iter().next().ok_or_else(|| "attributes missing in CatalogsUpsertRetailItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsUpsertRetailItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsUpsertRetailItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsUpsertRetailItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsUpsertRetailItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CatalogsUpsertRetailItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsUpsertRetailItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsUpsertRetailItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A request object that can have multiple operations on a single batch


/// One of:
/// - CatalogsHotelBatchRequest
/// - CatalogsRetailBatchRequest
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsVerticalBatchRequest(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsVerticalBatchRequest
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsVerticalBatchRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsVerticalBatchRequest {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsVerticalBatchRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Request object for creating a feed.


/// One of:
/// - CatalogsHotelFeedsCreateRequest
/// - CatalogsRetailFeedsCreateRequest
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsVerticalFeedsCreateRequest(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsVerticalFeedsCreateRequest
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsVerticalFeedsCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsVerticalFeedsCreateRequest {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsVerticalFeedsCreateRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Request object for updating a feed.


/// One of:
/// - CatalogsHotelFeedsUpdateRequest
/// - CatalogsRetailFeedsUpdateRequest
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsVerticalFeedsUpdateRequest(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsVerticalFeedsUpdateRequest
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsVerticalFeedsUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsVerticalFeedsUpdateRequest {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsVerticalFeedsUpdateRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}







/// One of:
/// - CatalogsHotelProductGroup
/// - CatalogsRetailProductGroup
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsVerticalProductGroup(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsVerticalProductGroup
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsVerticalProductGroup value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsVerticalProductGroup {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsVerticalProductGroup {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Request object for creating a hotel product group.


/// One of:
/// - CatalogsHotelProductGroupCreateRequest
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsVerticalProductGroupCreateRequest(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsVerticalProductGroupCreateRequest
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsVerticalProductGroupCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsVerticalProductGroupCreateRequest {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsVerticalProductGroupCreateRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Request object for updating a hotel product group.


/// One of:
/// - CatalogsHotelProductGroupUpdateRequest
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CatalogsVerticalProductGroupUpdateRequest(Box<serde_json::value::RawValue>);

impl validator::Validate for CatalogsVerticalProductGroupUpdateRequest
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsVerticalProductGroupUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsVerticalProductGroupUpdateRequest {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CatalogsVerticalProductGroupUpdateRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConditionFilter {
    #[serde(rename = "CONDITION")]
    pub condition: models::CatalogsProductGroupMultipleStringCriteria,

}


impl ConditionFilter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(condition: models::CatalogsProductGroupMultipleStringCriteria, ) -> ConditionFilter {
        ConditionFilter {
            condition,
        }
    }
}

/// Converts the ConditionFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ConditionFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping CONDITION in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConditionFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConditionFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub condition: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConditionFilter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CONDITION" => intermediate_rep.condition.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConditionFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConditionFilter {
            condition: intermediate_rep.condition.into_iter().next().ok_or_else(|| "CONDITION missing in ConditionFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConditionFilter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConditionFilter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConditionFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConditionFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConditionFilter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConditionFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConditionFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Schema describing the object in the response, which contains information about the events that were received and processed.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConversionApiResponse {
/// Total number of events received in the request.
    #[serde(rename = "num_events_received")]
    pub num_events_received: i32,

/// Number of events that were successfully processed from the events.
    #[serde(rename = "num_events_processed")]
    pub num_events_processed: i32,

/// Specific messages for each event received. The order will match the order in which the events were received in the request.
    #[serde(rename = "events")]
    pub events: Vec<models::ConversionApiResponseEventsInner>,

}


impl ConversionApiResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(num_events_received: i32, num_events_processed: i32, events: Vec<models::ConversionApiResponseEventsInner>, ) -> ConversionApiResponse {
        ConversionApiResponse {
            num_events_received,
            num_events_processed,
            events,
        }
    }
}

/// Converts the ConversionApiResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ConversionApiResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("num_events_received".to_string()),
            Some(self.num_events_received.to_string()),


            Some("num_events_processed".to_string()),
            Some(self.num_events_processed.to_string()),

            // Skipping events in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConversionApiResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConversionApiResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub num_events_received: Vec<i32>,
            pub num_events_processed: Vec<i32>,
            pub events: Vec<Vec<models::ConversionApiResponseEventsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConversionApiResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "num_events_received" => intermediate_rep.num_events_received.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "num_events_processed" => intermediate_rep.num_events_processed.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "events" => return std::result::Result::Err("Parsing a container in this style is not supported in ConversionApiResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConversionApiResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConversionApiResponse {
            num_events_received: intermediate_rep.num_events_received.into_iter().next().ok_or_else(|| "num_events_received missing in ConversionApiResponse".to_string())?,
            num_events_processed: intermediate_rep.num_events_processed.into_iter().next().ok_or_else(|| "num_events_processed missing in ConversionApiResponse".to_string())?,
            events: intermediate_rep.events.into_iter().next().ok_or_else(|| "events missing in ConversionApiResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConversionApiResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConversionApiResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConversionApiResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConversionApiResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConversionApiResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConversionApiResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConversionApiResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConversionApiResponseEventsInner {
/// Whether the event was processed successfully.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

/// Error message containing more information about why the event failed to be processed.
    #[serde(rename = "error_message")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_message: Option<Nullable<String>>,

/// Warning messages about any fields in the event which are not standard. These are not critical to event processing.
    #[serde(rename = "warning_message")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warning_message: Option<Nullable<String>>,

}


impl ConversionApiResponseEventsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(status: String, ) -> ConversionApiResponseEventsInner {
        ConversionApiResponseEventsInner {
            status,
            error_message: None,
            warning_message: None,
        }
    }
}

/// Converts the ConversionApiResponseEventsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ConversionApiResponseEventsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("status".to_string()),
            Some(self.status.to_string()),


            self.error_message.as_ref().map(|error_message| {
                [
                    "error_message".to_string(),
                    error_message.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.warning_message.as_ref().map(|warning_message| {
                [
                    "warning_message".to_string(),
                    warning_message.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConversionApiResponseEventsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConversionApiResponseEventsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status: Vec<String>,
            pub error_message: Vec<String>,
            pub warning_message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConversionApiResponseEventsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "error_message" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionApiResponseEventsInner".to_string()),
                    "warning_message" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionApiResponseEventsInner".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConversionApiResponseEventsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConversionApiResponseEventsInner {
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in ConversionApiResponseEventsInner".to_string())?,
            error_message: std::result::Result::Err("Nullable types not supported in ConversionApiResponseEventsInner".to_string())?,
            warning_message: std::result::Result::Err("Nullable types not supported in ConversionApiResponseEventsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConversionApiResponseEventsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConversionApiResponseEventsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConversionApiResponseEventsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConversionApiResponseEventsInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConversionApiResponseEventsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConversionApiResponseEventsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConversionApiResponseEventsInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ConversionAttributionWindowDays {
    #[serde(rename = "0")]
    Variant0,
    #[serde(rename = "1")]
    Variant1,
    #[serde(rename = "7")]
    Variant7,
    #[serde(rename = "14")]
    Variant14,
    #[serde(rename = "30")]
    Variant30,
    #[serde(rename = "60")]
    Variant60,
}

impl std::fmt::Display for ConversionAttributionWindowDays {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ConversionAttributionWindowDays::Variant0 => write!(f, "0"),
            ConversionAttributionWindowDays::Variant1 => write!(f, "1"),
            ConversionAttributionWindowDays::Variant7 => write!(f, "7"),
            ConversionAttributionWindowDays::Variant14 => write!(f, "14"),
            ConversionAttributionWindowDays::Variant30 => write!(f, "30"),
            ConversionAttributionWindowDays::Variant60 => write!(f, "60"),
        }
    }
}

impl std::str::FromStr for ConversionAttributionWindowDays {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "0" => std::result::Result::Ok(ConversionAttributionWindowDays::Variant0),
            "1" => std::result::Result::Ok(ConversionAttributionWindowDays::Variant1),
            "7" => std::result::Result::Ok(ConversionAttributionWindowDays::Variant7),
            "14" => std::result::Result::Ok(ConversionAttributionWindowDays::Variant14),
            "30" => std::result::Result::Ok(ConversionAttributionWindowDays::Variant30),
            "60" => std::result::Result::Ok(ConversionAttributionWindowDays::Variant60),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConversionEventResponse {
    #[serde(rename = "conversion_event")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conversion_event: Option<models::ConversionTagType>,

/// Id of the tag.
    #[serde(rename = "conversion_tag_id")]
    #[validate(
           regex = "RE_CONVERSIONEVENTRESPONSE_CONVERSION_TAG_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conversion_tag_id: Option<String>,

/// Id of the ad account.
    #[serde(rename = "ad_account_id")]
    #[validate(
           regex = "RE_CONVERSIONEVENTRESPONSE_AD_ACCOUNT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// Creation date in epoch format.
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<i32>,

}

lazy_static::lazy_static! {
    static ref RE_CONVERSIONEVENTRESPONSE_CONVERSION_TAG_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_CONVERSIONEVENTRESPONSE_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl ConversionEventResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ConversionEventResponse {
        ConversionEventResponse {
            conversion_event: None,
            conversion_tag_id: None,
            ad_account_id: None,
            created_time: None,
        }
    }
}

/// Converts the ConversionEventResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ConversionEventResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping conversion_event in query parameter serialization


            self.conversion_tag_id.as_ref().map(|conversion_tag_id| {
                [
                    "conversion_tag_id".to_string(),
                    conversion_tag_id.to_string(),
                ].join(",")
            }),


            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.created_time.as_ref().map(|created_time| {
                [
                    "created_time".to_string(),
                    created_time.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConversionEventResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConversionEventResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub conversion_event: Vec<models::ConversionTagType>,
            pub conversion_tag_id: Vec<String>,
            pub ad_account_id: Vec<String>,
            pub created_time: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConversionEventResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "conversion_event" => intermediate_rep.conversion_event.push(<models::ConversionTagType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "conversion_tag_id" => intermediate_rep.conversion_tag_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_time" => intermediate_rep.created_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConversionEventResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConversionEventResponse {
            conversion_event: intermediate_rep.conversion_event.into_iter().next(),
            conversion_tag_id: intermediate_rep.conversion_tag_id.into_iter().next(),
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            created_time: intermediate_rep.created_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConversionEventResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConversionEventResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConversionEventResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConversionEventResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConversionEventResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConversionEventResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConversionEventResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A list of events (one or more) encapsulated by a data object.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConversionEvents {
    #[serde(rename = "data")]
    #[validate(
            length(min = 1, max = 1000),
        )]
    pub data: Vec<models::ConversionEventsDataInner>,

}


impl ConversionEvents {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(data: Vec<models::ConversionEventsDataInner>, ) -> ConversionEvents {
        ConversionEvents {
            data,
        }
    }
}

/// Converts the ConversionEvents value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ConversionEvents {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConversionEvents value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConversionEvents {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<Vec<models::ConversionEventsDataInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConversionEvents".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ConversionEvents".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConversionEvents".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConversionEvents {
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ConversionEvents".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConversionEvents> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConversionEvents>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConversionEvents>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConversionEvents - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConversionEvents> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConversionEvents as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConversionEvents - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConversionEventsDataInner {
/// The type of the user event. Please use the right event_name otherwise the event won’t be accepted and show up correctly in reports. <li><code>add_to_cart</code> <li><code>checkout</code> <li><code>custom</code> <li><code>lead</code> <li><code>page_visit</code> <li><code>search</code> <li><code>signup</code> <li><code>view_category</code> <li><code>watch_video</code>
    #[serde(rename = "event_name")]
    pub event_name: String,

/// The source indicating where the conversion event occurred. <li><code>app_android</code> <li><code>app_ios</code> <li><code>web</code> <li><code>offline</code>
    #[serde(rename = "action_source")]
    pub action_source: String,

/// The time when the event happened. Unix timestamp in seconds.
    #[serde(rename = "event_time")]
    pub event_time: i64,

/// A unique id string that identifies this event and can be used for deduping between events ingested via both the conversion API and Pinterest tracking. Without this, event's data is likely to be double counted and will cause report metric inflation. Third-party vendors make sure this field is updated on both Pinterest tag and Conversions API side before rolling out template for Conversions API.
    #[serde(rename = "event_id")]
    pub event_id: String,

/// URL of the web conversion event.
    #[serde(rename = "event_source_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_source_url: Option<Nullable<String>>,

/// When action_source is web or offline, it defines whether the user has opted out of tracking for web conversion events. While when action_source is app_android or app_ios, it defines whether the user has enabled Limit Ad Tracking on their iOS device, or opted out of Ads Personalization on their Android device.
    #[serde(rename = "opt_out")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub opt_out: Option<bool>,

/// The third party partner name responsible to send the event to Conversions API on behalf of the advertiser. The naming convention is \"ss-partnername\" lowercase. E.g ‘ss-shopify’
    #[serde(rename = "partner_name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_name: Option<Nullable<String>>,

    #[serde(rename = "user_data")]
    pub user_data: Nullable<models::ConversionEventsUserData>,

    #[serde(rename = "custom_data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_data: Option<models::ConversionEventsDataInnerCustomData>,

/// The app store app ID.
    #[serde(rename = "app_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_id: Option<Nullable<String>>,

/// Name of the app.
    #[serde(rename = "app_name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_name: Option<Nullable<String>>,

/// Version of the app.
    #[serde(rename = "app_version")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_version: Option<Nullable<String>>,

/// Brand of the user device.
    #[serde(rename = "device_brand")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_brand: Option<Nullable<String>>,

/// User device's mobile carrier.
    #[serde(rename = "device_carrier")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_carrier: Option<Nullable<String>>,

/// Model of the user device.
    #[serde(rename = "device_model")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_model: Option<Nullable<String>>,

/// Type of the user device.
    #[serde(rename = "device_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_type: Option<Nullable<String>>,

/// Version of the device operating system.
    #[serde(rename = "os_version")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os_version: Option<Nullable<String>>,

/// Whether the event occurred when the user device was connected to wifi.
    #[serde(rename = "wifi")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub wifi: Option<bool>,

/// Two-character ISO-639-1 language code indicating the user's language.
    #[serde(rename = "language")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<Nullable<String>>,

}


impl ConversionEventsDataInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_name: String, action_source: String, event_time: i64, event_id: String, user_data: Nullable<models::ConversionEventsUserData>, ) -> ConversionEventsDataInner {
        ConversionEventsDataInner {
            event_name,
            action_source,
            event_time,
            event_id,
            event_source_url: None,
            opt_out: None,
            partner_name: None,
            user_data,
            custom_data: None,
            app_id: None,
            app_name: None,
            app_version: None,
            device_brand: None,
            device_carrier: None,
            device_model: None,
            device_type: None,
            os_version: None,
            wifi: None,
            language: None,
        }
    }
}

/// Converts the ConversionEventsDataInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ConversionEventsDataInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_name".to_string()),
            Some(self.event_name.to_string()),


            Some("action_source".to_string()),
            Some(self.action_source.to_string()),


            Some("event_time".to_string()),
            Some(self.event_time.to_string()),


            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            self.event_source_url.as_ref().map(|event_source_url| {
                [
                    "event_source_url".to_string(),
                    event_source_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.opt_out.as_ref().map(|opt_out| {
                [
                    "opt_out".to_string(),
                    opt_out.to_string(),
                ].join(",")
            }),


            self.partner_name.as_ref().map(|partner_name| {
                [
                    "partner_name".to_string(),
                    partner_name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping user_data in query parameter serialization

            // Skipping custom_data in query parameter serialization


            self.app_id.as_ref().map(|app_id| {
                [
                    "app_id".to_string(),
                    app_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.app_name.as_ref().map(|app_name| {
                [
                    "app_name".to_string(),
                    app_name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.app_version.as_ref().map(|app_version| {
                [
                    "app_version".to_string(),
                    app_version.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.device_brand.as_ref().map(|device_brand| {
                [
                    "device_brand".to_string(),
                    device_brand.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.device_carrier.as_ref().map(|device_carrier| {
                [
                    "device_carrier".to_string(),
                    device_carrier.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.device_model.as_ref().map(|device_model| {
                [
                    "device_model".to_string(),
                    device_model.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.device_type.as_ref().map(|device_type| {
                [
                    "device_type".to_string(),
                    device_type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.os_version.as_ref().map(|os_version| {
                [
                    "os_version".to_string(),
                    os_version.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.wifi.as_ref().map(|wifi| {
                [
                    "wifi".to_string(),
                    wifi.to_string(),
                ].join(",")
            }),


            self.language.as_ref().map(|language| {
                [
                    "language".to_string(),
                    language.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConversionEventsDataInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConversionEventsDataInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_name: Vec<String>,
            pub action_source: Vec<String>,
            pub event_time: Vec<i64>,
            pub event_id: Vec<String>,
            pub event_source_url: Vec<String>,
            pub opt_out: Vec<bool>,
            pub partner_name: Vec<String>,
            pub user_data: Vec<models::ConversionEventsUserData>,
            pub custom_data: Vec<models::ConversionEventsDataInnerCustomData>,
            pub app_id: Vec<String>,
            pub app_name: Vec<String>,
            pub app_version: Vec<String>,
            pub device_brand: Vec<String>,
            pub device_carrier: Vec<String>,
            pub device_model: Vec<String>,
            pub device_type: Vec<String>,
            pub os_version: Vec<String>,
            pub wifi: Vec<bool>,
            pub language: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConversionEventsDataInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_name" => intermediate_rep.event_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "action_source" => intermediate_rep.action_source.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "event_time" => intermediate_rep.event_time.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "event_source_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInner".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "opt_out" => intermediate_rep.opt_out.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "partner_name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInner".to_string()),
                    "user_data" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInner".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "custom_data" => intermediate_rep.custom_data.push(<models::ConversionEventsDataInnerCustomData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "app_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInner".to_string()),
                    "app_name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInner".to_string()),
                    "app_version" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInner".to_string()),
                    "device_brand" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInner".to_string()),
                    "device_carrier" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInner".to_string()),
                    "device_model" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInner".to_string()),
                    "device_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInner".to_string()),
                    "os_version" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInner".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "wifi" => intermediate_rep.wifi.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "language" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInner".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConversionEventsDataInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConversionEventsDataInner {
            event_name: intermediate_rep.event_name.into_iter().next().ok_or_else(|| "event_name missing in ConversionEventsDataInner".to_string())?,
            action_source: intermediate_rep.action_source.into_iter().next().ok_or_else(|| "action_source missing in ConversionEventsDataInner".to_string())?,
            event_time: intermediate_rep.event_time.into_iter().next().ok_or_else(|| "event_time missing in ConversionEventsDataInner".to_string())?,
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in ConversionEventsDataInner".to_string())?,
            event_source_url: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInner".to_string())?,
            opt_out: intermediate_rep.opt_out.into_iter().next(),
            partner_name: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInner".to_string())?,
            user_data: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInner".to_string())?,
            custom_data: intermediate_rep.custom_data.into_iter().next(),
            app_id: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInner".to_string())?,
            app_name: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInner".to_string())?,
            app_version: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInner".to_string())?,
            device_brand: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInner".to_string())?,
            device_carrier: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInner".to_string())?,
            device_model: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInner".to_string())?,
            device_type: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInner".to_string())?,
            os_version: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInner".to_string())?,
            wifi: intermediate_rep.wifi.into_iter().next(),
            language: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConversionEventsDataInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConversionEventsDataInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConversionEventsDataInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConversionEventsDataInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConversionEventsDataInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConversionEventsDataInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConversionEventsDataInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object containing other custom data.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConversionEventsDataInnerCustomData {
/// The ISO-4217 currency code. If not provided, we will default to the advertiser's currency set during account creation. Your campaign performance needs this field to report right ROAS/CPA.
    #[serde(rename = "currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency: Option<Nullable<String>>,

/// Total value of the event. Accepted as a string in the request; it will be parsed into a double. For example, if there are two items in a checkout event, the value should be the total price. We recommend to use pre-tax, pre-shipping final value.
    #[serde(rename = "value")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<Nullable<String>>,

/// List of products IDs. We recommend using this if you are a merchant for PageVisit, AddToCart and Checkouts. For detail, please check <a href=\"https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\" target=\"_blank\">here</a> (Install the Pinterest tag section).
    #[serde(rename = "content_ids")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_ids: Option<Vec<String>>,

/// The name of the page or product associated with the event.
    #[serde(rename = "content_name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_name: Option<Nullable<String>>,

/// The category of the content associated with the event.
    #[serde(rename = "content_category")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_category: Option<Nullable<String>>,

/// The brand of the content associated with the event.
    #[serde(rename = "content_brand")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_brand: Option<Nullable<String>>,

/// A list of objects containing information about products, such as price and quantity. We recommend using this if you are a merchant for PageVisit, AddToCart and Checkouts. For detail, please check <a href=\"https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\" target=\"_blank\">here</a> (Install the Pinterest tag section).
    #[serde(rename = "contents")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents: Option<Vec<models::ConversionEventsDataInnerCustomDataContentsInner>>,

/// Total number of products of the event. For example, the total number of items purchased in a checkout event. We recommend using this if you are a merchant for AddToCart and Checkouts. For detail, please check <a href=\"https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\" target=\"_blank\">here</a> (Install the Pinterest tag section).
    #[serde(rename = "num_items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub num_items: Option<i64>,

/// The order ID. We recommend sending order_id to help us deduplicate events when necessary. This also helps to run other measurement products at Pinterest.
    #[serde(rename = "order_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_id: Option<Nullable<String>>,

/// The search string related to the user conversion event.
    #[serde(rename = "search_string")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub search_string: Option<Nullable<String>>,

/// Flags for different privacy rights laws to opt out users of sharing personal information. Values should be comma separated. Please follow the <a href=\"https://help.pinterest.com/en/business/article/limited-data-processing\" target=\"_blank\">Help Center</a> and <a href=\"https://developers.pinterest.com/docs/conversions/conversion-management/#Understanding%20Limited%20Data%20Processing\" target=\"_blank\">dev site</a> for specific opt_out_type set up.
    #[serde(rename = "opt_out_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub opt_out_type: Option<Nullable<String>>,

/// Named partner. Not required, this is for Pinterest internal use only. Please do not use this unless specifically guided.
    #[serde(rename = "np")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub np: Option<Nullable<String>>,

}


impl ConversionEventsDataInnerCustomData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ConversionEventsDataInnerCustomData {
        ConversionEventsDataInnerCustomData {
            currency: None,
            value: None,
            content_ids: None,
            content_name: None,
            content_category: None,
            content_brand: None,
            contents: None,
            num_items: None,
            order_id: None,
            search_string: None,
            opt_out_type: None,
            np: None,
        }
    }
}

/// Converts the ConversionEventsDataInnerCustomData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ConversionEventsDataInnerCustomData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.currency.as_ref().map(|currency| {
                [
                    "currency".to_string(),
                    currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.content_ids.as_ref().map(|content_ids| {
                [
                    "content_ids".to_string(),
                    content_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.content_name.as_ref().map(|content_name| {
                [
                    "content_name".to_string(),
                    content_name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.content_category.as_ref().map(|content_category| {
                [
                    "content_category".to_string(),
                    content_category.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.content_brand.as_ref().map(|content_brand| {
                [
                    "content_brand".to_string(),
                    content_brand.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping contents in query parameter serialization


            self.num_items.as_ref().map(|num_items| {
                [
                    "num_items".to_string(),
                    num_items.to_string(),
                ].join(",")
            }),


            self.order_id.as_ref().map(|order_id| {
                [
                    "order_id".to_string(),
                    order_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.search_string.as_ref().map(|search_string| {
                [
                    "search_string".to_string(),
                    search_string.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.opt_out_type.as_ref().map(|opt_out_type| {
                [
                    "opt_out_type".to_string(),
                    opt_out_type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.np.as_ref().map(|np| {
                [
                    "np".to_string(),
                    np.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConversionEventsDataInnerCustomData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConversionEventsDataInnerCustomData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub currency: Vec<String>,
            pub value: Vec<String>,
            pub content_ids: Vec<Vec<String>>,
            pub content_name: Vec<String>,
            pub content_category: Vec<String>,
            pub content_brand: Vec<String>,
            pub contents: Vec<Vec<models::ConversionEventsDataInnerCustomDataContentsInner>>,
            pub num_items: Vec<i64>,
            pub order_id: Vec<String>,
            pub search_string: Vec<String>,
            pub opt_out_type: Vec<String>,
            pub np: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConversionEventsDataInnerCustomData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInnerCustomData".to_string()),
                    "value" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInnerCustomData".to_string()),
                    "content_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in ConversionEventsDataInnerCustomData".to_string()),
                    "content_name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInnerCustomData".to_string()),
                    "content_category" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInnerCustomData".to_string()),
                    "content_brand" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInnerCustomData".to_string()),
                    "contents" => return std::result::Result::Err("Parsing a container in this style is not supported in ConversionEventsDataInnerCustomData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "num_items" => intermediate_rep.num_items.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "order_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInnerCustomData".to_string()),
                    "search_string" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInnerCustomData".to_string()),
                    "opt_out_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInnerCustomData".to_string()),
                    "np" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsDataInnerCustomData".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConversionEventsDataInnerCustomData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConversionEventsDataInnerCustomData {
            currency: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInnerCustomData".to_string())?,
            value: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInnerCustomData".to_string())?,
            content_ids: intermediate_rep.content_ids.into_iter().next(),
            content_name: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInnerCustomData".to_string())?,
            content_category: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInnerCustomData".to_string())?,
            content_brand: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInnerCustomData".to_string())?,
            contents: intermediate_rep.contents.into_iter().next(),
            num_items: intermediate_rep.num_items.into_iter().next(),
            order_id: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInnerCustomData".to_string())?,
            search_string: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInnerCustomData".to_string())?,
            opt_out_type: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInnerCustomData".to_string())?,
            np: std::result::Result::Err("Nullable types not supported in ConversionEventsDataInnerCustomData".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConversionEventsDataInnerCustomData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConversionEventsDataInnerCustomData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConversionEventsDataInnerCustomData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConversionEventsDataInnerCustomData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConversionEventsDataInnerCustomData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConversionEventsDataInnerCustomData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConversionEventsDataInnerCustomData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConversionEventsDataInnerCustomDataContentsInner {
/// The id of a product. We recommend using this if you are a merchant for AddToCart and Checkouts. For detail, please check <a href=\"https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\" target=\"_blank\">here</a> (Install the Pinterest tag section).
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// The price of a product. Accepted as a string in the request; it will be parsed into a double. This is the original item value before any discount. We recommend using this if you are a merchant for PageVisit, AddToCart and Checkouts. For detail, please check <a href=\"https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\" target=\"_blank\">here</a> (Install the Pinterest tag section).
    #[serde(rename = "item_price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_price: Option<String>,

/// The amount of a product. We recommend using this if you are a merchant for AddToCart and Checkouts. For detail, please check <a href=\"https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\" target=\"_blank\">here</a> (Install the Pinterest tag section).
    #[serde(rename = "quantity")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quantity: Option<i64>,

/// The name of a product.
    #[serde(rename = "item_name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_name: Option<String>,

/// The category of a product.
    #[serde(rename = "item_category")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_category: Option<String>,

/// The brand of a product.
    #[serde(rename = "item_brand")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_brand: Option<String>,

}


impl ConversionEventsDataInnerCustomDataContentsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ConversionEventsDataInnerCustomDataContentsInner {
        ConversionEventsDataInnerCustomDataContentsInner {
            id: None,
            item_price: None,
            quantity: None,
            item_name: None,
            item_category: None,
            item_brand: None,
        }
    }
}

/// Converts the ConversionEventsDataInnerCustomDataContentsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ConversionEventsDataInnerCustomDataContentsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.item_price.as_ref().map(|item_price| {
                [
                    "item_price".to_string(),
                    item_price.to_string(),
                ].join(",")
            }),


            self.quantity.as_ref().map(|quantity| {
                [
                    "quantity".to_string(),
                    quantity.to_string(),
                ].join(",")
            }),


            self.item_name.as_ref().map(|item_name| {
                [
                    "item_name".to_string(),
                    item_name.to_string(),
                ].join(",")
            }),


            self.item_category.as_ref().map(|item_category| {
                [
                    "item_category".to_string(),
                    item_category.to_string(),
                ].join(",")
            }),


            self.item_brand.as_ref().map(|item_brand| {
                [
                    "item_brand".to_string(),
                    item_brand.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConversionEventsDataInnerCustomDataContentsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConversionEventsDataInnerCustomDataContentsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub item_price: Vec<String>,
            pub quantity: Vec<i64>,
            pub item_name: Vec<String>,
            pub item_category: Vec<String>,
            pub item_brand: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConversionEventsDataInnerCustomDataContentsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_price" => intermediate_rep.item_price.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quantity" => intermediate_rep.quantity.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_name" => intermediate_rep.item_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_category" => intermediate_rep.item_category.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_brand" => intermediate_rep.item_brand.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConversionEventsDataInnerCustomDataContentsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConversionEventsDataInnerCustomDataContentsInner {
            id: intermediate_rep.id.into_iter().next(),
            item_price: intermediate_rep.item_price.into_iter().next(),
            quantity: intermediate_rep.quantity.into_iter().next(),
            item_name: intermediate_rep.item_name.into_iter().next(),
            item_category: intermediate_rep.item_category.into_iter().next(),
            item_brand: intermediate_rep.item_brand.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConversionEventsDataInnerCustomDataContentsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConversionEventsDataInnerCustomDataContentsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConversionEventsDataInnerCustomDataContentsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConversionEventsDataInnerCustomDataContentsInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConversionEventsDataInnerCustomDataContentsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConversionEventsDataInnerCustomDataContentsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConversionEventsDataInnerCustomDataContentsInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object containing customer information data. Note, It is required at least one of 1) em, 2) hashed_maids or 3) pair client_ip_address + client_user_agent.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConversionEventsUserData {
/// Sha256 hashes of user's phone numbers, only digits with country code, area code, and number. Remove any symbols, letters, spaces and leading zeros. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA.
    #[serde(rename = "ph")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ph: Option<Vec<String>>,

/// Sha256 hashes of user's gender, in lowercase. Either \"f\" or \"m\" or \"n\" for non-binary gender.
    #[serde(rename = "ge")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ge: Option<Vec<String>>,

/// Sha256 hashes of user's date of birthday, given as year, month, and day.
    #[serde(rename = "db")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub db: Option<Vec<String>>,

/// Sha256 hashes of user's last name, in lowercase. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA.
    #[serde(rename = "ln")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ln: Option<Vec<String>>,

/// Sha256 hashes of user's first name, in lowercase. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA.
    #[serde(rename = "fn")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#fn: Option<Vec<String>>,

/// Sha256 hashes of user's city, in lowercase, and without spaces or punctuation. User residency city (mostly billing).
    #[serde(rename = "ct")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ct: Option<Vec<String>>,

/// Sha256 hashes of user's state, given as a two-letter code in lowercase. User residency state (mostly billing).
    #[serde(rename = "st")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub st: Option<Vec<String>>,

/// Sha256 hashes of user's zipcode, only digits. User residency zipcode (mostly billing).
    #[serde(rename = "zp")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub zp: Option<Vec<String>>,

/// Sha256 hashes of two-character ISO-3166 country code indicating the user's country, in lowercase.
    #[serde(rename = "country")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub country: Option<Vec<String>>,

/// Sha256 hashes of the unique id from the advertiser that identifies a user in their space, e.g. user id, loyalty id, etc. We highly recommend this on all events. It may improve reporting performance such as ROAS/CPA.
    #[serde(rename = "external_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_id: Option<Vec<String>>,

/// The unique identifier stored in _epik cookie on your domain or &epik= query parameter in the URL. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA.
    #[serde(rename = "click_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub click_id: Option<Nullable<String>>,

/// A unique identifier of visitors' information defined by third party partners. e.g RampID
    #[serde(rename = "partner_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_id: Option<Nullable<String>>,

}


impl ConversionEventsUserData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ConversionEventsUserData {
        ConversionEventsUserData {
            ph: None,
            ge: None,
            db: None,
            ln: None,
            r#fn: None,
            ct: None,
            st: None,
            zp: None,
            country: None,
            external_id: None,
            click_id: None,
            partner_id: None,
        }
    }
}

/// Converts the ConversionEventsUserData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ConversionEventsUserData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ph.as_ref().map(|ph| {
                [
                    "ph".to_string(),
                    ph.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.ge.as_ref().map(|ge| {
                [
                    "ge".to_string(),
                    ge.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.db.as_ref().map(|db| {
                [
                    "db".to_string(),
                    db.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.ln.as_ref().map(|ln| {
                [
                    "ln".to_string(),
                    ln.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.r#fn.as_ref().map(|r#fn| {
                [
                    "fn".to_string(),
                    r#fn.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.ct.as_ref().map(|ct| {
                [
                    "ct".to_string(),
                    ct.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.st.as_ref().map(|st| {
                [
                    "st".to_string(),
                    st.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.zp.as_ref().map(|zp| {
                [
                    "zp".to_string(),
                    zp.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.country.as_ref().map(|country| {
                [
                    "country".to_string(),
                    country.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.external_id.as_ref().map(|external_id| {
                [
                    "external_id".to_string(),
                    external_id.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.click_id.as_ref().map(|click_id| {
                [
                    "click_id".to_string(),
                    click_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.partner_id.as_ref().map(|partner_id| {
                [
                    "partner_id".to_string(),
                    partner_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConversionEventsUserData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConversionEventsUserData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ph: Vec<Vec<String>>,
            pub ge: Vec<Vec<String>>,
            pub db: Vec<Vec<String>>,
            pub ln: Vec<Vec<String>>,
            pub r#fn: Vec<Vec<String>>,
            pub ct: Vec<Vec<String>>,
            pub st: Vec<Vec<String>>,
            pub zp: Vec<Vec<String>>,
            pub country: Vec<Vec<String>>,
            pub external_id: Vec<Vec<String>>,
            pub click_id: Vec<String>,
            pub partner_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConversionEventsUserData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ph" => return std::result::Result::Err("Parsing a container in this style is not supported in ConversionEventsUserData".to_string()),
                    "ge" => return std::result::Result::Err("Parsing a container in this style is not supported in ConversionEventsUserData".to_string()),
                    "db" => return std::result::Result::Err("Parsing a container in this style is not supported in ConversionEventsUserData".to_string()),
                    "ln" => return std::result::Result::Err("Parsing a container in this style is not supported in ConversionEventsUserData".to_string()),
                    "fn" => return std::result::Result::Err("Parsing a container in this style is not supported in ConversionEventsUserData".to_string()),
                    "ct" => return std::result::Result::Err("Parsing a container in this style is not supported in ConversionEventsUserData".to_string()),
                    "st" => return std::result::Result::Err("Parsing a container in this style is not supported in ConversionEventsUserData".to_string()),
                    "zp" => return std::result::Result::Err("Parsing a container in this style is not supported in ConversionEventsUserData".to_string()),
                    "country" => return std::result::Result::Err("Parsing a container in this style is not supported in ConversionEventsUserData".to_string()),
                    "external_id" => return std::result::Result::Err("Parsing a container in this style is not supported in ConversionEventsUserData".to_string()),
                    "click_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsUserData".to_string()),
                    "partner_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionEventsUserData".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConversionEventsUserData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConversionEventsUserData {
            ph: intermediate_rep.ph.into_iter().next(),
            ge: intermediate_rep.ge.into_iter().next(),
            db: intermediate_rep.db.into_iter().next(),
            ln: intermediate_rep.ln.into_iter().next(),
            r#fn: intermediate_rep.r#fn.into_iter().next(),
            ct: intermediate_rep.ct.into_iter().next(),
            st: intermediate_rep.st.into_iter().next(),
            zp: intermediate_rep.zp.into_iter().next(),
            country: intermediate_rep.country.into_iter().next(),
            external_id: intermediate_rep.external_id.into_iter().next(),
            click_id: std::result::Result::Err("Nullable types not supported in ConversionEventsUserData".to_string())?,
            partner_id: std::result::Result::Err("Nullable types not supported in ConversionEventsUserData".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConversionEventsUserData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConversionEventsUserData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConversionEventsUserData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConversionEventsUserData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConversionEventsUserData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConversionEventsUserData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConversionEventsUserData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Attribution type. Refers to the Pinterest Tag endpoints
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ConversionReportAttributionType {
    #[serde(rename = "INDIVIDUAL")]
    Individual,
    #[serde(rename = "HOUSEHOLD")]
    Household,
}

impl std::fmt::Display for ConversionReportAttributionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ConversionReportAttributionType::Individual => write!(f, "INDIVIDUAL"),
            ConversionReportAttributionType::Household => write!(f, "HOUSEHOLD"),
        }
    }
}

impl std::str::FromStr for ConversionReportAttributionType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "INDIVIDUAL" => std::result::Result::Ok(ConversionReportAttributionType::Individual),
            "HOUSEHOLD" => std::result::Result::Ok(ConversionReportAttributionType::Household),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Conversion report time type
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ConversionReportTimeType {
    #[serde(rename = "TIME_OF_AD_ACTION")]
    AdAction,
    #[serde(rename = "TIME_OF_CONVERSION")]
    Conversion,
}

impl std::fmt::Display for ConversionReportTimeType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ConversionReportTimeType::AdAction => write!(f, "TIME_OF_AD_ACTION"),
            ConversionReportTimeType::Conversion => write!(f, "TIME_OF_CONVERSION"),
        }
    }
}

impl std::str::FromStr for ConversionReportTimeType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "TIME_OF_AD_ACTION" => std::result::Result::Ok(ConversionReportTimeType::AdAction),
            "TIME_OF_CONVERSION" => std::result::Result::Ok(ConversionReportTimeType::Conversion),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConversionTagCommon {
/// Ad account ID.
    #[serde(rename = "ad_account_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// Tag code snippet.
    #[serde(rename = "code_snippet")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_snippet: Option<String>,

    #[serde(rename = "enhanced_match_status")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enhanced_match_status: Option<Nullable<models::EnhancedMatchStatusType>>,

/// Tag ID.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Time for the last event fired.
    #[serde(rename = "last_fired_time_ms")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_fired_time_ms: Option<Nullable<f64>>,

/// Conversion tag name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

/// Version number.
    #[serde(rename = "version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,

    #[serde(rename = "configs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub configs: Option<models::ConversionTagConfigs>,

}


impl ConversionTagCommon {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ConversionTagCommon {
        ConversionTagCommon {
            ad_account_id: None,
            code_snippet: None,
            enhanced_match_status: None,
            id: None,
            last_fired_time_ms: None,
            name: None,
            status: None,
            version: None,
            configs: None,
        }
    }
}

/// Converts the ConversionTagCommon value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ConversionTagCommon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.code_snippet.as_ref().map(|code_snippet| {
                [
                    "code_snippet".to_string(),
                    code_snippet.to_string(),
                ].join(",")
            }),

            // Skipping enhanced_match_status in query parameter serialization


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.last_fired_time_ms.as_ref().map(|last_fired_time_ms| {
                [
                    "last_fired_time_ms".to_string(),
                    last_fired_time_ms.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.version.as_ref().map(|version| {
                [
                    "version".to_string(),
                    version.to_string(),
                ].join(",")
            }),

            // Skipping configs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConversionTagCommon value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConversionTagCommon {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_account_id: Vec<String>,
            pub code_snippet: Vec<String>,
            pub enhanced_match_status: Vec<models::EnhancedMatchStatusType>,
            pub id: Vec<String>,
            pub last_fired_time_ms: Vec<f64>,
            pub name: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub version: Vec<String>,
            pub configs: Vec<models::ConversionTagConfigs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConversionTagCommon".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "code_snippet" => intermediate_rep.code_snippet.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "enhanced_match_status" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagCommon".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "last_fired_time_ms" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagCommon".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "configs" => intermediate_rep.configs.push(<models::ConversionTagConfigs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConversionTagCommon".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConversionTagCommon {
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            code_snippet: intermediate_rep.code_snippet.into_iter().next(),
            enhanced_match_status: std::result::Result::Err("Nullable types not supported in ConversionTagCommon".to_string())?,
            id: intermediate_rep.id.into_iter().next(),
            last_fired_time_ms: std::result::Result::Err("Nullable types not supported in ConversionTagCommon".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
            configs: intermediate_rep.configs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConversionTagCommon> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConversionTagCommon>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConversionTagCommon>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConversionTagCommon - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConversionTagCommon> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConversionTagCommon as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConversionTagCommon - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConversionTagConfigs {
/// Whether Automatic Enhanced Match email is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
    #[serde(rename = "aem_enabled")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aem_enabled: Option<Nullable<bool>>,

/// Metadata ingestion frequency.
    #[serde(rename = "md_frequency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub md_frequency: Option<Nullable<f64>>,

/// Whether Automatic Enhanced Match name is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
    #[serde(rename = "aem_fnln_enabled")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aem_fnln_enabled: Option<Nullable<bool>>,

/// Whether Automatic Enhanced Match phone is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
    #[serde(rename = "aem_ph_enabled")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aem_ph_enabled: Option<Nullable<bool>>,

/// Whether Automatic Enhanced Match gender is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
    #[serde(rename = "aem_ge_enabled")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aem_ge_enabled: Option<Nullable<bool>>,

/// Whether Automatic Enhanced Match birthdate is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
    #[serde(rename = "aem_db_enabled")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aem_db_enabled: Option<Nullable<bool>>,

/// Whether Automatic Enhanced Match location is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
    #[serde(rename = "aem_loc_enabled")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aem_loc_enabled: Option<Nullable<bool>>,

}


impl ConversionTagConfigs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ConversionTagConfigs {
        ConversionTagConfigs {
            aem_enabled: Some(Nullable::Present(false)),
            md_frequency: Some(Nullable::Present(1)),
            aem_fnln_enabled: Some(Nullable::Present(false)),
            aem_ph_enabled: Some(Nullable::Present(false)),
            aem_ge_enabled: Some(Nullable::Present(false)),
            aem_db_enabled: Some(Nullable::Present(false)),
            aem_loc_enabled: Some(Nullable::Present(false)),
        }
    }
}

/// Converts the ConversionTagConfigs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ConversionTagConfigs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.aem_enabled.as_ref().map(|aem_enabled| {
                [
                    "aem_enabled".to_string(),
                    aem_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.md_frequency.as_ref().map(|md_frequency| {
                [
                    "md_frequency".to_string(),
                    md_frequency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.aem_fnln_enabled.as_ref().map(|aem_fnln_enabled| {
                [
                    "aem_fnln_enabled".to_string(),
                    aem_fnln_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.aem_ph_enabled.as_ref().map(|aem_ph_enabled| {
                [
                    "aem_ph_enabled".to_string(),
                    aem_ph_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.aem_ge_enabled.as_ref().map(|aem_ge_enabled| {
                [
                    "aem_ge_enabled".to_string(),
                    aem_ge_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.aem_db_enabled.as_ref().map(|aem_db_enabled| {
                [
                    "aem_db_enabled".to_string(),
                    aem_db_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.aem_loc_enabled.as_ref().map(|aem_loc_enabled| {
                [
                    "aem_loc_enabled".to_string(),
                    aem_loc_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConversionTagConfigs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConversionTagConfigs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub aem_enabled: Vec<bool>,
            pub md_frequency: Vec<f64>,
            pub aem_fnln_enabled: Vec<bool>,
            pub aem_ph_enabled: Vec<bool>,
            pub aem_ge_enabled: Vec<bool>,
            pub aem_db_enabled: Vec<bool>,
            pub aem_loc_enabled: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConversionTagConfigs".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "aem_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagConfigs".to_string()),
                    "md_frequency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagConfigs".to_string()),
                    "aem_fnln_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagConfigs".to_string()),
                    "aem_ph_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagConfigs".to_string()),
                    "aem_ge_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagConfigs".to_string()),
                    "aem_db_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagConfigs".to_string()),
                    "aem_loc_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagConfigs".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConversionTagConfigs".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConversionTagConfigs {
            aem_enabled: std::result::Result::Err("Nullable types not supported in ConversionTagConfigs".to_string())?,
            md_frequency: std::result::Result::Err("Nullable types not supported in ConversionTagConfigs".to_string())?,
            aem_fnln_enabled: std::result::Result::Err("Nullable types not supported in ConversionTagConfigs".to_string())?,
            aem_ph_enabled: std::result::Result::Err("Nullable types not supported in ConversionTagConfigs".to_string())?,
            aem_ge_enabled: std::result::Result::Err("Nullable types not supported in ConversionTagConfigs".to_string())?,
            aem_db_enabled: std::result::Result::Err("Nullable types not supported in ConversionTagConfigs".to_string())?,
            aem_loc_enabled: std::result::Result::Err("Nullable types not supported in ConversionTagConfigs".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConversionTagConfigs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConversionTagConfigs>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConversionTagConfigs>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConversionTagConfigs - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConversionTagConfigs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConversionTagConfigs as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConversionTagConfigs - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConversionTagCreate {
/// Conversion tag name.
    #[serde(rename = "name")]
    pub name: String,

/// Whether Automatic Enhanced Match email is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
    #[serde(rename = "aem_enabled")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aem_enabled: Option<Nullable<bool>>,

/// Metadata ingestion frequency.
    #[serde(rename = "md_frequency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub md_frequency: Option<Nullable<f64>>,

/// Whether Automatic Enhanced Match name is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
    #[serde(rename = "aem_fnln_enabled")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aem_fnln_enabled: Option<Nullable<bool>>,

/// Whether Automatic Enhanced Match phone is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
    #[serde(rename = "aem_ph_enabled")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aem_ph_enabled: Option<Nullable<bool>>,

/// Whether Automatic Enhanced Match gender is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
    #[serde(rename = "aem_ge_enabled")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aem_ge_enabled: Option<Nullable<bool>>,

/// Whether Automatic Enhanced Match birthdate is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
    #[serde(rename = "aem_db_enabled")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aem_db_enabled: Option<Nullable<bool>>,

/// Whether Automatic Enhanced Match location is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
    #[serde(rename = "aem_loc_enabled")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aem_loc_enabled: Option<Nullable<bool>>,

}


impl ConversionTagCreate {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, ) -> ConversionTagCreate {
        ConversionTagCreate {
            name,
            aem_enabled: Some(Nullable::Present(false)),
            md_frequency: Some(Nullable::Present(1)),
            aem_fnln_enabled: Some(Nullable::Present(false)),
            aem_ph_enabled: Some(Nullable::Present(false)),
            aem_ge_enabled: Some(Nullable::Present(false)),
            aem_db_enabled: Some(Nullable::Present(false)),
            aem_loc_enabled: Some(Nullable::Present(false)),
        }
    }
}

/// Converts the ConversionTagCreate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ConversionTagCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            self.aem_enabled.as_ref().map(|aem_enabled| {
                [
                    "aem_enabled".to_string(),
                    aem_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.md_frequency.as_ref().map(|md_frequency| {
                [
                    "md_frequency".to_string(),
                    md_frequency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.aem_fnln_enabled.as_ref().map(|aem_fnln_enabled| {
                [
                    "aem_fnln_enabled".to_string(),
                    aem_fnln_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.aem_ph_enabled.as_ref().map(|aem_ph_enabled| {
                [
                    "aem_ph_enabled".to_string(),
                    aem_ph_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.aem_ge_enabled.as_ref().map(|aem_ge_enabled| {
                [
                    "aem_ge_enabled".to_string(),
                    aem_ge_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.aem_db_enabled.as_ref().map(|aem_db_enabled| {
                [
                    "aem_db_enabled".to_string(),
                    aem_db_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.aem_loc_enabled.as_ref().map(|aem_loc_enabled| {
                [
                    "aem_loc_enabled".to_string(),
                    aem_loc_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConversionTagCreate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConversionTagCreate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub aem_enabled: Vec<bool>,
            pub md_frequency: Vec<f64>,
            pub aem_fnln_enabled: Vec<bool>,
            pub aem_ph_enabled: Vec<bool>,
            pub aem_ge_enabled: Vec<bool>,
            pub aem_db_enabled: Vec<bool>,
            pub aem_loc_enabled: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConversionTagCreate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "aem_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagCreate".to_string()),
                    "md_frequency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagCreate".to_string()),
                    "aem_fnln_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagCreate".to_string()),
                    "aem_ph_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagCreate".to_string()),
                    "aem_ge_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagCreate".to_string()),
                    "aem_db_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagCreate".to_string()),
                    "aem_loc_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagCreate".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConversionTagCreate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConversionTagCreate {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ConversionTagCreate".to_string())?,
            aem_enabled: std::result::Result::Err("Nullable types not supported in ConversionTagCreate".to_string())?,
            md_frequency: std::result::Result::Err("Nullable types not supported in ConversionTagCreate".to_string())?,
            aem_fnln_enabled: std::result::Result::Err("Nullable types not supported in ConversionTagCreate".to_string())?,
            aem_ph_enabled: std::result::Result::Err("Nullable types not supported in ConversionTagCreate".to_string())?,
            aem_ge_enabled: std::result::Result::Err("Nullable types not supported in ConversionTagCreate".to_string())?,
            aem_db_enabled: std::result::Result::Err("Nullable types not supported in ConversionTagCreate".to_string())?,
            aem_loc_enabled: std::result::Result::Err("Nullable types not supported in ConversionTagCreate".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConversionTagCreate> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConversionTagCreate>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConversionTagCreate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConversionTagCreate - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConversionTagCreate> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConversionTagCreate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConversionTagCreate - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConversionTagListResponse {
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::ConversionTagResponse>>,

}


impl ConversionTagListResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ConversionTagListResponse {
        ConversionTagListResponse {
            items: None,
        }
    }
}

/// Converts the ConversionTagListResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ConversionTagListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConversionTagListResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConversionTagListResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::ConversionTagResponse>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConversionTagListResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in ConversionTagListResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConversionTagListResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConversionTagListResponse {
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConversionTagListResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConversionTagListResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConversionTagListResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConversionTagListResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConversionTagListResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConversionTagListResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConversionTagListResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConversionTagResponse {
/// Ad account ID.
    #[serde(rename = "ad_account_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// Tag code snippet.
    #[serde(rename = "code_snippet")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_snippet: Option<String>,

    #[serde(rename = "enhanced_match_status")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enhanced_match_status: Option<Nullable<models::EnhancedMatchStatusType>>,

/// Tag ID.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Time for the last event fired.
    #[serde(rename = "last_fired_time_ms")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_fired_time_ms: Option<Nullable<f64>>,

/// Conversion tag name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

/// Version number.
    #[serde(rename = "version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,

    #[serde(rename = "configs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub configs: Option<models::ConversionTagConfigs>,

}


impl ConversionTagResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ConversionTagResponse {
        ConversionTagResponse {
            ad_account_id: None,
            code_snippet: None,
            enhanced_match_status: None,
            id: None,
            last_fired_time_ms: None,
            name: None,
            status: None,
            version: None,
            configs: None,
        }
    }
}

/// Converts the ConversionTagResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ConversionTagResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.code_snippet.as_ref().map(|code_snippet| {
                [
                    "code_snippet".to_string(),
                    code_snippet.to_string(),
                ].join(",")
            }),

            // Skipping enhanced_match_status in query parameter serialization


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.last_fired_time_ms.as_ref().map(|last_fired_time_ms| {
                [
                    "last_fired_time_ms".to_string(),
                    last_fired_time_ms.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.version.as_ref().map(|version| {
                [
                    "version".to_string(),
                    version.to_string(),
                ].join(",")
            }),

            // Skipping configs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConversionTagResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConversionTagResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_account_id: Vec<String>,
            pub code_snippet: Vec<String>,
            pub enhanced_match_status: Vec<models::EnhancedMatchStatusType>,
            pub id: Vec<String>,
            pub last_fired_time_ms: Vec<f64>,
            pub name: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub version: Vec<String>,
            pub configs: Vec<models::ConversionTagConfigs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConversionTagResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "code_snippet" => intermediate_rep.code_snippet.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "enhanced_match_status" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "last_fired_time_ms" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ConversionTagResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "configs" => intermediate_rep.configs.push(<models::ConversionTagConfigs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConversionTagResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConversionTagResponse {
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            code_snippet: intermediate_rep.code_snippet.into_iter().next(),
            enhanced_match_status: std::result::Result::Err("Nullable types not supported in ConversionTagResponse".to_string())?,
            id: intermediate_rep.id.into_iter().next(),
            last_fired_time_ms: std::result::Result::Err("Nullable types not supported in ConversionTagResponse".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
            configs: intermediate_rep.configs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConversionTagResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConversionTagResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConversionTagResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConversionTagResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConversionTagResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConversionTagResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConversionTagResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// conversion tag type
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ConversionTagType {
    #[serde(rename = "PAGE_LOAD")]
    PageLoad,
    #[serde(rename = "UNKNOWN")]
    Unknown,
    #[serde(rename = "INITIALIZED")]
    Initialized,
    #[serde(rename = "PAGE_VISIT")]
    PageVisit,
    #[serde(rename = "SIGNUP")]
    Signup,
    #[serde(rename = "CHECKOUT")]
    Checkout,
    #[serde(rename = "CUSTOM")]
    Custom,
    #[serde(rename = "VIEW_CATEGORY")]
    ViewCategory,
    #[serde(rename = "SEARCH")]
    Search,
    #[serde(rename = "ADD_TO_CART")]
    AddToCart,
    #[serde(rename = "WATCH_VIDEO")]
    WatchVideo,
    #[serde(rename = "LEAD")]
    Lead,
    #[serde(rename = "APP_INSTALL")]
    AppInstall,
    #[serde(rename = "WEB_SESSION")]
    WebSession,
    #[serde(rename = "EXTERNAL_MEASUREMENT")]
    ExternalMeasurement,
}

impl std::fmt::Display for ConversionTagType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ConversionTagType::PageLoad => write!(f, "PAGE_LOAD"),
            ConversionTagType::Unknown => write!(f, "UNKNOWN"),
            ConversionTagType::Initialized => write!(f, "INITIALIZED"),
            ConversionTagType::PageVisit => write!(f, "PAGE_VISIT"),
            ConversionTagType::Signup => write!(f, "SIGNUP"),
            ConversionTagType::Checkout => write!(f, "CHECKOUT"),
            ConversionTagType::Custom => write!(f, "CUSTOM"),
            ConversionTagType::ViewCategory => write!(f, "VIEW_CATEGORY"),
            ConversionTagType::Search => write!(f, "SEARCH"),
            ConversionTagType::AddToCart => write!(f, "ADD_TO_CART"),
            ConversionTagType::WatchVideo => write!(f, "WATCH_VIDEO"),
            ConversionTagType::Lead => write!(f, "LEAD"),
            ConversionTagType::AppInstall => write!(f, "APP_INSTALL"),
            ConversionTagType::WebSession => write!(f, "WEB_SESSION"),
            ConversionTagType::ExternalMeasurement => write!(f, "EXTERNAL_MEASUREMENT"),
        }
    }
}

impl std::str::FromStr for ConversionTagType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PAGE_LOAD" => std::result::Result::Ok(ConversionTagType::PageLoad),
            "UNKNOWN" => std::result::Result::Ok(ConversionTagType::Unknown),
            "INITIALIZED" => std::result::Result::Ok(ConversionTagType::Initialized),
            "PAGE_VISIT" => std::result::Result::Ok(ConversionTagType::PageVisit),
            "SIGNUP" => std::result::Result::Ok(ConversionTagType::Signup),
            "CHECKOUT" => std::result::Result::Ok(ConversionTagType::Checkout),
            "CUSTOM" => std::result::Result::Ok(ConversionTagType::Custom),
            "VIEW_CATEGORY" => std::result::Result::Ok(ConversionTagType::ViewCategory),
            "SEARCH" => std::result::Result::Ok(ConversionTagType::Search),
            "ADD_TO_CART" => std::result::Result::Ok(ConversionTagType::AddToCart),
            "WATCH_VIDEO" => std::result::Result::Ok(ConversionTagType::WatchVideo),
            "LEAD" => std::result::Result::Ok(ConversionTagType::Lead),
            "APP_INSTALL" => std::result::Result::Ok(ConversionTagType::AppInstall),
            "WEB_SESSION" => std::result::Result::Ok(ConversionTagType::WebSession),
            "EXTERNAL_MEASUREMENT" => std::result::Result::Ok(ConversionTagType::ExternalMeasurement),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Country ID from ISO 3166-1 alpha-2.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum Country {
    #[serde(rename = "AD")]
    Ad,
    #[serde(rename = "AE")]
    Ae,
    #[serde(rename = "AF")]
    Af,
    #[serde(rename = "AG")]
    Ag,
    #[serde(rename = "AI")]
    Ai,
    #[serde(rename = "AL")]
    Al,
    #[serde(rename = "AM")]
    Am,
    #[serde(rename = "AO")]
    Ao,
    #[serde(rename = "AQ")]
    Aq,
    #[serde(rename = "AR")]
    Ar,
    #[serde(rename = "AS")]
    As,
    #[serde(rename = "AT")]
    At,
    #[serde(rename = "AU")]
    Au,
    #[serde(rename = "AW")]
    Aw,
    #[serde(rename = "AX")]
    Ax,
    #[serde(rename = "AZ")]
    Az,
    #[serde(rename = "BA")]
    Ba,
    #[serde(rename = "BB")]
    Bb,
    #[serde(rename = "BD")]
    Bd,
    #[serde(rename = "BE")]
    Be,
    #[serde(rename = "BF")]
    Bf,
    #[serde(rename = "BG")]
    Bg,
    #[serde(rename = "BH")]
    Bh,
    #[serde(rename = "BI")]
    Bi,
    #[serde(rename = "BJ")]
    Bj,
    #[serde(rename = "BL")]
    Bl,
    #[serde(rename = "BM")]
    Bm,
    #[serde(rename = "BN")]
    Bn,
    #[serde(rename = "BO")]
    Bo,
    #[serde(rename = "BQ")]
    Bq,
    #[serde(rename = "BR")]
    Br,
    #[serde(rename = "BS")]
    Bs,
    #[serde(rename = "BT")]
    Bt,
    #[serde(rename = "BV")]
    Bv,
    #[serde(rename = "BW")]
    Bw,
    #[serde(rename = "BY")]
    By,
    #[serde(rename = "BZ")]
    Bz,
    #[serde(rename = "CA")]
    Ca,
    #[serde(rename = "CC")]
    Cc,
    #[serde(rename = "CD")]
    Cd,
    #[serde(rename = "CF")]
    Cf,
    #[serde(rename = "CG")]
    Cg,
    #[serde(rename = "CH")]
    Ch,
    #[serde(rename = "CI")]
    Ci,
    #[serde(rename = "CK")]
    Ck,
    #[serde(rename = "CL")]
    Cl,
    #[serde(rename = "CM")]
    Cm,
    #[serde(rename = "CN")]
    Cn,
    #[serde(rename = "CO")]
    Co,
    #[serde(rename = "CR")]
    Cr,
    #[serde(rename = "CU")]
    Cu,
    #[serde(rename = "CV")]
    Cv,
    #[serde(rename = "CW")]
    Cw,
    #[serde(rename = "CX")]
    Cx,
    #[serde(rename = "CY")]
    Cy,
    #[serde(rename = "CZ")]
    Cz,
    #[serde(rename = "DE")]
    De,
    #[serde(rename = "DJ")]
    Dj,
    #[serde(rename = "DK")]
    Dk,
    #[serde(rename = "DM")]
    Dm,
    #[serde(rename = "DO")]
    Do,
    #[serde(rename = "DZ")]
    Dz,
    #[serde(rename = "EC")]
    Ec,
    #[serde(rename = "EE")]
    Ee,
    #[serde(rename = "EG")]
    Eg,
    #[serde(rename = "EH")]
    Eh,
    #[serde(rename = "ER")]
    Er,
    #[serde(rename = "ES")]
    Es,
    #[serde(rename = "ET")]
    Et,
    #[serde(rename = "FI")]
    Fi,
    #[serde(rename = "FJ")]
    Fj,
    #[serde(rename = "FK")]
    Fk,
    #[serde(rename = "FM")]
    Fm,
    #[serde(rename = "FO")]
    Fo,
    #[serde(rename = "FR")]
    Fr,
    #[serde(rename = "GA")]
    Ga,
    #[serde(rename = "GB")]
    Gb,
    #[serde(rename = "GD")]
    Gd,
    #[serde(rename = "GE")]
    Ge,
    #[serde(rename = "GF")]
    Gf,
    #[serde(rename = "GG")]
    Gg,
    #[serde(rename = "GH")]
    Gh,
    #[serde(rename = "GI")]
    Gi,
    #[serde(rename = "GL")]
    Gl,
    #[serde(rename = "GM")]
    Gm,
    #[serde(rename = "GN")]
    Gn,
    #[serde(rename = "GP")]
    Gp,
    #[serde(rename = "GQ")]
    Gq,
    #[serde(rename = "GR")]
    Gr,
    #[serde(rename = "GS")]
    Gs,
    #[serde(rename = "GT")]
    Gt,
    #[serde(rename = "GU")]
    Gu,
    #[serde(rename = "GW")]
    Gw,
    #[serde(rename = "GY")]
    Gy,
    #[serde(rename = "HK")]
    Hk,
    #[serde(rename = "HM")]
    Hm,
    #[serde(rename = "HN")]
    Hn,
    #[serde(rename = "HR")]
    Hr,
    #[serde(rename = "HT")]
    Ht,
    #[serde(rename = "HU")]
    Hu,
    #[serde(rename = "ID")]
    Id,
    #[serde(rename = "IE")]
    Ie,
    #[serde(rename = "IL")]
    Il,
    #[serde(rename = "IM")]
    Im,
    #[serde(rename = "IN")]
    In,
    #[serde(rename = "IO")]
    Io,
    #[serde(rename = "IQ")]
    Iq,
    #[serde(rename = "IR")]
    Ir,
    #[serde(rename = "IS")]
    Is,
    #[serde(rename = "IT")]
    It,
    #[serde(rename = "JE")]
    Je,
    #[serde(rename = "JM")]
    Jm,
    #[serde(rename = "JO")]
    Jo,
    #[serde(rename = "JP")]
    Jp,
    #[serde(rename = "KE")]
    Ke,
    #[serde(rename = "KG")]
    Kg,
    #[serde(rename = "KH")]
    Kh,
    #[serde(rename = "KI")]
    Ki,
    #[serde(rename = "KM")]
    Km,
    #[serde(rename = "KN")]
    Kn,
    #[serde(rename = "KR")]
    Kr,
    #[serde(rename = "KW")]
    Kw,
    #[serde(rename = "KY")]
    Ky,
    #[serde(rename = "KZ")]
    Kz,
    #[serde(rename = "LA")]
    La,
    #[serde(rename = "LB")]
    Lb,
    #[serde(rename = "LC")]
    Lc,
    #[serde(rename = "LI")]
    Li,
    #[serde(rename = "LK")]
    Lk,
    #[serde(rename = "LR")]
    Lr,
    #[serde(rename = "LS")]
    Ls,
    #[serde(rename = "LT")]
    Lt,
    #[serde(rename = "LU")]
    Lu,
    #[serde(rename = "LV")]
    Lv,
    #[serde(rename = "LY")]
    Ly,
    #[serde(rename = "MA")]
    Ma,
    #[serde(rename = "MC")]
    Mc,
    #[serde(rename = "MD")]
    Md,
    #[serde(rename = "ME")]
    Me,
    #[serde(rename = "MF")]
    Mf,
    #[serde(rename = "MG")]
    Mg,
    #[serde(rename = "MH")]
    Mh,
    #[serde(rename = "MK")]
    Mk,
    #[serde(rename = "ML")]
    Ml,
    #[serde(rename = "MM")]
    Mm,
    #[serde(rename = "MN")]
    Mn,
    #[serde(rename = "MO")]
    Mo,
    #[serde(rename = "MP")]
    Mp,
    #[serde(rename = "MQ")]
    Mq,
    #[serde(rename = "MR")]
    Mr,
    #[serde(rename = "MS")]
    Ms,
    #[serde(rename = "MT")]
    Mt,
    #[serde(rename = "MU")]
    Mu,
    #[serde(rename = "MV")]
    Mv,
    #[serde(rename = "MW")]
    Mw,
    #[serde(rename = "MX")]
    Mx,
    #[serde(rename = "MY")]
    My,
    #[serde(rename = "MZ")]
    Mz,
    #[serde(rename = "NA")]
    Na,
    #[serde(rename = "NC")]
    Nc,
    #[serde(rename = "NE")]
    Ne,
    #[serde(rename = "NF")]
    Nf,
    #[serde(rename = "NG")]
    Ng,
    #[serde(rename = "NI")]
    Ni,
    #[serde(rename = "NL")]
    Nl,
    #[serde(rename = "NO")]
    No,
    #[serde(rename = "NP")]
    Np,
    #[serde(rename = "NR")]
    Nr,
    #[serde(rename = "NU")]
    Nu,
    #[serde(rename = "NZ")]
    Nz,
    #[serde(rename = "OM")]
    Om,
    #[serde(rename = "PA")]
    Pa,
    #[serde(rename = "PE")]
    Pe,
    #[serde(rename = "PF")]
    Pf,
    #[serde(rename = "PG")]
    Pg,
    #[serde(rename = "PH")]
    Ph,
    #[serde(rename = "PK")]
    Pk,
    #[serde(rename = "PL")]
    Pl,
    #[serde(rename = "PM")]
    Pm,
    #[serde(rename = "PN")]
    Pn,
    #[serde(rename = "PR")]
    Pr,
    #[serde(rename = "PS")]
    Ps,
    #[serde(rename = "PT")]
    Pt,
    #[serde(rename = "PW")]
    Pw,
    #[serde(rename = "PY")]
    Py,
    #[serde(rename = "QA")]
    Qa,
    #[serde(rename = "RE")]
    Re,
    #[serde(rename = "RO")]
    Ro,
    #[serde(rename = "RS")]
    Rs,
    #[serde(rename = "RU")]
    Ru,
    #[serde(rename = "RW")]
    Rw,
    #[serde(rename = "SA")]
    Sa,
    #[serde(rename = "SB")]
    Sb,
    #[serde(rename = "SC")]
    Sc,
    #[serde(rename = "SD")]
    Sd,
    #[serde(rename = "SE")]
    Se,
    #[serde(rename = "SG")]
    Sg,
    #[serde(rename = "SH")]
    Sh,
    #[serde(rename = "SI")]
    Si,
    #[serde(rename = "SJ")]
    Sj,
    #[serde(rename = "SK")]
    Sk,
    #[serde(rename = "SL")]
    Sl,
    #[serde(rename = "SM")]
    Sm,
    #[serde(rename = "SN")]
    Sn,
    #[serde(rename = "SO")]
    So,
    #[serde(rename = "SR")]
    Sr,
    #[serde(rename = "SS")]
    Ss,
    #[serde(rename = "ST")]
    St,
    #[serde(rename = "SV")]
    Sv,
    #[serde(rename = "SX")]
    Sx,
    #[serde(rename = "SY")]
    Sy,
    #[serde(rename = "SZ")]
    Sz,
    #[serde(rename = "TC")]
    Tc,
    #[serde(rename = "TD")]
    Td,
    #[serde(rename = "TF")]
    Tf,
    #[serde(rename = "TG")]
    Tg,
    #[serde(rename = "TH")]
    Th,
    #[serde(rename = "TJ")]
    Tj,
    #[serde(rename = "TK")]
    Tk,
    #[serde(rename = "TL")]
    Tl,
    #[serde(rename = "TM")]
    Tm,
    #[serde(rename = "TN")]
    Tn,
    #[serde(rename = "TO")]
    To,
    #[serde(rename = "TR")]
    Tr,
    #[serde(rename = "TT")]
    Tt,
    #[serde(rename = "TV")]
    Tv,
    #[serde(rename = "TW")]
    Tw,
    #[serde(rename = "TZ")]
    Tz,
    #[serde(rename = "UA")]
    Ua,
    #[serde(rename = "UG")]
    Ug,
    #[serde(rename = "UM")]
    Um,
    #[serde(rename = "US")]
    Us,
    #[serde(rename = "UY")]
    Uy,
    #[serde(rename = "UZ")]
    Uz,
    #[serde(rename = "VA")]
    Va,
    #[serde(rename = "VC")]
    Vc,
    #[serde(rename = "VE")]
    Ve,
    #[serde(rename = "VG")]
    Vg,
    #[serde(rename = "VI")]
    Vi,
    #[serde(rename = "VN")]
    Vn,
    #[serde(rename = "VU")]
    Vu,
    #[serde(rename = "WF")]
    Wf,
    #[serde(rename = "WS")]
    Ws,
    #[serde(rename = "YE")]
    Ye,
    #[serde(rename = "YT")]
    Yt,
    #[serde(rename = "ZA")]
    Za,
    #[serde(rename = "ZM")]
    Zm,
    #[serde(rename = "ZW")]
    Zw,
}

impl std::fmt::Display for Country {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Country::Ad => write!(f, "AD"),
            Country::Ae => write!(f, "AE"),
            Country::Af => write!(f, "AF"),
            Country::Ag => write!(f, "AG"),
            Country::Ai => write!(f, "AI"),
            Country::Al => write!(f, "AL"),
            Country::Am => write!(f, "AM"),
            Country::Ao => write!(f, "AO"),
            Country::Aq => write!(f, "AQ"),
            Country::Ar => write!(f, "AR"),
            Country::As => write!(f, "AS"),
            Country::At => write!(f, "AT"),
            Country::Au => write!(f, "AU"),
            Country::Aw => write!(f, "AW"),
            Country::Ax => write!(f, "AX"),
            Country::Az => write!(f, "AZ"),
            Country::Ba => write!(f, "BA"),
            Country::Bb => write!(f, "BB"),
            Country::Bd => write!(f, "BD"),
            Country::Be => write!(f, "BE"),
            Country::Bf => write!(f, "BF"),
            Country::Bg => write!(f, "BG"),
            Country::Bh => write!(f, "BH"),
            Country::Bi => write!(f, "BI"),
            Country::Bj => write!(f, "BJ"),
            Country::Bl => write!(f, "BL"),
            Country::Bm => write!(f, "BM"),
            Country::Bn => write!(f, "BN"),
            Country::Bo => write!(f, "BO"),
            Country::Bq => write!(f, "BQ"),
            Country::Br => write!(f, "BR"),
            Country::Bs => write!(f, "BS"),
            Country::Bt => write!(f, "BT"),
            Country::Bv => write!(f, "BV"),
            Country::Bw => write!(f, "BW"),
            Country::By => write!(f, "BY"),
            Country::Bz => write!(f, "BZ"),
            Country::Ca => write!(f, "CA"),
            Country::Cc => write!(f, "CC"),
            Country::Cd => write!(f, "CD"),
            Country::Cf => write!(f, "CF"),
            Country::Cg => write!(f, "CG"),
            Country::Ch => write!(f, "CH"),
            Country::Ci => write!(f, "CI"),
            Country::Ck => write!(f, "CK"),
            Country::Cl => write!(f, "CL"),
            Country::Cm => write!(f, "CM"),
            Country::Cn => write!(f, "CN"),
            Country::Co => write!(f, "CO"),
            Country::Cr => write!(f, "CR"),
            Country::Cu => write!(f, "CU"),
            Country::Cv => write!(f, "CV"),
            Country::Cw => write!(f, "CW"),
            Country::Cx => write!(f, "CX"),
            Country::Cy => write!(f, "CY"),
            Country::Cz => write!(f, "CZ"),
            Country::De => write!(f, "DE"),
            Country::Dj => write!(f, "DJ"),
            Country::Dk => write!(f, "DK"),
            Country::Dm => write!(f, "DM"),
            Country::Do => write!(f, "DO"),
            Country::Dz => write!(f, "DZ"),
            Country::Ec => write!(f, "EC"),
            Country::Ee => write!(f, "EE"),
            Country::Eg => write!(f, "EG"),
            Country::Eh => write!(f, "EH"),
            Country::Er => write!(f, "ER"),
            Country::Es => write!(f, "ES"),
            Country::Et => write!(f, "ET"),
            Country::Fi => write!(f, "FI"),
            Country::Fj => write!(f, "FJ"),
            Country::Fk => write!(f, "FK"),
            Country::Fm => write!(f, "FM"),
            Country::Fo => write!(f, "FO"),
            Country::Fr => write!(f, "FR"),
            Country::Ga => write!(f, "GA"),
            Country::Gb => write!(f, "GB"),
            Country::Gd => write!(f, "GD"),
            Country::Ge => write!(f, "GE"),
            Country::Gf => write!(f, "GF"),
            Country::Gg => write!(f, "GG"),
            Country::Gh => write!(f, "GH"),
            Country::Gi => write!(f, "GI"),
            Country::Gl => write!(f, "GL"),
            Country::Gm => write!(f, "GM"),
            Country::Gn => write!(f, "GN"),
            Country::Gp => write!(f, "GP"),
            Country::Gq => write!(f, "GQ"),
            Country::Gr => write!(f, "GR"),
            Country::Gs => write!(f, "GS"),
            Country::Gt => write!(f, "GT"),
            Country::Gu => write!(f, "GU"),
            Country::Gw => write!(f, "GW"),
            Country::Gy => write!(f, "GY"),
            Country::Hk => write!(f, "HK"),
            Country::Hm => write!(f, "HM"),
            Country::Hn => write!(f, "HN"),
            Country::Hr => write!(f, "HR"),
            Country::Ht => write!(f, "HT"),
            Country::Hu => write!(f, "HU"),
            Country::Id => write!(f, "ID"),
            Country::Ie => write!(f, "IE"),
            Country::Il => write!(f, "IL"),
            Country::Im => write!(f, "IM"),
            Country::In => write!(f, "IN"),
            Country::Io => write!(f, "IO"),
            Country::Iq => write!(f, "IQ"),
            Country::Ir => write!(f, "IR"),
            Country::Is => write!(f, "IS"),
            Country::It => write!(f, "IT"),
            Country::Je => write!(f, "JE"),
            Country::Jm => write!(f, "JM"),
            Country::Jo => write!(f, "JO"),
            Country::Jp => write!(f, "JP"),
            Country::Ke => write!(f, "KE"),
            Country::Kg => write!(f, "KG"),
            Country::Kh => write!(f, "KH"),
            Country::Ki => write!(f, "KI"),
            Country::Km => write!(f, "KM"),
            Country::Kn => write!(f, "KN"),
            Country::Kr => write!(f, "KR"),
            Country::Kw => write!(f, "KW"),
            Country::Ky => write!(f, "KY"),
            Country::Kz => write!(f, "KZ"),
            Country::La => write!(f, "LA"),
            Country::Lb => write!(f, "LB"),
            Country::Lc => write!(f, "LC"),
            Country::Li => write!(f, "LI"),
            Country::Lk => write!(f, "LK"),
            Country::Lr => write!(f, "LR"),
            Country::Ls => write!(f, "LS"),
            Country::Lt => write!(f, "LT"),
            Country::Lu => write!(f, "LU"),
            Country::Lv => write!(f, "LV"),
            Country::Ly => write!(f, "LY"),
            Country::Ma => write!(f, "MA"),
            Country::Mc => write!(f, "MC"),
            Country::Md => write!(f, "MD"),
            Country::Me => write!(f, "ME"),
            Country::Mf => write!(f, "MF"),
            Country::Mg => write!(f, "MG"),
            Country::Mh => write!(f, "MH"),
            Country::Mk => write!(f, "MK"),
            Country::Ml => write!(f, "ML"),
            Country::Mm => write!(f, "MM"),
            Country::Mn => write!(f, "MN"),
            Country::Mo => write!(f, "MO"),
            Country::Mp => write!(f, "MP"),
            Country::Mq => write!(f, "MQ"),
            Country::Mr => write!(f, "MR"),
            Country::Ms => write!(f, "MS"),
            Country::Mt => write!(f, "MT"),
            Country::Mu => write!(f, "MU"),
            Country::Mv => write!(f, "MV"),
            Country::Mw => write!(f, "MW"),
            Country::Mx => write!(f, "MX"),
            Country::My => write!(f, "MY"),
            Country::Mz => write!(f, "MZ"),
            Country::Na => write!(f, "NA"),
            Country::Nc => write!(f, "NC"),
            Country::Ne => write!(f, "NE"),
            Country::Nf => write!(f, "NF"),
            Country::Ng => write!(f, "NG"),
            Country::Ni => write!(f, "NI"),
            Country::Nl => write!(f, "NL"),
            Country::No => write!(f, "NO"),
            Country::Np => write!(f, "NP"),
            Country::Nr => write!(f, "NR"),
            Country::Nu => write!(f, "NU"),
            Country::Nz => write!(f, "NZ"),
            Country::Om => write!(f, "OM"),
            Country::Pa => write!(f, "PA"),
            Country::Pe => write!(f, "PE"),
            Country::Pf => write!(f, "PF"),
            Country::Pg => write!(f, "PG"),
            Country::Ph => write!(f, "PH"),
            Country::Pk => write!(f, "PK"),
            Country::Pl => write!(f, "PL"),
            Country::Pm => write!(f, "PM"),
            Country::Pn => write!(f, "PN"),
            Country::Pr => write!(f, "PR"),
            Country::Ps => write!(f, "PS"),
            Country::Pt => write!(f, "PT"),
            Country::Pw => write!(f, "PW"),
            Country::Py => write!(f, "PY"),
            Country::Qa => write!(f, "QA"),
            Country::Re => write!(f, "RE"),
            Country::Ro => write!(f, "RO"),
            Country::Rs => write!(f, "RS"),
            Country::Ru => write!(f, "RU"),
            Country::Rw => write!(f, "RW"),
            Country::Sa => write!(f, "SA"),
            Country::Sb => write!(f, "SB"),
            Country::Sc => write!(f, "SC"),
            Country::Sd => write!(f, "SD"),
            Country::Se => write!(f, "SE"),
            Country::Sg => write!(f, "SG"),
            Country::Sh => write!(f, "SH"),
            Country::Si => write!(f, "SI"),
            Country::Sj => write!(f, "SJ"),
            Country::Sk => write!(f, "SK"),
            Country::Sl => write!(f, "SL"),
            Country::Sm => write!(f, "SM"),
            Country::Sn => write!(f, "SN"),
            Country::So => write!(f, "SO"),
            Country::Sr => write!(f, "SR"),
            Country::Ss => write!(f, "SS"),
            Country::St => write!(f, "ST"),
            Country::Sv => write!(f, "SV"),
            Country::Sx => write!(f, "SX"),
            Country::Sy => write!(f, "SY"),
            Country::Sz => write!(f, "SZ"),
            Country::Tc => write!(f, "TC"),
            Country::Td => write!(f, "TD"),
            Country::Tf => write!(f, "TF"),
            Country::Tg => write!(f, "TG"),
            Country::Th => write!(f, "TH"),
            Country::Tj => write!(f, "TJ"),
            Country::Tk => write!(f, "TK"),
            Country::Tl => write!(f, "TL"),
            Country::Tm => write!(f, "TM"),
            Country::Tn => write!(f, "TN"),
            Country::To => write!(f, "TO"),
            Country::Tr => write!(f, "TR"),
            Country::Tt => write!(f, "TT"),
            Country::Tv => write!(f, "TV"),
            Country::Tw => write!(f, "TW"),
            Country::Tz => write!(f, "TZ"),
            Country::Ua => write!(f, "UA"),
            Country::Ug => write!(f, "UG"),
            Country::Um => write!(f, "UM"),
            Country::Us => write!(f, "US"),
            Country::Uy => write!(f, "UY"),
            Country::Uz => write!(f, "UZ"),
            Country::Va => write!(f, "VA"),
            Country::Vc => write!(f, "VC"),
            Country::Ve => write!(f, "VE"),
            Country::Vg => write!(f, "VG"),
            Country::Vi => write!(f, "VI"),
            Country::Vn => write!(f, "VN"),
            Country::Vu => write!(f, "VU"),
            Country::Wf => write!(f, "WF"),
            Country::Ws => write!(f, "WS"),
            Country::Ye => write!(f, "YE"),
            Country::Yt => write!(f, "YT"),
            Country::Za => write!(f, "ZA"),
            Country::Zm => write!(f, "ZM"),
            Country::Zw => write!(f, "ZW"),
        }
    }
}

impl std::str::FromStr for Country {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AD" => std::result::Result::Ok(Country::Ad),
            "AE" => std::result::Result::Ok(Country::Ae),
            "AF" => std::result::Result::Ok(Country::Af),
            "AG" => std::result::Result::Ok(Country::Ag),
            "AI" => std::result::Result::Ok(Country::Ai),
            "AL" => std::result::Result::Ok(Country::Al),
            "AM" => std::result::Result::Ok(Country::Am),
            "AO" => std::result::Result::Ok(Country::Ao),
            "AQ" => std::result::Result::Ok(Country::Aq),
            "AR" => std::result::Result::Ok(Country::Ar),
            "AS" => std::result::Result::Ok(Country::As),
            "AT" => std::result::Result::Ok(Country::At),
            "AU" => std::result::Result::Ok(Country::Au),
            "AW" => std::result::Result::Ok(Country::Aw),
            "AX" => std::result::Result::Ok(Country::Ax),
            "AZ" => std::result::Result::Ok(Country::Az),
            "BA" => std::result::Result::Ok(Country::Ba),
            "BB" => std::result::Result::Ok(Country::Bb),
            "BD" => std::result::Result::Ok(Country::Bd),
            "BE" => std::result::Result::Ok(Country::Be),
            "BF" => std::result::Result::Ok(Country::Bf),
            "BG" => std::result::Result::Ok(Country::Bg),
            "BH" => std::result::Result::Ok(Country::Bh),
            "BI" => std::result::Result::Ok(Country::Bi),
            "BJ" => std::result::Result::Ok(Country::Bj),
            "BL" => std::result::Result::Ok(Country::Bl),
            "BM" => std::result::Result::Ok(Country::Bm),
            "BN" => std::result::Result::Ok(Country::Bn),
            "BO" => std::result::Result::Ok(Country::Bo),
            "BQ" => std::result::Result::Ok(Country::Bq),
            "BR" => std::result::Result::Ok(Country::Br),
            "BS" => std::result::Result::Ok(Country::Bs),
            "BT" => std::result::Result::Ok(Country::Bt),
            "BV" => std::result::Result::Ok(Country::Bv),
            "BW" => std::result::Result::Ok(Country::Bw),
            "BY" => std::result::Result::Ok(Country::By),
            "BZ" => std::result::Result::Ok(Country::Bz),
            "CA" => std::result::Result::Ok(Country::Ca),
            "CC" => std::result::Result::Ok(Country::Cc),
            "CD" => std::result::Result::Ok(Country::Cd),
            "CF" => std::result::Result::Ok(Country::Cf),
            "CG" => std::result::Result::Ok(Country::Cg),
            "CH" => std::result::Result::Ok(Country::Ch),
            "CI" => std::result::Result::Ok(Country::Ci),
            "CK" => std::result::Result::Ok(Country::Ck),
            "CL" => std::result::Result::Ok(Country::Cl),
            "CM" => std::result::Result::Ok(Country::Cm),
            "CN" => std::result::Result::Ok(Country::Cn),
            "CO" => std::result::Result::Ok(Country::Co),
            "CR" => std::result::Result::Ok(Country::Cr),
            "CU" => std::result::Result::Ok(Country::Cu),
            "CV" => std::result::Result::Ok(Country::Cv),
            "CW" => std::result::Result::Ok(Country::Cw),
            "CX" => std::result::Result::Ok(Country::Cx),
            "CY" => std::result::Result::Ok(Country::Cy),
            "CZ" => std::result::Result::Ok(Country::Cz),
            "DE" => std::result::Result::Ok(Country::De),
            "DJ" => std::result::Result::Ok(Country::Dj),
            "DK" => std::result::Result::Ok(Country::Dk),
            "DM" => std::result::Result::Ok(Country::Dm),
            "DO" => std::result::Result::Ok(Country::Do),
            "DZ" => std::result::Result::Ok(Country::Dz),
            "EC" => std::result::Result::Ok(Country::Ec),
            "EE" => std::result::Result::Ok(Country::Ee),
            "EG" => std::result::Result::Ok(Country::Eg),
            "EH" => std::result::Result::Ok(Country::Eh),
            "ER" => std::result::Result::Ok(Country::Er),
            "ES" => std::result::Result::Ok(Country::Es),
            "ET" => std::result::Result::Ok(Country::Et),
            "FI" => std::result::Result::Ok(Country::Fi),
            "FJ" => std::result::Result::Ok(Country::Fj),
            "FK" => std::result::Result::Ok(Country::Fk),
            "FM" => std::result::Result::Ok(Country::Fm),
            "FO" => std::result::Result::Ok(Country::Fo),
            "FR" => std::result::Result::Ok(Country::Fr),
            "GA" => std::result::Result::Ok(Country::Ga),
            "GB" => std::result::Result::Ok(Country::Gb),
            "GD" => std::result::Result::Ok(Country::Gd),
            "GE" => std::result::Result::Ok(Country::Ge),
            "GF" => std::result::Result::Ok(Country::Gf),
            "GG" => std::result::Result::Ok(Country::Gg),
            "GH" => std::result::Result::Ok(Country::Gh),
            "GI" => std::result::Result::Ok(Country::Gi),
            "GL" => std::result::Result::Ok(Country::Gl),
            "GM" => std::result::Result::Ok(Country::Gm),
            "GN" => std::result::Result::Ok(Country::Gn),
            "GP" => std::result::Result::Ok(Country::Gp),
            "GQ" => std::result::Result::Ok(Country::Gq),
            "GR" => std::result::Result::Ok(Country::Gr),
            "GS" => std::result::Result::Ok(Country::Gs),
            "GT" => std::result::Result::Ok(Country::Gt),
            "GU" => std::result::Result::Ok(Country::Gu),
            "GW" => std::result::Result::Ok(Country::Gw),
            "GY" => std::result::Result::Ok(Country::Gy),
            "HK" => std::result::Result::Ok(Country::Hk),
            "HM" => std::result::Result::Ok(Country::Hm),
            "HN" => std::result::Result::Ok(Country::Hn),
            "HR" => std::result::Result::Ok(Country::Hr),
            "HT" => std::result::Result::Ok(Country::Ht),
            "HU" => std::result::Result::Ok(Country::Hu),
            "ID" => std::result::Result::Ok(Country::Id),
            "IE" => std::result::Result::Ok(Country::Ie),
            "IL" => std::result::Result::Ok(Country::Il),
            "IM" => std::result::Result::Ok(Country::Im),
            "IN" => std::result::Result::Ok(Country::In),
            "IO" => std::result::Result::Ok(Country::Io),
            "IQ" => std::result::Result::Ok(Country::Iq),
            "IR" => std::result::Result::Ok(Country::Ir),
            "IS" => std::result::Result::Ok(Country::Is),
            "IT" => std::result::Result::Ok(Country::It),
            "JE" => std::result::Result::Ok(Country::Je),
            "JM" => std::result::Result::Ok(Country::Jm),
            "JO" => std::result::Result::Ok(Country::Jo),
            "JP" => std::result::Result::Ok(Country::Jp),
            "KE" => std::result::Result::Ok(Country::Ke),
            "KG" => std::result::Result::Ok(Country::Kg),
            "KH" => std::result::Result::Ok(Country::Kh),
            "KI" => std::result::Result::Ok(Country::Ki),
            "KM" => std::result::Result::Ok(Country::Km),
            "KN" => std::result::Result::Ok(Country::Kn),
            "KR" => std::result::Result::Ok(Country::Kr),
            "KW" => std::result::Result::Ok(Country::Kw),
            "KY" => std::result::Result::Ok(Country::Ky),
            "KZ" => std::result::Result::Ok(Country::Kz),
            "LA" => std::result::Result::Ok(Country::La),
            "LB" => std::result::Result::Ok(Country::Lb),
            "LC" => std::result::Result::Ok(Country::Lc),
            "LI" => std::result::Result::Ok(Country::Li),
            "LK" => std::result::Result::Ok(Country::Lk),
            "LR" => std::result::Result::Ok(Country::Lr),
            "LS" => std::result::Result::Ok(Country::Ls),
            "LT" => std::result::Result::Ok(Country::Lt),
            "LU" => std::result::Result::Ok(Country::Lu),
            "LV" => std::result::Result::Ok(Country::Lv),
            "LY" => std::result::Result::Ok(Country::Ly),
            "MA" => std::result::Result::Ok(Country::Ma),
            "MC" => std::result::Result::Ok(Country::Mc),
            "MD" => std::result::Result::Ok(Country::Md),
            "ME" => std::result::Result::Ok(Country::Me),
            "MF" => std::result::Result::Ok(Country::Mf),
            "MG" => std::result::Result::Ok(Country::Mg),
            "MH" => std::result::Result::Ok(Country::Mh),
            "MK" => std::result::Result::Ok(Country::Mk),
            "ML" => std::result::Result::Ok(Country::Ml),
            "MM" => std::result::Result::Ok(Country::Mm),
            "MN" => std::result::Result::Ok(Country::Mn),
            "MO" => std::result::Result::Ok(Country::Mo),
            "MP" => std::result::Result::Ok(Country::Mp),
            "MQ" => std::result::Result::Ok(Country::Mq),
            "MR" => std::result::Result::Ok(Country::Mr),
            "MS" => std::result::Result::Ok(Country::Ms),
            "MT" => std::result::Result::Ok(Country::Mt),
            "MU" => std::result::Result::Ok(Country::Mu),
            "MV" => std::result::Result::Ok(Country::Mv),
            "MW" => std::result::Result::Ok(Country::Mw),
            "MX" => std::result::Result::Ok(Country::Mx),
            "MY" => std::result::Result::Ok(Country::My),
            "MZ" => std::result::Result::Ok(Country::Mz),
            "NA" => std::result::Result::Ok(Country::Na),
            "NC" => std::result::Result::Ok(Country::Nc),
            "NE" => std::result::Result::Ok(Country::Ne),
            "NF" => std::result::Result::Ok(Country::Nf),
            "NG" => std::result::Result::Ok(Country::Ng),
            "NI" => std::result::Result::Ok(Country::Ni),
            "NL" => std::result::Result::Ok(Country::Nl),
            "NO" => std::result::Result::Ok(Country::No),
            "NP" => std::result::Result::Ok(Country::Np),
            "NR" => std::result::Result::Ok(Country::Nr),
            "NU" => std::result::Result::Ok(Country::Nu),
            "NZ" => std::result::Result::Ok(Country::Nz),
            "OM" => std::result::Result::Ok(Country::Om),
            "PA" => std::result::Result::Ok(Country::Pa),
            "PE" => std::result::Result::Ok(Country::Pe),
            "PF" => std::result::Result::Ok(Country::Pf),
            "PG" => std::result::Result::Ok(Country::Pg),
            "PH" => std::result::Result::Ok(Country::Ph),
            "PK" => std::result::Result::Ok(Country::Pk),
            "PL" => std::result::Result::Ok(Country::Pl),
            "PM" => std::result::Result::Ok(Country::Pm),
            "PN" => std::result::Result::Ok(Country::Pn),
            "PR" => std::result::Result::Ok(Country::Pr),
            "PS" => std::result::Result::Ok(Country::Ps),
            "PT" => std::result::Result::Ok(Country::Pt),
            "PW" => std::result::Result::Ok(Country::Pw),
            "PY" => std::result::Result::Ok(Country::Py),
            "QA" => std::result::Result::Ok(Country::Qa),
            "RE" => std::result::Result::Ok(Country::Re),
            "RO" => std::result::Result::Ok(Country::Ro),
            "RS" => std::result::Result::Ok(Country::Rs),
            "RU" => std::result::Result::Ok(Country::Ru),
            "RW" => std::result::Result::Ok(Country::Rw),
            "SA" => std::result::Result::Ok(Country::Sa),
            "SB" => std::result::Result::Ok(Country::Sb),
            "SC" => std::result::Result::Ok(Country::Sc),
            "SD" => std::result::Result::Ok(Country::Sd),
            "SE" => std::result::Result::Ok(Country::Se),
            "SG" => std::result::Result::Ok(Country::Sg),
            "SH" => std::result::Result::Ok(Country::Sh),
            "SI" => std::result::Result::Ok(Country::Si),
            "SJ" => std::result::Result::Ok(Country::Sj),
            "SK" => std::result::Result::Ok(Country::Sk),
            "SL" => std::result::Result::Ok(Country::Sl),
            "SM" => std::result::Result::Ok(Country::Sm),
            "SN" => std::result::Result::Ok(Country::Sn),
            "SO" => std::result::Result::Ok(Country::So),
            "SR" => std::result::Result::Ok(Country::Sr),
            "SS" => std::result::Result::Ok(Country::Ss),
            "ST" => std::result::Result::Ok(Country::St),
            "SV" => std::result::Result::Ok(Country::Sv),
            "SX" => std::result::Result::Ok(Country::Sx),
            "SY" => std::result::Result::Ok(Country::Sy),
            "SZ" => std::result::Result::Ok(Country::Sz),
            "TC" => std::result::Result::Ok(Country::Tc),
            "TD" => std::result::Result::Ok(Country::Td),
            "TF" => std::result::Result::Ok(Country::Tf),
            "TG" => std::result::Result::Ok(Country::Tg),
            "TH" => std::result::Result::Ok(Country::Th),
            "TJ" => std::result::Result::Ok(Country::Tj),
            "TK" => std::result::Result::Ok(Country::Tk),
            "TL" => std::result::Result::Ok(Country::Tl),
            "TM" => std::result::Result::Ok(Country::Tm),
            "TN" => std::result::Result::Ok(Country::Tn),
            "TO" => std::result::Result::Ok(Country::To),
            "TR" => std::result::Result::Ok(Country::Tr),
            "TT" => std::result::Result::Ok(Country::Tt),
            "TV" => std::result::Result::Ok(Country::Tv),
            "TW" => std::result::Result::Ok(Country::Tw),
            "TZ" => std::result::Result::Ok(Country::Tz),
            "UA" => std::result::Result::Ok(Country::Ua),
            "UG" => std::result::Result::Ok(Country::Ug),
            "UM" => std::result::Result::Ok(Country::Um),
            "US" => std::result::Result::Ok(Country::Us),
            "UY" => std::result::Result::Ok(Country::Uy),
            "UZ" => std::result::Result::Ok(Country::Uz),
            "VA" => std::result::Result::Ok(Country::Va),
            "VC" => std::result::Result::Ok(Country::Vc),
            "VE" => std::result::Result::Ok(Country::Ve),
            "VG" => std::result::Result::Ok(Country::Vg),
            "VI" => std::result::Result::Ok(Country::Vi),
            "VN" => std::result::Result::Ok(Country::Vn),
            "VU" => std::result::Result::Ok(Country::Vu),
            "WF" => std::result::Result::Ok(Country::Wf),
            "WS" => std::result::Result::Ok(Country::Ws),
            "YE" => std::result::Result::Ok(Country::Ye),
            "YT" => std::result::Result::Ok(Country::Yt),
            "ZA" => std::result::Result::Ok(Country::Za),
            "ZM" => std::result::Result::Ok(Country::Zm),
            "ZW" => std::result::Result::Ok(Country::Zw),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CountryFilter {
    #[serde(rename = "COUNTRY")]
    pub country: models::CatalogsProductGroupMultipleCountriesCriteria,

}


impl CountryFilter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(country: models::CatalogsProductGroupMultipleCountriesCriteria, ) -> CountryFilter {
        CountryFilter {
            country,
        }
    }
}

/// Converts the CountryFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CountryFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping COUNTRY in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CountryFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CountryFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub country: Vec<models::CatalogsProductGroupMultipleCountriesCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CountryFilter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "COUNTRY" => intermediate_rep.country.push(<models::CatalogsProductGroupMultipleCountriesCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CountryFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CountryFilter {
            country: intermediate_rep.country.into_iter().next().ok_or_else(|| "COUNTRY missing in CountryFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CountryFilter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CountryFilter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CountryFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CountryFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CountryFilter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CountryFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CountryFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateMmmReportRequest {
/// Name of the Marketing Mix Modeling (MMM) report
    #[serde(rename = "report_name")]
    pub report_name: String,

/// Metric report start date (UTC). Format: YYYY-MM-DD
    #[serde(rename = "start_date")]
    #[validate(
           regex = "RE_CREATEMMMREPORTREQUEST_START_DATE",
        )]
    pub start_date: String,

/// Metric report end date (UTC). Format: YYYY-MM-DD
    #[serde(rename = "end_date")]
    #[validate(
           regex = "RE_CREATEMMMREPORTREQUEST_END_DATE",
        )]
    pub end_date: String,

/// DAY - metrics are broken down daily.<br> WEEK - metrics are broken down weekly.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "granularity")]
    pub granularity: String,

/// Level of the report
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "level")]
    pub level: String,

/// List of targeting types
    #[serde(rename = "targeting_types")]
    #[validate(
            length(min = 1, max = 5),
        )]
    pub targeting_types: Vec<models::MmmReportingTargetingType>,

/// Metric and entity columns
    #[serde(rename = "columns")]
    pub columns: Vec<models::MmmReportingColumn>,

/// A List of countries for filtering
    #[serde(rename = "countries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub countries: Option<Vec<models::TargetingAdvertiserCountry>>,

}

lazy_static::lazy_static! {
    static ref RE_CREATEMMMREPORTREQUEST_START_DATE: regex::Regex = regex::Regex::new(r"^(\\d{4})-(\\d{2})-(\\d{2})$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_CREATEMMMREPORTREQUEST_END_DATE: regex::Regex = regex::Regex::new(r"^(\\d{4})-(\\d{2})-(\\d{2})$").unwrap();
}

impl CreateMmmReportRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(report_name: String, start_date: String, end_date: String, granularity: String, level: String, targeting_types: Vec<models::MmmReportingTargetingType>, columns: Vec<models::MmmReportingColumn>, ) -> CreateMmmReportRequest {
        CreateMmmReportRequest {
            report_name,
            start_date,
            end_date,
            granularity,
            level,
            targeting_types,
            columns,
            countries: None,
        }
    }
}

/// Converts the CreateMmmReportRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateMmmReportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("report_name".to_string()),
            Some(self.report_name.to_string()),


            Some("start_date".to_string()),
            Some(self.start_date.to_string()),


            Some("end_date".to_string()),
            Some(self.end_date.to_string()),


            Some("granularity".to_string()),
            Some(self.granularity.to_string()),


            Some("level".to_string()),
            Some(self.level.to_string()),

            // Skipping targeting_types in query parameter serialization

            // Skipping columns in query parameter serialization

            // Skipping countries in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateMmmReportRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateMmmReportRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub report_name: Vec<String>,
            pub start_date: Vec<String>,
            pub end_date: Vec<String>,
            pub granularity: Vec<String>,
            pub level: Vec<String>,
            pub targeting_types: Vec<Vec<models::MmmReportingTargetingType>>,
            pub columns: Vec<Vec<models::MmmReportingColumn>>,
            pub countries: Vec<Vec<models::TargetingAdvertiserCountry>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateMmmReportRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "report_name" => intermediate_rep.report_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "start_date" => intermediate_rep.start_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end_date" => intermediate_rep.end_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "granularity" => intermediate_rep.granularity.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "level" => intermediate_rep.level.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "targeting_types" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateMmmReportRequest".to_string()),
                    "columns" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateMmmReportRequest".to_string()),
                    "countries" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateMmmReportRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateMmmReportRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateMmmReportRequest {
            report_name: intermediate_rep.report_name.into_iter().next().ok_or_else(|| "report_name missing in CreateMmmReportRequest".to_string())?,
            start_date: intermediate_rep.start_date.into_iter().next().ok_or_else(|| "start_date missing in CreateMmmReportRequest".to_string())?,
            end_date: intermediate_rep.end_date.into_iter().next().ok_or_else(|| "end_date missing in CreateMmmReportRequest".to_string())?,
            granularity: intermediate_rep.granularity.into_iter().next().ok_or_else(|| "granularity missing in CreateMmmReportRequest".to_string())?,
            level: intermediate_rep.level.into_iter().next().ok_or_else(|| "level missing in CreateMmmReportRequest".to_string())?,
            targeting_types: intermediate_rep.targeting_types.into_iter().next().ok_or_else(|| "targeting_types missing in CreateMmmReportRequest".to_string())?,
            columns: intermediate_rep.columns.into_iter().next().ok_or_else(|| "columns missing in CreateMmmReportRequest".to_string())?,
            countries: intermediate_rep.countries.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateMmmReportRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateMmmReportRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateMmmReportRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateMmmReportRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateMmmReportRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateMmmReportRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateMmmReportRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateMmmReportResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<f64>,

    #[serde(rename = "data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<models::CreateMmmReportResponseData>,

}


impl CreateMmmReportResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateMmmReportResponse {
        CreateMmmReportResponse {
            code: None,
            data: None,
        }
    }
}

/// Converts the CreateMmmReportResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateMmmReportResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateMmmReportResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateMmmReportResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<f64>,
            pub data: Vec<models::CreateMmmReportResponseData>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateMmmReportResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::CreateMmmReportResponseData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateMmmReportResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateMmmReportResponse {
            code: intermediate_rep.code.into_iter().next(),
            data: intermediate_rep.data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateMmmReportResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateMmmReportResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateMmmReportResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateMmmReportResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateMmmReportResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateMmmReportResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateMmmReportResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateMmmReportResponseData {
    #[serde(rename = "report_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub report_status: Option<models::BulkReportingJobStatus>,

    #[serde(rename = "token")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub token: Option<String>,

    #[serde(rename = "message")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<Nullable<String>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

}


impl CreateMmmReportResponseData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateMmmReportResponseData {
        CreateMmmReportResponseData {
            report_status: None,
            token: None,
            message: None,
            status: None,
        }
    }
}

/// Converts the CreateMmmReportResponseData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateMmmReportResponseData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping report_status in query parameter serialization


            self.token.as_ref().map(|token| {
                [
                    "token".to_string(),
                    token.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateMmmReportResponseData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateMmmReportResponseData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub report_status: Vec<models::BulkReportingJobStatus>,
            pub token: Vec<String>,
            pub message: Vec<String>,
            pub status: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateMmmReportResponseData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "report_status" => intermediate_rep.report_status.push(<models::BulkReportingJobStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "token" => intermediate_rep.token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "message" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateMmmReportResponseData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateMmmReportResponseData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateMmmReportResponseData {
            report_status: intermediate_rep.report_status.into_iter().next(),
            token: intermediate_rep.token.into_iter().next(),
            message: std::result::Result::Err("Nullable types not supported in CreateMmmReportResponseData".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateMmmReportResponseData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateMmmReportResponseData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateMmmReportResponseData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateMmmReportResponseData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateMmmReportResponseData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateMmmReportResponseData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateMmmReportResponseData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Ad creative type enum. For update, only draft ads may update creative type. </p><strong>Note:</strong> SHOP_THE_PIN has been deprecated. Please use COLLECTION instead.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CreativeType {
    #[serde(rename = "REGULAR")]
    Regular,
    #[serde(rename = "VIDEO")]
    Video,
    #[serde(rename = "SHOPPING")]
    Shopping,
    #[serde(rename = "CAROUSEL")]
    Carousel,
    #[serde(rename = "MAX_VIDEO")]
    MaxVideo,
    #[serde(rename = "SHOP_THE_PIN")]
    ShopThePin,
    #[serde(rename = "COLLECTION")]
    Collection,
    #[serde(rename = "IDEA")]
    Idea,
    #[serde(rename = "SHOWCASE")]
    Showcase,
    #[serde(rename = "QUIZ")]
    Quiz,
}

impl std::fmt::Display for CreativeType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CreativeType::Regular => write!(f, "REGULAR"),
            CreativeType::Video => write!(f, "VIDEO"),
            CreativeType::Shopping => write!(f, "SHOPPING"),
            CreativeType::Carousel => write!(f, "CAROUSEL"),
            CreativeType::MaxVideo => write!(f, "MAX_VIDEO"),
            CreativeType::ShopThePin => write!(f, "SHOP_THE_PIN"),
            CreativeType::Collection => write!(f, "COLLECTION"),
            CreativeType::Idea => write!(f, "IDEA"),
            CreativeType::Showcase => write!(f, "SHOWCASE"),
            CreativeType::Quiz => write!(f, "QUIZ"),
        }
    }
}

impl std::str::FromStr for CreativeType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "REGULAR" => std::result::Result::Ok(CreativeType::Regular),
            "VIDEO" => std::result::Result::Ok(CreativeType::Video),
            "SHOPPING" => std::result::Result::Ok(CreativeType::Shopping),
            "CAROUSEL" => std::result::Result::Ok(CreativeType::Carousel),
            "MAX_VIDEO" => std::result::Result::Ok(CreativeType::MaxVideo),
            "SHOP_THE_PIN" => std::result::Result::Ok(CreativeType::ShopThePin),
            "COLLECTION" => std::result::Result::Ok(CreativeType::Collection),
            "IDEA" => std::result::Result::Ok(CreativeType::Idea),
            "SHOWCASE" => std::result::Result::Ok(CreativeType::Showcase),
            "QUIZ" => std::result::Result::Ok(CreativeType::Quiz),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Currency Codes from ISO 4217
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum Currency {
    #[serde(rename = "UNK")]
    Unk,
    #[serde(rename = "USD")]
    Usd,
    #[serde(rename = "GBP")]
    Gbp,
    #[serde(rename = "CAD")]
    Cad,
    #[serde(rename = "EUR")]
    Eur,
    #[serde(rename = "AUD")]
    Aud,
    #[serde(rename = "NZD")]
    Nzd,
    #[serde(rename = "SEK")]
    Sek,
    #[serde(rename = "ILS")]
    Ils,
    #[serde(rename = "CHF")]
    Chf,
    #[serde(rename = "HKD")]
    Hkd,
    #[serde(rename = "JPY")]
    Jpy,
    #[serde(rename = "SGD")]
    Sgd,
    #[serde(rename = "KRW")]
    Krw,
    #[serde(rename = "NOK")]
    Nok,
    #[serde(rename = "DKK")]
    Dkk,
    #[serde(rename = "PLN")]
    Pln,
    #[serde(rename = "RON")]
    Ron,
    #[serde(rename = "HUF")]
    Huf,
    #[serde(rename = "CZK")]
    Czk,
    #[serde(rename = "BRL")]
    Brl,
    #[serde(rename = "MXN")]
    Mxn,
    #[serde(rename = "ARS")]
    Ars,
    #[serde(rename = "CLP")]
    Clp,
    #[serde(rename = "COP")]
    Cop,
}

impl std::fmt::Display for Currency {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Currency::Unk => write!(f, "UNK"),
            Currency::Usd => write!(f, "USD"),
            Currency::Gbp => write!(f, "GBP"),
            Currency::Cad => write!(f, "CAD"),
            Currency::Eur => write!(f, "EUR"),
            Currency::Aud => write!(f, "AUD"),
            Currency::Nzd => write!(f, "NZD"),
            Currency::Sek => write!(f, "SEK"),
            Currency::Ils => write!(f, "ILS"),
            Currency::Chf => write!(f, "CHF"),
            Currency::Hkd => write!(f, "HKD"),
            Currency::Jpy => write!(f, "JPY"),
            Currency::Sgd => write!(f, "SGD"),
            Currency::Krw => write!(f, "KRW"),
            Currency::Nok => write!(f, "NOK"),
            Currency::Dkk => write!(f, "DKK"),
            Currency::Pln => write!(f, "PLN"),
            Currency::Ron => write!(f, "RON"),
            Currency::Huf => write!(f, "HUF"),
            Currency::Czk => write!(f, "CZK"),
            Currency::Brl => write!(f, "BRL"),
            Currency::Mxn => write!(f, "MXN"),
            Currency::Ars => write!(f, "ARS"),
            Currency::Clp => write!(f, "CLP"),
            Currency::Cop => write!(f, "COP"),
        }
    }
}

impl std::str::FromStr for Currency {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "UNK" => std::result::Result::Ok(Currency::Unk),
            "USD" => std::result::Result::Ok(Currency::Usd),
            "GBP" => std::result::Result::Ok(Currency::Gbp),
            "CAD" => std::result::Result::Ok(Currency::Cad),
            "EUR" => std::result::Result::Ok(Currency::Eur),
            "AUD" => std::result::Result::Ok(Currency::Aud),
            "NZD" => std::result::Result::Ok(Currency::Nzd),
            "SEK" => std::result::Result::Ok(Currency::Sek),
            "ILS" => std::result::Result::Ok(Currency::Ils),
            "CHF" => std::result::Result::Ok(Currency::Chf),
            "HKD" => std::result::Result::Ok(Currency::Hkd),
            "JPY" => std::result::Result::Ok(Currency::Jpy),
            "SGD" => std::result::Result::Ok(Currency::Sgd),
            "KRW" => std::result::Result::Ok(Currency::Krw),
            "NOK" => std::result::Result::Ok(Currency::Nok),
            "DKK" => std::result::Result::Ok(Currency::Dkk),
            "PLN" => std::result::Result::Ok(Currency::Pln),
            "RON" => std::result::Result::Ok(Currency::Ron),
            "HUF" => std::result::Result::Ok(Currency::Huf),
            "CZK" => std::result::Result::Ok(Currency::Czk),
            "BRL" => std::result::Result::Ok(Currency::Brl),
            "MXN" => std::result::Result::Ok(Currency::Mxn),
            "ARS" => std::result::Result::Ok(Currency::Ars),
            "CLP" => std::result::Result::Ok(Currency::Clp),
            "COP" => std::result::Result::Ok(Currency::Cop),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CurrencyFilter {
    #[serde(rename = "CURRENCY")]
    pub currency: models::CatalogsProductGroupCurrencyCriteria,

}


impl CurrencyFilter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(currency: models::CatalogsProductGroupCurrencyCriteria, ) -> CurrencyFilter {
        CurrencyFilter {
            currency,
        }
    }
}

/// Converts the CurrencyFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CurrencyFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping CURRENCY in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CurrencyFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CurrencyFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub currency: Vec<models::CatalogsProductGroupCurrencyCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CurrencyFilter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CURRENCY" => intermediate_rep.currency.push(<models::CatalogsProductGroupCurrencyCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CurrencyFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CurrencyFilter {
            currency: intermediate_rep.currency.into_iter().next().ok_or_else(|| "CURRENCY missing in CurrencyFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CurrencyFilter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CurrencyFilter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CurrencyFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CurrencyFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CurrencyFilter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CurrencyFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CurrencyFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Custom Column ID
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CustomColumnId(String);

impl validator::Validate for CustomColumnId {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for CustomColumnId {
    fn from(x: String) -> Self {
        CustomColumnId(x)
    }
}

impl std::fmt::Display for CustomColumnId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for CustomColumnId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(CustomColumnId(x.to_string()))
    }
}

impl std::convert::From<CustomColumnId> for String {
    fn from(x: CustomColumnId) -> Self {
        x.0
    }
}

impl std::ops::Deref for CustomColumnId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for CustomColumnId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CustomLabel0Filter {
    #[serde(rename = "CUSTOM_LABEL_0")]
    pub custom_label_0: models::CatalogsProductGroupMultipleStringCriteria,

}


impl CustomLabel0Filter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(custom_label_0: models::CatalogsProductGroupMultipleStringCriteria, ) -> CustomLabel0Filter {
        CustomLabel0Filter {
            custom_label_0,
        }
    }
}

/// Converts the CustomLabel0Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CustomLabel0Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping CUSTOM_LABEL_0 in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CustomLabel0Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CustomLabel0Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub custom_label_0: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CustomLabel0Filter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CUSTOM_LABEL_0" => intermediate_rep.custom_label_0.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CustomLabel0Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CustomLabel0Filter {
            custom_label_0: intermediate_rep.custom_label_0.into_iter().next().ok_or_else(|| "CUSTOM_LABEL_0 missing in CustomLabel0Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CustomLabel0Filter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CustomLabel0Filter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CustomLabel0Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CustomLabel0Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CustomLabel0Filter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CustomLabel0Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CustomLabel0Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CustomLabel1Filter {
    #[serde(rename = "CUSTOM_LABEL_1")]
    pub custom_label_1: models::CatalogsProductGroupMultipleStringCriteria,

}


impl CustomLabel1Filter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(custom_label_1: models::CatalogsProductGroupMultipleStringCriteria, ) -> CustomLabel1Filter {
        CustomLabel1Filter {
            custom_label_1,
        }
    }
}

/// Converts the CustomLabel1Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CustomLabel1Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping CUSTOM_LABEL_1 in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CustomLabel1Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CustomLabel1Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub custom_label_1: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CustomLabel1Filter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CUSTOM_LABEL_1" => intermediate_rep.custom_label_1.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CustomLabel1Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CustomLabel1Filter {
            custom_label_1: intermediate_rep.custom_label_1.into_iter().next().ok_or_else(|| "CUSTOM_LABEL_1 missing in CustomLabel1Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CustomLabel1Filter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CustomLabel1Filter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CustomLabel1Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CustomLabel1Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CustomLabel1Filter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CustomLabel1Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CustomLabel1Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CustomLabel2Filter {
    #[serde(rename = "CUSTOM_LABEL_2")]
    pub custom_label_2: models::CatalogsProductGroupMultipleStringCriteria,

}


impl CustomLabel2Filter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(custom_label_2: models::CatalogsProductGroupMultipleStringCriteria, ) -> CustomLabel2Filter {
        CustomLabel2Filter {
            custom_label_2,
        }
    }
}

/// Converts the CustomLabel2Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CustomLabel2Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping CUSTOM_LABEL_2 in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CustomLabel2Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CustomLabel2Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub custom_label_2: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CustomLabel2Filter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CUSTOM_LABEL_2" => intermediate_rep.custom_label_2.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CustomLabel2Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CustomLabel2Filter {
            custom_label_2: intermediate_rep.custom_label_2.into_iter().next().ok_or_else(|| "CUSTOM_LABEL_2 missing in CustomLabel2Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CustomLabel2Filter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CustomLabel2Filter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CustomLabel2Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CustomLabel2Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CustomLabel2Filter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CustomLabel2Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CustomLabel2Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CustomLabel3Filter {
    #[serde(rename = "CUSTOM_LABEL_3")]
    pub custom_label_3: models::CatalogsProductGroupMultipleStringCriteria,

}


impl CustomLabel3Filter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(custom_label_3: models::CatalogsProductGroupMultipleStringCriteria, ) -> CustomLabel3Filter {
        CustomLabel3Filter {
            custom_label_3,
        }
    }
}

/// Converts the CustomLabel3Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CustomLabel3Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping CUSTOM_LABEL_3 in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CustomLabel3Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CustomLabel3Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub custom_label_3: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CustomLabel3Filter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CUSTOM_LABEL_3" => intermediate_rep.custom_label_3.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CustomLabel3Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CustomLabel3Filter {
            custom_label_3: intermediate_rep.custom_label_3.into_iter().next().ok_or_else(|| "CUSTOM_LABEL_3 missing in CustomLabel3Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CustomLabel3Filter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CustomLabel3Filter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CustomLabel3Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CustomLabel3Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CustomLabel3Filter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CustomLabel3Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CustomLabel3Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CustomLabel4Filter {
    #[serde(rename = "CUSTOM_LABEL_4")]
    pub custom_label_4: models::CatalogsProductGroupMultipleStringCriteria,

}


impl CustomLabel4Filter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(custom_label_4: models::CatalogsProductGroupMultipleStringCriteria, ) -> CustomLabel4Filter {
        CustomLabel4Filter {
            custom_label_4,
        }
    }
}

/// Converts the CustomLabel4Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CustomLabel4Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping CUSTOM_LABEL_4 in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CustomLabel4Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CustomLabel4Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub custom_label_4: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CustomLabel4Filter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CUSTOM_LABEL_4" => intermediate_rep.custom_label_4.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CustomLabel4Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CustomLabel4Filter {
            custom_label_4: intermediate_rep.custom_label_4.into_iter().next().ok_or_else(|| "CUSTOM_LABEL_4 missing in CustomLabel4Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CustomLabel4Filter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CustomLabel4Filter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CustomLabel4Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CustomLabel4Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CustomLabel4Filter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CustomLabel4Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CustomLabel4Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CustomerList {
/// Associated ad account ID.
    #[serde(rename = "ad_account_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// Creation time. Unix timestamp in seconds.
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<f64>,

/// Customer list ID.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Customer list name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Total number of list updates.  List creation counts as one batch. Each <a href=\"/docs/redoc/#operation/ads_v3_customer_list_add_handler_PUT\">Append</a> or <a href=\"/docs/redoc/#operation/ads_v3_customer_list_remove_handler_PUT\">Remove API</a> call counts as another. List creation via the Ads Manager UI could result in more than one batch since the UI breaks up large lists.
    #[serde(rename = "num_batches")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub num_batches: Option<f64>,

/// Number of removed user records. In a <a href=\"/docs/redoc/#operation/ads_v3_customer_list_remove_handler_PUT\">Remove API</a> call, this counter increases even if the user is not found in the list.
    #[serde(rename = "num_removed_user_records")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub num_removed_user_records: Option<f64>,

/// Number of uploaded user records. In an <a href=\"/docs/redoc/#operation/ads_v3_customer_list_add_handler_PUT\">Append API</a> call, this counter increases even if the uploaded user is already in the list.
    #[serde(rename = "num_uploaded_user_records")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub num_uploaded_user_records: Option<f64>,

/// Customer list status. TOO_SMALL - the list has less than 100 Pinterest users.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

/// Always \"customerlist\".
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

/// Last update time. Unix timestamp in seconds.
    #[serde(rename = "updated_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_time: Option<f64>,

/// Customer list errors
    #[serde(rename = "exceptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exceptions: Option<crate::types::Object>,

}


impl CustomerList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CustomerList {
        CustomerList {
            ad_account_id: None,
            created_time: None,
            id: None,
            name: None,
            num_batches: None,
            num_removed_user_records: None,
            num_uploaded_user_records: None,
            status: None,
            r#type: None,
            updated_time: None,
            exceptions: None,
        }
    }
}

/// Converts the CustomerList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CustomerList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.created_time.as_ref().map(|created_time| {
                [
                    "created_time".to_string(),
                    created_time.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.num_batches.as_ref().map(|num_batches| {
                [
                    "num_batches".to_string(),
                    num_batches.to_string(),
                ].join(",")
            }),


            self.num_removed_user_records.as_ref().map(|num_removed_user_records| {
                [
                    "num_removed_user_records".to_string(),
                    num_removed_user_records.to_string(),
                ].join(",")
            }),


            self.num_uploaded_user_records.as_ref().map(|num_uploaded_user_records| {
                [
                    "num_uploaded_user_records".to_string(),
                    num_uploaded_user_records.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.updated_time.as_ref().map(|updated_time| {
                [
                    "updated_time".to_string(),
                    updated_time.to_string(),
                ].join(",")
            }),

            // Skipping exceptions in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CustomerList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CustomerList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_account_id: Vec<String>,
            pub created_time: Vec<f64>,
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub num_batches: Vec<f64>,
            pub num_removed_user_records: Vec<f64>,
            pub num_uploaded_user_records: Vec<f64>,
            pub status: Vec<String>,
            pub r#type: Vec<String>,
            pub updated_time: Vec<f64>,
            pub exceptions: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CustomerList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_time" => intermediate_rep.created_time.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "num_batches" => intermediate_rep.num_batches.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "num_removed_user_records" => intermediate_rep.num_removed_user_records.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "num_uploaded_user_records" => intermediate_rep.num_uploaded_user_records.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updated_time" => intermediate_rep.updated_time.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "exceptions" => intermediate_rep.exceptions.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CustomerList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CustomerList {
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            created_time: intermediate_rep.created_time.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            num_batches: intermediate_rep.num_batches.into_iter().next(),
            num_removed_user_records: intermediate_rep.num_removed_user_records.into_iter().next(),
            num_uploaded_user_records: intermediate_rep.num_uploaded_user_records.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            updated_time: intermediate_rep.updated_time.into_iter().next(),
            exceptions: intermediate_rep.exceptions.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CustomerList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CustomerList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CustomerList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CustomerList - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CustomerList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CustomerList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CustomerList - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CustomerListRequest {
/// Customer list name.
    #[serde(rename = "name")]
    pub name: String,

/// Records list. Can be any combination of emails, MAIDs, or IDFAs. Emails must be lowercase and can be plain text or hashed using SHA1, SHA256, or MD5. MAIDs and IDFAs must be hashed with SHA1, SHA256, or MD5.
    #[serde(rename = "records")]
    pub records: String,

    #[serde(rename = "list_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub list_type: Option<models::UserListType>,

/// Customer list errors.
    #[serde(rename = "exceptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exceptions: Option<crate::types::Object>,

}


impl CustomerListRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, records: String, ) -> CustomerListRequest {
        CustomerListRequest {
            name,
            records,
            list_type: Some("EMAIL".to_string()),
            exceptions: None,
        }
    }
}

/// Converts the CustomerListRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CustomerListRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("records".to_string()),
            Some(self.records.to_string()),

            // Skipping list_type in query parameter serialization

            // Skipping exceptions in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CustomerListRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CustomerListRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub records: Vec<String>,
            pub list_type: Vec<models::UserListType>,
            pub exceptions: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CustomerListRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "records" => intermediate_rep.records.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "list_type" => intermediate_rep.list_type.push(<models::UserListType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "exceptions" => intermediate_rep.exceptions.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CustomerListRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CustomerListRequest {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in CustomerListRequest".to_string())?,
            records: intermediate_rep.records.into_iter().next().ok_or_else(|| "records missing in CustomerListRequest".to_string())?,
            list_type: intermediate_rep.list_type.into_iter().next(),
            exceptions: intermediate_rep.exceptions.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CustomerListRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CustomerListRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CustomerListRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CustomerListRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CustomerListRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CustomerListRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CustomerListRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CustomerListUpdateRequest {
/// Records list. Can be any combination of emails, MAIDs, or IDFAs. Emails must be lowercase and can be plain text or hashed using SHA1, SHA256, or MD5. MAIDs and IDFAs must be hashed with SHA1, SHA256, or MD5.
    #[serde(rename = "records")]
    pub records: String,

    #[serde(rename = "operation_type")]
    pub operation_type: models::UserListOperationType,

    #[serde(rename = "exceptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exceptions: Option<models::Exception>,

}


impl CustomerListUpdateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(records: String, operation_type: models::UserListOperationType, ) -> CustomerListUpdateRequest {
        CustomerListUpdateRequest {
            records,
            operation_type,
            exceptions: None,
        }
    }
}

/// Converts the CustomerListUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CustomerListUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("records".to_string()),
            Some(self.records.to_string()),

            // Skipping operation_type in query parameter serialization

            // Skipping exceptions in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CustomerListUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CustomerListUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub records: Vec<String>,
            pub operation_type: Vec<models::UserListOperationType>,
            pub exceptions: Vec<models::Exception>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CustomerListUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "records" => intermediate_rep.records.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "operation_type" => intermediate_rep.operation_type.push(<models::UserListOperationType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "exceptions" => intermediate_rep.exceptions.push(<models::Exception as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CustomerListUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CustomerListUpdateRequest {
            records: intermediate_rep.records.into_iter().next().ok_or_else(|| "records missing in CustomerListUpdateRequest".to_string())?,
            operation_type: intermediate_rep.operation_type.into_iter().next().ok_or_else(|| "operation_type missing in CustomerListUpdateRequest".to_string())?,
            exceptions: intermediate_rep.exceptions.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CustomerListUpdateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CustomerListUpdateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CustomerListUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CustomerListUpdateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CustomerListUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CustomerListUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CustomerListUpdateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CustomerListsList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::CustomerList>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl CustomerListsList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::CustomerList>, ) -> CustomerListsList200Response {
        CustomerListsList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the CustomerListsList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CustomerListsList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CustomerListsList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CustomerListsList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::CustomerList>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CustomerListsList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CustomerListsList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CustomerListsList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CustomerListsList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CustomerListsList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in CustomerListsList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in CustomerListsList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CustomerListsList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CustomerListsList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CustomerListsList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CustomerListsList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CustomerListsList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CustomerListsList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CustomerListsList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Format of generated report
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum DataOutputFormat {
    #[serde(rename = "JSON")]
    Json,
    #[serde(rename = "CSV")]
    Csv,
}

impl std::fmt::Display for DataOutputFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            DataOutputFormat::Json => write!(f, "JSON"),
            DataOutputFormat::Csv => write!(f, "CSV"),
        }
    }
}

impl std::str::FromStr for DataOutputFormat {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "JSON" => std::result::Result::Ok(DataOutputFormat::Json),
            "CSV" => std::result::Result::Ok(DataOutputFormat::Csv),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Metrics availablity, e.g., \"READY\".
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum DataStatus {
    #[serde(rename = "PROCESSING")]
    Processing,
    #[serde(rename = "READY")]
    Ready,
    #[serde(rename = "ESTIMATE")]
    Estimate,
    #[serde(rename = "BEFORE_BUSINESS_CREATED")]
    BeforeBusinessCreated,
    #[serde(rename = "BEFORE_DATA_RETENTION_PERIOD")]
    BeforeDataRetentionPeriod,
    #[serde(rename = "BEFORE_PIN_DATA_RETENTION_PERIOD")]
    BeforePinDataRetentionPeriod,
    #[serde(rename = "BEFORE_METRIC_START_DATE")]
    BeforeMetricStartDate,
    #[serde(rename = "BEFORE_CORE_METRIC_START_DATE")]
    BeforeCoreMetricStartDate,
    #[serde(rename = "BEFORE_PIN_FORMAT_METRIC_START_DATE")]
    BeforePinFormatMetricStartDate,
    #[serde(rename = "BEFORE_AUDIENCE_METRIC_START_DATE")]
    BeforeAudienceMetricStartDate,
    #[serde(rename = "BEFORE_AUDIENCE_MONTHLY_METRIC_START_DATE")]
    BeforeAudienceMonthlyMetricStartDate,
    #[serde(rename = "BEFORE_VIDEO_METRIC_START_DATE")]
    BeforeVideoMetricStartDate,
    #[serde(rename = "BEFORE_CONVERSION_METRIC_START_DATE")]
    BeforeConversionMetricStartDate,
    #[serde(rename = "PURCHASERS_METRIC_SMALLER_THAN_THRESHOLD")]
    PurchasersMetricSmallerThanThreshold,
    #[serde(rename = "IN_BAD_TAG_DATE")]
    InBadTagDate,
    #[serde(rename = "BEFORE_PUBLISHED_METRIC_START_DATE")]
    BeforePublishedMetricStartDate,
    #[serde(rename = "BEFORE_ASSIST_METRIC_START_DATE")]
    BeforeAssistMetricStartDate,
    #[serde(rename = "BEFORE_PIN_CREATED")]
    BeforePinCreated,
    #[serde(rename = "BEFORE_ACCOUNT_CLAIMED")]
    BeforeAccountClaimed,
    #[serde(rename = "BEFORE_DEMOGRAPHIC_FILTERS_START_DATE")]
    BeforeDemographicFiltersStartDate,
    #[serde(rename = "AUDIENCE_SEGMENT_SMALLER_THAN_THRESHOLD")]
    AudienceSegmentSmallerThanThreshold,
    #[serde(rename = "AUDIENCE_TOTAL_SMALLER_THAN_THRESHOLD")]
    AudienceTotalSmallerThanThreshold,
    #[serde(rename = "BEFORE_PRODUCT_GROUP_FILTER_START_DATE")]
    BeforeProductGroupFilterStartDate,
}

impl std::fmt::Display for DataStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            DataStatus::Processing => write!(f, "PROCESSING"),
            DataStatus::Ready => write!(f, "READY"),
            DataStatus::Estimate => write!(f, "ESTIMATE"),
            DataStatus::BeforeBusinessCreated => write!(f, "BEFORE_BUSINESS_CREATED"),
            DataStatus::BeforeDataRetentionPeriod => write!(f, "BEFORE_DATA_RETENTION_PERIOD"),
            DataStatus::BeforePinDataRetentionPeriod => write!(f, "BEFORE_PIN_DATA_RETENTION_PERIOD"),
            DataStatus::BeforeMetricStartDate => write!(f, "BEFORE_METRIC_START_DATE"),
            DataStatus::BeforeCoreMetricStartDate => write!(f, "BEFORE_CORE_METRIC_START_DATE"),
            DataStatus::BeforePinFormatMetricStartDate => write!(f, "BEFORE_PIN_FORMAT_METRIC_START_DATE"),
            DataStatus::BeforeAudienceMetricStartDate => write!(f, "BEFORE_AUDIENCE_METRIC_START_DATE"),
            DataStatus::BeforeAudienceMonthlyMetricStartDate => write!(f, "BEFORE_AUDIENCE_MONTHLY_METRIC_START_DATE"),
            DataStatus::BeforeVideoMetricStartDate => write!(f, "BEFORE_VIDEO_METRIC_START_DATE"),
            DataStatus::BeforeConversionMetricStartDate => write!(f, "BEFORE_CONVERSION_METRIC_START_DATE"),
            DataStatus::PurchasersMetricSmallerThanThreshold => write!(f, "PURCHASERS_METRIC_SMALLER_THAN_THRESHOLD"),
            DataStatus::InBadTagDate => write!(f, "IN_BAD_TAG_DATE"),
            DataStatus::BeforePublishedMetricStartDate => write!(f, "BEFORE_PUBLISHED_METRIC_START_DATE"),
            DataStatus::BeforeAssistMetricStartDate => write!(f, "BEFORE_ASSIST_METRIC_START_DATE"),
            DataStatus::BeforePinCreated => write!(f, "BEFORE_PIN_CREATED"),
            DataStatus::BeforeAccountClaimed => write!(f, "BEFORE_ACCOUNT_CLAIMED"),
            DataStatus::BeforeDemographicFiltersStartDate => write!(f, "BEFORE_DEMOGRAPHIC_FILTERS_START_DATE"),
            DataStatus::AudienceSegmentSmallerThanThreshold => write!(f, "AUDIENCE_SEGMENT_SMALLER_THAN_THRESHOLD"),
            DataStatus::AudienceTotalSmallerThanThreshold => write!(f, "AUDIENCE_TOTAL_SMALLER_THAN_THRESHOLD"),
            DataStatus::BeforeProductGroupFilterStartDate => write!(f, "BEFORE_PRODUCT_GROUP_FILTER_START_DATE"),
        }
    }
}

impl std::str::FromStr for DataStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PROCESSING" => std::result::Result::Ok(DataStatus::Processing),
            "READY" => std::result::Result::Ok(DataStatus::Ready),
            "ESTIMATE" => std::result::Result::Ok(DataStatus::Estimate),
            "BEFORE_BUSINESS_CREATED" => std::result::Result::Ok(DataStatus::BeforeBusinessCreated),
            "BEFORE_DATA_RETENTION_PERIOD" => std::result::Result::Ok(DataStatus::BeforeDataRetentionPeriod),
            "BEFORE_PIN_DATA_RETENTION_PERIOD" => std::result::Result::Ok(DataStatus::BeforePinDataRetentionPeriod),
            "BEFORE_METRIC_START_DATE" => std::result::Result::Ok(DataStatus::BeforeMetricStartDate),
            "BEFORE_CORE_METRIC_START_DATE" => std::result::Result::Ok(DataStatus::BeforeCoreMetricStartDate),
            "BEFORE_PIN_FORMAT_METRIC_START_DATE" => std::result::Result::Ok(DataStatus::BeforePinFormatMetricStartDate),
            "BEFORE_AUDIENCE_METRIC_START_DATE" => std::result::Result::Ok(DataStatus::BeforeAudienceMetricStartDate),
            "BEFORE_AUDIENCE_MONTHLY_METRIC_START_DATE" => std::result::Result::Ok(DataStatus::BeforeAudienceMonthlyMetricStartDate),
            "BEFORE_VIDEO_METRIC_START_DATE" => std::result::Result::Ok(DataStatus::BeforeVideoMetricStartDate),
            "BEFORE_CONVERSION_METRIC_START_DATE" => std::result::Result::Ok(DataStatus::BeforeConversionMetricStartDate),
            "PURCHASERS_METRIC_SMALLER_THAN_THRESHOLD" => std::result::Result::Ok(DataStatus::PurchasersMetricSmallerThanThreshold),
            "IN_BAD_TAG_DATE" => std::result::Result::Ok(DataStatus::InBadTagDate),
            "BEFORE_PUBLISHED_METRIC_START_DATE" => std::result::Result::Ok(DataStatus::BeforePublishedMetricStartDate),
            "BEFORE_ASSIST_METRIC_START_DATE" => std::result::Result::Ok(DataStatus::BeforeAssistMetricStartDate),
            "BEFORE_PIN_CREATED" => std::result::Result::Ok(DataStatus::BeforePinCreated),
            "BEFORE_ACCOUNT_CLAIMED" => std::result::Result::Ok(DataStatus::BeforeAccountClaimed),
            "BEFORE_DEMOGRAPHIC_FILTERS_START_DATE" => std::result::Result::Ok(DataStatus::BeforeDemographicFiltersStartDate),
            "AUDIENCE_SEGMENT_SMALLER_THAN_THRESHOLD" => std::result::Result::Ok(DataStatus::AudienceSegmentSmallerThanThreshold),
            "AUDIENCE_TOTAL_SMALLER_THAN_THRESHOLD" => std::result::Result::Ok(DataStatus::AudienceTotalSmallerThanThreshold),
            "BEFORE_PRODUCT_GROUP_FILTER_START_DATE" => std::result::Result::Ok(DataStatus::BeforeProductGroupFilterStartDate),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeliveryMetricsResponse {
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::DeliveryMetricsResponseItemsInner>>,

}


impl DeliveryMetricsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DeliveryMetricsResponse {
        DeliveryMetricsResponse {
            items: None,
        }
    }
}

/// Converts the DeliveryMetricsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeliveryMetricsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeliveryMetricsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeliveryMetricsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::DeliveryMetricsResponseItemsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeliveryMetricsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in DeliveryMetricsResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeliveryMetricsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeliveryMetricsResponse {
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeliveryMetricsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeliveryMetricsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeliveryMetricsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeliveryMetricsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeliveryMetricsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeliveryMetricsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeliveryMetricsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeliveryMetricsResponseItemsInner {
/// Metric's name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Category name
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "category")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<String>,

/// How the metric is defined.
    #[serde(rename = "definition")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub definition: Option<String>,

/// Display name, when available. If unavaible it will not be returned. Matches how the metric is named in our native tools like Pinterest Ads Manager.
    #[serde(rename = "display_name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_name: Option<String>,

}


impl DeliveryMetricsResponseItemsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DeliveryMetricsResponseItemsInner {
        DeliveryMetricsResponseItemsInner {
            name: None,
            category: None,
            definition: None,
            display_name: None,
        }
    }
}

/// Converts the DeliveryMetricsResponseItemsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeliveryMetricsResponseItemsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.category.as_ref().map(|category| {
                [
                    "category".to_string(),
                    category.to_string(),
                ].join(",")
            }),


            self.definition.as_ref().map(|definition| {
                [
                    "definition".to_string(),
                    definition.to_string(),
                ].join(",")
            }),


            self.display_name.as_ref().map(|display_name| {
                [
                    "display_name".to_string(),
                    display_name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeliveryMetricsResponseItemsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeliveryMetricsResponseItemsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub category: Vec<String>,
            pub definition: Vec<String>,
            pub display_name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeliveryMetricsResponseItemsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "category" => intermediate_rep.category.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "definition" => intermediate_rep.definition.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "display_name" => intermediate_rep.display_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeliveryMetricsResponseItemsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeliveryMetricsResponseItemsInner {
            name: intermediate_rep.name.into_iter().next(),
            category: intermediate_rep.category.into_iter().next(),
            definition: intermediate_rep.definition.into_iter().next(),
            display_name: intermediate_rep.display_name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeliveryMetricsResponseItemsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeliveryMetricsResponseItemsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeliveryMetricsResponseItemsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeliveryMetricsResponseItemsInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeliveryMetricsResponseItemsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeliveryMetricsResponseItemsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeliveryMetricsResponseItemsInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Used for including extra details to a base error



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DetailedError {
    #[serde(rename = "code")]
    pub code: i32,

    #[serde(rename = "message")]
    pub message: String,

    #[serde(rename = "details")]
    pub details: crate::types::Object,

}


impl DetailedError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(code: i32, message: String, details: crate::types::Object, ) -> DetailedError {
        DetailedError {
            code,
            message,
            details,
        }
    }
}

/// Converts the DetailedError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DetailedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("code".to_string()),
            Some(self.code.to_string()),


            Some("message".to_string()),
            Some(self.message.to_string()),

            // Skipping details in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DetailedError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DetailedError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<i32>,
            pub message: Vec<String>,
            pub details: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DetailedError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "details" => intermediate_rep.details.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DetailedError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DetailedError {
            code: intermediate_rep.code.into_iter().next().ok_or_else(|| "code missing in DetailedError".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in DetailedError".to_string())?,
            details: intermediate_rep.details.into_iter().next().ok_or_else(|| "details missing in DetailedError".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DetailedError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DetailedError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DetailedError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DetailedError - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DetailedError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DetailedError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DetailedError - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The enhanced match status of the tag
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum EnhancedMatchStatusType {
    #[serde(rename = "UNKNOWN")]
    Unknown,
    #[serde(rename = "NOT_VALIDATED")]
    NotValidated,
    #[serde(rename = "VALIDATING_IN_PROGRESS")]
    ValidatingInProgress,
    #[serde(rename = "VALIDATION_COMPLETE")]
    ValidationComplete,
    #[serde(rename = "null")]
    Null,
}

impl std::fmt::Display for EnhancedMatchStatusType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            EnhancedMatchStatusType::Unknown => write!(f, "UNKNOWN"),
            EnhancedMatchStatusType::NotValidated => write!(f, "NOT_VALIDATED"),
            EnhancedMatchStatusType::ValidatingInProgress => write!(f, "VALIDATING_IN_PROGRESS"),
            EnhancedMatchStatusType::ValidationComplete => write!(f, "VALIDATION_COMPLETE"),
            EnhancedMatchStatusType::Null => write!(f, "null"),
        }
    }
}

impl std::str::FromStr for EnhancedMatchStatusType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "UNKNOWN" => std::result::Result::Ok(EnhancedMatchStatusType::Unknown),
            "NOT_VALIDATED" => std::result::Result::Ok(EnhancedMatchStatusType::NotValidated),
            "VALIDATING_IN_PROGRESS" => std::result::Result::Ok(EnhancedMatchStatusType::ValidatingInProgress),
            "VALIDATION_COMPLETE" => std::result::Result::Ok(EnhancedMatchStatusType::ValidationComplete),
            "null" => std::result::Result::Ok(EnhancedMatchStatusType::Null),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Entity status
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum EntityStatus {
    #[serde(rename = "ACTIVE")]
    Active,
    #[serde(rename = "PAUSED")]
    Paused,
    #[serde(rename = "ARCHIVED")]
    Archived,
    #[serde(rename = "DRAFT")]
    Draft,
    #[serde(rename = "DELETED_DRAFT")]
    DeletedDraft,
}

impl std::fmt::Display for EntityStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            EntityStatus::Active => write!(f, "ACTIVE"),
            EntityStatus::Paused => write!(f, "PAUSED"),
            EntityStatus::Archived => write!(f, "ARCHIVED"),
            EntityStatus::Draft => write!(f, "DRAFT"),
            EntityStatus::DeletedDraft => write!(f, "DELETED_DRAFT"),
        }
    }
}

impl std::str::FromStr for EntityStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ACTIVE" => std::result::Result::Ok(EntityStatus::Active),
            "PAUSED" => std::result::Result::Ok(EntityStatus::Paused),
            "ARCHIVED" => std::result::Result::Ok(EntityStatus::Archived),
            "DRAFT" => std::result::Result::Ok(EntityStatus::Draft),
            "DELETED_DRAFT" => std::result::Result::Ok(EntityStatus::DeletedDraft),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Error {
    #[serde(rename = "code")]
    pub code: i32,

    #[serde(rename = "message")]
    pub message: String,

}


impl Error {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(code: i32, message: String, ) -> Error {
        Error {
            code,
            message,
        }
    }
}

/// Converts the Error value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("code".to_string()),
            Some(self.code.to_string()),


            Some("message".to_string()),
            Some(self.message.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Error value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Error {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<i32>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Error".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Error".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Error {
            code: intermediate_rep.code.into_iter().next().ok_or_else(|| "code missing in Error".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in Error".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Error> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Error>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Error>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Error - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Error> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Error as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Error - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Exception {
/// Exception error code.
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<i32>,

/// Exception message.
    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

}


impl Exception {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Exception {
        Exception {
            code: None,
            message: None,
        }
    }
}

/// Converts the Exception value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Exception {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Exception value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Exception {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<i32>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Exception".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Exception".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Exception {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Exception> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Exception>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Exception>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Exception - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Exception> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Exception as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Exception - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedProcessingResultsList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::CatalogsFeedProcessingResult>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl FeedProcessingResultsList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::CatalogsFeedProcessingResult>, ) -> FeedProcessingResultsList200Response {
        FeedProcessingResultsList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the FeedProcessingResultsList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FeedProcessingResultsList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedProcessingResultsList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedProcessingResultsList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::CatalogsFeedProcessingResult>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedProcessingResultsList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in FeedProcessingResultsList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FeedProcessingResultsList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedProcessingResultsList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedProcessingResultsList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in FeedProcessingResultsList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in FeedProcessingResultsList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedProcessingResultsList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedProcessingResultsList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedProcessingResultsList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedProcessingResultsList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FeedProcessingResultsList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedProcessingResultsList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedProcessingResultsList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - CatalogsFeedsCreateRequest
/// - CatalogsVerticalFeedsCreateRequest
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FeedsCreateRequest(Box<serde_json::value::RawValue>);

impl validator::Validate for FeedsCreateRequest
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedsCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedsCreateRequest {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for FeedsCreateRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedsList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::CatalogsFeed>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl FeedsList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::CatalogsFeed>, ) -> FeedsList200Response {
        FeedsList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the FeedsList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FeedsList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedsList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedsList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::CatalogsFeed>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedsList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in FeedsList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FeedsList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedsList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedsList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in FeedsList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in FeedsList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedsList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedsList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedsList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedsList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FeedsList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedsList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedsList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - CatalogsFeedsUpdateRequest
/// - CatalogsVerticalFeedsUpdateRequest
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FeedsUpdateRequest(Box<serde_json::value::RawValue>);

impl validator::Validate for FeedsUpdateRequest
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedsUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedsUpdateRequest {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for FeedsUpdateRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FollowUserRequest {
/// Whether this request comes as result of auto-follow after clicking on a link. Follow links can be used by partners on their site or in emails. Only selected partners can be followed this way. We verify that partner can be auto-followed.
    #[serde(rename = "auto_follow")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_follow: Option<bool>,

}


impl FollowUserRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> FollowUserRequest {
        FollowUserRequest {
            auto_follow: Some(false),
        }
    }
}

/// Converts the FollowUserRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FollowUserRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.auto_follow.as_ref().map(|auto_follow| {
                [
                    "auto_follow".to_string(),
                    auto_follow.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FollowUserRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FollowUserRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub auto_follow: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FollowUserRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "auto_follow" => intermediate_rep.auto_follow.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FollowUserRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FollowUserRequest {
            auto_follow: intermediate_rep.auto_follow.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FollowUserRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FollowUserRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FollowUserRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FollowUserRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FollowUserRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FollowUserRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FollowUserRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FollowersList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::UserSummary>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl FollowersList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::UserSummary>, ) -> FollowersList200Response {
        FollowersList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the FollowersList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FollowersList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FollowersList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FollowersList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::UserSummary>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FollowersList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in FollowersList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FollowersList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing FollowersList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FollowersList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in FollowersList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in FollowersList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FollowersList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FollowersList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FollowersList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FollowersList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FollowersList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FollowersList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FollowersList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum Gender {
    #[serde(rename = "FEMALE")]
    Female,
    #[serde(rename = "MALE")]
    Male,
    #[serde(rename = "UNISEX")]
    Unisex,
}

impl std::fmt::Display for Gender {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Gender::Female => write!(f, "FEMALE"),
            Gender::Male => write!(f, "MALE"),
            Gender::Unisex => write!(f, "UNISEX"),
        }
    }
}

impl std::str::FromStr for Gender {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "FEMALE" => std::result::Result::Ok(Gender::Female),
            "MALE" => std::result::Result::Ok(Gender::Male),
            "UNISEX" => std::result::Result::Ok(Gender::Unisex),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenderFilter {
    #[serde(rename = "GENDER")]
    pub gender: models::CatalogsProductGroupMultipleGenderCriteria,

}


impl GenderFilter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(gender: models::CatalogsProductGroupMultipleGenderCriteria, ) -> GenderFilter {
        GenderFilter {
            gender,
        }
    }
}

/// Converts the GenderFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GenderFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping GENDER in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenderFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenderFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub gender: Vec<models::CatalogsProductGroupMultipleGenderCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenderFilter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "GENDER" => intermediate_rep.gender.push(<models::CatalogsProductGroupMultipleGenderCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenderFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenderFilter {
            gender: intermediate_rep.gender.into_iter().next().ok_or_else(|| "GENDER missing in GenderFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenderFilter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GenderFilter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenderFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenderFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GenderFilter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenderFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenderFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum GetAudiencesOrderBy {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "ID")]
    Id,
    #[serde(rename = "SIZE")]
    Size,
    #[serde(rename = "CREATION_DATE")]
    CreationDate,
    #[serde(rename = "UPDATED_TIME")]
    UpdatedTime,
    #[serde(rename = "NAME")]
    Name,
    #[serde(rename = "STATUS")]
    Status,
    #[serde(rename = "TYPE")]
    Type,
}

impl std::fmt::Display for GetAudiencesOrderBy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            GetAudiencesOrderBy::None => write!(f, "NONE"),
            GetAudiencesOrderBy::Id => write!(f, "ID"),
            GetAudiencesOrderBy::Size => write!(f, "SIZE"),
            GetAudiencesOrderBy::CreationDate => write!(f, "CREATION_DATE"),
            GetAudiencesOrderBy::UpdatedTime => write!(f, "UPDATED_TIME"),
            GetAudiencesOrderBy::Name => write!(f, "NAME"),
            GetAudiencesOrderBy::Status => write!(f, "STATUS"),
            GetAudiencesOrderBy::Type => write!(f, "TYPE"),
        }
    }
}

impl std::str::FromStr for GetAudiencesOrderBy {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NONE" => std::result::Result::Ok(GetAudiencesOrderBy::None),
            "ID" => std::result::Result::Ok(GetAudiencesOrderBy::Id),
            "SIZE" => std::result::Result::Ok(GetAudiencesOrderBy::Size),
            "CREATION_DATE" => std::result::Result::Ok(GetAudiencesOrderBy::CreationDate),
            "UPDATED_TIME" => std::result::Result::Ok(GetAudiencesOrderBy::UpdatedTime),
            "NAME" => std::result::Result::Ok(GetAudiencesOrderBy::Name),
            "STATUS" => std::result::Result::Ok(GetAudiencesOrderBy::Status),
            "TYPE" => std::result::Result::Ok(GetAudiencesOrderBy::Type),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetMmmReportResponse {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<f64>,

    #[serde(rename = "data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<models::GetMmmReportResponseData>,

    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

}


impl GetMmmReportResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetMmmReportResponse {
        GetMmmReportResponse {
            code: None,
            data: None,
            message: None,
            status: None,
        }
    }
}

/// Converts the GetMmmReportResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetMmmReportResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),

            // Skipping data in query parameter serialization


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetMmmReportResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetMmmReportResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<f64>,
            pub data: Vec<models::GetMmmReportResponseData>,
            pub message: Vec<String>,
            pub status: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetMmmReportResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::GetMmmReportResponseData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetMmmReportResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetMmmReportResponse {
            code: intermediate_rep.code.into_iter().next(),
            data: intermediate_rep.data.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetMmmReportResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetMmmReportResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetMmmReportResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetMmmReportResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetMmmReportResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetMmmReportResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetMmmReportResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetMmmReportResponseData {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "report_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub report_status: Option<String>,

    #[serde(rename = "url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<Nullable<String>>,

    #[serde(rename = "size")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<Nullable<f64>>,

}


impl GetMmmReportResponseData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetMmmReportResponseData {
        GetMmmReportResponseData {
            report_status: None,
            url: None,
            size: None,
        }
    }
}

/// Converts the GetMmmReportResponseData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetMmmReportResponseData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.report_status.as_ref().map(|report_status| {
                [
                    "report_status".to_string(),
                    report_status.to_string(),
                ].join(",")
            }),


            self.url.as_ref().map(|url| {
                [
                    "url".to_string(),
                    url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "size".to_string(),
                    size.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetMmmReportResponseData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetMmmReportResponseData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub report_status: Vec<String>,
            pub url: Vec<String>,
            pub size: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GetMmmReportResponseData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "report_status" => intermediate_rep.report_status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in GetMmmReportResponseData".to_string()),
                    "size" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in GetMmmReportResponseData".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetMmmReportResponseData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetMmmReportResponseData {
            report_status: intermediate_rep.report_status.into_iter().next(),
            url: std::result::Result::Err("Nullable types not supported in GetMmmReportResponseData".to_string())?,
            size: std::result::Result::Err("Nullable types not supported in GetMmmReportResponseData".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetMmmReportResponseData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetMmmReportResponseData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GetMmmReportResponseData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetMmmReportResponseData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetMmmReportResponseData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetMmmReportResponseData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetMmmReportResponseData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoogleProductCategory0Filter {
    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_0")]
    pub google_product_category_0: models::CatalogsProductGroupMultipleStringListCriteria,

}


impl GoogleProductCategory0Filter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(google_product_category_0: models::CatalogsProductGroupMultipleStringListCriteria, ) -> GoogleProductCategory0Filter {
        GoogleProductCategory0Filter {
            google_product_category_0,
        }
    }
}

/// Converts the GoogleProductCategory0Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GoogleProductCategory0Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping GOOGLE_PRODUCT_CATEGORY_0 in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoogleProductCategory0Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoogleProductCategory0Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub google_product_category_0: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoogleProductCategory0Filter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "GOOGLE_PRODUCT_CATEGORY_0" => intermediate_rep.google_product_category_0.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoogleProductCategory0Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoogleProductCategory0Filter {
            google_product_category_0: intermediate_rep.google_product_category_0.into_iter().next().ok_or_else(|| "GOOGLE_PRODUCT_CATEGORY_0 missing in GoogleProductCategory0Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoogleProductCategory0Filter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GoogleProductCategory0Filter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoogleProductCategory0Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoogleProductCategory0Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GoogleProductCategory0Filter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoogleProductCategory0Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoogleProductCategory0Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoogleProductCategory1Filter {
    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_1")]
    pub google_product_category_1: models::CatalogsProductGroupMultipleStringListCriteria,

}


impl GoogleProductCategory1Filter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(google_product_category_1: models::CatalogsProductGroupMultipleStringListCriteria, ) -> GoogleProductCategory1Filter {
        GoogleProductCategory1Filter {
            google_product_category_1,
        }
    }
}

/// Converts the GoogleProductCategory1Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GoogleProductCategory1Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping GOOGLE_PRODUCT_CATEGORY_1 in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoogleProductCategory1Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoogleProductCategory1Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub google_product_category_1: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoogleProductCategory1Filter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "GOOGLE_PRODUCT_CATEGORY_1" => intermediate_rep.google_product_category_1.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoogleProductCategory1Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoogleProductCategory1Filter {
            google_product_category_1: intermediate_rep.google_product_category_1.into_iter().next().ok_or_else(|| "GOOGLE_PRODUCT_CATEGORY_1 missing in GoogleProductCategory1Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoogleProductCategory1Filter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GoogleProductCategory1Filter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoogleProductCategory1Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoogleProductCategory1Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GoogleProductCategory1Filter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoogleProductCategory1Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoogleProductCategory1Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoogleProductCategory2Filter {
    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_2")]
    pub google_product_category_2: models::CatalogsProductGroupMultipleStringListCriteria,

}


impl GoogleProductCategory2Filter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(google_product_category_2: models::CatalogsProductGroupMultipleStringListCriteria, ) -> GoogleProductCategory2Filter {
        GoogleProductCategory2Filter {
            google_product_category_2,
        }
    }
}

/// Converts the GoogleProductCategory2Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GoogleProductCategory2Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping GOOGLE_PRODUCT_CATEGORY_2 in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoogleProductCategory2Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoogleProductCategory2Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub google_product_category_2: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoogleProductCategory2Filter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "GOOGLE_PRODUCT_CATEGORY_2" => intermediate_rep.google_product_category_2.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoogleProductCategory2Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoogleProductCategory2Filter {
            google_product_category_2: intermediate_rep.google_product_category_2.into_iter().next().ok_or_else(|| "GOOGLE_PRODUCT_CATEGORY_2 missing in GoogleProductCategory2Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoogleProductCategory2Filter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GoogleProductCategory2Filter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoogleProductCategory2Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoogleProductCategory2Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GoogleProductCategory2Filter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoogleProductCategory2Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoogleProductCategory2Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoogleProductCategory3Filter {
    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_3")]
    pub google_product_category_3: models::CatalogsProductGroupMultipleStringListCriteria,

}


impl GoogleProductCategory3Filter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(google_product_category_3: models::CatalogsProductGroupMultipleStringListCriteria, ) -> GoogleProductCategory3Filter {
        GoogleProductCategory3Filter {
            google_product_category_3,
        }
    }
}

/// Converts the GoogleProductCategory3Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GoogleProductCategory3Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping GOOGLE_PRODUCT_CATEGORY_3 in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoogleProductCategory3Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoogleProductCategory3Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub google_product_category_3: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoogleProductCategory3Filter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "GOOGLE_PRODUCT_CATEGORY_3" => intermediate_rep.google_product_category_3.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoogleProductCategory3Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoogleProductCategory3Filter {
            google_product_category_3: intermediate_rep.google_product_category_3.into_iter().next().ok_or_else(|| "GOOGLE_PRODUCT_CATEGORY_3 missing in GoogleProductCategory3Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoogleProductCategory3Filter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GoogleProductCategory3Filter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoogleProductCategory3Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoogleProductCategory3Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GoogleProductCategory3Filter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoogleProductCategory3Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoogleProductCategory3Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoogleProductCategory4Filter {
    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_4")]
    pub google_product_category_4: models::CatalogsProductGroupMultipleStringListCriteria,

}


impl GoogleProductCategory4Filter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(google_product_category_4: models::CatalogsProductGroupMultipleStringListCriteria, ) -> GoogleProductCategory4Filter {
        GoogleProductCategory4Filter {
            google_product_category_4,
        }
    }
}

/// Converts the GoogleProductCategory4Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GoogleProductCategory4Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping GOOGLE_PRODUCT_CATEGORY_4 in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoogleProductCategory4Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoogleProductCategory4Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub google_product_category_4: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoogleProductCategory4Filter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "GOOGLE_PRODUCT_CATEGORY_4" => intermediate_rep.google_product_category_4.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoogleProductCategory4Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoogleProductCategory4Filter {
            google_product_category_4: intermediate_rep.google_product_category_4.into_iter().next().ok_or_else(|| "GOOGLE_PRODUCT_CATEGORY_4 missing in GoogleProductCategory4Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoogleProductCategory4Filter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GoogleProductCategory4Filter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoogleProductCategory4Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoogleProductCategory4Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GoogleProductCategory4Filter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoogleProductCategory4Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoogleProductCategory4Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoogleProductCategory5Filter {
    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_5")]
    pub google_product_category_5: models::CatalogsProductGroupMultipleStringListCriteria,

}


impl GoogleProductCategory5Filter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(google_product_category_5: models::CatalogsProductGroupMultipleStringListCriteria, ) -> GoogleProductCategory5Filter {
        GoogleProductCategory5Filter {
            google_product_category_5,
        }
    }
}

/// Converts the GoogleProductCategory5Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GoogleProductCategory5Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping GOOGLE_PRODUCT_CATEGORY_5 in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoogleProductCategory5Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoogleProductCategory5Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub google_product_category_5: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoogleProductCategory5Filter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "GOOGLE_PRODUCT_CATEGORY_5" => intermediate_rep.google_product_category_5.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoogleProductCategory5Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoogleProductCategory5Filter {
            google_product_category_5: intermediate_rep.google_product_category_5.into_iter().next().ok_or_else(|| "GOOGLE_PRODUCT_CATEGORY_5 missing in GoogleProductCategory5Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoogleProductCategory5Filter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GoogleProductCategory5Filter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoogleProductCategory5Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoogleProductCategory5Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GoogleProductCategory5Filter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoogleProductCategory5Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoogleProductCategory5Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoogleProductCategory6Filter {
    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_6")]
    pub google_product_category_6: models::CatalogsProductGroupMultipleStringListCriteria,

}


impl GoogleProductCategory6Filter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(google_product_category_6: models::CatalogsProductGroupMultipleStringListCriteria, ) -> GoogleProductCategory6Filter {
        GoogleProductCategory6Filter {
            google_product_category_6,
        }
    }
}

/// Converts the GoogleProductCategory6Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GoogleProductCategory6Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping GOOGLE_PRODUCT_CATEGORY_6 in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoogleProductCategory6Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoogleProductCategory6Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub google_product_category_6: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoogleProductCategory6Filter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "GOOGLE_PRODUCT_CATEGORY_6" => intermediate_rep.google_product_category_6.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoogleProductCategory6Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoogleProductCategory6Filter {
            google_product_category_6: intermediate_rep.google_product_category_6.into_iter().next().ok_or_else(|| "GOOGLE_PRODUCT_CATEGORY_6 missing in GoogleProductCategory6Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoogleProductCategory6Filter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GoogleProductCategory6Filter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoogleProductCategory6Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoogleProductCategory6Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GoogleProductCategory6Filter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoogleProductCategory6Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoogleProductCategory6Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Granularity
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum Granularity {
    #[serde(rename = "TOTAL")]
    Total,
    #[serde(rename = "DAY")]
    Day,
    #[serde(rename = "HOUR")]
    Hour,
    #[serde(rename = "WEEK")]
    Week,
    #[serde(rename = "MONTH")]
    Month,
}

impl std::fmt::Display for Granularity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Granularity::Total => write!(f, "TOTAL"),
            Granularity::Day => write!(f, "DAY"),
            Granularity::Hour => write!(f, "HOUR"),
            Granularity::Week => write!(f, "WEEK"),
            Granularity::Month => write!(f, "MONTH"),
        }
    }
}

impl std::str::FromStr for Granularity {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "TOTAL" => std::result::Result::Ok(Granularity::Total),
            "DAY" => std::result::Result::Ok(Granularity::Day),
            "HOUR" => std::result::Result::Ok(Granularity::Hour),
            "WEEK" => std::result::Result::Ok(Granularity::Week),
            "MONTH" => std::result::Result::Ok(Granularity::Month),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Where a user is taken after clicking on an ad in grid.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum GridClickType {
    #[serde(rename = "CLOSEUP")]
    Closeup,
    #[serde(rename = "DIRECT_TO_DESTINATION")]
    DirectToDestination,
}

impl std::fmt::Display for GridClickType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            GridClickType::Closeup => write!(f, "CLOSEUP"),
            GridClickType::DirectToDestination => write!(f, "DIRECT_TO_DESTINATION"),
        }
    }
}

impl std::str::FromStr for GridClickType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CLOSEUP" => std::result::Result::Ok(GridClickType::Closeup),
            "DIRECT_TO_DESTINATION" => std::result::Result::Ok(GridClickType::DirectToDestination),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HotelIdFilter {
    #[serde(rename = "HOTEL_ID")]
    pub hotel_id: models::CatalogsProductGroupMultipleStringCriteria,

}


impl HotelIdFilter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(hotel_id: models::CatalogsProductGroupMultipleStringCriteria, ) -> HotelIdFilter {
        HotelIdFilter {
            hotel_id,
        }
    }
}

/// Converts the HotelIdFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for HotelIdFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping HOTEL_ID in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HotelIdFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HotelIdFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hotel_id: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HotelIdFilter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "HOTEL_ID" => intermediate_rep.hotel_id.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing HotelIdFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HotelIdFilter {
            hotel_id: intermediate_rep.hotel_id.into_iter().next().ok_or_else(|| "HOTEL_ID missing in HotelIdFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HotelIdFilter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HotelIdFilter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HotelIdFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HotelIdFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HotelIdFilter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HotelIdFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HotelIdFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object describing an item processing record



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HotelProcessingRecord {
/// The catalog hotel id in the merchant namespace
    #[serde(rename = "hotel_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hotel_id: Option<String>,

/// Array with the validation errors for the item processing record. A non empty errors list causes the item processing to fail.
    #[serde(rename = "errors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<models::ItemValidationEvent>>,

/// Array with the validation warnings for the item processing record
    #[serde(rename = "warnings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warnings: Option<Vec<models::ItemValidationEvent>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ItemProcessingStatus>,

}


impl HotelProcessingRecord {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> HotelProcessingRecord {
        HotelProcessingRecord {
            hotel_id: None,
            errors: None,
            warnings: None,
            status: None,
        }
    }
}

/// Converts the HotelProcessingRecord value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for HotelProcessingRecord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.hotel_id.as_ref().map(|hotel_id| {
                [
                    "hotel_id".to_string(),
                    hotel_id.to_string(),
                ].join(",")
            }),

            // Skipping errors in query parameter serialization

            // Skipping warnings in query parameter serialization

            // Skipping status in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HotelProcessingRecord value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HotelProcessingRecord {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hotel_id: Vec<String>,
            pub errors: Vec<Vec<models::ItemValidationEvent>>,
            pub warnings: Vec<Vec<models::ItemValidationEvent>>,
            pub status: Vec<models::ItemProcessingStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HotelProcessingRecord".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "hotel_id" => intermediate_rep.hotel_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in HotelProcessingRecord".to_string()),
                    "warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in HotelProcessingRecord".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ItemProcessingStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing HotelProcessingRecord".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HotelProcessingRecord {
            hotel_id: intermediate_rep.hotel_id.into_iter().next(),
            errors: intermediate_rep.errors.into_iter().next(),
            warnings: intermediate_rep.warnings.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HotelProcessingRecord> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HotelProcessingRecord>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HotelProcessingRecord>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HotelProcessingRecord - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HotelProcessingRecord> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HotelProcessingRecord as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HotelProcessingRecord - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageDetails {
    #[serde(rename = "width")]
    #[validate(
            range(min = 100),
        )]
    pub width: u32,

    #[serde(rename = "height")]
    #[validate(
            range(min = 100),
        )]
    pub height: Nullable<u32>,

    #[serde(rename = "url")]
    pub url: String,

}


impl ImageDetails {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(width: u32, height: Nullable<u32>, url: String, ) -> ImageDetails {
        ImageDetails {
            width,
            height,
            url,
        }
    }
}

/// Converts the ImageDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ImageDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("width".to_string()),
            Some(self.width.to_string()),


            Some("height".to_string()),
            Some(self.height.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub width: Vec<u32>,
            pub height: Vec<u32>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageDetails".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "width" => intermediate_rep.width.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "height" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ImageDetails".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageDetails {
            width: intermediate_rep.width.into_iter().next().ok_or_else(|| "width missing in ImageDetails".to_string())?,
            height: std::result::Result::Err("Nullable types not supported in ImageDetails".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in ImageDetails".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageDetails> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageDetails>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageDetails - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImageDetails> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageDetails - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageMetadata {
    #[serde(rename = "item_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_type: Option<String>,

    #[serde(rename = "title")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<Nullable<String>>,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

    #[serde(rename = "link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link: Option<Nullable<String>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub images: Option<models::ImageMetadataImages>,

}


impl ImageMetadata {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ImageMetadata {
        ImageMetadata {
            item_type: None,
            title: None,
            description: None,
            link: None,
            images: None,
        }
    }
}

/// Converts the ImageMetadata value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ImageMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.item_type.as_ref().map(|item_type| {
                [
                    "item_type".to_string(),
                    item_type.to_string(),
                ].join(",")
            }),


            self.title.as_ref().map(|title| {
                [
                    "title".to_string(),
                    title.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.link.as_ref().map(|link| {
                [
                    "link".to_string(),
                    link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping images in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageMetadata value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageMetadata {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_type: Vec<String>,
            pub title: Vec<String>,
            pub description: Vec<String>,
            pub link: Vec<String>,
            pub images: Vec<models::ImageMetadataImages>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageMetadata".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "item_type" => intermediate_rep.item_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "title" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ImageMetadata".to_string()),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ImageMetadata".to_string()),
                    "link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ImageMetadata".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "images" => intermediate_rep.images.push(<models::ImageMetadataImages as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageMetadata".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageMetadata {
            item_type: intermediate_rep.item_type.into_iter().next(),
            title: std::result::Result::Err("Nullable types not supported in ImageMetadata".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in ImageMetadata".to_string())?,
            link: std::result::Result::Err("Nullable types not supported in ImageMetadata".to_string())?,
            images: intermediate_rep.images.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageMetadata> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageMetadata>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageMetadata>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageMetadata - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImageMetadata> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageMetadata as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageMetadata - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageMetadataImages {
    #[serde(rename = "150x150")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub param_150x150: Option<models::ImageDetails>,

    #[serde(rename = "400x300")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub param_400x300: Option<models::ImageDetails>,

    #[serde(rename = "600x")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub param_600x: Option<models::ImageDetails>,

    #[serde(rename = "1200x")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub param_1200x: Option<models::ImageDetails>,

}


impl ImageMetadataImages {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ImageMetadataImages {
        ImageMetadataImages {
            param_150x150: None,
            param_400x300: None,
            param_600x: None,
            param_1200x: None,
        }
    }
}

/// Converts the ImageMetadataImages value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ImageMetadataImages {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping 150x150 in query parameter serialization

            // Skipping 400x300 in query parameter serialization

            // Skipping 600x in query parameter serialization

            // Skipping 1200x in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageMetadataImages value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageMetadataImages {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub param_150x150: Vec<models::ImageDetails>,
            pub param_400x300: Vec<models::ImageDetails>,
            pub param_600x: Vec<models::ImageDetails>,
            pub param_1200x: Vec<models::ImageDetails>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageMetadataImages".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "150x150" => intermediate_rep.param_150x150.push(<models::ImageDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "400x300" => intermediate_rep.param_400x300.push(<models::ImageDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "600x" => intermediate_rep.param_600x.push(<models::ImageDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "1200x" => intermediate_rep.param_1200x.push(<models::ImageDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageMetadataImages".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageMetadataImages {
            param_150x150: intermediate_rep.param_150x150.into_iter().next(),
            param_400x300: intermediate_rep.param_400x300.into_iter().next(),
            param_600x: intermediate_rep.param_600x.into_iter().next(),
            param_1200x: intermediate_rep.param_1200x.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageMetadataImages> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageMetadataImages>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageMetadataImages>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageMetadataImages - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImageMetadataImages> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageMetadataImages as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageMetadataImages - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Schema for log sent from an integration application.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IntegrationLog {
/// Timestamp in milliseconds of when the log was executed at the client.
    #[serde(rename = "client_timestamp")]
    pub client_timestamp: i32,

/// Log event type
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event_type")]
    pub event_type: String,

/// Log level type
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "log_level")]
    pub log_level: String,

    #[serde(rename = "external_business_id")]
    #[validate(
            length(max = 2048),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_business_id: Option<Nullable<String>>,

    #[serde(rename = "advertiser_id")]
    #[validate(
            length(max = 128),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub advertiser_id: Option<Nullable<String>>,

    #[serde(rename = "merchant_id")]
    #[validate(
            length(max = 128),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub merchant_id: Option<Nullable<String>>,

    #[serde(rename = "tag_id")]
    #[validate(
            length(max = 128),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag_id: Option<Nullable<String>>,

    #[serde(rename = "feed_profile_id")]
    #[validate(
            length(max = 128),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feed_profile_id: Option<Nullable<String>>,

/// Explanation of the event that occured.
    #[serde(rename = "message")]
    #[validate(
            length(max = 2048),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

/// Version number of the integration application.
    #[serde(rename = "app_version_number")]
    #[validate(
            length(max = 20),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_version_number: Option<String>,

/// Version number of the platform the integration application is running on.
    #[serde(rename = "platform_version_number")]
    #[validate(
            length(max = 20),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub platform_version_number: Option<String>,

    #[serde(rename = "error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<models::IntegrationLogClientError>,

    #[serde(rename = "request")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub request: Option<models::IntegrationLogClientRequest>,

}


impl IntegrationLog {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(client_timestamp: i32, event_type: String, log_level: String, ) -> IntegrationLog {
        IntegrationLog {
            client_timestamp,
            event_type,
            log_level,
            external_business_id: None,
            advertiser_id: None,
            merchant_id: None,
            tag_id: None,
            feed_profile_id: None,
            message: None,
            app_version_number: None,
            platform_version_number: None,
            error: None,
            request: None,
        }
    }
}

/// Converts the IntegrationLog value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IntegrationLog {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("client_timestamp".to_string()),
            Some(self.client_timestamp.to_string()),


            Some("event_type".to_string()),
            Some(self.event_type.to_string()),


            Some("log_level".to_string()),
            Some(self.log_level.to_string()),


            self.external_business_id.as_ref().map(|external_business_id| {
                [
                    "external_business_id".to_string(),
                    external_business_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.advertiser_id.as_ref().map(|advertiser_id| {
                [
                    "advertiser_id".to_string(),
                    advertiser_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.merchant_id.as_ref().map(|merchant_id| {
                [
                    "merchant_id".to_string(),
                    merchant_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.tag_id.as_ref().map(|tag_id| {
                [
                    "tag_id".to_string(),
                    tag_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.feed_profile_id.as_ref().map(|feed_profile_id| {
                [
                    "feed_profile_id".to_string(),
                    feed_profile_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),


            self.app_version_number.as_ref().map(|app_version_number| {
                [
                    "app_version_number".to_string(),
                    app_version_number.to_string(),
                ].join(",")
            }),


            self.platform_version_number.as_ref().map(|platform_version_number| {
                [
                    "platform_version_number".to_string(),
                    platform_version_number.to_string(),
                ].join(",")
            }),

            // Skipping error in query parameter serialization

            // Skipping request in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IntegrationLog value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IntegrationLog {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub client_timestamp: Vec<i32>,
            pub event_type: Vec<String>,
            pub log_level: Vec<String>,
            pub external_business_id: Vec<String>,
            pub advertiser_id: Vec<String>,
            pub merchant_id: Vec<String>,
            pub tag_id: Vec<String>,
            pub feed_profile_id: Vec<String>,
            pub message: Vec<String>,
            pub app_version_number: Vec<String>,
            pub platform_version_number: Vec<String>,
            pub error: Vec<models::IntegrationLogClientError>,
            pub request: Vec<models::IntegrationLogClientRequest>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IntegrationLog".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "client_timestamp" => intermediate_rep.client_timestamp.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "event_type" => intermediate_rep.event_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "log_level" => intermediate_rep.log_level.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "external_business_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationLog".to_string()),
                    "advertiser_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationLog".to_string()),
                    "merchant_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationLog".to_string()),
                    "tag_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationLog".to_string()),
                    "feed_profile_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationLog".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "app_version_number" => intermediate_rep.app_version_number.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "platform_version_number" => intermediate_rep.platform_version_number.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(<models::IntegrationLogClientError as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "request" => intermediate_rep.request.push(<models::IntegrationLogClientRequest as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing IntegrationLog".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IntegrationLog {
            client_timestamp: intermediate_rep.client_timestamp.into_iter().next().ok_or_else(|| "client_timestamp missing in IntegrationLog".to_string())?,
            event_type: intermediate_rep.event_type.into_iter().next().ok_or_else(|| "event_type missing in IntegrationLog".to_string())?,
            log_level: intermediate_rep.log_level.into_iter().next().ok_or_else(|| "log_level missing in IntegrationLog".to_string())?,
            external_business_id: std::result::Result::Err("Nullable types not supported in IntegrationLog".to_string())?,
            advertiser_id: std::result::Result::Err("Nullable types not supported in IntegrationLog".to_string())?,
            merchant_id: std::result::Result::Err("Nullable types not supported in IntegrationLog".to_string())?,
            tag_id: std::result::Result::Err("Nullable types not supported in IntegrationLog".to_string())?,
            feed_profile_id: std::result::Result::Err("Nullable types not supported in IntegrationLog".to_string())?,
            message: intermediate_rep.message.into_iter().next(),
            app_version_number: intermediate_rep.app_version_number.into_iter().next(),
            platform_version_number: intermediate_rep.platform_version_number.into_iter().next(),
            error: intermediate_rep.error.into_iter().next(),
            request: intermediate_rep.request.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IntegrationLog> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IntegrationLog>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IntegrationLog>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IntegrationLog - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IntegrationLog> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IntegrationLog as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IntegrationLog - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// System error details included in the log sent by the client.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IntegrationLogClientError {
/// Original cause of the error.
    #[serde(rename = "cause")]
    #[validate(
            length(max = 512),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cause: Option<String>,

/// Column number in the line of the file that raised the error.
    #[serde(rename = "column_number")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub column_number: Option<i32>,

/// Filename where the error happened.
    #[serde(rename = "file_name")]
    #[validate(
            length(max = 256),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_name: Option<String>,

/// Line number where the error happened.
    #[serde(rename = "line_number")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub line_number: Option<i32>,

/// Human-readable description of the error.
    #[serde(rename = "message")]
    #[validate(
            length(max = 512),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

/// More detail about the message.
    #[serde(rename = "message_detail")]
    #[validate(
            length(max = 1024),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message_detail: Option<String>,

/// Filename where the error happened.
    #[serde(rename = "name")]
    #[validate(
            length(max = 256),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Integer that specifies the error code.
    #[serde(rename = "number")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i32>,

/// Stack trace of where the error happened.
    #[serde(rename = "stack_trace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stack_trace: Option<String>,

}


impl IntegrationLogClientError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> IntegrationLogClientError {
        IntegrationLogClientError {
            cause: None,
            column_number: None,
            file_name: None,
            line_number: None,
            message: None,
            message_detail: None,
            name: None,
            number: None,
            stack_trace: None,
        }
    }
}

/// Converts the IntegrationLogClientError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IntegrationLogClientError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.cause.as_ref().map(|cause| {
                [
                    "cause".to_string(),
                    cause.to_string(),
                ].join(",")
            }),


            self.column_number.as_ref().map(|column_number| {
                [
                    "column_number".to_string(),
                    column_number.to_string(),
                ].join(",")
            }),


            self.file_name.as_ref().map(|file_name| {
                [
                    "file_name".to_string(),
                    file_name.to_string(),
                ].join(",")
            }),


            self.line_number.as_ref().map(|line_number| {
                [
                    "line_number".to_string(),
                    line_number.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),


            self.message_detail.as_ref().map(|message_detail| {
                [
                    "message_detail".to_string(),
                    message_detail.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.number.as_ref().map(|number| {
                [
                    "number".to_string(),
                    number.to_string(),
                ].join(",")
            }),


            self.stack_trace.as_ref().map(|stack_trace| {
                [
                    "stack_trace".to_string(),
                    stack_trace.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IntegrationLogClientError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IntegrationLogClientError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cause: Vec<String>,
            pub column_number: Vec<i32>,
            pub file_name: Vec<String>,
            pub line_number: Vec<i32>,
            pub message: Vec<String>,
            pub message_detail: Vec<String>,
            pub name: Vec<String>,
            pub number: Vec<i32>,
            pub stack_trace: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IntegrationLogClientError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "column_number" => intermediate_rep.column_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_name" => intermediate_rep.file_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "line_number" => intermediate_rep.line_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message_detail" => intermediate_rep.message_detail.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "number" => intermediate_rep.number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stack_trace" => intermediate_rep.stack_trace.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing IntegrationLogClientError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IntegrationLogClientError {
            cause: intermediate_rep.cause.into_iter().next(),
            column_number: intermediate_rep.column_number.into_iter().next(),
            file_name: intermediate_rep.file_name.into_iter().next(),
            line_number: intermediate_rep.line_number.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            message_detail: intermediate_rep.message_detail.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            number: intermediate_rep.number.into_iter().next(),
            stack_trace: intermediate_rep.stack_trace.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IntegrationLogClientError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IntegrationLogClientError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IntegrationLogClientError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IntegrationLogClientError - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IntegrationLogClientError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IntegrationLogClientError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IntegrationLogClientError - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// HTTP request details included in the log sent by the client.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IntegrationLogClientRequest {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "method")]
    pub method: String,

/// HTTP request host from host header.
    #[serde(rename = "host")]
    pub host: String,

/// HTTP request path.
    #[serde(rename = "path")]
    pub path: String,

/// HTTP request headers as key-value pairs.
    #[serde(rename = "request_headers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub request_headers: Option<std::collections::HashMap<String, String>>,

/// HTTP response headers as key-value pairs.
    #[serde(rename = "response_headers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_headers: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "response_status_code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_status_code: Option<i32>,

}


impl IntegrationLogClientRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(method: String, host: String, path: String, ) -> IntegrationLogClientRequest {
        IntegrationLogClientRequest {
            method,
            host,
            path,
            request_headers: None,
            response_headers: None,
            response_status_code: None,
        }
    }
}

/// Converts the IntegrationLogClientRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IntegrationLogClientRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("method".to_string()),
            Some(self.method.to_string()),


            Some("host".to_string()),
            Some(self.host.to_string()),


            Some("path".to_string()),
            Some(self.path.to_string()),

            // Skipping request_headers in query parameter serialization

            // Skipping response_headers in query parameter serialization


            self.response_status_code.as_ref().map(|response_status_code| {
                [
                    "response_status_code".to_string(),
                    response_status_code.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IntegrationLogClientRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IntegrationLogClientRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub method: Vec<String>,
            pub host: Vec<String>,
            pub path: Vec<String>,
            pub request_headers: Vec<std::collections::HashMap<String, String>>,
            pub response_headers: Vec<std::collections::HashMap<String, String>>,
            pub response_status_code: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IntegrationLogClientRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "method" => intermediate_rep.method.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "host" => intermediate_rep.host.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "request_headers" => return std::result::Result::Err("Parsing a container in this style is not supported in IntegrationLogClientRequest".to_string()),
                    "response_headers" => return std::result::Result::Err("Parsing a container in this style is not supported in IntegrationLogClientRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "response_status_code" => intermediate_rep.response_status_code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing IntegrationLogClientRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IntegrationLogClientRequest {
            method: intermediate_rep.method.into_iter().next().ok_or_else(|| "method missing in IntegrationLogClientRequest".to_string())?,
            host: intermediate_rep.host.into_iter().next().ok_or_else(|| "host missing in IntegrationLogClientRequest".to_string())?,
            path: intermediate_rep.path.into_iter().next().ok_or_else(|| "path missing in IntegrationLogClientRequest".to_string())?,
            request_headers: intermediate_rep.request_headers.into_iter().next(),
            response_headers: intermediate_rep.response_headers.into_iter().next(),
            response_status_code: intermediate_rep.response_status_code.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IntegrationLogClientRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IntegrationLogClientRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IntegrationLogClientRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IntegrationLogClientRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IntegrationLogClientRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IntegrationLogClientRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IntegrationLogClientRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Schema describing the response when a log has invalid fields.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IntegrationLogsInvalidLogResponse {
    #[serde(rename = "rejected_logs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rejected_logs: Option<Vec<models::IntegrationLogsInvalidLogResponseRejectedLogsInner>>,

}


impl IntegrationLogsInvalidLogResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> IntegrationLogsInvalidLogResponse {
        IntegrationLogsInvalidLogResponse {
            rejected_logs: None,
        }
    }
}

/// Converts the IntegrationLogsInvalidLogResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IntegrationLogsInvalidLogResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping rejected_logs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IntegrationLogsInvalidLogResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IntegrationLogsInvalidLogResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub rejected_logs: Vec<Vec<models::IntegrationLogsInvalidLogResponseRejectedLogsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IntegrationLogsInvalidLogResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "rejected_logs" => return std::result::Result::Err("Parsing a container in this style is not supported in IntegrationLogsInvalidLogResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing IntegrationLogsInvalidLogResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IntegrationLogsInvalidLogResponse {
            rejected_logs: intermediate_rep.rejected_logs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IntegrationLogsInvalidLogResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IntegrationLogsInvalidLogResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IntegrationLogsInvalidLogResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IntegrationLogsInvalidLogResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IntegrationLogsInvalidLogResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IntegrationLogsInvalidLogResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IntegrationLogsInvalidLogResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IntegrationLogsInvalidLogResponseRejectedLogsInner {
/// Index of the log in the batch.
    #[serde(rename = "log_index")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub log_index: Option<i32>,

/// The field name containing an invalid value.
    #[serde(rename = "field")]
    pub field: String,

/// The value that is invalid.
    #[serde(rename = "value")]
    pub value: String,

/// The reason the value is invalid.
    #[serde(rename = "reason")]
    pub reason: String,

}


impl IntegrationLogsInvalidLogResponseRejectedLogsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(field: String, value: String, reason: String, ) -> IntegrationLogsInvalidLogResponseRejectedLogsInner {
        IntegrationLogsInvalidLogResponseRejectedLogsInner {
            log_index: None,
            field,
            value,
            reason,
        }
    }
}

/// Converts the IntegrationLogsInvalidLogResponseRejectedLogsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IntegrationLogsInvalidLogResponseRejectedLogsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.log_index.as_ref().map(|log_index| {
                [
                    "log_index".to_string(),
                    log_index.to_string(),
                ].join(",")
            }),


            Some("field".to_string()),
            Some(self.field.to_string()),


            Some("value".to_string()),
            Some(self.value.to_string()),


            Some("reason".to_string()),
            Some(self.reason.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IntegrationLogsInvalidLogResponseRejectedLogsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IntegrationLogsInvalidLogResponseRejectedLogsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub log_index: Vec<i32>,
            pub field: Vec<String>,
            pub value: Vec<String>,
            pub reason: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IntegrationLogsInvalidLogResponseRejectedLogsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "log_index" => intermediate_rep.log_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "field" => intermediate_rep.field.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing IntegrationLogsInvalidLogResponseRejectedLogsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IntegrationLogsInvalidLogResponseRejectedLogsInner {
            log_index: intermediate_rep.log_index.into_iter().next(),
            field: intermediate_rep.field.into_iter().next().ok_or_else(|| "field missing in IntegrationLogsInvalidLogResponseRejectedLogsInner".to_string())?,
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in IntegrationLogsInvalidLogResponseRejectedLogsInner".to_string())?,
            reason: intermediate_rep.reason.into_iter().next().ok_or_else(|| "reason missing in IntegrationLogsInvalidLogResponseRejectedLogsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IntegrationLogsInvalidLogResponseRejectedLogsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IntegrationLogsInvalidLogResponseRejectedLogsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IntegrationLogsInvalidLogResponseRejectedLogsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IntegrationLogsInvalidLogResponseRejectedLogsInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IntegrationLogsInvalidLogResponseRejectedLogsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IntegrationLogsInvalidLogResponseRejectedLogsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IntegrationLogsInvalidLogResponseRejectedLogsInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Batch of logs sent from an integration application.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IntegrationLogsRequest {
    #[serde(rename = "logs")]
    pub logs: Vec<models::IntegrationLog>,

}


impl IntegrationLogsRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(logs: Vec<models::IntegrationLog>, ) -> IntegrationLogsRequest {
        IntegrationLogsRequest {
            logs,
        }
    }
}

/// Converts the IntegrationLogsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IntegrationLogsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping logs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IntegrationLogsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IntegrationLogsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub logs: Vec<Vec<models::IntegrationLog>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IntegrationLogsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "logs" => return std::result::Result::Err("Parsing a container in this style is not supported in IntegrationLogsRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing IntegrationLogsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IntegrationLogsRequest {
            logs: intermediate_rep.logs.into_iter().next().ok_or_else(|| "logs missing in IntegrationLogsRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IntegrationLogsRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IntegrationLogsRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IntegrationLogsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IntegrationLogsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IntegrationLogsRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IntegrationLogsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IntegrationLogsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Response when logs are successfully processed.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IntegrationLogsSuccessResponse {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

}


impl IntegrationLogsSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> IntegrationLogsSuccessResponse {
        IntegrationLogsSuccessResponse {
            message: None,
        }
    }
}

/// Converts the IntegrationLogsSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IntegrationLogsSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IntegrationLogsSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IntegrationLogsSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IntegrationLogsSuccessResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing IntegrationLogsSuccessResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IntegrationLogsSuccessResponse {
            message: intermediate_rep.message.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IntegrationLogsSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IntegrationLogsSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IntegrationLogsSuccessResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IntegrationLogsSuccessResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IntegrationLogsSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IntegrationLogsSuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IntegrationLogsSuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Integration metadata



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IntegrationMetadata {
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_INTEGRATIONMETADATA_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "external_business_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_business_id: Option<String>,

    #[serde(rename = "connected_merchant_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_merchant_id: Option<String>,

    #[serde(rename = "connected_user_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_user_id: Option<String>,

    #[serde(rename = "connected_advertiser_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_advertiser_id: Option<String>,

    #[serde(rename = "connected_lba_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_lba_id: Option<String>,

    #[serde(rename = "connected_tag_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_tag_id: Option<String>,

    #[serde(rename = "partner_access_token_expiry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_access_token_expiry: Option<f64>,

    #[serde(rename = "partner_refresh_token_expiry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_refresh_token_expiry: Option<f64>,

    #[serde(rename = "scopes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scopes: Option<String>,

    #[serde(rename = "created_timestamp")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_timestamp: Option<f64>,

    #[serde(rename = "updated_timestamp")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_timestamp: Option<f64>,

    #[serde(rename = "additional_id_1")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_id_1: Option<String>,

    #[serde(rename = "partner_metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_metadata: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_INTEGRATIONMETADATA_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl IntegrationMetadata {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> IntegrationMetadata {
        IntegrationMetadata {
            id: None,
            external_business_id: None,
            connected_merchant_id: None,
            connected_user_id: None,
            connected_advertiser_id: None,
            connected_lba_id: None,
            connected_tag_id: None,
            partner_access_token_expiry: None,
            partner_refresh_token_expiry: None,
            scopes: None,
            created_timestamp: None,
            updated_timestamp: None,
            additional_id_1: None,
            partner_metadata: None,
        }
    }
}

/// Converts the IntegrationMetadata value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IntegrationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.external_business_id.as_ref().map(|external_business_id| {
                [
                    "external_business_id".to_string(),
                    external_business_id.to_string(),
                ].join(",")
            }),


            self.connected_merchant_id.as_ref().map(|connected_merchant_id| {
                [
                    "connected_merchant_id".to_string(),
                    connected_merchant_id.to_string(),
                ].join(",")
            }),


            self.connected_user_id.as_ref().map(|connected_user_id| {
                [
                    "connected_user_id".to_string(),
                    connected_user_id.to_string(),
                ].join(",")
            }),


            self.connected_advertiser_id.as_ref().map(|connected_advertiser_id| {
                [
                    "connected_advertiser_id".to_string(),
                    connected_advertiser_id.to_string(),
                ].join(",")
            }),


            self.connected_lba_id.as_ref().map(|connected_lba_id| {
                [
                    "connected_lba_id".to_string(),
                    connected_lba_id.to_string(),
                ].join(",")
            }),


            self.connected_tag_id.as_ref().map(|connected_tag_id| {
                [
                    "connected_tag_id".to_string(),
                    connected_tag_id.to_string(),
                ].join(",")
            }),


            self.partner_access_token_expiry.as_ref().map(|partner_access_token_expiry| {
                [
                    "partner_access_token_expiry".to_string(),
                    partner_access_token_expiry.to_string(),
                ].join(",")
            }),


            self.partner_refresh_token_expiry.as_ref().map(|partner_refresh_token_expiry| {
                [
                    "partner_refresh_token_expiry".to_string(),
                    partner_refresh_token_expiry.to_string(),
                ].join(",")
            }),


            self.scopes.as_ref().map(|scopes| {
                [
                    "scopes".to_string(),
                    scopes.to_string(),
                ].join(",")
            }),


            self.created_timestamp.as_ref().map(|created_timestamp| {
                [
                    "created_timestamp".to_string(),
                    created_timestamp.to_string(),
                ].join(",")
            }),


            self.updated_timestamp.as_ref().map(|updated_timestamp| {
                [
                    "updated_timestamp".to_string(),
                    updated_timestamp.to_string(),
                ].join(",")
            }),


            self.additional_id_1.as_ref().map(|additional_id_1| {
                [
                    "additional_id_1".to_string(),
                    additional_id_1.to_string(),
                ].join(",")
            }),


            self.partner_metadata.as_ref().map(|partner_metadata| {
                [
                    "partner_metadata".to_string(),
                    partner_metadata.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IntegrationMetadata value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IntegrationMetadata {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub external_business_id: Vec<String>,
            pub connected_merchant_id: Vec<String>,
            pub connected_user_id: Vec<String>,
            pub connected_advertiser_id: Vec<String>,
            pub connected_lba_id: Vec<String>,
            pub connected_tag_id: Vec<String>,
            pub partner_access_token_expiry: Vec<f64>,
            pub partner_refresh_token_expiry: Vec<f64>,
            pub scopes: Vec<String>,
            pub created_timestamp: Vec<f64>,
            pub updated_timestamp: Vec<f64>,
            pub additional_id_1: Vec<String>,
            pub partner_metadata: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IntegrationMetadata".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "external_business_id" => intermediate_rep.external_business_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connected_merchant_id" => intermediate_rep.connected_merchant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connected_user_id" => intermediate_rep.connected_user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connected_advertiser_id" => intermediate_rep.connected_advertiser_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connected_lba_id" => intermediate_rep.connected_lba_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connected_tag_id" => intermediate_rep.connected_tag_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partner_access_token_expiry" => intermediate_rep.partner_access_token_expiry.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partner_refresh_token_expiry" => intermediate_rep.partner_refresh_token_expiry.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scopes" => intermediate_rep.scopes.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_timestamp" => intermediate_rep.created_timestamp.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updated_timestamp" => intermediate_rep.updated_timestamp.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "additional_id_1" => intermediate_rep.additional_id_1.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partner_metadata" => intermediate_rep.partner_metadata.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing IntegrationMetadata".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IntegrationMetadata {
            id: intermediate_rep.id.into_iter().next(),
            external_business_id: intermediate_rep.external_business_id.into_iter().next(),
            connected_merchant_id: intermediate_rep.connected_merchant_id.into_iter().next(),
            connected_user_id: intermediate_rep.connected_user_id.into_iter().next(),
            connected_advertiser_id: intermediate_rep.connected_advertiser_id.into_iter().next(),
            connected_lba_id: intermediate_rep.connected_lba_id.into_iter().next(),
            connected_tag_id: intermediate_rep.connected_tag_id.into_iter().next(),
            partner_access_token_expiry: intermediate_rep.partner_access_token_expiry.into_iter().next(),
            partner_refresh_token_expiry: intermediate_rep.partner_refresh_token_expiry.into_iter().next(),
            scopes: intermediate_rep.scopes.into_iter().next(),
            created_timestamp: intermediate_rep.created_timestamp.into_iter().next(),
            updated_timestamp: intermediate_rep.updated_timestamp.into_iter().next(),
            additional_id_1: intermediate_rep.additional_id_1.into_iter().next(),
            partner_metadata: intermediate_rep.partner_metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IntegrationMetadata> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IntegrationMetadata>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IntegrationMetadata>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IntegrationMetadata - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IntegrationMetadata> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IntegrationMetadata as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IntegrationMetadata - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Integration record



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IntegrationRecord {
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_INTEGRATIONRECORD_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "external_business_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_business_id: Option<Nullable<String>>,

    #[serde(rename = "connected_merchant_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_merchant_id: Option<Nullable<String>>,

    #[serde(rename = "connected_user_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_user_id: Option<String>,

    #[serde(rename = "connected_advertiser_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_advertiser_id: Option<Nullable<String>>,

    #[serde(rename = "connected_lba_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_lba_id: Option<Nullable<String>>,

    #[serde(rename = "connected_tag_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_tag_id: Option<Nullable<String>>,

    #[serde(rename = "partner_access_token")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_access_token: Option<Nullable<String>>,

    #[serde(rename = "partner_refresh_token")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_refresh_token: Option<Nullable<String>>,

    #[serde(rename = "partner_primary_email")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_primary_email: Option<Nullable<String>>,

    #[serde(rename = "partner_access_token_expiry")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_access_token_expiry: Option<Nullable<i32>>,

    #[serde(rename = "partner_refresh_token_expiry")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_refresh_token_expiry: Option<Nullable<i32>>,

    #[serde(rename = "scopes")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scopes: Option<Nullable<String>>,

    #[serde(rename = "partner_metadata")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_metadata: Option<Nullable<String>>,

    #[serde(rename = "additional_id_1")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_id_1: Option<Nullable<String>>,

    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<i32>,

    #[serde(rename = "updated_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_time: Option<i32>,

}

lazy_static::lazy_static! {
    static ref RE_INTEGRATIONRECORD_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl IntegrationRecord {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> IntegrationRecord {
        IntegrationRecord {
            id: None,
            external_business_id: None,
            connected_merchant_id: None,
            connected_user_id: None,
            connected_advertiser_id: None,
            connected_lba_id: None,
            connected_tag_id: None,
            partner_access_token: None,
            partner_refresh_token: None,
            partner_primary_email: None,
            partner_access_token_expiry: None,
            partner_refresh_token_expiry: None,
            scopes: None,
            partner_metadata: None,
            additional_id_1: None,
            created_time: None,
            updated_time: None,
        }
    }
}

/// Converts the IntegrationRecord value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IntegrationRecord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.external_business_id.as_ref().map(|external_business_id| {
                [
                    "external_business_id".to_string(),
                    external_business_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.connected_merchant_id.as_ref().map(|connected_merchant_id| {
                [
                    "connected_merchant_id".to_string(),
                    connected_merchant_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.connected_user_id.as_ref().map(|connected_user_id| {
                [
                    "connected_user_id".to_string(),
                    connected_user_id.to_string(),
                ].join(",")
            }),


            self.connected_advertiser_id.as_ref().map(|connected_advertiser_id| {
                [
                    "connected_advertiser_id".to_string(),
                    connected_advertiser_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.connected_lba_id.as_ref().map(|connected_lba_id| {
                [
                    "connected_lba_id".to_string(),
                    connected_lba_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.connected_tag_id.as_ref().map(|connected_tag_id| {
                [
                    "connected_tag_id".to_string(),
                    connected_tag_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.partner_access_token.as_ref().map(|partner_access_token| {
                [
                    "partner_access_token".to_string(),
                    partner_access_token.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.partner_refresh_token.as_ref().map(|partner_refresh_token| {
                [
                    "partner_refresh_token".to_string(),
                    partner_refresh_token.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.partner_primary_email.as_ref().map(|partner_primary_email| {
                [
                    "partner_primary_email".to_string(),
                    partner_primary_email.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.partner_access_token_expiry.as_ref().map(|partner_access_token_expiry| {
                [
                    "partner_access_token_expiry".to_string(),
                    partner_access_token_expiry.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.partner_refresh_token_expiry.as_ref().map(|partner_refresh_token_expiry| {
                [
                    "partner_refresh_token_expiry".to_string(),
                    partner_refresh_token_expiry.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.scopes.as_ref().map(|scopes| {
                [
                    "scopes".to_string(),
                    scopes.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.partner_metadata.as_ref().map(|partner_metadata| {
                [
                    "partner_metadata".to_string(),
                    partner_metadata.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.additional_id_1.as_ref().map(|additional_id_1| {
                [
                    "additional_id_1".to_string(),
                    additional_id_1.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.created_time.as_ref().map(|created_time| {
                [
                    "created_time".to_string(),
                    created_time.to_string(),
                ].join(",")
            }),


            self.updated_time.as_ref().map(|updated_time| {
                [
                    "updated_time".to_string(),
                    updated_time.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IntegrationRecord value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IntegrationRecord {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub external_business_id: Vec<String>,
            pub connected_merchant_id: Vec<String>,
            pub connected_user_id: Vec<String>,
            pub connected_advertiser_id: Vec<String>,
            pub connected_lba_id: Vec<String>,
            pub connected_tag_id: Vec<String>,
            pub partner_access_token: Vec<String>,
            pub partner_refresh_token: Vec<String>,
            pub partner_primary_email: Vec<String>,
            pub partner_access_token_expiry: Vec<i32>,
            pub partner_refresh_token_expiry: Vec<i32>,
            pub scopes: Vec<String>,
            pub partner_metadata: Vec<String>,
            pub additional_id_1: Vec<String>,
            pub created_time: Vec<i32>,
            pub updated_time: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IntegrationRecord".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "external_business_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationRecord".to_string()),
                    "connected_merchant_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationRecord".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "connected_user_id" => intermediate_rep.connected_user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "connected_advertiser_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationRecord".to_string()),
                    "connected_lba_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationRecord".to_string()),
                    "connected_tag_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationRecord".to_string()),
                    "partner_access_token" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationRecord".to_string()),
                    "partner_refresh_token" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationRecord".to_string()),
                    "partner_primary_email" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationRecord".to_string()),
                    "partner_access_token_expiry" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationRecord".to_string()),
                    "partner_refresh_token_expiry" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationRecord".to_string()),
                    "scopes" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationRecord".to_string()),
                    "partner_metadata" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationRecord".to_string()),
                    "additional_id_1" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationRecord".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "created_time" => intermediate_rep.created_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updated_time" => intermediate_rep.updated_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing IntegrationRecord".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IntegrationRecord {
            id: intermediate_rep.id.into_iter().next(),
            external_business_id: std::result::Result::Err("Nullable types not supported in IntegrationRecord".to_string())?,
            connected_merchant_id: std::result::Result::Err("Nullable types not supported in IntegrationRecord".to_string())?,
            connected_user_id: intermediate_rep.connected_user_id.into_iter().next(),
            connected_advertiser_id: std::result::Result::Err("Nullable types not supported in IntegrationRecord".to_string())?,
            connected_lba_id: std::result::Result::Err("Nullable types not supported in IntegrationRecord".to_string())?,
            connected_tag_id: std::result::Result::Err("Nullable types not supported in IntegrationRecord".to_string())?,
            partner_access_token: std::result::Result::Err("Nullable types not supported in IntegrationRecord".to_string())?,
            partner_refresh_token: std::result::Result::Err("Nullable types not supported in IntegrationRecord".to_string())?,
            partner_primary_email: std::result::Result::Err("Nullable types not supported in IntegrationRecord".to_string())?,
            partner_access_token_expiry: std::result::Result::Err("Nullable types not supported in IntegrationRecord".to_string())?,
            partner_refresh_token_expiry: std::result::Result::Err("Nullable types not supported in IntegrationRecord".to_string())?,
            scopes: std::result::Result::Err("Nullable types not supported in IntegrationRecord".to_string())?,
            partner_metadata: std::result::Result::Err("Nullable types not supported in IntegrationRecord".to_string())?,
            additional_id_1: std::result::Result::Err("Nullable types not supported in IntegrationRecord".to_string())?,
            created_time: intermediate_rep.created_time.into_iter().next(),
            updated_time: intermediate_rep.updated_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IntegrationRecord> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IntegrationRecord>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IntegrationRecord>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IntegrationRecord - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IntegrationRecord> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IntegrationRecord as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IntegrationRecord - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Schema used for creating the integration metadata.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IntegrationRequest {
/// External business ID for the integration.
    #[serde(rename = "external_business_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_business_id: Option<Nullable<String>>,

    #[serde(rename = "connected_merchant_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_merchant_id: Option<String>,

    #[serde(rename = "connected_advertiser_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_advertiser_id: Option<String>,

    #[serde(rename = "connected_lba_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_lba_id: Option<String>,

    #[serde(rename = "connected_tag_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_tag_id: Option<String>,

    #[serde(rename = "partner_access_token")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_access_token: Option<String>,

    #[serde(rename = "partner_refresh_token")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_refresh_token: Option<String>,

    #[serde(rename = "partner_primary_email")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_primary_email: Option<String>,

    #[serde(rename = "partner_access_token_expiry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_access_token_expiry: Option<i32>,

    #[serde(rename = "partner_refresh_token_expiry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_refresh_token_expiry: Option<i32>,

    #[serde(rename = "scopes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scopes: Option<String>,

    #[serde(rename = "additional_id_1")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_id_1: Option<String>,

    #[serde(rename = "partner_metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_metadata: Option<String>,

}


impl IntegrationRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> IntegrationRequest {
        IntegrationRequest {
            external_business_id: None,
            connected_merchant_id: None,
            connected_advertiser_id: None,
            connected_lba_id: None,
            connected_tag_id: None,
            partner_access_token: None,
            partner_refresh_token: None,
            partner_primary_email: None,
            partner_access_token_expiry: None,
            partner_refresh_token_expiry: None,
            scopes: None,
            additional_id_1: None,
            partner_metadata: None,
        }
    }
}

/// Converts the IntegrationRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IntegrationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.external_business_id.as_ref().map(|external_business_id| {
                [
                    "external_business_id".to_string(),
                    external_business_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.connected_merchant_id.as_ref().map(|connected_merchant_id| {
                [
                    "connected_merchant_id".to_string(),
                    connected_merchant_id.to_string(),
                ].join(",")
            }),


            self.connected_advertiser_id.as_ref().map(|connected_advertiser_id| {
                [
                    "connected_advertiser_id".to_string(),
                    connected_advertiser_id.to_string(),
                ].join(",")
            }),


            self.connected_lba_id.as_ref().map(|connected_lba_id| {
                [
                    "connected_lba_id".to_string(),
                    connected_lba_id.to_string(),
                ].join(",")
            }),


            self.connected_tag_id.as_ref().map(|connected_tag_id| {
                [
                    "connected_tag_id".to_string(),
                    connected_tag_id.to_string(),
                ].join(",")
            }),


            self.partner_access_token.as_ref().map(|partner_access_token| {
                [
                    "partner_access_token".to_string(),
                    partner_access_token.to_string(),
                ].join(",")
            }),


            self.partner_refresh_token.as_ref().map(|partner_refresh_token| {
                [
                    "partner_refresh_token".to_string(),
                    partner_refresh_token.to_string(),
                ].join(",")
            }),


            self.partner_primary_email.as_ref().map(|partner_primary_email| {
                [
                    "partner_primary_email".to_string(),
                    partner_primary_email.to_string(),
                ].join(",")
            }),


            self.partner_access_token_expiry.as_ref().map(|partner_access_token_expiry| {
                [
                    "partner_access_token_expiry".to_string(),
                    partner_access_token_expiry.to_string(),
                ].join(",")
            }),


            self.partner_refresh_token_expiry.as_ref().map(|partner_refresh_token_expiry| {
                [
                    "partner_refresh_token_expiry".to_string(),
                    partner_refresh_token_expiry.to_string(),
                ].join(",")
            }),


            self.scopes.as_ref().map(|scopes| {
                [
                    "scopes".to_string(),
                    scopes.to_string(),
                ].join(",")
            }),


            self.additional_id_1.as_ref().map(|additional_id_1| {
                [
                    "additional_id_1".to_string(),
                    additional_id_1.to_string(),
                ].join(",")
            }),


            self.partner_metadata.as_ref().map(|partner_metadata| {
                [
                    "partner_metadata".to_string(),
                    partner_metadata.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IntegrationRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IntegrationRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub external_business_id: Vec<String>,
            pub connected_merchant_id: Vec<String>,
            pub connected_advertiser_id: Vec<String>,
            pub connected_lba_id: Vec<String>,
            pub connected_tag_id: Vec<String>,
            pub partner_access_token: Vec<String>,
            pub partner_refresh_token: Vec<String>,
            pub partner_primary_email: Vec<String>,
            pub partner_access_token_expiry: Vec<i32>,
            pub partner_refresh_token_expiry: Vec<i32>,
            pub scopes: Vec<String>,
            pub additional_id_1: Vec<String>,
            pub partner_metadata: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IntegrationRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "external_business_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "connected_merchant_id" => intermediate_rep.connected_merchant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connected_advertiser_id" => intermediate_rep.connected_advertiser_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connected_lba_id" => intermediate_rep.connected_lba_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connected_tag_id" => intermediate_rep.connected_tag_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partner_access_token" => intermediate_rep.partner_access_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partner_refresh_token" => intermediate_rep.partner_refresh_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partner_primary_email" => intermediate_rep.partner_primary_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partner_access_token_expiry" => intermediate_rep.partner_access_token_expiry.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partner_refresh_token_expiry" => intermediate_rep.partner_refresh_token_expiry.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scopes" => intermediate_rep.scopes.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "additional_id_1" => intermediate_rep.additional_id_1.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partner_metadata" => intermediate_rep.partner_metadata.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing IntegrationRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IntegrationRequest {
            external_business_id: std::result::Result::Err("Nullable types not supported in IntegrationRequest".to_string())?,
            connected_merchant_id: intermediate_rep.connected_merchant_id.into_iter().next(),
            connected_advertiser_id: intermediate_rep.connected_advertiser_id.into_iter().next(),
            connected_lba_id: intermediate_rep.connected_lba_id.into_iter().next(),
            connected_tag_id: intermediate_rep.connected_tag_id.into_iter().next(),
            partner_access_token: intermediate_rep.partner_access_token.into_iter().next(),
            partner_refresh_token: intermediate_rep.partner_refresh_token.into_iter().next(),
            partner_primary_email: intermediate_rep.partner_primary_email.into_iter().next(),
            partner_access_token_expiry: intermediate_rep.partner_access_token_expiry.into_iter().next(),
            partner_refresh_token_expiry: intermediate_rep.partner_refresh_token_expiry.into_iter().next(),
            scopes: intermediate_rep.scopes.into_iter().next(),
            additional_id_1: intermediate_rep.additional_id_1.into_iter().next(),
            partner_metadata: intermediate_rep.partner_metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IntegrationRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IntegrationRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IntegrationRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IntegrationRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IntegrationRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IntegrationRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IntegrationRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Schema used for updating the integration metadata.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IntegrationRequestPatch {
    #[serde(rename = "connected_merchant_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_merchant_id: Option<String>,

    #[serde(rename = "connected_advertiser_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_advertiser_id: Option<String>,

    #[serde(rename = "connected_lba_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_lba_id: Option<String>,

    #[serde(rename = "connected_tag_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub connected_tag_id: Option<String>,

    #[serde(rename = "partner_access_token")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_access_token: Option<String>,

    #[serde(rename = "partner_refresh_token")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_refresh_token: Option<String>,

    #[serde(rename = "partner_primary_email")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_primary_email: Option<String>,

    #[serde(rename = "partner_access_token_expiry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_access_token_expiry: Option<f64>,

    #[serde(rename = "partner_refresh_token_expiry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_refresh_token_expiry: Option<f64>,

    #[serde(rename = "scopes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scopes: Option<String>,

    #[serde(rename = "additional_id_1")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_id_1: Option<String>,

    #[serde(rename = "partner_metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub partner_metadata: Option<String>,

}


impl IntegrationRequestPatch {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> IntegrationRequestPatch {
        IntegrationRequestPatch {
            connected_merchant_id: None,
            connected_advertiser_id: None,
            connected_lba_id: None,
            connected_tag_id: None,
            partner_access_token: None,
            partner_refresh_token: None,
            partner_primary_email: None,
            partner_access_token_expiry: None,
            partner_refresh_token_expiry: None,
            scopes: None,
            additional_id_1: None,
            partner_metadata: None,
        }
    }
}

/// Converts the IntegrationRequestPatch value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IntegrationRequestPatch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.connected_merchant_id.as_ref().map(|connected_merchant_id| {
                [
                    "connected_merchant_id".to_string(),
                    connected_merchant_id.to_string(),
                ].join(",")
            }),


            self.connected_advertiser_id.as_ref().map(|connected_advertiser_id| {
                [
                    "connected_advertiser_id".to_string(),
                    connected_advertiser_id.to_string(),
                ].join(",")
            }),


            self.connected_lba_id.as_ref().map(|connected_lba_id| {
                [
                    "connected_lba_id".to_string(),
                    connected_lba_id.to_string(),
                ].join(",")
            }),


            self.connected_tag_id.as_ref().map(|connected_tag_id| {
                [
                    "connected_tag_id".to_string(),
                    connected_tag_id.to_string(),
                ].join(",")
            }),


            self.partner_access_token.as_ref().map(|partner_access_token| {
                [
                    "partner_access_token".to_string(),
                    partner_access_token.to_string(),
                ].join(",")
            }),


            self.partner_refresh_token.as_ref().map(|partner_refresh_token| {
                [
                    "partner_refresh_token".to_string(),
                    partner_refresh_token.to_string(),
                ].join(",")
            }),


            self.partner_primary_email.as_ref().map(|partner_primary_email| {
                [
                    "partner_primary_email".to_string(),
                    partner_primary_email.to_string(),
                ].join(",")
            }),


            self.partner_access_token_expiry.as_ref().map(|partner_access_token_expiry| {
                [
                    "partner_access_token_expiry".to_string(),
                    partner_access_token_expiry.to_string(),
                ].join(",")
            }),


            self.partner_refresh_token_expiry.as_ref().map(|partner_refresh_token_expiry| {
                [
                    "partner_refresh_token_expiry".to_string(),
                    partner_refresh_token_expiry.to_string(),
                ].join(",")
            }),


            self.scopes.as_ref().map(|scopes| {
                [
                    "scopes".to_string(),
                    scopes.to_string(),
                ].join(",")
            }),


            self.additional_id_1.as_ref().map(|additional_id_1| {
                [
                    "additional_id_1".to_string(),
                    additional_id_1.to_string(),
                ].join(",")
            }),


            self.partner_metadata.as_ref().map(|partner_metadata| {
                [
                    "partner_metadata".to_string(),
                    partner_metadata.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IntegrationRequestPatch value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IntegrationRequestPatch {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub connected_merchant_id: Vec<String>,
            pub connected_advertiser_id: Vec<String>,
            pub connected_lba_id: Vec<String>,
            pub connected_tag_id: Vec<String>,
            pub partner_access_token: Vec<String>,
            pub partner_refresh_token: Vec<String>,
            pub partner_primary_email: Vec<String>,
            pub partner_access_token_expiry: Vec<f64>,
            pub partner_refresh_token_expiry: Vec<f64>,
            pub scopes: Vec<String>,
            pub additional_id_1: Vec<String>,
            pub partner_metadata: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IntegrationRequestPatch".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "connected_merchant_id" => intermediate_rep.connected_merchant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connected_advertiser_id" => intermediate_rep.connected_advertiser_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connected_lba_id" => intermediate_rep.connected_lba_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "connected_tag_id" => intermediate_rep.connected_tag_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partner_access_token" => intermediate_rep.partner_access_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partner_refresh_token" => intermediate_rep.partner_refresh_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partner_primary_email" => intermediate_rep.partner_primary_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partner_access_token_expiry" => intermediate_rep.partner_access_token_expiry.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partner_refresh_token_expiry" => intermediate_rep.partner_refresh_token_expiry.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scopes" => intermediate_rep.scopes.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "additional_id_1" => intermediate_rep.additional_id_1.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "partner_metadata" => intermediate_rep.partner_metadata.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing IntegrationRequestPatch".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IntegrationRequestPatch {
            connected_merchant_id: intermediate_rep.connected_merchant_id.into_iter().next(),
            connected_advertiser_id: intermediate_rep.connected_advertiser_id.into_iter().next(),
            connected_lba_id: intermediate_rep.connected_lba_id.into_iter().next(),
            connected_tag_id: intermediate_rep.connected_tag_id.into_iter().next(),
            partner_access_token: intermediate_rep.partner_access_token.into_iter().next(),
            partner_refresh_token: intermediate_rep.partner_refresh_token.into_iter().next(),
            partner_primary_email: intermediate_rep.partner_primary_email.into_iter().next(),
            partner_access_token_expiry: intermediate_rep.partner_access_token_expiry.into_iter().next(),
            partner_refresh_token_expiry: intermediate_rep.partner_refresh_token_expiry.into_iter().next(),
            scopes: intermediate_rep.scopes.into_iter().next(),
            additional_id_1: intermediate_rep.additional_id_1.into_iter().next(),
            partner_metadata: intermediate_rep.partner_metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IntegrationRequestPatch> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IntegrationRequestPatch>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IntegrationRequestPatch>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IntegrationRequestPatch - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IntegrationRequestPatch> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IntegrationRequestPatch as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IntegrationRequestPatch - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IntegrationsGetList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::IntegrationRecord>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl IntegrationsGetList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::IntegrationRecord>, ) -> IntegrationsGetList200Response {
        IntegrationsGetList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the IntegrationsGetList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IntegrationsGetList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IntegrationsGetList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IntegrationsGetList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::IntegrationRecord>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IntegrationsGetList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in IntegrationsGetList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in IntegrationsGetList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing IntegrationsGetList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IntegrationsGetList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in IntegrationsGetList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in IntegrationsGetList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IntegrationsGetList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IntegrationsGetList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IntegrationsGetList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IntegrationsGetList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IntegrationsGetList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IntegrationsGetList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IntegrationsGetList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Interest {
    #[serde(rename = "canonical_url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub canonical_url: Option<String>,

    #[serde(rename = "id")]
    #[validate(
           regex = "RE_INTEREST_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_INTEREST_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl Interest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Interest {
        Interest {
            canonical_url: None,
            id: None,
            key: None,
            name: None,
        }
    }
}

/// Converts the Interest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Interest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.canonical_url.as_ref().map(|canonical_url| {
                [
                    "canonical_url".to_string(),
                    canonical_url.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.key.as_ref().map(|key| {
                [
                    "key".to_string(),
                    key.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Interest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Interest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub canonical_url: Vec<String>,
            pub id: Vec<String>,
            pub key: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Interest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "canonical_url" => intermediate_rep.canonical_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Interest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Interest {
            canonical_url: intermediate_rep.canonical_url.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            key: intermediate_rep.key.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Interest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Interest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Interest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Interest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Interest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Interest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Interest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemAttributes {
/// Allows advertisers to specify a separate URL that can be used to track traffic coming from Pinterest shopping ads. Must send full URL including tracking—do not send tracking parameters only. At this time we do not support impression tracking. Must begin with http:// or https://.
    #[serde(rename = "ad_link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_link: Option<Nullable<String>>,

/// Set this attribute to TRUE if you're submitting items that are considered “adult”. These will not be shown on Pinterest.
    #[serde(rename = "adult")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adult: Option<Nullable<bool>>,

/// The age group to apply a demographic range to the product. Must be one of the following values (upper or lowercased): ‘newborn’, ‘infant’, ‘toddler’, ‘kids’, or ‘adult’.
    #[serde(rename = "age_group")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub age_group: Option<Nullable<String>>,

/// The availability of the product. Must be one of the following values (upper or lowercased): ‘in stock’, ‘out of stock’, ‘preorder’.
    #[serde(rename = "availability")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub availability: Option<String>,

/// Average reviews for the item. Can be a number from 1-5.
    #[serde(rename = "average_review_rating")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub average_review_rating: Option<Nullable<f64>>,

/// The brand of the product.
    #[serde(rename = "brand")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub brand: Option<Nullable<String>>,

/// This attribute is not supported anymore.
    #[serde(rename = "checkout_enabled")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub checkout_enabled: Option<Nullable<bool>>,

/// The primary color of the product.
    #[serde(rename = "color")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub color: Option<Nullable<String>>,

/// The condition of the product. Must be one of the following values (upper or lowercased): ‘new’, ‘used’, or ‘refurbished’.
    #[serde(rename = "condition")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub condition: Option<Nullable<String>>,

/// <p><= 1000 characters</p> <p>Custom grouping of products.</p>
    #[serde(rename = "custom_label_0")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_0: Option<Nullable<String>>,

/// <p><= 1000 characters</p> <p>Custom grouping of products.</p>
    #[serde(rename = "custom_label_1")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_1: Option<Nullable<String>>,

/// <p><= 1000 characters</p> <p>Custom grouping of products.</p>
    #[serde(rename = "custom_label_2")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_2: Option<Nullable<String>>,

/// <p><= 1000 characters</p> <p>Custom grouping of products.</p>
    #[serde(rename = "custom_label_3")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_3: Option<Nullable<String>>,

/// <p><= 1000 characters</p> <p>Custom grouping of products.</p>
    #[serde(rename = "custom_label_4")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_4: Option<Nullable<String>>,

/// <p><= 10000 characters</p> <p>The description of the product.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

/// The item is free to ship.
    #[serde(rename = "free_shipping_label")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub free_shipping_label: Option<Nullable<bool>>,

/// The minimum order purchase necessary for the customer to get free shipping. Only relevant if free shipping is offered.
    #[serde(rename = "free_shipping_limit")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub free_shipping_limit: Option<Nullable<String>>,

/// The gender associated with the product. Must be one of the following values (upper or lowercased): ‘male’, ‘female’, or ‘unisex’.
    #[serde(rename = "gender")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gender: Option<Nullable<String>>,

/// The categorization of the product based on the standardized Google Product Taxonomy. This is a set taxonomy. Both the text values and numeric codes are accepted.
    #[serde(rename = "google_product_category")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub google_product_category: Option<Nullable<String>>,

/// The unique universal product identifier.
    #[serde(rename = "gtin")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gtin: Option<Nullable<i32>>,

/// <p><= 127 characters</p> <p>The user-created unique ID that represents the product. Only Unicode characters are accepted.</p>
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// <p><= 127 characters</p> <p>The parent ID of the product.</p>
    #[serde(rename = "item_group_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_group_id: Option<Nullable<String>>,

/// The millisecond timestamp when the item was lastly modified by the merchant.
    #[serde(rename = "last_updated_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_updated_time: Option<Nullable<i64>>,

/// <p><= 511 characters</p> <p>The landing page for the product.</p>
    #[serde(rename = "link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link: Option<String>,

/// The material used to make the product.
    #[serde(rename = "material")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub material: Option<Nullable<String>>,

/// The minimum advertised price of the product. It supports the following formats, \"19.99 USD\", \"19.99USD\" and \"19.99\". If the currency is not included, we default to US dollars.
    #[serde(rename = "min_ad_price")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_ad_price: Option<Nullable<String>>,

/// The mobile-optimized version of your landing page. Must begin with http:// or https://.
    #[serde(rename = "mobile_link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mobile_link: Option<Nullable<String>>,

/// Manufacturer Part Number are alpha-numeric codes created by the manufacturer of a product to uniquely identify it among all products from the same manufacturer.
    #[serde(rename = "mpn")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mpn: Option<Nullable<String>>,

/// The number of ratings for the item.
    #[serde(rename = "number_of_ratings")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub number_of_ratings: Option<Nullable<i32>>,

/// The number of reviews available for the item.
    #[serde(rename = "number_of_reviews")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub number_of_reviews: Option<Nullable<i32>>,

/// The description of the pattern used for the product.
    #[serde(rename = "pattern")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pattern: Option<Nullable<String>>,

/// The price of the product. It supports the following formats, \"24.99 USD\", \"24.99USD\" and \"24.99\". If the currency is not included, we default to US dollars.
    #[serde(rename = "price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<String>,

/// <p><= 1000 characters</p> <p>The categorization of your product based on your custom product taxonomy. Subcategories must be sent separated by “ > “. The > must be wrapped by spaces. We do not recognize any other delimiters such as comma or pipe.</p>
    #[serde(rename = "product_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_type: Option<Nullable<String>>,

/// The discounted price of the product. The sale_price must be lower than the price. It supports the following formats, \"14.99 USD\", \"14.99USD\" and \"14.99\". If the currency is not included, we default to US dollars.
    #[serde(rename = "sale_price")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sale_price: Option<Nullable<String>>,

/// Shipping consists of one group of up to four elements, country, region, service (all optional) and price (required). All colons, even for blank values, are required.
    #[serde(rename = "shipping")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping: Option<Nullable<String>>,

/// The height of the package needed to ship the product. Ensure there is a space between the numeric string and the metric.
    #[serde(rename = "shipping_height")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_height: Option<Nullable<String>>,

/// The weight of the product. Ensure there is a space between the numeric string and the metric.
    #[serde(rename = "shipping_weight")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_weight: Option<Nullable<String>>,

/// The width of the package needed to ship the product. Ensure there is a space between the numeric string and the metric.
    #[serde(rename = "shipping_width")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_width: Option<Nullable<String>>,

/// The size of the product.
    #[serde(rename = "size")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<Nullable<String>>,

/// Indicates the country’s sizing system in which you are submitting your product. Must be one of the following values (upper or lowercased): ‘US’, ‘UK’, ‘EU’, ‘DE’, ‘FR’, ‘JP’, ‘CN’, ‘IT’, ‘BR’, ‘MEX’, or ‘AU’.
    #[serde(rename = "size_system")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_system: Option<Nullable<String>>,

/// Additional description for the size. Must be one of the following values (upper or lowercased): ‘regular’, ‘petite’, ‘plus’, ‘big_and_tall’, or ‘maternity’.
    #[serde(rename = "size_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_type: Option<Nullable<String>>,

/// Tax consists of one group of up to four elements, country, region, rate (all required) and tax_ship (optional). All colons, even for blank values, are required.
    #[serde(rename = "tax")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tax: Option<Nullable<String>>,

/// <p><= 500 characters</p> <p>The name of the product.</p>
    #[serde(rename = "title")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,

/// Options for this variant. People will see these options next to your Pin and can select the one they want. List them in the order you want them displayed.
    #[serde(rename = "variant_names")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub variant_names: Option<Nullable<Vec<String>>>,

/// Option values for this variant. People will see these options next to your Pin and can select the one they want. List them in the order you want them displayed. The order of the variant values must be consistent with the order of the variant names.
    #[serde(rename = "variant_values")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub variant_values: Option<Nullable<Vec<String>>>,

/// <p><= 2000 characters</p> <p>The links to additional images for your product. Up to ten additional images can be used to show a product from different angles or to show different stages. Must begin with http:// or https://.</p>
    #[serde(rename = "additional_image_link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_image_link: Option<Nullable<Vec<String>>>,

/// <p><= 2000 characters</p> <p>The link to the main product images. Images should be at least 75x75 pixels to avoid errors. Use the additional_image_link field to add more images of your product. The URL of your image_link must be accessible by the Pinterest user-agent, and send the accurate images. Please make sure there are no template or placeholder images at the link. Must start with http:// or https://.</p>
    #[serde(rename = "image_link")]
    #[validate(
            length(min = 1),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_link: Option<Vec<String>>,

}


impl ItemAttributes {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ItemAttributes {
        ItemAttributes {
            ad_link: None,
            adult: None,
            age_group: None,
            availability: None,
            average_review_rating: None,
            brand: None,
            checkout_enabled: None,
            color: None,
            condition: None,
            custom_label_0: None,
            custom_label_1: None,
            custom_label_2: None,
            custom_label_3: None,
            custom_label_4: None,
            description: None,
            free_shipping_label: None,
            free_shipping_limit: None,
            gender: None,
            google_product_category: None,
            gtin: None,
            id: None,
            item_group_id: None,
            last_updated_time: None,
            link: None,
            material: None,
            min_ad_price: None,
            mobile_link: None,
            mpn: None,
            number_of_ratings: None,
            number_of_reviews: None,
            pattern: None,
            price: None,
            product_type: None,
            sale_price: None,
            shipping: None,
            shipping_height: None,
            shipping_weight: None,
            shipping_width: None,
            size: None,
            size_system: None,
            size_type: None,
            tax: None,
            title: None,
            variant_names: None,
            variant_values: None,
            additional_image_link: None,
            image_link: None,
        }
    }
}

/// Converts the ItemAttributes value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ad_link.as_ref().map(|ad_link| {
                [
                    "ad_link".to_string(),
                    ad_link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.adult.as_ref().map(|adult| {
                [
                    "adult".to_string(),
                    adult.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.age_group.as_ref().map(|age_group| {
                [
                    "age_group".to_string(),
                    age_group.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.availability.as_ref().map(|availability| {
                [
                    "availability".to_string(),
                    availability.to_string(),
                ].join(",")
            }),


            self.average_review_rating.as_ref().map(|average_review_rating| {
                [
                    "average_review_rating".to_string(),
                    average_review_rating.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.brand.as_ref().map(|brand| {
                [
                    "brand".to_string(),
                    brand.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.checkout_enabled.as_ref().map(|checkout_enabled| {
                [
                    "checkout_enabled".to_string(),
                    checkout_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.color.as_ref().map(|color| {
                [
                    "color".to_string(),
                    color.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.condition.as_ref().map(|condition| {
                [
                    "condition".to_string(),
                    condition.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_0.as_ref().map(|custom_label_0| {
                [
                    "custom_label_0".to_string(),
                    custom_label_0.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_1.as_ref().map(|custom_label_1| {
                [
                    "custom_label_1".to_string(),
                    custom_label_1.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_2.as_ref().map(|custom_label_2| {
                [
                    "custom_label_2".to_string(),
                    custom_label_2.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_3.as_ref().map(|custom_label_3| {
                [
                    "custom_label_3".to_string(),
                    custom_label_3.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_4.as_ref().map(|custom_label_4| {
                [
                    "custom_label_4".to_string(),
                    custom_label_4.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.free_shipping_label.as_ref().map(|free_shipping_label| {
                [
                    "free_shipping_label".to_string(),
                    free_shipping_label.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.free_shipping_limit.as_ref().map(|free_shipping_limit| {
                [
                    "free_shipping_limit".to_string(),
                    free_shipping_limit.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.gender.as_ref().map(|gender| {
                [
                    "gender".to_string(),
                    gender.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.google_product_category.as_ref().map(|google_product_category| {
                [
                    "google_product_category".to_string(),
                    google_product_category.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.gtin.as_ref().map(|gtin| {
                [
                    "gtin".to_string(),
                    gtin.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.item_group_id.as_ref().map(|item_group_id| {
                [
                    "item_group_id".to_string(),
                    item_group_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.last_updated_time.as_ref().map(|last_updated_time| {
                [
                    "last_updated_time".to_string(),
                    last_updated_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.link.as_ref().map(|link| {
                [
                    "link".to_string(),
                    link.to_string(),
                ].join(",")
            }),


            self.material.as_ref().map(|material| {
                [
                    "material".to_string(),
                    material.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.min_ad_price.as_ref().map(|min_ad_price| {
                [
                    "min_ad_price".to_string(),
                    min_ad_price.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.mobile_link.as_ref().map(|mobile_link| {
                [
                    "mobile_link".to_string(),
                    mobile_link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.mpn.as_ref().map(|mpn| {
                [
                    "mpn".to_string(),
                    mpn.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.number_of_ratings.as_ref().map(|number_of_ratings| {
                [
                    "number_of_ratings".to_string(),
                    number_of_ratings.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.number_of_reviews.as_ref().map(|number_of_reviews| {
                [
                    "number_of_reviews".to_string(),
                    number_of_reviews.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.pattern.as_ref().map(|pattern| {
                [
                    "pattern".to_string(),
                    pattern.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.price.as_ref().map(|price| {
                [
                    "price".to_string(),
                    price.to_string(),
                ].join(",")
            }),


            self.product_type.as_ref().map(|product_type| {
                [
                    "product_type".to_string(),
                    product_type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.sale_price.as_ref().map(|sale_price| {
                [
                    "sale_price".to_string(),
                    sale_price.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.shipping.as_ref().map(|shipping| {
                [
                    "shipping".to_string(),
                    shipping.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.shipping_height.as_ref().map(|shipping_height| {
                [
                    "shipping_height".to_string(),
                    shipping_height.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.shipping_weight.as_ref().map(|shipping_weight| {
                [
                    "shipping_weight".to_string(),
                    shipping_weight.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.shipping_width.as_ref().map(|shipping_width| {
                [
                    "shipping_width".to_string(),
                    shipping_width.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "size".to_string(),
                    size.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.size_system.as_ref().map(|size_system| {
                [
                    "size_system".to_string(),
                    size_system.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.size_type.as_ref().map(|size_type| {
                [
                    "size_type".to_string(),
                    size_type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.tax.as_ref().map(|tax| {
                [
                    "tax".to_string(),
                    tax.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.title.as_ref().map(|title| {
                [
                    "title".to_string(),
                    title.to_string(),
                ].join(",")
            }),


            self.variant_names.as_ref().map(|variant_names| {
                [
                    "variant_names".to_string(),
                    variant_names.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.variant_values.as_ref().map(|variant_values| {
                [
                    "variant_values".to_string(),
                    variant_values.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.additional_image_link.as_ref().map(|additional_image_link| {
                [
                    "additional_image_link".to_string(),
                    additional_image_link.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.image_link.as_ref().map(|image_link| {
                [
                    "image_link".to_string(),
                    image_link.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemAttributes value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemAttributes {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_link: Vec<String>,
            pub adult: Vec<bool>,
            pub age_group: Vec<String>,
            pub availability: Vec<String>,
            pub average_review_rating: Vec<f64>,
            pub brand: Vec<String>,
            pub checkout_enabled: Vec<bool>,
            pub color: Vec<String>,
            pub condition: Vec<String>,
            pub custom_label_0: Vec<String>,
            pub custom_label_1: Vec<String>,
            pub custom_label_2: Vec<String>,
            pub custom_label_3: Vec<String>,
            pub custom_label_4: Vec<String>,
            pub description: Vec<String>,
            pub free_shipping_label: Vec<bool>,
            pub free_shipping_limit: Vec<String>,
            pub gender: Vec<String>,
            pub google_product_category: Vec<String>,
            pub gtin: Vec<i32>,
            pub id: Vec<String>,
            pub item_group_id: Vec<String>,
            pub last_updated_time: Vec<i64>,
            pub link: Vec<String>,
            pub material: Vec<String>,
            pub min_ad_price: Vec<String>,
            pub mobile_link: Vec<String>,
            pub mpn: Vec<String>,
            pub number_of_ratings: Vec<i32>,
            pub number_of_reviews: Vec<i32>,
            pub pattern: Vec<String>,
            pub price: Vec<String>,
            pub product_type: Vec<String>,
            pub sale_price: Vec<String>,
            pub shipping: Vec<String>,
            pub shipping_height: Vec<String>,
            pub shipping_weight: Vec<String>,
            pub shipping_width: Vec<String>,
            pub size: Vec<String>,
            pub size_system: Vec<String>,
            pub size_type: Vec<String>,
            pub tax: Vec<String>,
            pub title: Vec<String>,
            pub variant_names: Vec<Vec<String>>,
            pub variant_values: Vec<Vec<String>>,
            pub additional_image_link: Vec<Vec<String>>,
            pub image_link: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemAttributes".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ad_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "adult" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "age_group" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "availability" => intermediate_rep.availability.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "average_review_rating" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "brand" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "checkout_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "color" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "condition" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "custom_label_0" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "custom_label_1" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "custom_label_2" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "custom_label_3" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "custom_label_4" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "free_shipping_label" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "free_shipping_limit" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "gender" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "google_product_category" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "gtin" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "item_group_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "last_updated_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "link" => intermediate_rep.link.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "material" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "min_ad_price" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "mobile_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "mpn" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "number_of_ratings" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "number_of_reviews" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "pattern" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "product_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "sale_price" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "shipping" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "shipping_height" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "shipping_weight" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "shipping_width" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "size" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "size_system" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "size_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    "tax" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "variant_names" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemAttributes".to_string()),
                    "variant_values" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemAttributes".to_string()),
                    "additional_image_link" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemAttributes".to_string()),
                    "image_link" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemAttributes".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemAttributes".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemAttributes {
            ad_link: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            adult: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            age_group: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            availability: intermediate_rep.availability.into_iter().next(),
            average_review_rating: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            brand: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            checkout_enabled: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            color: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            condition: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            custom_label_0: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            custom_label_1: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            custom_label_2: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            custom_label_3: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            custom_label_4: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            description: intermediate_rep.description.into_iter().next(),
            free_shipping_label: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            free_shipping_limit: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            gender: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            google_product_category: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            gtin: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            id: intermediate_rep.id.into_iter().next(),
            item_group_id: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            last_updated_time: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            link: intermediate_rep.link.into_iter().next(),
            material: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            min_ad_price: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            mobile_link: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            mpn: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            number_of_ratings: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            number_of_reviews: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            pattern: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            price: intermediate_rep.price.into_iter().next(),
            product_type: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            sale_price: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            shipping: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            shipping_height: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            shipping_weight: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            shipping_width: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            size: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            size_system: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            size_type: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            tax: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            title: intermediate_rep.title.into_iter().next(),
            variant_names: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            variant_values: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            additional_image_link: std::result::Result::Err("Nullable types not supported in ItemAttributes".to_string())?,
            image_link: intermediate_rep.image_link.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemAttributes> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemAttributes>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemAttributes>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ItemAttributes - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemAttributes> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemAttributes as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ItemAttributes - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object describing an item batch record


/// One of:
/// - ItemCreateBatchRecord
/// - ItemDeleteBatchRecord
/// - ItemDeleteDiscontinuedBatchRecord
/// - ItemUpdateBatchRecord
/// - ItemUpsertBatchRecord
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ItemBatchRecord(Box<serde_json::value::RawValue>);

impl validator::Validate for ItemBatchRecord
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemBatchRecord value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemBatchRecord {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for ItemBatchRecord {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Object describing an item batch record to create items



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemCreateBatchRecord {
/// The catalog item id in the merchant namespace
    #[serde(rename = "item_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_id: Option<String>,

    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attributes: Option<models::ItemAttributes>,

}


impl ItemCreateBatchRecord {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ItemCreateBatchRecord {
        ItemCreateBatchRecord {
            item_id: None,
            attributes: None,
        }
    }
}

/// Converts the ItemCreateBatchRecord value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemCreateBatchRecord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.item_id.as_ref().map(|item_id| {
                [
                    "item_id".to_string(),
                    item_id.to_string(),
                ].join(",")
            }),

            // Skipping attributes in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemCreateBatchRecord value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemCreateBatchRecord {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_id: Vec<String>,
            pub attributes: Vec<models::ItemAttributes>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemCreateBatchRecord".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "attributes" => intermediate_rep.attributes.push(<models::ItemAttributes as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemCreateBatchRecord".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemCreateBatchRecord {
            item_id: intermediate_rep.item_id.into_iter().next(),
            attributes: intermediate_rep.attributes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemCreateBatchRecord> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemCreateBatchRecord>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemCreateBatchRecord>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ItemCreateBatchRecord - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemCreateBatchRecord> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemCreateBatchRecord as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ItemCreateBatchRecord - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object describing an item batch record to delete items



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemDeleteBatchRecord {
/// The catalog item id in the merchant namespace
    #[serde(rename = "item_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_id: Option<String>,

}


impl ItemDeleteBatchRecord {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ItemDeleteBatchRecord {
        ItemDeleteBatchRecord {
            item_id: None,
        }
    }
}

/// Converts the ItemDeleteBatchRecord value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemDeleteBatchRecord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.item_id.as_ref().map(|item_id| {
                [
                    "item_id".to_string(),
                    item_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemDeleteBatchRecord value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemDeleteBatchRecord {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemDeleteBatchRecord".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemDeleteBatchRecord".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemDeleteBatchRecord {
            item_id: intermediate_rep.item_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemDeleteBatchRecord> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemDeleteBatchRecord>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemDeleteBatchRecord>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ItemDeleteBatchRecord - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemDeleteBatchRecord> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemDeleteBatchRecord as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ItemDeleteBatchRecord - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object describing an item batch record to discontinue items



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemDeleteDiscontinuedBatchRecord {
/// The catalog item id in the merchant namespace
    #[serde(rename = "item_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_id: Option<String>,

}


impl ItemDeleteDiscontinuedBatchRecord {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ItemDeleteDiscontinuedBatchRecord {
        ItemDeleteDiscontinuedBatchRecord {
            item_id: None,
        }
    }
}

/// Converts the ItemDeleteDiscontinuedBatchRecord value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemDeleteDiscontinuedBatchRecord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.item_id.as_ref().map(|item_id| {
                [
                    "item_id".to_string(),
                    item_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemDeleteDiscontinuedBatchRecord value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemDeleteDiscontinuedBatchRecord {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemDeleteDiscontinuedBatchRecord".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemDeleteDiscontinuedBatchRecord".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemDeleteDiscontinuedBatchRecord {
            item_id: intermediate_rep.item_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemDeleteDiscontinuedBatchRecord> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemDeleteDiscontinuedBatchRecord>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemDeleteDiscontinuedBatchRecord>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ItemDeleteDiscontinuedBatchRecord - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemDeleteDiscontinuedBatchRecord> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemDeleteDiscontinuedBatchRecord as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ItemDeleteDiscontinuedBatchRecord - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemGroupIdFilter {
    #[serde(rename = "ITEM_GROUP_ID")]
    pub item_group_id: models::CatalogsProductGroupMultipleStringCriteria,

}


impl ItemGroupIdFilter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(item_group_id: models::CatalogsProductGroupMultipleStringCriteria, ) -> ItemGroupIdFilter {
        ItemGroupIdFilter {
            item_group_id,
        }
    }
}

/// Converts the ItemGroupIdFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemGroupIdFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping ITEM_GROUP_ID in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemGroupIdFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemGroupIdFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_group_id: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemGroupIdFilter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ITEM_GROUP_ID" => intermediate_rep.item_group_id.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemGroupIdFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemGroupIdFilter {
            item_group_id: intermediate_rep.item_group_id.into_iter().next().ok_or_else(|| "ITEM_GROUP_ID missing in ItemGroupIdFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemGroupIdFilter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemGroupIdFilter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemGroupIdFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ItemGroupIdFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemGroupIdFilter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemGroupIdFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ItemGroupIdFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemIdFilter {
    #[serde(rename = "ITEM_ID")]
    pub item_id: models::CatalogsProductGroupMultipleStringCriteria,

}


impl ItemIdFilter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(item_id: models::CatalogsProductGroupMultipleStringCriteria, ) -> ItemIdFilter {
        ItemIdFilter {
            item_id,
        }
    }
}

/// Converts the ItemIdFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemIdFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping ITEM_ID in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemIdFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemIdFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_id: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemIdFilter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ITEM_ID" => intermediate_rep.item_id.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemIdFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemIdFilter {
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "ITEM_ID missing in ItemIdFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemIdFilter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemIdFilter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemIdFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ItemIdFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemIdFilter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemIdFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ItemIdFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object describing an item processing record



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemProcessingRecord {
/// The catalog item id in the merchant namespace
    #[serde(rename = "item_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_id: Option<String>,

/// Array with the validation errors for the item processing record. A non empty errors list causes the item processing to fail.
    #[serde(rename = "errors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<models::ItemValidationEvent>>,

/// Array with the validation warnings for the item processing record
    #[serde(rename = "warnings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warnings: Option<Vec<models::ItemValidationEvent>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ItemProcessingStatus>,

}


impl ItemProcessingRecord {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ItemProcessingRecord {
        ItemProcessingRecord {
            item_id: None,
            errors: None,
            warnings: None,
            status: None,
        }
    }
}

/// Converts the ItemProcessingRecord value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemProcessingRecord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.item_id.as_ref().map(|item_id| {
                [
                    "item_id".to_string(),
                    item_id.to_string(),
                ].join(",")
            }),

            // Skipping errors in query parameter serialization

            // Skipping warnings in query parameter serialization

            // Skipping status in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemProcessingRecord value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemProcessingRecord {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_id: Vec<String>,
            pub errors: Vec<Vec<models::ItemValidationEvent>>,
            pub warnings: Vec<Vec<models::ItemValidationEvent>>,
            pub status: Vec<models::ItemProcessingStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemProcessingRecord".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemProcessingRecord".to_string()),
                    "warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemProcessingRecord".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::ItemProcessingStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemProcessingRecord".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemProcessingRecord {
            item_id: intermediate_rep.item_id.into_iter().next(),
            errors: intermediate_rep.errors.into_iter().next(),
            warnings: intermediate_rep.warnings.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemProcessingRecord> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemProcessingRecord>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemProcessingRecord>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ItemProcessingRecord - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemProcessingRecord> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemProcessingRecord as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ItemProcessingRecord - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The status of the item processing record
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ItemProcessingStatus {
    #[serde(rename = "SUCCESS")]
    Success,
    #[serde(rename = "FAILURE")]
    Failure,
    #[serde(rename = "PROCESSING")]
    Processing,
}

impl std::fmt::Display for ItemProcessingStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ItemProcessingStatus::Success => write!(f, "SUCCESS"),
            ItemProcessingStatus::Failure => write!(f, "FAILURE"),
            ItemProcessingStatus::Processing => write!(f, "PROCESSING"),
        }
    }
}

impl std::str::FromStr for ItemProcessingStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SUCCESS" => std::result::Result::Ok(ItemProcessingStatus::Success),
            "FAILURE" => std::result::Result::Ok(ItemProcessingStatus::Failure),
            "PROCESSING" => std::result::Result::Ok(ItemProcessingStatus::Processing),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Object describing an item record

/// Any of:
/// - ItemResponseAnyOf
/// - ItemResponseAnyOf1
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ItemResponse(Box<serde_json::value::RawValue>);

impl validator::Validate for ItemResponse
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for ItemResponse {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








/// One of:
/// - CatalogsHotelItemResponse
/// - CatalogsRetailItemResponse
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ItemResponseAnyOf(Box<serde_json::value::RawValue>);

impl validator::Validate for ItemResponseAnyOf
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemResponseAnyOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemResponseAnyOf {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for ItemResponseAnyOf {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}







/// One of:
/// - CatalogsHotelItemErrorResponse
/// - CatalogsRetailItemErrorResponse
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ItemResponseAnyOf1(Box<serde_json::value::RawValue>);

impl validator::Validate for ItemResponseAnyOf1
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemResponseAnyOf1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemResponseAnyOf1 {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for ItemResponseAnyOf1 {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Object describing an item batch record to update items



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemUpdateBatchRecord {
/// The catalog item id in the merchant namespace
    #[serde(rename = "item_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_id: Option<String>,

    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attributes: Option<models::UpdatableItemAttributes>,

/// The list of product attributes to be updated. Attributes specified in the update mask without a value specified in the body will be deleted from the product item.
    #[serde(rename = "update_mask")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub update_mask: Option<Nullable<Vec<models::UpdateMaskFieldType>>>,

}


impl ItemUpdateBatchRecord {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ItemUpdateBatchRecord {
        ItemUpdateBatchRecord {
            item_id: None,
            attributes: None,
            update_mask: None,
        }
    }
}

/// Converts the ItemUpdateBatchRecord value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemUpdateBatchRecord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.item_id.as_ref().map(|item_id| {
                [
                    "item_id".to_string(),
                    item_id.to_string(),
                ].join(",")
            }),

            // Skipping attributes in query parameter serialization

            // Skipping update_mask in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemUpdateBatchRecord value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemUpdateBatchRecord {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_id: Vec<String>,
            pub attributes: Vec<models::UpdatableItemAttributes>,
            pub update_mask: Vec<Vec<models::UpdateMaskFieldType>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemUpdateBatchRecord".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "attributes" => intermediate_rep.attributes.push(<models::UpdatableItemAttributes as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "update_mask" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemUpdateBatchRecord".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemUpdateBatchRecord".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemUpdateBatchRecord {
            item_id: intermediate_rep.item_id.into_iter().next(),
            attributes: intermediate_rep.attributes.into_iter().next(),
            update_mask: std::result::Result::Err("Nullable types not supported in ItemUpdateBatchRecord".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemUpdateBatchRecord> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemUpdateBatchRecord>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemUpdateBatchRecord>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ItemUpdateBatchRecord - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemUpdateBatchRecord> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemUpdateBatchRecord as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ItemUpdateBatchRecord - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object describing an item batch record to upsert items



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemUpsertBatchRecord {
/// The catalog item id in the merchant namespace
    #[serde(rename = "item_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_id: Option<String>,

    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attributes: Option<models::ItemAttributes>,

}


impl ItemUpsertBatchRecord {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ItemUpsertBatchRecord {
        ItemUpsertBatchRecord {
            item_id: None,
            attributes: None,
        }
    }
}

/// Converts the ItemUpsertBatchRecord value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemUpsertBatchRecord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.item_id.as_ref().map(|item_id| {
                [
                    "item_id".to_string(),
                    item_id.to_string(),
                ].join(",")
            }),

            // Skipping attributes in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemUpsertBatchRecord value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemUpsertBatchRecord {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_id: Vec<String>,
            pub attributes: Vec<models::ItemAttributes>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemUpsertBatchRecord".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "attributes" => intermediate_rep.attributes.push(<models::ItemAttributes as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemUpsertBatchRecord".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemUpsertBatchRecord {
            item_id: intermediate_rep.item_id.into_iter().next(),
            attributes: intermediate_rep.attributes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemUpsertBatchRecord> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemUpsertBatchRecord>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemUpsertBatchRecord>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ItemUpsertBatchRecord - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemUpsertBatchRecord> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemUpsertBatchRecord as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ItemUpsertBatchRecord - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Object describing an item validation event



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemValidationEvent {
/// The attribute that the item validation event references
    #[serde(rename = "attribute")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attribute: Option<String>,

/// The event code that the item validation event references
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<i32>,

/// Title message describing the item validation event
    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

}


impl ItemValidationEvent {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ItemValidationEvent {
        ItemValidationEvent {
            attribute: None,
            code: None,
            message: None,
        }
    }
}

/// Converts the ItemValidationEvent value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemValidationEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.attribute.as_ref().map(|attribute| {
                [
                    "attribute".to_string(),
                    attribute.to_string(),
                ].join(",")
            }),


            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemValidationEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemValidationEvent {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub attribute: Vec<String>,
            pub code: Vec<i32>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemValidationEvent".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "attribute" => intermediate_rep.attribute.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemValidationEvent".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemValidationEvent {
            attribute: intermediate_rep.attribute.into_iter().next(),
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemValidationEvent> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemValidationEvent>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemValidationEvent>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ItemValidationEvent - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemValidationEvent> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemValidationEvent as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ItemValidationEvent - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - CatalogsItemsBatchRequest
/// - CatalogsVerticalBatchRequest
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ItemsBatchPostRequest(Box<serde_json::value::RawValue>);

impl validator::Validate for ItemsBatchPostRequest
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemsBatchPostRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemsBatchPostRequest {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for ItemsBatchPostRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemsIssuesList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::CatalogsItemValidationIssues>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl ItemsIssuesList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::CatalogsItemValidationIssues>, ) -> ItemsIssuesList200Response {
        ItemsIssuesList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the ItemsIssuesList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemsIssuesList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemsIssuesList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemsIssuesList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::CatalogsItemValidationIssues>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemsIssuesList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemsIssuesList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemsIssuesList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemsIssuesList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemsIssuesList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in ItemsIssuesList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in ItemsIssuesList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemsIssuesList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemsIssuesList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemsIssuesList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ItemsIssuesList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemsIssuesList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemsIssuesList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ItemsIssuesList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Keyword {
    #[serde(rename = "archived")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,

/// Keyword ID .
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_KEYWORD_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Keyword parent entity ID (advertiser, campaign, ad group).
    #[serde(rename = "parent_id")]
    #[validate(
           regex = "RE_KEYWORD_PARENT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_id: Option<String>,

/// Parent entity type
    #[serde(rename = "parent_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_type: Option<String>,

/// Always keyword
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

/// Keyword custom bid in microcurrency - null if inherited from parent ad group.
    #[serde(rename = "bid")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid: Option<Nullable<i32>>,

    #[serde(rename = "match_type")]
    pub match_type: Nullable<models::MatchTypeResponse>,

/// Keyword value (120 chars max).
    #[serde(rename = "value")]
    pub value: String,

}

lazy_static::lazy_static! {
    static ref RE_KEYWORD_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_KEYWORD_PARENT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl Keyword {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(match_type: Nullable<models::MatchTypeResponse>, value: String, ) -> Keyword {
        Keyword {
            archived: None,
            id: None,
            parent_id: None,
            parent_type: None,
            r#type: None,
            bid: None,
            match_type,
            value,
        }
    }
}

/// Converts the Keyword value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Keyword {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.archived.as_ref().map(|archived| {
                [
                    "archived".to_string(),
                    archived.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.parent_id.as_ref().map(|parent_id| {
                [
                    "parent_id".to_string(),
                    parent_id.to_string(),
                ].join(",")
            }),


            self.parent_type.as_ref().map(|parent_type| {
                [
                    "parent_type".to_string(),
                    parent_type.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.bid.as_ref().map(|bid| {
                [
                    "bid".to_string(),
                    bid.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping match_type in query parameter serialization


            Some("value".to_string()),
            Some(self.value.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Keyword value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Keyword {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub archived: Vec<bool>,
            pub id: Vec<String>,
            pub parent_id: Vec<String>,
            pub parent_type: Vec<String>,
            pub r#type: Vec<String>,
            pub bid: Vec<i32>,
            pub match_type: Vec<models::MatchTypeResponse>,
            pub value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Keyword".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "archived" => intermediate_rep.archived.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "parent_id" => intermediate_rep.parent_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "parent_type" => intermediate_rep.parent_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "bid" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Keyword".to_string()),
                    "match_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Keyword".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Keyword".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Keyword {
            archived: intermediate_rep.archived.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            parent_id: intermediate_rep.parent_id.into_iter().next(),
            parent_type: intermediate_rep.parent_type.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            bid: std::result::Result::Err("Nullable types not supported in Keyword".to_string())?,
            match_type: std::result::Result::Err("Nullable types not supported in Keyword".to_string())?,
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in Keyword".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Keyword> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Keyword>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Keyword>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Keyword - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Keyword> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Keyword as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Keyword - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct KeywordError {
    #[serde(rename = "data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<models::Keyword>,

    #[serde(rename = "error_messages")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_messages: Option<Vec<String>>,

}


impl KeywordError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> KeywordError {
        KeywordError {
            data: None,
            error_messages: None,
        }
    }
}

/// Converts the KeywordError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for KeywordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization


            self.error_messages.as_ref().map(|error_messages| {
                [
                    "error_messages".to_string(),
                    error_messages.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a KeywordError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for KeywordError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<models::Keyword>,
            pub error_messages: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing KeywordError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::Keyword as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "error_messages" => return std::result::Result::Err("Parsing a container in this style is not supported in KeywordError".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing KeywordError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(KeywordError {
            data: intermediate_rep.data.into_iter().next(),
            error_messages: intermediate_rep.error_messages.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<KeywordError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<KeywordError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<KeywordError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for KeywordError - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<KeywordError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <KeywordError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into KeywordError - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Keyword metrics JSON



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct KeywordMetrics {
/// Average cost per click
    #[serde(rename = "avg_cpc_in_micro_currency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub avg_cpc_in_micro_currency: Option<f64>,

/// Keyword's search frequency. This value is based on keyword frequency in pepsi client response
    #[serde(rename = "keyword_query_volume")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub keyword_query_volume: Option<String>,

}


impl KeywordMetrics {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> KeywordMetrics {
        KeywordMetrics {
            avg_cpc_in_micro_currency: None,
            keyword_query_volume: None,
        }
    }
}

/// Converts the KeywordMetrics value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for KeywordMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.avg_cpc_in_micro_currency.as_ref().map(|avg_cpc_in_micro_currency| {
                [
                    "avg_cpc_in_micro_currency".to_string(),
                    avg_cpc_in_micro_currency.to_string(),
                ].join(",")
            }),


            self.keyword_query_volume.as_ref().map(|keyword_query_volume| {
                [
                    "keyword_query_volume".to_string(),
                    keyword_query_volume.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a KeywordMetrics value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for KeywordMetrics {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub avg_cpc_in_micro_currency: Vec<f64>,
            pub keyword_query_volume: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing KeywordMetrics".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "avg_cpc_in_micro_currency" => intermediate_rep.avg_cpc_in_micro_currency.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "keyword_query_volume" => intermediate_rep.keyword_query_volume.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing KeywordMetrics".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(KeywordMetrics {
            avg_cpc_in_micro_currency: intermediate_rep.avg_cpc_in_micro_currency.into_iter().next(),
            keyword_query_volume: intermediate_rep.keyword_query_volume.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<KeywordMetrics> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<KeywordMetrics>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<KeywordMetrics>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for KeywordMetrics - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<KeywordMetrics> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <KeywordMetrics as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into KeywordMetrics - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct KeywordMetricsResponse {
/// Keyword name, e.g., \"keyword\":\"fashion outfits\"
    #[serde(rename = "keyword")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub keyword: Option<String>,

    #[serde(rename = "metrics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metrics: Option<models::KeywordMetrics>,

}


impl KeywordMetricsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> KeywordMetricsResponse {
        KeywordMetricsResponse {
            keyword: None,
            metrics: None,
        }
    }
}

/// Converts the KeywordMetricsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for KeywordMetricsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.keyword.as_ref().map(|keyword| {
                [
                    "keyword".to_string(),
                    keyword.to_string(),
                ].join(",")
            }),

            // Skipping metrics in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a KeywordMetricsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for KeywordMetricsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub keyword: Vec<String>,
            pub metrics: Vec<models::KeywordMetrics>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing KeywordMetricsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "keyword" => intermediate_rep.keyword.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "metrics" => intermediate_rep.metrics.push(<models::KeywordMetrics as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing KeywordMetricsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(KeywordMetricsResponse {
            keyword: intermediate_rep.keyword.into_iter().next(),
            metrics: intermediate_rep.metrics.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<KeywordMetricsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<KeywordMetricsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<KeywordMetricsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for KeywordMetricsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<KeywordMetricsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <KeywordMetricsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into KeywordMetricsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct KeywordUpdate {
/// Keyword ID.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_KEYWORDUPDATE_ID",
        )]
    pub id: String,

/// Is keyword archived?
    #[serde(rename = "archived")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,

/// Keyword custom bid in microcurrency - null if inherited from parent ad group.
    #[serde(rename = "bid")]
    #[validate(
            range(min = 1),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid: Option<Nullable<u32>>,

}

lazy_static::lazy_static! {
    static ref RE_KEYWORDUPDATE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl KeywordUpdate {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, ) -> KeywordUpdate {
        KeywordUpdate {
            id,
            archived: None,
            bid: None,
        }
    }
}

/// Converts the KeywordUpdate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for KeywordUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            self.archived.as_ref().map(|archived| {
                [
                    "archived".to_string(),
                    archived.to_string(),
                ].join(",")
            }),


            self.bid.as_ref().map(|bid| {
                [
                    "bid".to_string(),
                    bid.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a KeywordUpdate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for KeywordUpdate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub archived: Vec<bool>,
            pub bid: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing KeywordUpdate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "archived" => intermediate_rep.archived.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "bid" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in KeywordUpdate".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing KeywordUpdate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(KeywordUpdate {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in KeywordUpdate".to_string())?,
            archived: intermediate_rep.archived.into_iter().next(),
            bid: std::result::Result::Err("Nullable types not supported in KeywordUpdate".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<KeywordUpdate> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<KeywordUpdate>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<KeywordUpdate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for KeywordUpdate - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<KeywordUpdate> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <KeywordUpdate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into KeywordUpdate - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct KeywordUpdateBody {
/// Keywords to update. Object array. Each object has 3 possible fields:<br>1. \"id\": (required) keyword ID<br>2. \"archived\": boolean. Should keyword be archived?<br>3. \"bid\": number<br>For example: [{\"id\":\"2886610576653\", \"archived\": false, \"bid\": 20000}, {\"id\":\"2886610576654\",  \"archived\": true, \"bid\": 20000}, ...]
    #[serde(rename = "keywords")]
    pub keywords: Vec<models::KeywordUpdate>,

}


impl KeywordUpdateBody {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(keywords: Vec<models::KeywordUpdate>, ) -> KeywordUpdateBody {
        KeywordUpdateBody {
            keywords,
        }
    }
}

/// Converts the KeywordUpdateBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for KeywordUpdateBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping keywords in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a KeywordUpdateBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for KeywordUpdateBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub keywords: Vec<Vec<models::KeywordUpdate>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing KeywordUpdateBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "keywords" => return std::result::Result::Err("Parsing a container in this style is not supported in KeywordUpdateBody".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing KeywordUpdateBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(KeywordUpdateBody {
            keywords: intermediate_rep.keywords.into_iter().next().ok_or_else(|| "keywords missing in KeywordUpdateBody".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<KeywordUpdateBody> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<KeywordUpdateBody>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<KeywordUpdateBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for KeywordUpdateBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<KeywordUpdateBody> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <KeywordUpdateBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into KeywordUpdateBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct KeywordsCommon {
/// Keyword custom bid in microcurrency - null if inherited from parent ad group.
    #[serde(rename = "bid")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid: Option<Nullable<i32>>,

    #[serde(rename = "match_type")]
    pub match_type: Nullable<models::MatchTypeResponse>,

/// Keyword value (120 chars max).
    #[serde(rename = "value")]
    pub value: String,

}


impl KeywordsCommon {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(match_type: Nullable<models::MatchTypeResponse>, value: String, ) -> KeywordsCommon {
        KeywordsCommon {
            bid: None,
            match_type,
            value,
        }
    }
}

/// Converts the KeywordsCommon value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for KeywordsCommon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.bid.as_ref().map(|bid| {
                [
                    "bid".to_string(),
                    bid.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping match_type in query parameter serialization


            Some("value".to_string()),
            Some(self.value.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a KeywordsCommon value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for KeywordsCommon {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub bid: Vec<i32>,
            pub match_type: Vec<models::MatchTypeResponse>,
            pub value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing KeywordsCommon".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "bid" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in KeywordsCommon".to_string()),
                    "match_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in KeywordsCommon".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing KeywordsCommon".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(KeywordsCommon {
            bid: std::result::Result::Err("Nullable types not supported in KeywordsCommon".to_string())?,
            match_type: std::result::Result::Err("Nullable types not supported in KeywordsCommon".to_string())?,
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in KeywordsCommon".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<KeywordsCommon> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<KeywordsCommon>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<KeywordsCommon>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for KeywordsCommon - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<KeywordsCommon> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <KeywordsCommon as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into KeywordsCommon - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct KeywordsGet200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::Keyword>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl KeywordsGet200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::Keyword>, ) -> KeywordsGet200Response {
        KeywordsGet200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the KeywordsGet200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for KeywordsGet200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a KeywordsGet200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for KeywordsGet200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::Keyword>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing KeywordsGet200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in KeywordsGet200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in KeywordsGet200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing KeywordsGet200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(KeywordsGet200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in KeywordsGet200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in KeywordsGet200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<KeywordsGet200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<KeywordsGet200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<KeywordsGet200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for KeywordsGet200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<KeywordsGet200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <KeywordsGet200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into KeywordsGet200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct KeywordsMetricsArrayResponse {
    #[serde(rename = "data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<Vec<models::KeywordMetricsResponse>>,

}


impl KeywordsMetricsArrayResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> KeywordsMetricsArrayResponse {
        KeywordsMetricsArrayResponse {
            data: None,
        }
    }
}

/// Converts the KeywordsMetricsArrayResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for KeywordsMetricsArrayResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a KeywordsMetricsArrayResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for KeywordsMetricsArrayResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<Vec<models::KeywordMetricsResponse>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing KeywordsMetricsArrayResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in KeywordsMetricsArrayResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing KeywordsMetricsArrayResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(KeywordsMetricsArrayResponse {
            data: intermediate_rep.data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<KeywordsMetricsArrayResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<KeywordsMetricsArrayResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<KeywordsMetricsArrayResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for KeywordsMetricsArrayResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<KeywordsMetricsArrayResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <KeywordsMetricsArrayResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into KeywordsMetricsArrayResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct KeywordsRequest {
/// Keyword JSON array. Each array element has 3 fields
    #[serde(rename = "keywords")]
    pub keywords: Vec<models::KeywordsCommon>,

/// Keyword parent entity ID (advertiser, campaign, ad group).
    #[serde(rename = "parent_id")]
    #[validate(
           regex = "RE_KEYWORDSREQUEST_PARENT_ID",
        )]
    pub parent_id: String,

}

lazy_static::lazy_static! {
    static ref RE_KEYWORDSREQUEST_PARENT_ID: regex::Regex = regex::Regex::new(r"^((AG)|C)?\\d+$").unwrap();
}

impl KeywordsRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(keywords: Vec<models::KeywordsCommon>, parent_id: String, ) -> KeywordsRequest {
        KeywordsRequest {
            keywords,
            parent_id,
        }
    }
}

/// Converts the KeywordsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for KeywordsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping keywords in query parameter serialization


            Some("parent_id".to_string()),
            Some(self.parent_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a KeywordsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for KeywordsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub keywords: Vec<Vec<models::KeywordsCommon>>,
            pub parent_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing KeywordsRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "keywords" => return std::result::Result::Err("Parsing a container in this style is not supported in KeywordsRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "parent_id" => intermediate_rep.parent_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing KeywordsRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(KeywordsRequest {
            keywords: intermediate_rep.keywords.into_iter().next().ok_or_else(|| "keywords missing in KeywordsRequest".to_string())?,
            parent_id: intermediate_rep.parent_id.into_iter().next().ok_or_else(|| "parent_id missing in KeywordsRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<KeywordsRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<KeywordsRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<KeywordsRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for KeywordsRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<KeywordsRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <KeywordsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into KeywordsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct KeywordsResponse {
    #[serde(rename = "errors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<models::KeywordError>>,

    #[serde(rename = "keywords")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub keywords: Option<Vec<models::Keyword>>,

}


impl KeywordsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> KeywordsResponse {
        KeywordsResponse {
            errors: None,
            keywords: None,
        }
    }
}

/// Converts the KeywordsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for KeywordsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping errors in query parameter serialization

            // Skipping keywords in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a KeywordsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for KeywordsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub errors: Vec<Vec<models::KeywordError>>,
            pub keywords: Vec<Vec<models::Keyword>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing KeywordsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in KeywordsResponse".to_string()),
                    "keywords" => return std::result::Result::Err("Parsing a container in this style is not supported in KeywordsResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing KeywordsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(KeywordsResponse {
            errors: intermediate_rep.errors.into_iter().next(),
            keywords: intermediate_rep.keywords.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<KeywordsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<KeywordsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<KeywordsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for KeywordsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<KeywordsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <KeywordsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into KeywordsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Language code, which is among the offical ISO 639-1 language list.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum Language {
    #[serde(rename = "AM")]
    Am,
    #[serde(rename = "AR")]
    Ar,
    #[serde(rename = "AZ")]
    Az,
    #[serde(rename = "BG")]
    Bg,
    #[serde(rename = "BN")]
    Bn,
    #[serde(rename = "BS")]
    Bs,
    #[serde(rename = "CA")]
    Ca,
    #[serde(rename = "CS")]
    Cs,
    #[serde(rename = "DA")]
    Da,
    #[serde(rename = "DV")]
    Dv,
    #[serde(rename = "DZ")]
    Dz,
    #[serde(rename = "DE")]
    De,
    #[serde(rename = "EL")]
    El,
    #[serde(rename = "EN")]
    En,
    #[serde(rename = "ES")]
    Es,
    #[serde(rename = "ET")]
    Et,
    #[serde(rename = "FA")]
    Fa,
    #[serde(rename = "FI")]
    Fi,
    #[serde(rename = "FR")]
    Fr,
    #[serde(rename = "HE")]
    He,
    #[serde(rename = "HI")]
    Hi,
    #[serde(rename = "HR")]
    Hr,
    #[serde(rename = "HU")]
    Hu,
    #[serde(rename = "HY")]
    Hy,
    #[serde(rename = "ID")]
    Id,
    #[serde(rename = "IN")]
    In,
    #[serde(rename = "IS")]
    Is,
    #[serde(rename = "IT")]
    It,
    #[serde(rename = "IW")]
    Iw,
    #[serde(rename = "JA")]
    Ja,
    #[serde(rename = "KA")]
    Ka,
    #[serde(rename = "KM")]
    Km,
    #[serde(rename = "KO")]
    Ko,
    #[serde(rename = "LO")]
    Lo,
    #[serde(rename = "LT")]
    Lt,
    #[serde(rename = "LV")]
    Lv,
    #[serde(rename = "MK")]
    Mk,
    #[serde(rename = "MN")]
    Mn,
    #[serde(rename = "MS")]
    Ms,
    #[serde(rename = "MY")]
    My,
    #[serde(rename = "NB")]
    Nb,
    #[serde(rename = "NE")]
    Ne,
    #[serde(rename = "NL")]
    Nl,
    #[serde(rename = "NO")]
    No,
    #[serde(rename = "PL")]
    Pl,
    #[serde(rename = "PT")]
    Pt,
    #[serde(rename = "RO")]
    Ro,
    #[serde(rename = "RU")]
    Ru,
    #[serde(rename = "SK")]
    Sk,
    #[serde(rename = "SL")]
    Sl,
    #[serde(rename = "SQ")]
    Sq,
    #[serde(rename = "SR")]
    Sr,
    #[serde(rename = "SV")]
    Sv,
    #[serde(rename = "TL")]
    Tl,
    #[serde(rename = "UK")]
    Uk,
    #[serde(rename = "VI")]
    Vi,
    #[serde(rename = "TE")]
    Te,
    #[serde(rename = "TH")]
    Th,
    #[serde(rename = "TR")]
    Tr,
    #[serde(rename = "XX")]
    Xx,
    #[serde(rename = "ZH")]
    Zh,
}

impl std::fmt::Display for Language {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Language::Am => write!(f, "AM"),
            Language::Ar => write!(f, "AR"),
            Language::Az => write!(f, "AZ"),
            Language::Bg => write!(f, "BG"),
            Language::Bn => write!(f, "BN"),
            Language::Bs => write!(f, "BS"),
            Language::Ca => write!(f, "CA"),
            Language::Cs => write!(f, "CS"),
            Language::Da => write!(f, "DA"),
            Language::Dv => write!(f, "DV"),
            Language::Dz => write!(f, "DZ"),
            Language::De => write!(f, "DE"),
            Language::El => write!(f, "EL"),
            Language::En => write!(f, "EN"),
            Language::Es => write!(f, "ES"),
            Language::Et => write!(f, "ET"),
            Language::Fa => write!(f, "FA"),
            Language::Fi => write!(f, "FI"),
            Language::Fr => write!(f, "FR"),
            Language::He => write!(f, "HE"),
            Language::Hi => write!(f, "HI"),
            Language::Hr => write!(f, "HR"),
            Language::Hu => write!(f, "HU"),
            Language::Hy => write!(f, "HY"),
            Language::Id => write!(f, "ID"),
            Language::In => write!(f, "IN"),
            Language::Is => write!(f, "IS"),
            Language::It => write!(f, "IT"),
            Language::Iw => write!(f, "IW"),
            Language::Ja => write!(f, "JA"),
            Language::Ka => write!(f, "KA"),
            Language::Km => write!(f, "KM"),
            Language::Ko => write!(f, "KO"),
            Language::Lo => write!(f, "LO"),
            Language::Lt => write!(f, "LT"),
            Language::Lv => write!(f, "LV"),
            Language::Mk => write!(f, "MK"),
            Language::Mn => write!(f, "MN"),
            Language::Ms => write!(f, "MS"),
            Language::My => write!(f, "MY"),
            Language::Nb => write!(f, "NB"),
            Language::Ne => write!(f, "NE"),
            Language::Nl => write!(f, "NL"),
            Language::No => write!(f, "NO"),
            Language::Pl => write!(f, "PL"),
            Language::Pt => write!(f, "PT"),
            Language::Ro => write!(f, "RO"),
            Language::Ru => write!(f, "RU"),
            Language::Sk => write!(f, "SK"),
            Language::Sl => write!(f, "SL"),
            Language::Sq => write!(f, "SQ"),
            Language::Sr => write!(f, "SR"),
            Language::Sv => write!(f, "SV"),
            Language::Tl => write!(f, "TL"),
            Language::Uk => write!(f, "UK"),
            Language::Vi => write!(f, "VI"),
            Language::Te => write!(f, "TE"),
            Language::Th => write!(f, "TH"),
            Language::Tr => write!(f, "TR"),
            Language::Xx => write!(f, "XX"),
            Language::Zh => write!(f, "ZH"),
        }
    }
}

impl std::str::FromStr for Language {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AM" => std::result::Result::Ok(Language::Am),
            "AR" => std::result::Result::Ok(Language::Ar),
            "AZ" => std::result::Result::Ok(Language::Az),
            "BG" => std::result::Result::Ok(Language::Bg),
            "BN" => std::result::Result::Ok(Language::Bn),
            "BS" => std::result::Result::Ok(Language::Bs),
            "CA" => std::result::Result::Ok(Language::Ca),
            "CS" => std::result::Result::Ok(Language::Cs),
            "DA" => std::result::Result::Ok(Language::Da),
            "DV" => std::result::Result::Ok(Language::Dv),
            "DZ" => std::result::Result::Ok(Language::Dz),
            "DE" => std::result::Result::Ok(Language::De),
            "EL" => std::result::Result::Ok(Language::El),
            "EN" => std::result::Result::Ok(Language::En),
            "ES" => std::result::Result::Ok(Language::Es),
            "ET" => std::result::Result::Ok(Language::Et),
            "FA" => std::result::Result::Ok(Language::Fa),
            "FI" => std::result::Result::Ok(Language::Fi),
            "FR" => std::result::Result::Ok(Language::Fr),
            "HE" => std::result::Result::Ok(Language::He),
            "HI" => std::result::Result::Ok(Language::Hi),
            "HR" => std::result::Result::Ok(Language::Hr),
            "HU" => std::result::Result::Ok(Language::Hu),
            "HY" => std::result::Result::Ok(Language::Hy),
            "ID" => std::result::Result::Ok(Language::Id),
            "IN" => std::result::Result::Ok(Language::In),
            "IS" => std::result::Result::Ok(Language::Is),
            "IT" => std::result::Result::Ok(Language::It),
            "IW" => std::result::Result::Ok(Language::Iw),
            "JA" => std::result::Result::Ok(Language::Ja),
            "KA" => std::result::Result::Ok(Language::Ka),
            "KM" => std::result::Result::Ok(Language::Km),
            "KO" => std::result::Result::Ok(Language::Ko),
            "LO" => std::result::Result::Ok(Language::Lo),
            "LT" => std::result::Result::Ok(Language::Lt),
            "LV" => std::result::Result::Ok(Language::Lv),
            "MK" => std::result::Result::Ok(Language::Mk),
            "MN" => std::result::Result::Ok(Language::Mn),
            "MS" => std::result::Result::Ok(Language::Ms),
            "MY" => std::result::Result::Ok(Language::My),
            "NB" => std::result::Result::Ok(Language::Nb),
            "NE" => std::result::Result::Ok(Language::Ne),
            "NL" => std::result::Result::Ok(Language::Nl),
            "NO" => std::result::Result::Ok(Language::No),
            "PL" => std::result::Result::Ok(Language::Pl),
            "PT" => std::result::Result::Ok(Language::Pt),
            "RO" => std::result::Result::Ok(Language::Ro),
            "RU" => std::result::Result::Ok(Language::Ru),
            "SK" => std::result::Result::Ok(Language::Sk),
            "SL" => std::result::Result::Ok(Language::Sl),
            "SQ" => std::result::Result::Ok(Language::Sq),
            "SR" => std::result::Result::Ok(Language::Sr),
            "SV" => std::result::Result::Ok(Language::Sv),
            "TL" => std::result::Result::Ok(Language::Tl),
            "UK" => std::result::Result::Ok(Language::Uk),
            "VI" => std::result::Result::Ok(Language::Vi),
            "TE" => std::result::Result::Ok(Language::Te),
            "TH" => std::result::Result::Ok(Language::Th),
            "TR" => std::result::Result::Ok(Language::Tr),
            "XX" => std::result::Result::Ok(Language::Xx),
            "ZH" => std::result::Result::Ok(Language::Zh),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Creation fields



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LeadFormCommon {
/// Internal name of the lead form.
    #[serde(rename = "name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

/// A link to the advertiser's privacy policy. This will be included in the lead form's disclosure language.
    #[serde(rename = "privacy_policy_link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy_policy_link: Option<Nullable<String>>,

/// Whether the advertiser has accepted Pinterest's terms of service for creating a lead ad.
    #[serde(rename = "has_accepted_terms")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_accepted_terms: Option<bool>,

/// A message for people who complete the form to let them know what happens next.
    #[serde(rename = "completion_message")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub completion_message: Option<Nullable<String>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::LeadFormStatus>,

/// Additional disclosure language to be included in the lead form.
    #[serde(rename = "disclosure_language")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub disclosure_language: Option<Nullable<String>>,

/// List of questions to be displayed on the lead form.
    #[serde(rename = "questions")]
    #[validate(
            length(max = 10),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub questions: Option<Vec<models::LeadFormQuestion>>,

}


impl LeadFormCommon {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LeadFormCommon {
        LeadFormCommon {
            name: None,
            privacy_policy_link: None,
            has_accepted_terms: None,
            completion_message: None,
            status: None,
            disclosure_language: None,
            questions: None,
        }
    }
}

/// Converts the LeadFormCommon value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LeadFormCommon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.privacy_policy_link.as_ref().map(|privacy_policy_link| {
                [
                    "privacy_policy_link".to_string(),
                    privacy_policy_link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.has_accepted_terms.as_ref().map(|has_accepted_terms| {
                [
                    "has_accepted_terms".to_string(),
                    has_accepted_terms.to_string(),
                ].join(",")
            }),


            self.completion_message.as_ref().map(|completion_message| {
                [
                    "completion_message".to_string(),
                    completion_message.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.disclosure_language.as_ref().map(|disclosure_language| {
                [
                    "disclosure_language".to_string(),
                    disclosure_language.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping questions in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LeadFormCommon value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LeadFormCommon {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub privacy_policy_link: Vec<String>,
            pub has_accepted_terms: Vec<bool>,
            pub completion_message: Vec<String>,
            pub status: Vec<models::LeadFormStatus>,
            pub disclosure_language: Vec<String>,
            pub questions: Vec<Vec<models::LeadFormQuestion>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LeadFormCommon".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in LeadFormCommon".to_string()),
                    "privacy_policy_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in LeadFormCommon".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "has_accepted_terms" => intermediate_rep.has_accepted_terms.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "completion_message" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in LeadFormCommon".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::LeadFormStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "disclosure_language" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in LeadFormCommon".to_string()),
                    "questions" => return std::result::Result::Err("Parsing a container in this style is not supported in LeadFormCommon".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing LeadFormCommon".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LeadFormCommon {
            name: std::result::Result::Err("Nullable types not supported in LeadFormCommon".to_string())?,
            privacy_policy_link: std::result::Result::Err("Nullable types not supported in LeadFormCommon".to_string())?,
            has_accepted_terms: intermediate_rep.has_accepted_terms.into_iter().next(),
            completion_message: std::result::Result::Err("Nullable types not supported in LeadFormCommon".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
            disclosure_language: std::result::Result::Err("Nullable types not supported in LeadFormCommon".to_string())?,
            questions: intermediate_rep.questions.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LeadFormCommon> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LeadFormCommon>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LeadFormCommon>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LeadFormCommon - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LeadFormCommon> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LeadFormCommon as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LeadFormCommon - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LeadFormQuestion {
    #[serde(rename = "question_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub question_type: Option<models::LeadFormQuestionType>,

    #[serde(rename = "custom_question_field_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_question_field_type: Option<Nullable<models::LeadFormQuestionFieldType>>,

/// Question label for a custom question.
    #[serde(rename = "custom_question_label")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_question_label: Option<Nullable<String>>,

/// Question options for a custom question.
    #[serde(rename = "custom_question_options")]
    #[validate(
            length(max = 5),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_question_options: Option<Nullable<Vec<String>>>,

}


impl LeadFormQuestion {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LeadFormQuestion {
        LeadFormQuestion {
            question_type: None,
            custom_question_field_type: None,
            custom_question_label: None,
            custom_question_options: None,
        }
    }
}

/// Converts the LeadFormQuestion value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LeadFormQuestion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping question_type in query parameter serialization

            // Skipping custom_question_field_type in query parameter serialization


            self.custom_question_label.as_ref().map(|custom_question_label| {
                [
                    "custom_question_label".to_string(),
                    custom_question_label.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_question_options.as_ref().map(|custom_question_options| {
                [
                    "custom_question_options".to_string(),
                    custom_question_options.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LeadFormQuestion value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LeadFormQuestion {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub question_type: Vec<models::LeadFormQuestionType>,
            pub custom_question_field_type: Vec<models::LeadFormQuestionFieldType>,
            pub custom_question_label: Vec<String>,
            pub custom_question_options: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LeadFormQuestion".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "question_type" => intermediate_rep.question_type.push(<models::LeadFormQuestionType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "custom_question_field_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in LeadFormQuestion".to_string()),
                    "custom_question_label" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in LeadFormQuestion".to_string()),
                    "custom_question_options" => return std::result::Result::Err("Parsing a container in this style is not supported in LeadFormQuestion".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing LeadFormQuestion".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LeadFormQuestion {
            question_type: intermediate_rep.question_type.into_iter().next(),
            custom_question_field_type: std::result::Result::Err("Nullable types not supported in LeadFormQuestion".to_string())?,
            custom_question_label: std::result::Result::Err("Nullable types not supported in LeadFormQuestion".to_string())?,
            custom_question_options: std::result::Result::Err("Nullable types not supported in LeadFormQuestion".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LeadFormQuestion> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LeadFormQuestion>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LeadFormQuestion>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LeadFormQuestion - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LeadFormQuestion> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LeadFormQuestion as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LeadFormQuestion - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Lead form question field type
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum LeadFormQuestionFieldType {
    #[serde(rename = "TEXT_FIELD")]
    TextField,
    #[serde(rename = "TEXT_AREA")]
    TextArea,
    #[serde(rename = "RADIO_LIST")]
    RadioList,
    #[serde(rename = "CHECKBOX")]
    Checkbox,
    #[serde(rename = "null")]
    Null,
}

impl std::fmt::Display for LeadFormQuestionFieldType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            LeadFormQuestionFieldType::TextField => write!(f, "TEXT_FIELD"),
            LeadFormQuestionFieldType::TextArea => write!(f, "TEXT_AREA"),
            LeadFormQuestionFieldType::RadioList => write!(f, "RADIO_LIST"),
            LeadFormQuestionFieldType::Checkbox => write!(f, "CHECKBOX"),
            LeadFormQuestionFieldType::Null => write!(f, "null"),
        }
    }
}

impl std::str::FromStr for LeadFormQuestionFieldType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "TEXT_FIELD" => std::result::Result::Ok(LeadFormQuestionFieldType::TextField),
            "TEXT_AREA" => std::result::Result::Ok(LeadFormQuestionFieldType::TextArea),
            "RADIO_LIST" => std::result::Result::Ok(LeadFormQuestionFieldType::RadioList),
            "CHECKBOX" => std::result::Result::Ok(LeadFormQuestionFieldType::Checkbox),
            "null" => std::result::Result::Ok(LeadFormQuestionFieldType::Null),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Lead form question type
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum LeadFormQuestionType {
    #[serde(rename = "CUSTOM")]
    Custom,
    #[serde(rename = "FULL_NAME")]
    FullName,
    #[serde(rename = "FIRST_NAME")]
    FirstName,
    #[serde(rename = "LAST_NAME")]
    LastName,
    #[serde(rename = "EMAIL")]
    Email,
    #[serde(rename = "PHONE_NUMBER")]
    PhoneNumber,
    #[serde(rename = "ZIP_CODE")]
    ZipCode,
    #[serde(rename = "AGE")]
    Age,
    #[serde(rename = "GENDER")]
    Gender,
    #[serde(rename = "CITY")]
    City,
    #[serde(rename = "COUNTRY")]
    Country,
    #[serde(rename = "PREFERRED_CONTACT_METHOD")]
    PreferredContactMethod,
    #[serde(rename = "STATE_PROVINCE")]
    StateProvince,
    #[serde(rename = "ADDRESS")]
    Address,
    #[serde(rename = "DATE_OF_BIRTH")]
    DateOfBirth,
}

impl std::fmt::Display for LeadFormQuestionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            LeadFormQuestionType::Custom => write!(f, "CUSTOM"),
            LeadFormQuestionType::FullName => write!(f, "FULL_NAME"),
            LeadFormQuestionType::FirstName => write!(f, "FIRST_NAME"),
            LeadFormQuestionType::LastName => write!(f, "LAST_NAME"),
            LeadFormQuestionType::Email => write!(f, "EMAIL"),
            LeadFormQuestionType::PhoneNumber => write!(f, "PHONE_NUMBER"),
            LeadFormQuestionType::ZipCode => write!(f, "ZIP_CODE"),
            LeadFormQuestionType::Age => write!(f, "AGE"),
            LeadFormQuestionType::Gender => write!(f, "GENDER"),
            LeadFormQuestionType::City => write!(f, "CITY"),
            LeadFormQuestionType::Country => write!(f, "COUNTRY"),
            LeadFormQuestionType::PreferredContactMethod => write!(f, "PREFERRED_CONTACT_METHOD"),
            LeadFormQuestionType::StateProvince => write!(f, "STATE_PROVINCE"),
            LeadFormQuestionType::Address => write!(f, "ADDRESS"),
            LeadFormQuestionType::DateOfBirth => write!(f, "DATE_OF_BIRTH"),
        }
    }
}

impl std::str::FromStr for LeadFormQuestionType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CUSTOM" => std::result::Result::Ok(LeadFormQuestionType::Custom),
            "FULL_NAME" => std::result::Result::Ok(LeadFormQuestionType::FullName),
            "FIRST_NAME" => std::result::Result::Ok(LeadFormQuestionType::FirstName),
            "LAST_NAME" => std::result::Result::Ok(LeadFormQuestionType::LastName),
            "EMAIL" => std::result::Result::Ok(LeadFormQuestionType::Email),
            "PHONE_NUMBER" => std::result::Result::Ok(LeadFormQuestionType::PhoneNumber),
            "ZIP_CODE" => std::result::Result::Ok(LeadFormQuestionType::ZipCode),
            "AGE" => std::result::Result::Ok(LeadFormQuestionType::Age),
            "GENDER" => std::result::Result::Ok(LeadFormQuestionType::Gender),
            "CITY" => std::result::Result::Ok(LeadFormQuestionType::City),
            "COUNTRY" => std::result::Result::Ok(LeadFormQuestionType::Country),
            "PREFERRED_CONTACT_METHOD" => std::result::Result::Ok(LeadFormQuestionType::PreferredContactMethod),
            "STATE_PROVINCE" => std::result::Result::Ok(LeadFormQuestionType::StateProvince),
            "ADDRESS" => std::result::Result::Ok(LeadFormQuestionType::Address),
            "DATE_OF_BIRTH" => std::result::Result::Ok(LeadFormQuestionType::DateOfBirth),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LeadFormResponse {
/// Internal name of the lead form.
    #[serde(rename = "name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

/// A link to the advertiser's privacy policy. This will be included in the lead form's disclosure language.
    #[serde(rename = "privacy_policy_link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy_policy_link: Option<Nullable<String>>,

/// Whether the advertiser has accepted Pinterest's terms of service for creating a lead ad.
    #[serde(rename = "has_accepted_terms")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_accepted_terms: Option<bool>,

/// A message for people who complete the form to let them know what happens next.
    #[serde(rename = "completion_message")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub completion_message: Option<Nullable<String>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::LeadFormStatus>,

/// Additional disclosure language to be included in the lead form.
    #[serde(rename = "disclosure_language")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub disclosure_language: Option<Nullable<String>>,

/// List of questions to be displayed on the lead form.
    #[serde(rename = "questions")]
    #[validate(
            length(max = 10),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub questions: Option<Vec<models::LeadFormQuestion>>,

/// The ID of this lead form
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_LEADFORMRESPONSE_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// The Ad Account ID that this lead form belongs to.
    #[serde(rename = "ad_account_id")]
    #[validate(
           regex = "RE_LEADFORMRESPONSE_AD_ACCOUNT_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// Lead form creation time. Unix timestamp in seconds.
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<i32>,

/// Last update time. Unix timestamp in seconds.
    #[serde(rename = "updated_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_time: Option<i32>,

}

lazy_static::lazy_static! {
    static ref RE_LEADFORMRESPONSE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_LEADFORMRESPONSE_AD_ACCOUNT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl LeadFormResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LeadFormResponse {
        LeadFormResponse {
            name: None,
            privacy_policy_link: None,
            has_accepted_terms: None,
            completion_message: None,
            status: None,
            disclosure_language: None,
            questions: None,
            id: None,
            ad_account_id: None,
            created_time: None,
            updated_time: None,
        }
    }
}

/// Converts the LeadFormResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LeadFormResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.privacy_policy_link.as_ref().map(|privacy_policy_link| {
                [
                    "privacy_policy_link".to_string(),
                    privacy_policy_link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.has_accepted_terms.as_ref().map(|has_accepted_terms| {
                [
                    "has_accepted_terms".to_string(),
                    has_accepted_terms.to_string(),
                ].join(",")
            }),


            self.completion_message.as_ref().map(|completion_message| {
                [
                    "completion_message".to_string(),
                    completion_message.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.disclosure_language.as_ref().map(|disclosure_language| {
                [
                    "disclosure_language".to_string(),
                    disclosure_language.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping questions in query parameter serialization


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.created_time.as_ref().map(|created_time| {
                [
                    "created_time".to_string(),
                    created_time.to_string(),
                ].join(",")
            }),


            self.updated_time.as_ref().map(|updated_time| {
                [
                    "updated_time".to_string(),
                    updated_time.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LeadFormResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LeadFormResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub privacy_policy_link: Vec<String>,
            pub has_accepted_terms: Vec<bool>,
            pub completion_message: Vec<String>,
            pub status: Vec<models::LeadFormStatus>,
            pub disclosure_language: Vec<String>,
            pub questions: Vec<Vec<models::LeadFormQuestion>>,
            pub id: Vec<String>,
            pub ad_account_id: Vec<String>,
            pub created_time: Vec<i32>,
            pub updated_time: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LeadFormResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in LeadFormResponse".to_string()),
                    "privacy_policy_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in LeadFormResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "has_accepted_terms" => intermediate_rep.has_accepted_terms.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "completion_message" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in LeadFormResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::LeadFormStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "disclosure_language" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in LeadFormResponse".to_string()),
                    "questions" => return std::result::Result::Err("Parsing a container in this style is not supported in LeadFormResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_time" => intermediate_rep.created_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "updated_time" => intermediate_rep.updated_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LeadFormResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LeadFormResponse {
            name: std::result::Result::Err("Nullable types not supported in LeadFormResponse".to_string())?,
            privacy_policy_link: std::result::Result::Err("Nullable types not supported in LeadFormResponse".to_string())?,
            has_accepted_terms: intermediate_rep.has_accepted_terms.into_iter().next(),
            completion_message: std::result::Result::Err("Nullable types not supported in LeadFormResponse".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
            disclosure_language: std::result::Result::Err("Nullable types not supported in LeadFormResponse".to_string())?,
            questions: intermediate_rep.questions.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            created_time: intermediate_rep.created_time.into_iter().next(),
            updated_time: intermediate_rep.updated_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LeadFormResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LeadFormResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LeadFormResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LeadFormResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LeadFormResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LeadFormResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LeadFormResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Status of the lead form
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum LeadFormStatus {
    #[serde(rename = "DRAFT")]
    Draft,
    #[serde(rename = "ACTIVE")]
    Active,
}

impl std::fmt::Display for LeadFormStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            LeadFormStatus::Draft => write!(f, "DRAFT"),
            LeadFormStatus::Active => write!(f, "ACTIVE"),
        }
    }
}

impl std::str::FromStr for LeadFormStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DRAFT" => std::result::Result::Ok(LeadFormStatus::Draft),
            "ACTIVE" => std::result::Result::Ok(LeadFormStatus::Active),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Request to create test data for lead data test API.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LeadFormTestRequest {
/// Test lead answers. Should follow the creation order.
    #[serde(rename = "answers")]
    pub answers: Vec<String>,

}


impl LeadFormTestRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(answers: Vec<String>, ) -> LeadFormTestRequest {
        LeadFormTestRequest {
            answers,
        }
    }
}

/// Converts the LeadFormTestRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LeadFormTestRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("answers".to_string()),
            Some(self.answers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LeadFormTestRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LeadFormTestRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub answers: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LeadFormTestRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "answers" => return std::result::Result::Err("Parsing a container in this style is not supported in LeadFormTestRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing LeadFormTestRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LeadFormTestRequest {
            answers: intermediate_rep.answers.into_iter().next().ok_or_else(|| "answers missing in LeadFormTestRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LeadFormTestRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LeadFormTestRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LeadFormTestRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LeadFormTestRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LeadFormTestRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LeadFormTestRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LeadFormTestRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Response for lead data test API.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LeadFormTestResponse {
/// Subscription ID.
    #[serde(rename = "subscription_id")]
    #[validate(
           regex = "RE_LEADFORMTESTRESPONSE_SUBSCRIPTION_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_id: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_LEADFORMTESTRESPONSE_SUBSCRIPTION_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl LeadFormTestResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LeadFormTestResponse {
        LeadFormTestResponse {
            subscription_id: None,
        }
    }
}

/// Converts the LeadFormTestResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LeadFormTestResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.subscription_id.as_ref().map(|subscription_id| {
                [
                    "subscription_id".to_string(),
                    subscription_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LeadFormTestResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LeadFormTestResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subscription_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LeadFormTestResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subscription_id" => intermediate_rep.subscription_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LeadFormTestResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LeadFormTestResponse {
            subscription_id: intermediate_rep.subscription_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LeadFormTestResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LeadFormTestResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LeadFormTestResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LeadFormTestResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LeadFormTestResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LeadFormTestResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LeadFormTestResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LeadFormsList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::LeadFormResponse>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl LeadFormsList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::LeadFormResponse>, ) -> LeadFormsList200Response {
        LeadFormsList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the LeadFormsList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LeadFormsList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LeadFormsList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LeadFormsList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::LeadFormResponse>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LeadFormsList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in LeadFormsList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in LeadFormsList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing LeadFormsList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LeadFormsList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in LeadFormsList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in LeadFormsList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LeadFormsList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LeadFormsList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LeadFormsList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LeadFormsList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LeadFormsList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LeadFormsList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LeadFormsList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LineItem {
/// Product brand. For example, \"Parker\".
    #[serde(rename = "product_brand")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_brand: Option<String>,

/// Product category. For example, \"Shoes\".
    #[serde(rename = "product_category")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_category: Option<String>,

/// Product ID. For example, 1414.
    #[serde(rename = "product_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_id: Option<i32>,

/// Product name. For example, \"Parker Boots\".
    #[serde(rename = "product_name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_name: Option<String>,

/// Product price. For example, \"99.99\".
    #[serde(rename = "product_price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_price: Option<String>,

/// Product quantity. For example, 2.
    #[serde(rename = "product_quantity")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_quantity: Option<i32>,

/// Product variant. For example, \"Red\".
    #[serde(rename = "product_variant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_variant: Option<String>,

/// Product variant ID. For example, \"1414-34832\".
    #[serde(rename = "product_variant_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_variant_id: Option<String>,

}


impl LineItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LineItem {
        LineItem {
            product_brand: None,
            product_category: None,
            product_id: None,
            product_name: None,
            product_price: None,
            product_quantity: None,
            product_variant: None,
            product_variant_id: None,
        }
    }
}

/// Converts the LineItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LineItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.product_brand.as_ref().map(|product_brand| {
                [
                    "product_brand".to_string(),
                    product_brand.to_string(),
                ].join(",")
            }),


            self.product_category.as_ref().map(|product_category| {
                [
                    "product_category".to_string(),
                    product_category.to_string(),
                ].join(",")
            }),


            self.product_id.as_ref().map(|product_id| {
                [
                    "product_id".to_string(),
                    product_id.to_string(),
                ].join(",")
            }),


            self.product_name.as_ref().map(|product_name| {
                [
                    "product_name".to_string(),
                    product_name.to_string(),
                ].join(",")
            }),


            self.product_price.as_ref().map(|product_price| {
                [
                    "product_price".to_string(),
                    product_price.to_string(),
                ].join(",")
            }),


            self.product_quantity.as_ref().map(|product_quantity| {
                [
                    "product_quantity".to_string(),
                    product_quantity.to_string(),
                ].join(",")
            }),


            self.product_variant.as_ref().map(|product_variant| {
                [
                    "product_variant".to_string(),
                    product_variant.to_string(),
                ].join(",")
            }),


            self.product_variant_id.as_ref().map(|product_variant_id| {
                [
                    "product_variant_id".to_string(),
                    product_variant_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LineItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LineItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub product_brand: Vec<String>,
            pub product_category: Vec<String>,
            pub product_id: Vec<i32>,
            pub product_name: Vec<String>,
            pub product_price: Vec<String>,
            pub product_quantity: Vec<i32>,
            pub product_variant: Vec<String>,
            pub product_variant_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LineItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "product_brand" => intermediate_rep.product_brand.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "product_category" => intermediate_rep.product_category.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "product_id" => intermediate_rep.product_id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "product_name" => intermediate_rep.product_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "product_price" => intermediate_rep.product_price.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "product_quantity" => intermediate_rep.product_quantity.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "product_variant" => intermediate_rep.product_variant.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "product_variant_id" => intermediate_rep.product_variant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LineItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LineItem {
            product_brand: intermediate_rep.product_brand.into_iter().next(),
            product_category: intermediate_rep.product_category.into_iter().next(),
            product_id: intermediate_rep.product_id.into_iter().next(),
            product_name: intermediate_rep.product_name.into_iter().next(),
            product_price: intermediate_rep.product_price.into_iter().next(),
            product_quantity: intermediate_rep.product_quantity.into_iter().next(),
            product_variant: intermediate_rep.product_variant.into_iter().next(),
            product_variant_id: intermediate_rep.product_variant_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LineItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LineItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LineItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LineItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LineItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LineItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LineItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinkedBusiness {
/// Username
    #[serde(rename = "username")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,

/// image_small_url
    #[serde(rename = "image_small_url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_small_url: Option<String>,

/// image_medium_url
    #[serde(rename = "image_medium_url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_medium_url: Option<String>,

/// image_large_url
    #[serde(rename = "image_large_url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_large_url: Option<String>,

/// image_xlarge_url
    #[serde(rename = "image_xlarge_url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_xlarge_url: Option<String>,

}


impl LinkedBusiness {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinkedBusiness {
        LinkedBusiness {
            username: None,
            image_small_url: None,
            image_medium_url: None,
            image_large_url: None,
            image_xlarge_url: None,
        }
    }
}

/// Converts the LinkedBusiness value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinkedBusiness {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.username.as_ref().map(|username| {
                [
                    "username".to_string(),
                    username.to_string(),
                ].join(",")
            }),


            self.image_small_url.as_ref().map(|image_small_url| {
                [
                    "image_small_url".to_string(),
                    image_small_url.to_string(),
                ].join(",")
            }),


            self.image_medium_url.as_ref().map(|image_medium_url| {
                [
                    "image_medium_url".to_string(),
                    image_medium_url.to_string(),
                ].join(",")
            }),


            self.image_large_url.as_ref().map(|image_large_url| {
                [
                    "image_large_url".to_string(),
                    image_large_url.to_string(),
                ].join(",")
            }),


            self.image_xlarge_url.as_ref().map(|image_xlarge_url| {
                [
                    "image_xlarge_url".to_string(),
                    image_xlarge_url.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinkedBusiness value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinkedBusiness {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub username: Vec<String>,
            pub image_small_url: Vec<String>,
            pub image_medium_url: Vec<String>,
            pub image_large_url: Vec<String>,
            pub image_xlarge_url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinkedBusiness".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_small_url" => intermediate_rep.image_small_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_medium_url" => intermediate_rep.image_medium_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_large_url" => intermediate_rep.image_large_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_xlarge_url" => intermediate_rep.image_xlarge_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinkedBusiness".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinkedBusiness {
            username: intermediate_rep.username.into_iter().next(),
            image_small_url: intermediate_rep.image_small_url.into_iter().next(),
            image_medium_url: intermediate_rep.image_medium_url.into_iter().next(),
            image_large_url: intermediate_rep.image_large_url.into_iter().next(),
            image_xlarge_url: intermediate_rep.image_xlarge_url.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinkedBusiness> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinkedBusiness>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinkedBusiness>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinkedBusiness - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinkedBusiness> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinkedBusiness as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinkedBusiness - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Keyword match type
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum MatchType {
    #[serde(rename = "BROAD")]
    Broad,
    #[serde(rename = "PHRASE")]
    Phrase,
    #[serde(rename = "EXACT")]
    Exact,
    #[serde(rename = "EXACT_NEGATIVE")]
    ExactNegative,
    #[serde(rename = "PHRASE_NEGATIVE")]
    PhraseNegative,
}

impl std::fmt::Display for MatchType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            MatchType::Broad => write!(f, "BROAD"),
            MatchType::Phrase => write!(f, "PHRASE"),
            MatchType::Exact => write!(f, "EXACT"),
            MatchType::ExactNegative => write!(f, "EXACT_NEGATIVE"),
            MatchType::PhraseNegative => write!(f, "PHRASE_NEGATIVE"),
        }
    }
}

impl std::str::FromStr for MatchType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "BROAD" => std::result::Result::Ok(MatchType::Broad),
            "PHRASE" => std::result::Result::Ok(MatchType::Phrase),
            "EXACT" => std::result::Result::Ok(MatchType::Exact),
            "EXACT_NEGATIVE" => std::result::Result::Ok(MatchType::ExactNegative),
            "PHRASE_NEGATIVE" => std::result::Result::Ok(MatchType::PhraseNegative),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Keyword match type
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum MatchTypeResponse {
    #[serde(rename = "BROAD")]
    Broad,
    #[serde(rename = "PHRASE")]
    Phrase,
    #[serde(rename = "EXACT")]
    Exact,
    #[serde(rename = "EXACT_NEGATIVE")]
    ExactNegative,
    #[serde(rename = "PHRASE_NEGATIVE")]
    PhraseNegative,
    #[serde(rename = "null")]
    Null,
}

impl std::fmt::Display for MatchTypeResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            MatchTypeResponse::Broad => write!(f, "BROAD"),
            MatchTypeResponse::Phrase => write!(f, "PHRASE"),
            MatchTypeResponse::Exact => write!(f, "EXACT"),
            MatchTypeResponse::ExactNegative => write!(f, "EXACT_NEGATIVE"),
            MatchTypeResponse::PhraseNegative => write!(f, "PHRASE_NEGATIVE"),
            MatchTypeResponse::Null => write!(f, "null"),
        }
    }
}

impl std::str::FromStr for MatchTypeResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "BROAD" => std::result::Result::Ok(MatchTypeResponse::Broad),
            "PHRASE" => std::result::Result::Ok(MatchTypeResponse::Phrase),
            "EXACT" => std::result::Result::Ok(MatchTypeResponse::Exact),
            "EXACT_NEGATIVE" => std::result::Result::Ok(MatchTypeResponse::ExactNegative),
            "PHRASE_NEGATIVE" => std::result::Result::Ok(MatchTypeResponse::PhraseNegative),
            "null" => std::result::Result::Ok(MatchTypeResponse::Null),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MaxPriceFilter {
    #[serde(rename = "MAX_PRICE")]
    pub max_price: models::CatalogsProductGroupPricingCriteria,

}


impl MaxPriceFilter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(max_price: models::CatalogsProductGroupPricingCriteria, ) -> MaxPriceFilter {
        MaxPriceFilter {
            max_price,
        }
    }
}

/// Converts the MaxPriceFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MaxPriceFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping MAX_PRICE in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MaxPriceFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MaxPriceFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub max_price: Vec<models::CatalogsProductGroupPricingCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MaxPriceFilter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "MAX_PRICE" => intermediate_rep.max_price.push(<models::CatalogsProductGroupPricingCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MaxPriceFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MaxPriceFilter {
            max_price: intermediate_rep.max_price.into_iter().next().ok_or_else(|| "MAX_PRICE missing in MaxPriceFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MaxPriceFilter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MaxPriceFilter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MaxPriceFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MaxPriceFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MaxPriceFilter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MaxPriceFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MaxPriceFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MediaList200Response {
/// Media
    #[serde(rename = "items")]
    pub items: Vec<models::MediaUploadDetails>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl MediaList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::MediaUploadDetails>, ) -> MediaList200Response {
        MediaList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the MediaList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MediaList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MediaList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MediaList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::MediaUploadDetails>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MediaList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in MediaList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MediaList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MediaList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MediaList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in MediaList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in MediaList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MediaList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MediaList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MediaList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MediaList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MediaList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MediaList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MediaList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Media upload that has been registered but not uploaded/processed yet.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MediaUpload {
/// Unique identifier for this media upload. Used to track status and for attaching during Pin creation.
    #[serde(rename = "media_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_id: Option<String>,

    #[serde(rename = "media_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<models::MediaUploadType>,

/// The URL where you will POST your media file.
    #[serde(rename = "upload_url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub upload_url: Option<String>,

    #[serde(rename = "upload_parameters")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub upload_parameters: Option<models::MediaUploadAllOfUploadParameters>,

}


impl MediaUpload {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MediaUpload {
        MediaUpload {
            media_id: None,
            media_type: None,
            upload_url: None,
            upload_parameters: None,
        }
    }
}

/// Converts the MediaUpload value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MediaUpload {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.media_id.as_ref().map(|media_id| {
                [
                    "media_id".to_string(),
                    media_id.to_string(),
                ].join(",")
            }),

            // Skipping media_type in query parameter serialization


            self.upload_url.as_ref().map(|upload_url| {
                [
                    "upload_url".to_string(),
                    upload_url.to_string(),
                ].join(",")
            }),

            // Skipping upload_parameters in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MediaUpload value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MediaUpload {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub media_id: Vec<String>,
            pub media_type: Vec<models::MediaUploadType>,
            pub upload_url: Vec<String>,
            pub upload_parameters: Vec<models::MediaUploadAllOfUploadParameters>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MediaUpload".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "media_id" => intermediate_rep.media_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media_type" => intermediate_rep.media_type.push(<models::MediaUploadType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "upload_url" => intermediate_rep.upload_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "upload_parameters" => intermediate_rep.upload_parameters.push(<models::MediaUploadAllOfUploadParameters as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MediaUpload".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MediaUpload {
            media_id: intermediate_rep.media_id.into_iter().next(),
            media_type: intermediate_rep.media_type.into_iter().next(),
            upload_url: intermediate_rep.upload_url.into_iter().next(),
            upload_parameters: intermediate_rep.upload_parameters.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MediaUpload> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MediaUpload>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MediaUpload>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MediaUpload - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MediaUpload> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MediaUpload as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MediaUpload - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The list of parameter key/value pairs you will need to send with your POST request to upload your media file.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MediaUploadAllOfUploadParameters {
    #[serde(rename = "x-amz-date")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub x_amz_date: Option<String>,

    #[serde(rename = "x-amz-signature")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub x_amz_signature: Option<String>,

    #[serde(rename = "x-amz-security-token")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub x_amz_security_token: Option<String>,

    #[serde(rename = "x-amz-algorithm")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub x_amz_algorithm: Option<String>,

    #[serde(rename = "key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

    #[serde(rename = "policy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub policy: Option<String>,

    #[serde(rename = "x-amz-credential")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub x_amz_credential: Option<String>,

    #[serde(rename = "Content-Type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<String>,

}


impl MediaUploadAllOfUploadParameters {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MediaUploadAllOfUploadParameters {
        MediaUploadAllOfUploadParameters {
            x_amz_date: None,
            x_amz_signature: None,
            x_amz_security_token: None,
            x_amz_algorithm: None,
            key: None,
            policy: None,
            x_amz_credential: None,
            content_type: None,
        }
    }
}

/// Converts the MediaUploadAllOfUploadParameters value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MediaUploadAllOfUploadParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.x_amz_date.as_ref().map(|x_amz_date| {
                [
                    "x-amz-date".to_string(),
                    x_amz_date.to_string(),
                ].join(",")
            }),


            self.x_amz_signature.as_ref().map(|x_amz_signature| {
                [
                    "x-amz-signature".to_string(),
                    x_amz_signature.to_string(),
                ].join(",")
            }),


            self.x_amz_security_token.as_ref().map(|x_amz_security_token| {
                [
                    "x-amz-security-token".to_string(),
                    x_amz_security_token.to_string(),
                ].join(",")
            }),


            self.x_amz_algorithm.as_ref().map(|x_amz_algorithm| {
                [
                    "x-amz-algorithm".to_string(),
                    x_amz_algorithm.to_string(),
                ].join(",")
            }),


            self.key.as_ref().map(|key| {
                [
                    "key".to_string(),
                    key.to_string(),
                ].join(",")
            }),


            self.policy.as_ref().map(|policy| {
                [
                    "policy".to_string(),
                    policy.to_string(),
                ].join(",")
            }),


            self.x_amz_credential.as_ref().map(|x_amz_credential| {
                [
                    "x-amz-credential".to_string(),
                    x_amz_credential.to_string(),
                ].join(",")
            }),


            self.content_type.as_ref().map(|content_type| {
                [
                    "Content-Type".to_string(),
                    content_type.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MediaUploadAllOfUploadParameters value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MediaUploadAllOfUploadParameters {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub x_amz_date: Vec<String>,
            pub x_amz_signature: Vec<String>,
            pub x_amz_security_token: Vec<String>,
            pub x_amz_algorithm: Vec<String>,
            pub key: Vec<String>,
            pub policy: Vec<String>,
            pub x_amz_credential: Vec<String>,
            pub content_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MediaUploadAllOfUploadParameters".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "x-amz-date" => intermediate_rep.x_amz_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "x-amz-signature" => intermediate_rep.x_amz_signature.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "x-amz-security-token" => intermediate_rep.x_amz_security_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "x-amz-algorithm" => intermediate_rep.x_amz_algorithm.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "policy" => intermediate_rep.policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "x-amz-credential" => intermediate_rep.x_amz_credential.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Content-Type" => intermediate_rep.content_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MediaUploadAllOfUploadParameters".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MediaUploadAllOfUploadParameters {
            x_amz_date: intermediate_rep.x_amz_date.into_iter().next(),
            x_amz_signature: intermediate_rep.x_amz_signature.into_iter().next(),
            x_amz_security_token: intermediate_rep.x_amz_security_token.into_iter().next(),
            x_amz_algorithm: intermediate_rep.x_amz_algorithm.into_iter().next(),
            key: intermediate_rep.key.into_iter().next(),
            policy: intermediate_rep.policy.into_iter().next(),
            x_amz_credential: intermediate_rep.x_amz_credential.into_iter().next(),
            content_type: intermediate_rep.content_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MediaUploadAllOfUploadParameters> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MediaUploadAllOfUploadParameters>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MediaUploadAllOfUploadParameters>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MediaUploadAllOfUploadParameters - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MediaUploadAllOfUploadParameters> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MediaUploadAllOfUploadParameters as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MediaUploadAllOfUploadParameters - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Media upload details



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MediaUploadDetails {
    #[serde(rename = "media_id")]
    #[validate(
           regex = "RE_MEDIAUPLOADDETAILS_MEDIA_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_id: Option<String>,

    #[serde(rename = "media_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<models::MediaUploadType>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::MediaUploadStatus>,

}

lazy_static::lazy_static! {
    static ref RE_MEDIAUPLOADDETAILS_MEDIA_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl MediaUploadDetails {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MediaUploadDetails {
        MediaUploadDetails {
            media_id: None,
            media_type: None,
            status: None,
        }
    }
}

/// Converts the MediaUploadDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MediaUploadDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.media_id.as_ref().map(|media_id| {
                [
                    "media_id".to_string(),
                    media_id.to_string(),
                ].join(",")
            }),

            // Skipping media_type in query parameter serialization

            // Skipping status in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MediaUploadDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MediaUploadDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub media_id: Vec<String>,
            pub media_type: Vec<models::MediaUploadType>,
            pub status: Vec<models::MediaUploadStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MediaUploadDetails".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "media_id" => intermediate_rep.media_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media_type" => intermediate_rep.media_type.push(<models::MediaUploadType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::MediaUploadStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MediaUploadDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MediaUploadDetails {
            media_id: intermediate_rep.media_id.into_iter().next(),
            media_type: intermediate_rep.media_type.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MediaUploadDetails> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MediaUploadDetails>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MediaUploadDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MediaUploadDetails - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MediaUploadDetails> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MediaUploadDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MediaUploadDetails - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Media upload request



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MediaUploadRequest {
    #[serde(rename = "media_type")]
    pub media_type: models::MediaUploadType,

}


impl MediaUploadRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(media_type: models::MediaUploadType, ) -> MediaUploadRequest {
        MediaUploadRequest {
            media_type,
        }
    }
}

/// Converts the MediaUploadRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MediaUploadRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping media_type in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MediaUploadRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MediaUploadRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub media_type: Vec<models::MediaUploadType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MediaUploadRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "media_type" => intermediate_rep.media_type.push(<models::MediaUploadType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MediaUploadRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MediaUploadRequest {
            media_type: intermediate_rep.media_type.into_iter().next().ok_or_else(|| "media_type missing in MediaUploadRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MediaUploadRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MediaUploadRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MediaUploadRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MediaUploadRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MediaUploadRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MediaUploadRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MediaUploadRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Media upload status
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum MediaUploadStatus {
    #[serde(rename = "registered")]
    Registered,
    #[serde(rename = "processing")]
    Processing,
    #[serde(rename = "succeeded")]
    Succeeded,
    #[serde(rename = "failed")]
    Failed,
}

impl std::fmt::Display for MediaUploadStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            MediaUploadStatus::Registered => write!(f, "registered"),
            MediaUploadStatus::Processing => write!(f, "processing"),
            MediaUploadStatus::Succeeded => write!(f, "succeeded"),
            MediaUploadStatus::Failed => write!(f, "failed"),
        }
    }
}

impl std::str::FromStr for MediaUploadStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "registered" => std::result::Result::Ok(MediaUploadStatus::Registered),
            "processing" => std::result::Result::Ok(MediaUploadStatus::Processing),
            "succeeded" => std::result::Result::Ok(MediaUploadStatus::Succeeded),
            "failed" => std::result::Result::Ok(MediaUploadStatus::Failed),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum MediaUploadType {
    #[serde(rename = "video")]
    Video,
}

impl std::fmt::Display for MediaUploadType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            MediaUploadType::Video => write!(f, "video"),
        }
    }
}

impl std::str::FromStr for MediaUploadType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "video" => std::result::Result::Ok(MediaUploadType::Video),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Level of the reporting request
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum MetricsReportingLevel {
    #[serde(rename = "ADVERTISER")]
    Advertiser,
    #[serde(rename = "ADVERTISER_TARGETING")]
    AdvertiserTargeting,
    #[serde(rename = "CAMPAIGN")]
    Campaign,
    #[serde(rename = "CAMPAIGN_TARGETING")]
    CampaignTargeting,
    #[serde(rename = "AD_GROUP")]
    AdGroup,
    #[serde(rename = "AD_GROUP_TARGETING")]
    AdGroupTargeting,
    #[serde(rename = "PIN_PROMOTION")]
    PinPromotion,
    #[serde(rename = "PIN_PROMOTION_TARGETING")]
    PinPromotionTargeting,
    #[serde(rename = "KEYWORD")]
    Keyword,
    #[serde(rename = "PRODUCT_GROUP")]
    ProductGroup,
    #[serde(rename = "PRODUCT_GROUP_TARGETING")]
    ProductGroupTargeting,
    #[serde(rename = "PRODUCT_ITEM")]
    ProductItem,
}

impl std::fmt::Display for MetricsReportingLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            MetricsReportingLevel::Advertiser => write!(f, "ADVERTISER"),
            MetricsReportingLevel::AdvertiserTargeting => write!(f, "ADVERTISER_TARGETING"),
            MetricsReportingLevel::Campaign => write!(f, "CAMPAIGN"),
            MetricsReportingLevel::CampaignTargeting => write!(f, "CAMPAIGN_TARGETING"),
            MetricsReportingLevel::AdGroup => write!(f, "AD_GROUP"),
            MetricsReportingLevel::AdGroupTargeting => write!(f, "AD_GROUP_TARGETING"),
            MetricsReportingLevel::PinPromotion => write!(f, "PIN_PROMOTION"),
            MetricsReportingLevel::PinPromotionTargeting => write!(f, "PIN_PROMOTION_TARGETING"),
            MetricsReportingLevel::Keyword => write!(f, "KEYWORD"),
            MetricsReportingLevel::ProductGroup => write!(f, "PRODUCT_GROUP"),
            MetricsReportingLevel::ProductGroupTargeting => write!(f, "PRODUCT_GROUP_TARGETING"),
            MetricsReportingLevel::ProductItem => write!(f, "PRODUCT_ITEM"),
        }
    }
}

impl std::str::FromStr for MetricsReportingLevel {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ADVERTISER" => std::result::Result::Ok(MetricsReportingLevel::Advertiser),
            "ADVERTISER_TARGETING" => std::result::Result::Ok(MetricsReportingLevel::AdvertiserTargeting),
            "CAMPAIGN" => std::result::Result::Ok(MetricsReportingLevel::Campaign),
            "CAMPAIGN_TARGETING" => std::result::Result::Ok(MetricsReportingLevel::CampaignTargeting),
            "AD_GROUP" => std::result::Result::Ok(MetricsReportingLevel::AdGroup),
            "AD_GROUP_TARGETING" => std::result::Result::Ok(MetricsReportingLevel::AdGroupTargeting),
            "PIN_PROMOTION" => std::result::Result::Ok(MetricsReportingLevel::PinPromotion),
            "PIN_PROMOTION_TARGETING" => std::result::Result::Ok(MetricsReportingLevel::PinPromotionTargeting),
            "KEYWORD" => std::result::Result::Ok(MetricsReportingLevel::Keyword),
            "PRODUCT_GROUP" => std::result::Result::Ok(MetricsReportingLevel::ProductGroup),
            "PRODUCT_GROUP_TARGETING" => std::result::Result::Ok(MetricsReportingLevel::ProductGroupTargeting),
            "PRODUCT_ITEM" => std::result::Result::Ok(MetricsReportingLevel::ProductItem),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MetricsResponse {
    #[serde(rename = "data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<Vec<crate::types::Object>>,

}


impl MetricsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MetricsResponse {
        MetricsResponse {
            data: None,
        }
    }
}

/// Converts the MetricsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MetricsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MetricsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MetricsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<Vec<crate::types::Object>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MetricsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in MetricsResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MetricsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MetricsResponse {
            data: intermediate_rep.data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MetricsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MetricsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MetricsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MetricsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MetricsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MetricsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MetricsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MinPriceFilter {
    #[serde(rename = "MIN_PRICE")]
    pub min_price: models::CatalogsProductGroupPricingCriteria,

}


impl MinPriceFilter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(min_price: models::CatalogsProductGroupPricingCriteria, ) -> MinPriceFilter {
        MinPriceFilter {
            min_price,
        }
    }
}

/// Converts the MinPriceFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MinPriceFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping MIN_PRICE in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MinPriceFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MinPriceFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub min_price: Vec<models::CatalogsProductGroupPricingCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MinPriceFilter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "MIN_PRICE" => intermediate_rep.min_price.push(<models::CatalogsProductGroupPricingCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MinPriceFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MinPriceFilter {
            min_price: intermediate_rep.min_price.into_iter().next().ok_or_else(|| "MIN_PRICE missing in MinPriceFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MinPriceFilter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MinPriceFilter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MinPriceFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MinPriceFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MinPriceFilter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MinPriceFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MinPriceFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Marketing Mix Modeling (MMM) Reporting Columns
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum MmmReportingColumn {
    #[serde(rename = "SPEND_IN_DOLLAR")]
    SpendInDollar,
    #[serde(rename = "SPEND_IN_MICRO_DOLLAR")]
    SpendInMicroDollar,
    #[serde(rename = "ECPC_IN_DOLLAR")]
    EcpcInDollar,
    #[serde(rename = "ECTR")]
    Ectr,
    #[serde(rename = "CAMPAIGN_NAME")]
    CampaignName,
    #[serde(rename = "TOTAL_ENGAGEMENT")]
    TotalEngagement,
    #[serde(rename = "EENGAGEMENT_RATE")]
    EengagementRate,
    #[serde(rename = "ECPM_IN_DOLLAR")]
    EcpmInDollar,
    #[serde(rename = "CAMPAIGN_ID")]
    CampaignId,
    #[serde(rename = "ADVERTISER_ID")]
    AdvertiserId,
    #[serde(rename = "AD_GROUP_ID")]
    AdGroupId,
    #[serde(rename = "AD_GROUP_NAME")]
    AdGroupName,
    #[serde(rename = "CLICKTHROUGH_1")]
    Clickthrough1,
    #[serde(rename = "IMPRESSION_1")]
    Impression1,
    #[serde(rename = "CLICKTHROUGH_2")]
    Clickthrough2,
    #[serde(rename = "IMPRESSION_2")]
    Impression2,
    #[serde(rename = "TOTAL_CLICKTHROUGH")]
    TotalClickthrough,
    #[serde(rename = "TOTAL_IMPRESSION")]
    TotalImpression,
    #[serde(rename = "ADVERTISER_NAME")]
    AdvertiserName,
    #[serde(rename = "SPEND_ORDER_LINE_PAID_TYPE")]
    SpendOrderLinePaidType,
}

impl std::fmt::Display for MmmReportingColumn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            MmmReportingColumn::SpendInDollar => write!(f, "SPEND_IN_DOLLAR"),
            MmmReportingColumn::SpendInMicroDollar => write!(f, "SPEND_IN_MICRO_DOLLAR"),
            MmmReportingColumn::EcpcInDollar => write!(f, "ECPC_IN_DOLLAR"),
            MmmReportingColumn::Ectr => write!(f, "ECTR"),
            MmmReportingColumn::CampaignName => write!(f, "CAMPAIGN_NAME"),
            MmmReportingColumn::TotalEngagement => write!(f, "TOTAL_ENGAGEMENT"),
            MmmReportingColumn::EengagementRate => write!(f, "EENGAGEMENT_RATE"),
            MmmReportingColumn::EcpmInDollar => write!(f, "ECPM_IN_DOLLAR"),
            MmmReportingColumn::CampaignId => write!(f, "CAMPAIGN_ID"),
            MmmReportingColumn::AdvertiserId => write!(f, "ADVERTISER_ID"),
            MmmReportingColumn::AdGroupId => write!(f, "AD_GROUP_ID"),
            MmmReportingColumn::AdGroupName => write!(f, "AD_GROUP_NAME"),
            MmmReportingColumn::Clickthrough1 => write!(f, "CLICKTHROUGH_1"),
            MmmReportingColumn::Impression1 => write!(f, "IMPRESSION_1"),
            MmmReportingColumn::Clickthrough2 => write!(f, "CLICKTHROUGH_2"),
            MmmReportingColumn::Impression2 => write!(f, "IMPRESSION_2"),
            MmmReportingColumn::TotalClickthrough => write!(f, "TOTAL_CLICKTHROUGH"),
            MmmReportingColumn::TotalImpression => write!(f, "TOTAL_IMPRESSION"),
            MmmReportingColumn::AdvertiserName => write!(f, "ADVERTISER_NAME"),
            MmmReportingColumn::SpendOrderLinePaidType => write!(f, "SPEND_ORDER_LINE_PAID_TYPE"),
        }
    }
}

impl std::str::FromStr for MmmReportingColumn {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SPEND_IN_DOLLAR" => std::result::Result::Ok(MmmReportingColumn::SpendInDollar),
            "SPEND_IN_MICRO_DOLLAR" => std::result::Result::Ok(MmmReportingColumn::SpendInMicroDollar),
            "ECPC_IN_DOLLAR" => std::result::Result::Ok(MmmReportingColumn::EcpcInDollar),
            "ECTR" => std::result::Result::Ok(MmmReportingColumn::Ectr),
            "CAMPAIGN_NAME" => std::result::Result::Ok(MmmReportingColumn::CampaignName),
            "TOTAL_ENGAGEMENT" => std::result::Result::Ok(MmmReportingColumn::TotalEngagement),
            "EENGAGEMENT_RATE" => std::result::Result::Ok(MmmReportingColumn::EengagementRate),
            "ECPM_IN_DOLLAR" => std::result::Result::Ok(MmmReportingColumn::EcpmInDollar),
            "CAMPAIGN_ID" => std::result::Result::Ok(MmmReportingColumn::CampaignId),
            "ADVERTISER_ID" => std::result::Result::Ok(MmmReportingColumn::AdvertiserId),
            "AD_GROUP_ID" => std::result::Result::Ok(MmmReportingColumn::AdGroupId),
            "AD_GROUP_NAME" => std::result::Result::Ok(MmmReportingColumn::AdGroupName),
            "CLICKTHROUGH_1" => std::result::Result::Ok(MmmReportingColumn::Clickthrough1),
            "IMPRESSION_1" => std::result::Result::Ok(MmmReportingColumn::Impression1),
            "CLICKTHROUGH_2" => std::result::Result::Ok(MmmReportingColumn::Clickthrough2),
            "IMPRESSION_2" => std::result::Result::Ok(MmmReportingColumn::Impression2),
            "TOTAL_CLICKTHROUGH" => std::result::Result::Ok(MmmReportingColumn::TotalClickthrough),
            "TOTAL_IMPRESSION" => std::result::Result::Ok(MmmReportingColumn::TotalImpression),
            "ADVERTISER_NAME" => std::result::Result::Ok(MmmReportingColumn::AdvertiserName),
            "SPEND_ORDER_LINE_PAID_TYPE" => std::result::Result::Ok(MmmReportingColumn::SpendOrderLinePaidType),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Ad targeting types for MMM report
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum MmmReportingTargetingType {
    #[serde(rename = "APPTYPE")]
    Apptype,
    #[serde(rename = "COUNTRY")]
    Country,
    #[serde(rename = "CREATIVE_TYPE")]
    CreativeType,
    #[serde(rename = "GENDER")]
    Gender,
    #[serde(rename = "LOCATION")]
    Location,
}

impl std::fmt::Display for MmmReportingTargetingType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            MmmReportingTargetingType::Apptype => write!(f, "APPTYPE"),
            MmmReportingTargetingType::Country => write!(f, "COUNTRY"),
            MmmReportingTargetingType::CreativeType => write!(f, "CREATIVE_TYPE"),
            MmmReportingTargetingType::Gender => write!(f, "GENDER"),
            MmmReportingTargetingType::Location => write!(f, "LOCATION"),
        }
    }
}

impl std::str::FromStr for MmmReportingTargetingType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "APPTYPE" => std::result::Result::Ok(MmmReportingTargetingType::Apptype),
            "COUNTRY" => std::result::Result::Ok(MmmReportingTargetingType::Country),
            "CREATIVE_TYPE" => std::result::Result::Ok(MmmReportingTargetingType::CreativeType),
            "GENDER" => std::result::Result::Ok(MmmReportingTargetingType::Gender),
            "LOCATION" => std::result::Result::Ok(MmmReportingTargetingType::Location),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Currency Codes from ISO 4217.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NonNullableCatalogsCurrency {
    #[serde(rename = "AED")]
    Aed,
    #[serde(rename = "AFN")]
    Afn,
    #[serde(rename = "ALL")]
    All,
    #[serde(rename = "AMD")]
    Amd,
    #[serde(rename = "ANG")]
    Ang,
    #[serde(rename = "AOA")]
    Aoa,
    #[serde(rename = "ARS")]
    Ars,
    #[serde(rename = "AUD")]
    Aud,
    #[serde(rename = "AWG")]
    Awg,
    #[serde(rename = "AZN")]
    Azn,
    #[serde(rename = "BAM")]
    Bam,
    #[serde(rename = "BBD")]
    Bbd,
    #[serde(rename = "BDT")]
    Bdt,
    #[serde(rename = "BGN")]
    Bgn,
    #[serde(rename = "BHD")]
    Bhd,
    #[serde(rename = "BIF")]
    Bif,
    #[serde(rename = "BMD")]
    Bmd,
    #[serde(rename = "BND")]
    Bnd,
    #[serde(rename = "BOB")]
    Bob,
    #[serde(rename = "BRL")]
    Brl,
    #[serde(rename = "BSD")]
    Bsd,
    #[serde(rename = "BTN")]
    Btn,
    #[serde(rename = "BWP")]
    Bwp,
    #[serde(rename = "BYN")]
    Byn,
    #[serde(rename = "BYR")]
    Byr,
    #[serde(rename = "BZD")]
    Bzd,
    #[serde(rename = "CAD")]
    Cad,
    #[serde(rename = "CDF")]
    Cdf,
    #[serde(rename = "CHF")]
    Chf,
    #[serde(rename = "CLP")]
    Clp,
    #[serde(rename = "CNY")]
    Cny,
    #[serde(rename = "COP")]
    Cop,
    #[serde(rename = "CRC")]
    Crc,
    #[serde(rename = "CUC")]
    Cuc,
    #[serde(rename = "CUP")]
    Cup,
    #[serde(rename = "CVE")]
    Cve,
    #[serde(rename = "CZK")]
    Czk,
    #[serde(rename = "DJF")]
    Djf,
    #[serde(rename = "DKK")]
    Dkk,
    #[serde(rename = "DOP")]
    Dop,
    #[serde(rename = "DZD")]
    Dzd,
    #[serde(rename = "EGP")]
    Egp,
    #[serde(rename = "ERN")]
    Ern,
    #[serde(rename = "ETB")]
    Etb,
    #[serde(rename = "EUR")]
    Eur,
    #[serde(rename = "FJD")]
    Fjd,
    #[serde(rename = "FKP")]
    Fkp,
    #[serde(rename = "GBP")]
    Gbp,
    #[serde(rename = "GEL")]
    Gel,
    #[serde(rename = "GGP")]
    Ggp,
    #[serde(rename = "GHS")]
    Ghs,
    #[serde(rename = "GIP")]
    Gip,
    #[serde(rename = "GMD")]
    Gmd,
    #[serde(rename = "GNF")]
    Gnf,
    #[serde(rename = "GTQ")]
    Gtq,
    #[serde(rename = "GYD")]
    Gyd,
    #[serde(rename = "HKD")]
    Hkd,
    #[serde(rename = "HNL")]
    Hnl,
    #[serde(rename = "HRK")]
    Hrk,
    #[serde(rename = "HTG")]
    Htg,
    #[serde(rename = "HUF")]
    Huf,
    #[serde(rename = "IDR")]
    Idr,
    #[serde(rename = "ILS")]
    Ils,
    #[serde(rename = "IMP")]
    Imp,
    #[serde(rename = "INR")]
    Inr,
    #[serde(rename = "IQD")]
    Iqd,
    #[serde(rename = "IRR")]
    Irr,
    #[serde(rename = "ISK")]
    Isk,
    #[serde(rename = "JEP")]
    Jep,
    #[serde(rename = "JMD")]
    Jmd,
    #[serde(rename = "JOD")]
    Jod,
    #[serde(rename = "JPY")]
    Jpy,
    #[serde(rename = "KES")]
    Kes,
    #[serde(rename = "KGS")]
    Kgs,
    #[serde(rename = "KHR")]
    Khr,
    #[serde(rename = "KMF")]
    Kmf,
    #[serde(rename = "KPW")]
    Kpw,
    #[serde(rename = "KRW")]
    Krw,
    #[serde(rename = "KWD")]
    Kwd,
    #[serde(rename = "KYD")]
    Kyd,
    #[serde(rename = "KZT")]
    Kzt,
    #[serde(rename = "LAK")]
    Lak,
    #[serde(rename = "LBP")]
    Lbp,
    #[serde(rename = "LKR")]
    Lkr,
    #[serde(rename = "LRD")]
    Lrd,
    #[serde(rename = "LSL")]
    Lsl,
    #[serde(rename = "LYD")]
    Lyd,
    #[serde(rename = "MAD")]
    Mad,
    #[serde(rename = "MDL")]
    Mdl,
    #[serde(rename = "MGA")]
    Mga,
    #[serde(rename = "MKD")]
    Mkd,
    #[serde(rename = "MMK")]
    Mmk,
    #[serde(rename = "MNT")]
    Mnt,
    #[serde(rename = "MOP")]
    Mop,
    #[serde(rename = "MRO")]
    Mro,
    #[serde(rename = "MUR")]
    Mur,
    #[serde(rename = "MVR")]
    Mvr,
    #[serde(rename = "MWK")]
    Mwk,
    #[serde(rename = "MXN")]
    Mxn,
    #[serde(rename = "MYR")]
    Myr,
    #[serde(rename = "MZN")]
    Mzn,
    #[serde(rename = "NAD")]
    Nad,
    #[serde(rename = "NGN")]
    Ngn,
    #[serde(rename = "NIO")]
    Nio,
    #[serde(rename = "NOK")]
    Nok,
    #[serde(rename = "NPR")]
    Npr,
    #[serde(rename = "NZD")]
    Nzd,
    #[serde(rename = "OMR")]
    Omr,
    #[serde(rename = "PAB")]
    Pab,
    #[serde(rename = "PEN")]
    Pen,
    #[serde(rename = "PGK")]
    Pgk,
    #[serde(rename = "PHP")]
    Php,
    #[serde(rename = "PKR")]
    Pkr,
    #[serde(rename = "PLN")]
    Pln,
    #[serde(rename = "PYG")]
    Pyg,
    #[serde(rename = "QAR")]
    Qar,
    #[serde(rename = "RON")]
    Ron,
    #[serde(rename = "RSD")]
    Rsd,
    #[serde(rename = "RUB")]
    Rub,
    #[serde(rename = "RWF")]
    Rwf,
    #[serde(rename = "SAR")]
    Sar,
    #[serde(rename = "SBD")]
    Sbd,
    #[serde(rename = "SCR")]
    Scr,
    #[serde(rename = "SDG")]
    Sdg,
    #[serde(rename = "SEK")]
    Sek,
    #[serde(rename = "SGD")]
    Sgd,
    #[serde(rename = "SHP")]
    Shp,
    #[serde(rename = "SLL")]
    Sll,
    #[serde(rename = "SOS")]
    Sos,
    #[serde(rename = "SPL")]
    Spl,
    #[serde(rename = "SRD")]
    Srd,
    #[serde(rename = "STD")]
    Std,
    #[serde(rename = "SVC")]
    Svc,
    #[serde(rename = "SYP")]
    Syp,
    #[serde(rename = "SZL")]
    Szl,
    #[serde(rename = "THB")]
    Thb,
    #[serde(rename = "TJS")]
    Tjs,
    #[serde(rename = "TMT")]
    Tmt,
    #[serde(rename = "TND")]
    Tnd,
    #[serde(rename = "TOP")]
    Top,
    #[serde(rename = "TRY")]
    Try,
    #[serde(rename = "TTD")]
    Ttd,
    #[serde(rename = "TVD")]
    Tvd,
    #[serde(rename = "TWD")]
    Twd,
    #[serde(rename = "TZS")]
    Tzs,
    #[serde(rename = "UAH")]
    Uah,
    #[serde(rename = "UGX")]
    Ugx,
    #[serde(rename = "USD")]
    Usd,
    #[serde(rename = "UYU")]
    Uyu,
    #[serde(rename = "UZS")]
    Uzs,
    #[serde(rename = "VEF")]
    Vef,
    #[serde(rename = "VND")]
    Vnd,
    #[serde(rename = "VUV")]
    Vuv,
    #[serde(rename = "WST")]
    Wst,
    #[serde(rename = "XAF")]
    Xaf,
    #[serde(rename = "XCD")]
    Xcd,
    #[serde(rename = "XDR")]
    Xdr,
    #[serde(rename = "XOF")]
    Xof,
    #[serde(rename = "XPF")]
    Xpf,
    #[serde(rename = "YER")]
    Yer,
    #[serde(rename = "ZAR")]
    Zar,
    #[serde(rename = "ZMW")]
    Zmw,
    #[serde(rename = "ZWD")]
    Zwd,
}

impl std::fmt::Display for NonNullableCatalogsCurrency {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NonNullableCatalogsCurrency::Aed => write!(f, "AED"),
            NonNullableCatalogsCurrency::Afn => write!(f, "AFN"),
            NonNullableCatalogsCurrency::All => write!(f, "ALL"),
            NonNullableCatalogsCurrency::Amd => write!(f, "AMD"),
            NonNullableCatalogsCurrency::Ang => write!(f, "ANG"),
            NonNullableCatalogsCurrency::Aoa => write!(f, "AOA"),
            NonNullableCatalogsCurrency::Ars => write!(f, "ARS"),
            NonNullableCatalogsCurrency::Aud => write!(f, "AUD"),
            NonNullableCatalogsCurrency::Awg => write!(f, "AWG"),
            NonNullableCatalogsCurrency::Azn => write!(f, "AZN"),
            NonNullableCatalogsCurrency::Bam => write!(f, "BAM"),
            NonNullableCatalogsCurrency::Bbd => write!(f, "BBD"),
            NonNullableCatalogsCurrency::Bdt => write!(f, "BDT"),
            NonNullableCatalogsCurrency::Bgn => write!(f, "BGN"),
            NonNullableCatalogsCurrency::Bhd => write!(f, "BHD"),
            NonNullableCatalogsCurrency::Bif => write!(f, "BIF"),
            NonNullableCatalogsCurrency::Bmd => write!(f, "BMD"),
            NonNullableCatalogsCurrency::Bnd => write!(f, "BND"),
            NonNullableCatalogsCurrency::Bob => write!(f, "BOB"),
            NonNullableCatalogsCurrency::Brl => write!(f, "BRL"),
            NonNullableCatalogsCurrency::Bsd => write!(f, "BSD"),
            NonNullableCatalogsCurrency::Btn => write!(f, "BTN"),
            NonNullableCatalogsCurrency::Bwp => write!(f, "BWP"),
            NonNullableCatalogsCurrency::Byn => write!(f, "BYN"),
            NonNullableCatalogsCurrency::Byr => write!(f, "BYR"),
            NonNullableCatalogsCurrency::Bzd => write!(f, "BZD"),
            NonNullableCatalogsCurrency::Cad => write!(f, "CAD"),
            NonNullableCatalogsCurrency::Cdf => write!(f, "CDF"),
            NonNullableCatalogsCurrency::Chf => write!(f, "CHF"),
            NonNullableCatalogsCurrency::Clp => write!(f, "CLP"),
            NonNullableCatalogsCurrency::Cny => write!(f, "CNY"),
            NonNullableCatalogsCurrency::Cop => write!(f, "COP"),
            NonNullableCatalogsCurrency::Crc => write!(f, "CRC"),
            NonNullableCatalogsCurrency::Cuc => write!(f, "CUC"),
            NonNullableCatalogsCurrency::Cup => write!(f, "CUP"),
            NonNullableCatalogsCurrency::Cve => write!(f, "CVE"),
            NonNullableCatalogsCurrency::Czk => write!(f, "CZK"),
            NonNullableCatalogsCurrency::Djf => write!(f, "DJF"),
            NonNullableCatalogsCurrency::Dkk => write!(f, "DKK"),
            NonNullableCatalogsCurrency::Dop => write!(f, "DOP"),
            NonNullableCatalogsCurrency::Dzd => write!(f, "DZD"),
            NonNullableCatalogsCurrency::Egp => write!(f, "EGP"),
            NonNullableCatalogsCurrency::Ern => write!(f, "ERN"),
            NonNullableCatalogsCurrency::Etb => write!(f, "ETB"),
            NonNullableCatalogsCurrency::Eur => write!(f, "EUR"),
            NonNullableCatalogsCurrency::Fjd => write!(f, "FJD"),
            NonNullableCatalogsCurrency::Fkp => write!(f, "FKP"),
            NonNullableCatalogsCurrency::Gbp => write!(f, "GBP"),
            NonNullableCatalogsCurrency::Gel => write!(f, "GEL"),
            NonNullableCatalogsCurrency::Ggp => write!(f, "GGP"),
            NonNullableCatalogsCurrency::Ghs => write!(f, "GHS"),
            NonNullableCatalogsCurrency::Gip => write!(f, "GIP"),
            NonNullableCatalogsCurrency::Gmd => write!(f, "GMD"),
            NonNullableCatalogsCurrency::Gnf => write!(f, "GNF"),
            NonNullableCatalogsCurrency::Gtq => write!(f, "GTQ"),
            NonNullableCatalogsCurrency::Gyd => write!(f, "GYD"),
            NonNullableCatalogsCurrency::Hkd => write!(f, "HKD"),
            NonNullableCatalogsCurrency::Hnl => write!(f, "HNL"),
            NonNullableCatalogsCurrency::Hrk => write!(f, "HRK"),
            NonNullableCatalogsCurrency::Htg => write!(f, "HTG"),
            NonNullableCatalogsCurrency::Huf => write!(f, "HUF"),
            NonNullableCatalogsCurrency::Idr => write!(f, "IDR"),
            NonNullableCatalogsCurrency::Ils => write!(f, "ILS"),
            NonNullableCatalogsCurrency::Imp => write!(f, "IMP"),
            NonNullableCatalogsCurrency::Inr => write!(f, "INR"),
            NonNullableCatalogsCurrency::Iqd => write!(f, "IQD"),
            NonNullableCatalogsCurrency::Irr => write!(f, "IRR"),
            NonNullableCatalogsCurrency::Isk => write!(f, "ISK"),
            NonNullableCatalogsCurrency::Jep => write!(f, "JEP"),
            NonNullableCatalogsCurrency::Jmd => write!(f, "JMD"),
            NonNullableCatalogsCurrency::Jod => write!(f, "JOD"),
            NonNullableCatalogsCurrency::Jpy => write!(f, "JPY"),
            NonNullableCatalogsCurrency::Kes => write!(f, "KES"),
            NonNullableCatalogsCurrency::Kgs => write!(f, "KGS"),
            NonNullableCatalogsCurrency::Khr => write!(f, "KHR"),
            NonNullableCatalogsCurrency::Kmf => write!(f, "KMF"),
            NonNullableCatalogsCurrency::Kpw => write!(f, "KPW"),
            NonNullableCatalogsCurrency::Krw => write!(f, "KRW"),
            NonNullableCatalogsCurrency::Kwd => write!(f, "KWD"),
            NonNullableCatalogsCurrency::Kyd => write!(f, "KYD"),
            NonNullableCatalogsCurrency::Kzt => write!(f, "KZT"),
            NonNullableCatalogsCurrency::Lak => write!(f, "LAK"),
            NonNullableCatalogsCurrency::Lbp => write!(f, "LBP"),
            NonNullableCatalogsCurrency::Lkr => write!(f, "LKR"),
            NonNullableCatalogsCurrency::Lrd => write!(f, "LRD"),
            NonNullableCatalogsCurrency::Lsl => write!(f, "LSL"),
            NonNullableCatalogsCurrency::Lyd => write!(f, "LYD"),
            NonNullableCatalogsCurrency::Mad => write!(f, "MAD"),
            NonNullableCatalogsCurrency::Mdl => write!(f, "MDL"),
            NonNullableCatalogsCurrency::Mga => write!(f, "MGA"),
            NonNullableCatalogsCurrency::Mkd => write!(f, "MKD"),
            NonNullableCatalogsCurrency::Mmk => write!(f, "MMK"),
            NonNullableCatalogsCurrency::Mnt => write!(f, "MNT"),
            NonNullableCatalogsCurrency::Mop => write!(f, "MOP"),
            NonNullableCatalogsCurrency::Mro => write!(f, "MRO"),
            NonNullableCatalogsCurrency::Mur => write!(f, "MUR"),
            NonNullableCatalogsCurrency::Mvr => write!(f, "MVR"),
            NonNullableCatalogsCurrency::Mwk => write!(f, "MWK"),
            NonNullableCatalogsCurrency::Mxn => write!(f, "MXN"),
            NonNullableCatalogsCurrency::Myr => write!(f, "MYR"),
            NonNullableCatalogsCurrency::Mzn => write!(f, "MZN"),
            NonNullableCatalogsCurrency::Nad => write!(f, "NAD"),
            NonNullableCatalogsCurrency::Ngn => write!(f, "NGN"),
            NonNullableCatalogsCurrency::Nio => write!(f, "NIO"),
            NonNullableCatalogsCurrency::Nok => write!(f, "NOK"),
            NonNullableCatalogsCurrency::Npr => write!(f, "NPR"),
            NonNullableCatalogsCurrency::Nzd => write!(f, "NZD"),
            NonNullableCatalogsCurrency::Omr => write!(f, "OMR"),
            NonNullableCatalogsCurrency::Pab => write!(f, "PAB"),
            NonNullableCatalogsCurrency::Pen => write!(f, "PEN"),
            NonNullableCatalogsCurrency::Pgk => write!(f, "PGK"),
            NonNullableCatalogsCurrency::Php => write!(f, "PHP"),
            NonNullableCatalogsCurrency::Pkr => write!(f, "PKR"),
            NonNullableCatalogsCurrency::Pln => write!(f, "PLN"),
            NonNullableCatalogsCurrency::Pyg => write!(f, "PYG"),
            NonNullableCatalogsCurrency::Qar => write!(f, "QAR"),
            NonNullableCatalogsCurrency::Ron => write!(f, "RON"),
            NonNullableCatalogsCurrency::Rsd => write!(f, "RSD"),
            NonNullableCatalogsCurrency::Rub => write!(f, "RUB"),
            NonNullableCatalogsCurrency::Rwf => write!(f, "RWF"),
            NonNullableCatalogsCurrency::Sar => write!(f, "SAR"),
            NonNullableCatalogsCurrency::Sbd => write!(f, "SBD"),
            NonNullableCatalogsCurrency::Scr => write!(f, "SCR"),
            NonNullableCatalogsCurrency::Sdg => write!(f, "SDG"),
            NonNullableCatalogsCurrency::Sek => write!(f, "SEK"),
            NonNullableCatalogsCurrency::Sgd => write!(f, "SGD"),
            NonNullableCatalogsCurrency::Shp => write!(f, "SHP"),
            NonNullableCatalogsCurrency::Sll => write!(f, "SLL"),
            NonNullableCatalogsCurrency::Sos => write!(f, "SOS"),
            NonNullableCatalogsCurrency::Spl => write!(f, "SPL"),
            NonNullableCatalogsCurrency::Srd => write!(f, "SRD"),
            NonNullableCatalogsCurrency::Std => write!(f, "STD"),
            NonNullableCatalogsCurrency::Svc => write!(f, "SVC"),
            NonNullableCatalogsCurrency::Syp => write!(f, "SYP"),
            NonNullableCatalogsCurrency::Szl => write!(f, "SZL"),
            NonNullableCatalogsCurrency::Thb => write!(f, "THB"),
            NonNullableCatalogsCurrency::Tjs => write!(f, "TJS"),
            NonNullableCatalogsCurrency::Tmt => write!(f, "TMT"),
            NonNullableCatalogsCurrency::Tnd => write!(f, "TND"),
            NonNullableCatalogsCurrency::Top => write!(f, "TOP"),
            NonNullableCatalogsCurrency::Try => write!(f, "TRY"),
            NonNullableCatalogsCurrency::Ttd => write!(f, "TTD"),
            NonNullableCatalogsCurrency::Tvd => write!(f, "TVD"),
            NonNullableCatalogsCurrency::Twd => write!(f, "TWD"),
            NonNullableCatalogsCurrency::Tzs => write!(f, "TZS"),
            NonNullableCatalogsCurrency::Uah => write!(f, "UAH"),
            NonNullableCatalogsCurrency::Ugx => write!(f, "UGX"),
            NonNullableCatalogsCurrency::Usd => write!(f, "USD"),
            NonNullableCatalogsCurrency::Uyu => write!(f, "UYU"),
            NonNullableCatalogsCurrency::Uzs => write!(f, "UZS"),
            NonNullableCatalogsCurrency::Vef => write!(f, "VEF"),
            NonNullableCatalogsCurrency::Vnd => write!(f, "VND"),
            NonNullableCatalogsCurrency::Vuv => write!(f, "VUV"),
            NonNullableCatalogsCurrency::Wst => write!(f, "WST"),
            NonNullableCatalogsCurrency::Xaf => write!(f, "XAF"),
            NonNullableCatalogsCurrency::Xcd => write!(f, "XCD"),
            NonNullableCatalogsCurrency::Xdr => write!(f, "XDR"),
            NonNullableCatalogsCurrency::Xof => write!(f, "XOF"),
            NonNullableCatalogsCurrency::Xpf => write!(f, "XPF"),
            NonNullableCatalogsCurrency::Yer => write!(f, "YER"),
            NonNullableCatalogsCurrency::Zar => write!(f, "ZAR"),
            NonNullableCatalogsCurrency::Zmw => write!(f, "ZMW"),
            NonNullableCatalogsCurrency::Zwd => write!(f, "ZWD"),
        }
    }
}

impl std::str::FromStr for NonNullableCatalogsCurrency {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AED" => std::result::Result::Ok(NonNullableCatalogsCurrency::Aed),
            "AFN" => std::result::Result::Ok(NonNullableCatalogsCurrency::Afn),
            "ALL" => std::result::Result::Ok(NonNullableCatalogsCurrency::All),
            "AMD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Amd),
            "ANG" => std::result::Result::Ok(NonNullableCatalogsCurrency::Ang),
            "AOA" => std::result::Result::Ok(NonNullableCatalogsCurrency::Aoa),
            "ARS" => std::result::Result::Ok(NonNullableCatalogsCurrency::Ars),
            "AUD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Aud),
            "AWG" => std::result::Result::Ok(NonNullableCatalogsCurrency::Awg),
            "AZN" => std::result::Result::Ok(NonNullableCatalogsCurrency::Azn),
            "BAM" => std::result::Result::Ok(NonNullableCatalogsCurrency::Bam),
            "BBD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Bbd),
            "BDT" => std::result::Result::Ok(NonNullableCatalogsCurrency::Bdt),
            "BGN" => std::result::Result::Ok(NonNullableCatalogsCurrency::Bgn),
            "BHD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Bhd),
            "BIF" => std::result::Result::Ok(NonNullableCatalogsCurrency::Bif),
            "BMD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Bmd),
            "BND" => std::result::Result::Ok(NonNullableCatalogsCurrency::Bnd),
            "BOB" => std::result::Result::Ok(NonNullableCatalogsCurrency::Bob),
            "BRL" => std::result::Result::Ok(NonNullableCatalogsCurrency::Brl),
            "BSD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Bsd),
            "BTN" => std::result::Result::Ok(NonNullableCatalogsCurrency::Btn),
            "BWP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Bwp),
            "BYN" => std::result::Result::Ok(NonNullableCatalogsCurrency::Byn),
            "BYR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Byr),
            "BZD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Bzd),
            "CAD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Cad),
            "CDF" => std::result::Result::Ok(NonNullableCatalogsCurrency::Cdf),
            "CHF" => std::result::Result::Ok(NonNullableCatalogsCurrency::Chf),
            "CLP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Clp),
            "CNY" => std::result::Result::Ok(NonNullableCatalogsCurrency::Cny),
            "COP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Cop),
            "CRC" => std::result::Result::Ok(NonNullableCatalogsCurrency::Crc),
            "CUC" => std::result::Result::Ok(NonNullableCatalogsCurrency::Cuc),
            "CUP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Cup),
            "CVE" => std::result::Result::Ok(NonNullableCatalogsCurrency::Cve),
            "CZK" => std::result::Result::Ok(NonNullableCatalogsCurrency::Czk),
            "DJF" => std::result::Result::Ok(NonNullableCatalogsCurrency::Djf),
            "DKK" => std::result::Result::Ok(NonNullableCatalogsCurrency::Dkk),
            "DOP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Dop),
            "DZD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Dzd),
            "EGP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Egp),
            "ERN" => std::result::Result::Ok(NonNullableCatalogsCurrency::Ern),
            "ETB" => std::result::Result::Ok(NonNullableCatalogsCurrency::Etb),
            "EUR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Eur),
            "FJD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Fjd),
            "FKP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Fkp),
            "GBP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Gbp),
            "GEL" => std::result::Result::Ok(NonNullableCatalogsCurrency::Gel),
            "GGP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Ggp),
            "GHS" => std::result::Result::Ok(NonNullableCatalogsCurrency::Ghs),
            "GIP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Gip),
            "GMD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Gmd),
            "GNF" => std::result::Result::Ok(NonNullableCatalogsCurrency::Gnf),
            "GTQ" => std::result::Result::Ok(NonNullableCatalogsCurrency::Gtq),
            "GYD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Gyd),
            "HKD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Hkd),
            "HNL" => std::result::Result::Ok(NonNullableCatalogsCurrency::Hnl),
            "HRK" => std::result::Result::Ok(NonNullableCatalogsCurrency::Hrk),
            "HTG" => std::result::Result::Ok(NonNullableCatalogsCurrency::Htg),
            "HUF" => std::result::Result::Ok(NonNullableCatalogsCurrency::Huf),
            "IDR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Idr),
            "ILS" => std::result::Result::Ok(NonNullableCatalogsCurrency::Ils),
            "IMP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Imp),
            "INR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Inr),
            "IQD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Iqd),
            "IRR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Irr),
            "ISK" => std::result::Result::Ok(NonNullableCatalogsCurrency::Isk),
            "JEP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Jep),
            "JMD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Jmd),
            "JOD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Jod),
            "JPY" => std::result::Result::Ok(NonNullableCatalogsCurrency::Jpy),
            "KES" => std::result::Result::Ok(NonNullableCatalogsCurrency::Kes),
            "KGS" => std::result::Result::Ok(NonNullableCatalogsCurrency::Kgs),
            "KHR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Khr),
            "KMF" => std::result::Result::Ok(NonNullableCatalogsCurrency::Kmf),
            "KPW" => std::result::Result::Ok(NonNullableCatalogsCurrency::Kpw),
            "KRW" => std::result::Result::Ok(NonNullableCatalogsCurrency::Krw),
            "KWD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Kwd),
            "KYD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Kyd),
            "KZT" => std::result::Result::Ok(NonNullableCatalogsCurrency::Kzt),
            "LAK" => std::result::Result::Ok(NonNullableCatalogsCurrency::Lak),
            "LBP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Lbp),
            "LKR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Lkr),
            "LRD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Lrd),
            "LSL" => std::result::Result::Ok(NonNullableCatalogsCurrency::Lsl),
            "LYD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Lyd),
            "MAD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Mad),
            "MDL" => std::result::Result::Ok(NonNullableCatalogsCurrency::Mdl),
            "MGA" => std::result::Result::Ok(NonNullableCatalogsCurrency::Mga),
            "MKD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Mkd),
            "MMK" => std::result::Result::Ok(NonNullableCatalogsCurrency::Mmk),
            "MNT" => std::result::Result::Ok(NonNullableCatalogsCurrency::Mnt),
            "MOP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Mop),
            "MRO" => std::result::Result::Ok(NonNullableCatalogsCurrency::Mro),
            "MUR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Mur),
            "MVR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Mvr),
            "MWK" => std::result::Result::Ok(NonNullableCatalogsCurrency::Mwk),
            "MXN" => std::result::Result::Ok(NonNullableCatalogsCurrency::Mxn),
            "MYR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Myr),
            "MZN" => std::result::Result::Ok(NonNullableCatalogsCurrency::Mzn),
            "NAD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Nad),
            "NGN" => std::result::Result::Ok(NonNullableCatalogsCurrency::Ngn),
            "NIO" => std::result::Result::Ok(NonNullableCatalogsCurrency::Nio),
            "NOK" => std::result::Result::Ok(NonNullableCatalogsCurrency::Nok),
            "NPR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Npr),
            "NZD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Nzd),
            "OMR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Omr),
            "PAB" => std::result::Result::Ok(NonNullableCatalogsCurrency::Pab),
            "PEN" => std::result::Result::Ok(NonNullableCatalogsCurrency::Pen),
            "PGK" => std::result::Result::Ok(NonNullableCatalogsCurrency::Pgk),
            "PHP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Php),
            "PKR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Pkr),
            "PLN" => std::result::Result::Ok(NonNullableCatalogsCurrency::Pln),
            "PYG" => std::result::Result::Ok(NonNullableCatalogsCurrency::Pyg),
            "QAR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Qar),
            "RON" => std::result::Result::Ok(NonNullableCatalogsCurrency::Ron),
            "RSD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Rsd),
            "RUB" => std::result::Result::Ok(NonNullableCatalogsCurrency::Rub),
            "RWF" => std::result::Result::Ok(NonNullableCatalogsCurrency::Rwf),
            "SAR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Sar),
            "SBD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Sbd),
            "SCR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Scr),
            "SDG" => std::result::Result::Ok(NonNullableCatalogsCurrency::Sdg),
            "SEK" => std::result::Result::Ok(NonNullableCatalogsCurrency::Sek),
            "SGD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Sgd),
            "SHP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Shp),
            "SLL" => std::result::Result::Ok(NonNullableCatalogsCurrency::Sll),
            "SOS" => std::result::Result::Ok(NonNullableCatalogsCurrency::Sos),
            "SPL" => std::result::Result::Ok(NonNullableCatalogsCurrency::Spl),
            "SRD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Srd),
            "STD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Std),
            "SVC" => std::result::Result::Ok(NonNullableCatalogsCurrency::Svc),
            "SYP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Syp),
            "SZL" => std::result::Result::Ok(NonNullableCatalogsCurrency::Szl),
            "THB" => std::result::Result::Ok(NonNullableCatalogsCurrency::Thb),
            "TJS" => std::result::Result::Ok(NonNullableCatalogsCurrency::Tjs),
            "TMT" => std::result::Result::Ok(NonNullableCatalogsCurrency::Tmt),
            "TND" => std::result::Result::Ok(NonNullableCatalogsCurrency::Tnd),
            "TOP" => std::result::Result::Ok(NonNullableCatalogsCurrency::Top),
            "TRY" => std::result::Result::Ok(NonNullableCatalogsCurrency::Try),
            "TTD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Ttd),
            "TVD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Tvd),
            "TWD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Twd),
            "TZS" => std::result::Result::Ok(NonNullableCatalogsCurrency::Tzs),
            "UAH" => std::result::Result::Ok(NonNullableCatalogsCurrency::Uah),
            "UGX" => std::result::Result::Ok(NonNullableCatalogsCurrency::Ugx),
            "USD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Usd),
            "UYU" => std::result::Result::Ok(NonNullableCatalogsCurrency::Uyu),
            "UZS" => std::result::Result::Ok(NonNullableCatalogsCurrency::Uzs),
            "VEF" => std::result::Result::Ok(NonNullableCatalogsCurrency::Vef),
            "VND" => std::result::Result::Ok(NonNullableCatalogsCurrency::Vnd),
            "VUV" => std::result::Result::Ok(NonNullableCatalogsCurrency::Vuv),
            "WST" => std::result::Result::Ok(NonNullableCatalogsCurrency::Wst),
            "XAF" => std::result::Result::Ok(NonNullableCatalogsCurrency::Xaf),
            "XCD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Xcd),
            "XDR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Xdr),
            "XOF" => std::result::Result::Ok(NonNullableCatalogsCurrency::Xof),
            "XPF" => std::result::Result::Ok(NonNullableCatalogsCurrency::Xpf),
            "YER" => std::result::Result::Ok(NonNullableCatalogsCurrency::Yer),
            "ZAR" => std::result::Result::Ok(NonNullableCatalogsCurrency::Zar),
            "ZMW" => std::result::Result::Ok(NonNullableCatalogsCurrency::Zmw),
            "ZWD" => std::result::Result::Ok(NonNullableCatalogsCurrency::Zwd),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Product availability.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NonNullableProductAvailabilityType {
    #[serde(rename = "IN_STOCK")]
    InStock,
    #[serde(rename = "OUT_OF_STOCK")]
    OutOfStock,
    #[serde(rename = "PREORDER")]
    Preorder,
}

impl std::fmt::Display for NonNullableProductAvailabilityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NonNullableProductAvailabilityType::InStock => write!(f, "IN_STOCK"),
            NonNullableProductAvailabilityType::OutOfStock => write!(f, "OUT_OF_STOCK"),
            NonNullableProductAvailabilityType::Preorder => write!(f, "PREORDER"),
        }
    }
}

impl std::str::FromStr for NonNullableProductAvailabilityType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "IN_STOCK" => std::result::Result::Ok(NonNullableProductAvailabilityType::InStock),
            "OUT_OF_STOCK" => std::result::Result::Ok(NonNullableProductAvailabilityType::OutOfStock),
            "PREORDER" => std::result::Result::Ok(NonNullableProductAvailabilityType::Preorder),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Product item fields
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NullableCatalogsItemFieldType {
    #[serde(rename = "ITEM_ID")]
    ItemId,
    #[serde(rename = "ITEM_GROUP_ID")]
    ItemGroupId,
    #[serde(rename = "TITLE")]
    Title,
    #[serde(rename = "DESCRIPTION")]
    Description,
    #[serde(rename = "ITEM_LINK")]
    ItemLink,
    #[serde(rename = "ORGANIC_LINK")]
    OrganicLink,
    #[serde(rename = "IMAGE_LINK")]
    ImageLink,
    #[serde(rename = "ADWORDS_REDIRECT_LINK")]
    AdwordsRedirectLink,
    #[serde(rename = "AD_LINK")]
    AdLink,
    #[serde(rename = "SIZE")]
    Size,
    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY")]
    GoogleProductCategory,
    #[serde(rename = "PRODUCT_CATEGORY")]
    ProductCategory,
    #[serde(rename = "CONDITION")]
    Condition,
    #[serde(rename = "AVAILABILITY")]
    Availability,
    #[serde(rename = "GENDER")]
    Gender,
    #[serde(rename = "AGE_GROUP")]
    AgeGroup,
    #[serde(rename = "SIZE_TYPE")]
    SizeType,
    #[serde(rename = "SIZE_SYSTEM")]
    SizeSystem,
    #[serde(rename = "ADULT")]
    Adult,
    #[serde(rename = "SHIPPING")]
    Shipping,
    #[serde(rename = "SHIPPING_WEIGHT")]
    ShippingWeight,
    #[serde(rename = "TAX")]
    Tax,
    #[serde(rename = "MULTIPACK")]
    Multipack,
    #[serde(rename = "ADDITIONAL_IMAGE_LINK")]
    AdditionalImageLink,
    #[serde(rename = "PRICE")]
    Price,
    #[serde(rename = "SALE_PRICE")]
    SalePrice,
    #[serde(rename = "IS_BUNDLE")]
    IsBundle,
    #[serde(rename = "EXPIRATION_DATE")]
    ExpirationDate,
    #[serde(rename = "SALE_PRICE_EFFECTIVE_DATE")]
    SalePriceEffectiveDate,
    #[serde(rename = "AVAILABILITY_DATE")]
    AvailabilityDate,
    #[serde(rename = "WEIGHT_UNIT")]
    WeightUnit,
    #[serde(rename = "PRODUCT_TYPE")]
    ProductType,
    #[serde(rename = "CUSTOM_LABEL_0")]
    CustomLabel0,
    #[serde(rename = "CUSTOM_LABEL_1")]
    CustomLabel1,
    #[serde(rename = "CUSTOM_LABEL_2")]
    CustomLabel2,
    #[serde(rename = "CUSTOM_LABEL_3")]
    CustomLabel3,
    #[serde(rename = "CUSTOM_LABEL_4")]
    CustomLabel4,
    #[serde(rename = "MATERIAL")]
    Material,
    #[serde(rename = "PATTERN")]
    Pattern,
    #[serde(rename = "COLOR")]
    Color,
    #[serde(rename = "BRAND")]
    Brand,
    #[serde(rename = "GTIN")]
    Gtin,
    #[serde(rename = "MPN")]
    Mpn,
    #[serde(rename = "IOS_DEEP_LINK")]
    IosDeepLink,
    #[serde(rename = "ANDROID_DEEP_LINK")]
    AndroidDeepLink,
    #[serde(rename = "FREE_SHIPPING_LABEL")]
    FreeShippingLabel,
    #[serde(rename = "FREE_SHIPPING_LIMIT")]
    FreeShippingLimit,
    #[serde(rename = "AVG_REVIEW_RATING")]
    AvgReviewRating,
    #[serde(rename = "NUM_RATINGS")]
    NumRatings,
    #[serde(rename = "NUM_REVIEWS")]
    NumReviews,
    #[serde(rename = "ALT_TEXT")]
    AltText,
    #[serde(rename = "VARIANT_NAMES")]
    VariantNames,
    #[serde(rename = "VARIANT_VALUES")]
    VariantValues,
    #[serde(rename = "MIN_AD_PRICE")]
    MinAdPrice,
    #[serde(rename = "SHIPPING_WIDTH")]
    ShippingWidth,
    #[serde(rename = "SHIPPING_HEIGHT")]
    ShippingHeight,
    #[serde(rename = "null")]
    Null,
}

impl std::fmt::Display for NullableCatalogsItemFieldType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NullableCatalogsItemFieldType::ItemId => write!(f, "ITEM_ID"),
            NullableCatalogsItemFieldType::ItemGroupId => write!(f, "ITEM_GROUP_ID"),
            NullableCatalogsItemFieldType::Title => write!(f, "TITLE"),
            NullableCatalogsItemFieldType::Description => write!(f, "DESCRIPTION"),
            NullableCatalogsItemFieldType::ItemLink => write!(f, "ITEM_LINK"),
            NullableCatalogsItemFieldType::OrganicLink => write!(f, "ORGANIC_LINK"),
            NullableCatalogsItemFieldType::ImageLink => write!(f, "IMAGE_LINK"),
            NullableCatalogsItemFieldType::AdwordsRedirectLink => write!(f, "ADWORDS_REDIRECT_LINK"),
            NullableCatalogsItemFieldType::AdLink => write!(f, "AD_LINK"),
            NullableCatalogsItemFieldType::Size => write!(f, "SIZE"),
            NullableCatalogsItemFieldType::GoogleProductCategory => write!(f, "GOOGLE_PRODUCT_CATEGORY"),
            NullableCatalogsItemFieldType::ProductCategory => write!(f, "PRODUCT_CATEGORY"),
            NullableCatalogsItemFieldType::Condition => write!(f, "CONDITION"),
            NullableCatalogsItemFieldType::Availability => write!(f, "AVAILABILITY"),
            NullableCatalogsItemFieldType::Gender => write!(f, "GENDER"),
            NullableCatalogsItemFieldType::AgeGroup => write!(f, "AGE_GROUP"),
            NullableCatalogsItemFieldType::SizeType => write!(f, "SIZE_TYPE"),
            NullableCatalogsItemFieldType::SizeSystem => write!(f, "SIZE_SYSTEM"),
            NullableCatalogsItemFieldType::Adult => write!(f, "ADULT"),
            NullableCatalogsItemFieldType::Shipping => write!(f, "SHIPPING"),
            NullableCatalogsItemFieldType::ShippingWeight => write!(f, "SHIPPING_WEIGHT"),
            NullableCatalogsItemFieldType::Tax => write!(f, "TAX"),
            NullableCatalogsItemFieldType::Multipack => write!(f, "MULTIPACK"),
            NullableCatalogsItemFieldType::AdditionalImageLink => write!(f, "ADDITIONAL_IMAGE_LINK"),
            NullableCatalogsItemFieldType::Price => write!(f, "PRICE"),
            NullableCatalogsItemFieldType::SalePrice => write!(f, "SALE_PRICE"),
            NullableCatalogsItemFieldType::IsBundle => write!(f, "IS_BUNDLE"),
            NullableCatalogsItemFieldType::ExpirationDate => write!(f, "EXPIRATION_DATE"),
            NullableCatalogsItemFieldType::SalePriceEffectiveDate => write!(f, "SALE_PRICE_EFFECTIVE_DATE"),
            NullableCatalogsItemFieldType::AvailabilityDate => write!(f, "AVAILABILITY_DATE"),
            NullableCatalogsItemFieldType::WeightUnit => write!(f, "WEIGHT_UNIT"),
            NullableCatalogsItemFieldType::ProductType => write!(f, "PRODUCT_TYPE"),
            NullableCatalogsItemFieldType::CustomLabel0 => write!(f, "CUSTOM_LABEL_0"),
            NullableCatalogsItemFieldType::CustomLabel1 => write!(f, "CUSTOM_LABEL_1"),
            NullableCatalogsItemFieldType::CustomLabel2 => write!(f, "CUSTOM_LABEL_2"),
            NullableCatalogsItemFieldType::CustomLabel3 => write!(f, "CUSTOM_LABEL_3"),
            NullableCatalogsItemFieldType::CustomLabel4 => write!(f, "CUSTOM_LABEL_4"),
            NullableCatalogsItemFieldType::Material => write!(f, "MATERIAL"),
            NullableCatalogsItemFieldType::Pattern => write!(f, "PATTERN"),
            NullableCatalogsItemFieldType::Color => write!(f, "COLOR"),
            NullableCatalogsItemFieldType::Brand => write!(f, "BRAND"),
            NullableCatalogsItemFieldType::Gtin => write!(f, "GTIN"),
            NullableCatalogsItemFieldType::Mpn => write!(f, "MPN"),
            NullableCatalogsItemFieldType::IosDeepLink => write!(f, "IOS_DEEP_LINK"),
            NullableCatalogsItemFieldType::AndroidDeepLink => write!(f, "ANDROID_DEEP_LINK"),
            NullableCatalogsItemFieldType::FreeShippingLabel => write!(f, "FREE_SHIPPING_LABEL"),
            NullableCatalogsItemFieldType::FreeShippingLimit => write!(f, "FREE_SHIPPING_LIMIT"),
            NullableCatalogsItemFieldType::AvgReviewRating => write!(f, "AVG_REVIEW_RATING"),
            NullableCatalogsItemFieldType::NumRatings => write!(f, "NUM_RATINGS"),
            NullableCatalogsItemFieldType::NumReviews => write!(f, "NUM_REVIEWS"),
            NullableCatalogsItemFieldType::AltText => write!(f, "ALT_TEXT"),
            NullableCatalogsItemFieldType::VariantNames => write!(f, "VARIANT_NAMES"),
            NullableCatalogsItemFieldType::VariantValues => write!(f, "VARIANT_VALUES"),
            NullableCatalogsItemFieldType::MinAdPrice => write!(f, "MIN_AD_PRICE"),
            NullableCatalogsItemFieldType::ShippingWidth => write!(f, "SHIPPING_WIDTH"),
            NullableCatalogsItemFieldType::ShippingHeight => write!(f, "SHIPPING_HEIGHT"),
            NullableCatalogsItemFieldType::Null => write!(f, "null"),
        }
    }
}

impl std::str::FromStr for NullableCatalogsItemFieldType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ITEM_ID" => std::result::Result::Ok(NullableCatalogsItemFieldType::ItemId),
            "ITEM_GROUP_ID" => std::result::Result::Ok(NullableCatalogsItemFieldType::ItemGroupId),
            "TITLE" => std::result::Result::Ok(NullableCatalogsItemFieldType::Title),
            "DESCRIPTION" => std::result::Result::Ok(NullableCatalogsItemFieldType::Description),
            "ITEM_LINK" => std::result::Result::Ok(NullableCatalogsItemFieldType::ItemLink),
            "ORGANIC_LINK" => std::result::Result::Ok(NullableCatalogsItemFieldType::OrganicLink),
            "IMAGE_LINK" => std::result::Result::Ok(NullableCatalogsItemFieldType::ImageLink),
            "ADWORDS_REDIRECT_LINK" => std::result::Result::Ok(NullableCatalogsItemFieldType::AdwordsRedirectLink),
            "AD_LINK" => std::result::Result::Ok(NullableCatalogsItemFieldType::AdLink),
            "SIZE" => std::result::Result::Ok(NullableCatalogsItemFieldType::Size),
            "GOOGLE_PRODUCT_CATEGORY" => std::result::Result::Ok(NullableCatalogsItemFieldType::GoogleProductCategory),
            "PRODUCT_CATEGORY" => std::result::Result::Ok(NullableCatalogsItemFieldType::ProductCategory),
            "CONDITION" => std::result::Result::Ok(NullableCatalogsItemFieldType::Condition),
            "AVAILABILITY" => std::result::Result::Ok(NullableCatalogsItemFieldType::Availability),
            "GENDER" => std::result::Result::Ok(NullableCatalogsItemFieldType::Gender),
            "AGE_GROUP" => std::result::Result::Ok(NullableCatalogsItemFieldType::AgeGroup),
            "SIZE_TYPE" => std::result::Result::Ok(NullableCatalogsItemFieldType::SizeType),
            "SIZE_SYSTEM" => std::result::Result::Ok(NullableCatalogsItemFieldType::SizeSystem),
            "ADULT" => std::result::Result::Ok(NullableCatalogsItemFieldType::Adult),
            "SHIPPING" => std::result::Result::Ok(NullableCatalogsItemFieldType::Shipping),
            "SHIPPING_WEIGHT" => std::result::Result::Ok(NullableCatalogsItemFieldType::ShippingWeight),
            "TAX" => std::result::Result::Ok(NullableCatalogsItemFieldType::Tax),
            "MULTIPACK" => std::result::Result::Ok(NullableCatalogsItemFieldType::Multipack),
            "ADDITIONAL_IMAGE_LINK" => std::result::Result::Ok(NullableCatalogsItemFieldType::AdditionalImageLink),
            "PRICE" => std::result::Result::Ok(NullableCatalogsItemFieldType::Price),
            "SALE_PRICE" => std::result::Result::Ok(NullableCatalogsItemFieldType::SalePrice),
            "IS_BUNDLE" => std::result::Result::Ok(NullableCatalogsItemFieldType::IsBundle),
            "EXPIRATION_DATE" => std::result::Result::Ok(NullableCatalogsItemFieldType::ExpirationDate),
            "SALE_PRICE_EFFECTIVE_DATE" => std::result::Result::Ok(NullableCatalogsItemFieldType::SalePriceEffectiveDate),
            "AVAILABILITY_DATE" => std::result::Result::Ok(NullableCatalogsItemFieldType::AvailabilityDate),
            "WEIGHT_UNIT" => std::result::Result::Ok(NullableCatalogsItemFieldType::WeightUnit),
            "PRODUCT_TYPE" => std::result::Result::Ok(NullableCatalogsItemFieldType::ProductType),
            "CUSTOM_LABEL_0" => std::result::Result::Ok(NullableCatalogsItemFieldType::CustomLabel0),
            "CUSTOM_LABEL_1" => std::result::Result::Ok(NullableCatalogsItemFieldType::CustomLabel1),
            "CUSTOM_LABEL_2" => std::result::Result::Ok(NullableCatalogsItemFieldType::CustomLabel2),
            "CUSTOM_LABEL_3" => std::result::Result::Ok(NullableCatalogsItemFieldType::CustomLabel3),
            "CUSTOM_LABEL_4" => std::result::Result::Ok(NullableCatalogsItemFieldType::CustomLabel4),
            "MATERIAL" => std::result::Result::Ok(NullableCatalogsItemFieldType::Material),
            "PATTERN" => std::result::Result::Ok(NullableCatalogsItemFieldType::Pattern),
            "COLOR" => std::result::Result::Ok(NullableCatalogsItemFieldType::Color),
            "BRAND" => std::result::Result::Ok(NullableCatalogsItemFieldType::Brand),
            "GTIN" => std::result::Result::Ok(NullableCatalogsItemFieldType::Gtin),
            "MPN" => std::result::Result::Ok(NullableCatalogsItemFieldType::Mpn),
            "IOS_DEEP_LINK" => std::result::Result::Ok(NullableCatalogsItemFieldType::IosDeepLink),
            "ANDROID_DEEP_LINK" => std::result::Result::Ok(NullableCatalogsItemFieldType::AndroidDeepLink),
            "FREE_SHIPPING_LABEL" => std::result::Result::Ok(NullableCatalogsItemFieldType::FreeShippingLabel),
            "FREE_SHIPPING_LIMIT" => std::result::Result::Ok(NullableCatalogsItemFieldType::FreeShippingLimit),
            "AVG_REVIEW_RATING" => std::result::Result::Ok(NullableCatalogsItemFieldType::AvgReviewRating),
            "NUM_RATINGS" => std::result::Result::Ok(NullableCatalogsItemFieldType::NumRatings),
            "NUM_REVIEWS" => std::result::Result::Ok(NullableCatalogsItemFieldType::NumReviews),
            "ALT_TEXT" => std::result::Result::Ok(NullableCatalogsItemFieldType::AltText),
            "VARIANT_NAMES" => std::result::Result::Ok(NullableCatalogsItemFieldType::VariantNames),
            "VARIANT_VALUES" => std::result::Result::Ok(NullableCatalogsItemFieldType::VariantValues),
            "MIN_AD_PRICE" => std::result::Result::Ok(NullableCatalogsItemFieldType::MinAdPrice),
            "SHIPPING_WIDTH" => std::result::Result::Ok(NullableCatalogsItemFieldType::ShippingWidth),
            "SHIPPING_HEIGHT" => std::result::Result::Ok(NullableCatalogsItemFieldType::ShippingHeight),
            "null" => std::result::Result::Ok(NullableCatalogsItemFieldType::Null),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Currency Codes from ISO 4217.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NullableCurrency {
    #[serde(rename = "AED")]
    Aed,
    #[serde(rename = "AFN")]
    Afn,
    #[serde(rename = "ALL")]
    All,
    #[serde(rename = "AMD")]
    Amd,
    #[serde(rename = "ANG")]
    Ang,
    #[serde(rename = "AOA")]
    Aoa,
    #[serde(rename = "ARS")]
    Ars,
    #[serde(rename = "AUD")]
    Aud,
    #[serde(rename = "AWG")]
    Awg,
    #[serde(rename = "AZN")]
    Azn,
    #[serde(rename = "BAM")]
    Bam,
    #[serde(rename = "BBD")]
    Bbd,
    #[serde(rename = "BDT")]
    Bdt,
    #[serde(rename = "BGN")]
    Bgn,
    #[serde(rename = "BHD")]
    Bhd,
    #[serde(rename = "BIF")]
    Bif,
    #[serde(rename = "BMD")]
    Bmd,
    #[serde(rename = "BND")]
    Bnd,
    #[serde(rename = "BOB")]
    Bob,
    #[serde(rename = "BRL")]
    Brl,
    #[serde(rename = "BSD")]
    Bsd,
    #[serde(rename = "BTN")]
    Btn,
    #[serde(rename = "BWP")]
    Bwp,
    #[serde(rename = "BYN")]
    Byn,
    #[serde(rename = "BYR")]
    Byr,
    #[serde(rename = "BZD")]
    Bzd,
    #[serde(rename = "CAD")]
    Cad,
    #[serde(rename = "CDF")]
    Cdf,
    #[serde(rename = "CHF")]
    Chf,
    #[serde(rename = "CLP")]
    Clp,
    #[serde(rename = "CNY")]
    Cny,
    #[serde(rename = "COP")]
    Cop,
    #[serde(rename = "CRC")]
    Crc,
    #[serde(rename = "CUC")]
    Cuc,
    #[serde(rename = "CUP")]
    Cup,
    #[serde(rename = "CVE")]
    Cve,
    #[serde(rename = "CZK")]
    Czk,
    #[serde(rename = "DJF")]
    Djf,
    #[serde(rename = "DKK")]
    Dkk,
    #[serde(rename = "DOP")]
    Dop,
    #[serde(rename = "DZD")]
    Dzd,
    #[serde(rename = "EGP")]
    Egp,
    #[serde(rename = "ERN")]
    Ern,
    #[serde(rename = "ETB")]
    Etb,
    #[serde(rename = "EUR")]
    Eur,
    #[serde(rename = "FJD")]
    Fjd,
    #[serde(rename = "FKP")]
    Fkp,
    #[serde(rename = "GBP")]
    Gbp,
    #[serde(rename = "GEL")]
    Gel,
    #[serde(rename = "GGP")]
    Ggp,
    #[serde(rename = "GHS")]
    Ghs,
    #[serde(rename = "GIP")]
    Gip,
    #[serde(rename = "GMD")]
    Gmd,
    #[serde(rename = "GNF")]
    Gnf,
    #[serde(rename = "GTQ")]
    Gtq,
    #[serde(rename = "GYD")]
    Gyd,
    #[serde(rename = "HKD")]
    Hkd,
    #[serde(rename = "HNL")]
    Hnl,
    #[serde(rename = "HRK")]
    Hrk,
    #[serde(rename = "HTG")]
    Htg,
    #[serde(rename = "HUF")]
    Huf,
    #[serde(rename = "IDR")]
    Idr,
    #[serde(rename = "ILS")]
    Ils,
    #[serde(rename = "IMP")]
    Imp,
    #[serde(rename = "INR")]
    Inr,
    #[serde(rename = "IQD")]
    Iqd,
    #[serde(rename = "IRR")]
    Irr,
    #[serde(rename = "ISK")]
    Isk,
    #[serde(rename = "JEP")]
    Jep,
    #[serde(rename = "JMD")]
    Jmd,
    #[serde(rename = "JOD")]
    Jod,
    #[serde(rename = "JPY")]
    Jpy,
    #[serde(rename = "KES")]
    Kes,
    #[serde(rename = "KGS")]
    Kgs,
    #[serde(rename = "KHR")]
    Khr,
    #[serde(rename = "KMF")]
    Kmf,
    #[serde(rename = "KPW")]
    Kpw,
    #[serde(rename = "KRW")]
    Krw,
    #[serde(rename = "KWD")]
    Kwd,
    #[serde(rename = "KYD")]
    Kyd,
    #[serde(rename = "KZT")]
    Kzt,
    #[serde(rename = "LAK")]
    Lak,
    #[serde(rename = "LBP")]
    Lbp,
    #[serde(rename = "LKR")]
    Lkr,
    #[serde(rename = "LRD")]
    Lrd,
    #[serde(rename = "LSL")]
    Lsl,
    #[serde(rename = "LYD")]
    Lyd,
    #[serde(rename = "MAD")]
    Mad,
    #[serde(rename = "MDL")]
    Mdl,
    #[serde(rename = "MGA")]
    Mga,
    #[serde(rename = "MKD")]
    Mkd,
    #[serde(rename = "MMK")]
    Mmk,
    #[serde(rename = "MNT")]
    Mnt,
    #[serde(rename = "MOP")]
    Mop,
    #[serde(rename = "MRO")]
    Mro,
    #[serde(rename = "MUR")]
    Mur,
    #[serde(rename = "MVR")]
    Mvr,
    #[serde(rename = "MWK")]
    Mwk,
    #[serde(rename = "MXN")]
    Mxn,
    #[serde(rename = "MYR")]
    Myr,
    #[serde(rename = "MZN")]
    Mzn,
    #[serde(rename = "NAD")]
    Nad,
    #[serde(rename = "NGN")]
    Ngn,
    #[serde(rename = "NIO")]
    Nio,
    #[serde(rename = "NOK")]
    Nok,
    #[serde(rename = "NPR")]
    Npr,
    #[serde(rename = "NZD")]
    Nzd,
    #[serde(rename = "OMR")]
    Omr,
    #[serde(rename = "PAB")]
    Pab,
    #[serde(rename = "PEN")]
    Pen,
    #[serde(rename = "PGK")]
    Pgk,
    #[serde(rename = "PHP")]
    Php,
    #[serde(rename = "PKR")]
    Pkr,
    #[serde(rename = "PLN")]
    Pln,
    #[serde(rename = "PYG")]
    Pyg,
    #[serde(rename = "QAR")]
    Qar,
    #[serde(rename = "RON")]
    Ron,
    #[serde(rename = "RSD")]
    Rsd,
    #[serde(rename = "RUB")]
    Rub,
    #[serde(rename = "RWF")]
    Rwf,
    #[serde(rename = "SAR")]
    Sar,
    #[serde(rename = "SBD")]
    Sbd,
    #[serde(rename = "SCR")]
    Scr,
    #[serde(rename = "SDG")]
    Sdg,
    #[serde(rename = "SEK")]
    Sek,
    #[serde(rename = "SGD")]
    Sgd,
    #[serde(rename = "SHP")]
    Shp,
    #[serde(rename = "SLL")]
    Sll,
    #[serde(rename = "SOS")]
    Sos,
    #[serde(rename = "SPL")]
    Spl,
    #[serde(rename = "SRD")]
    Srd,
    #[serde(rename = "STD")]
    Std,
    #[serde(rename = "SVC")]
    Svc,
    #[serde(rename = "SYP")]
    Syp,
    #[serde(rename = "SZL")]
    Szl,
    #[serde(rename = "THB")]
    Thb,
    #[serde(rename = "TJS")]
    Tjs,
    #[serde(rename = "TMT")]
    Tmt,
    #[serde(rename = "TND")]
    Tnd,
    #[serde(rename = "TOP")]
    Top,
    #[serde(rename = "TRY")]
    Try,
    #[serde(rename = "TTD")]
    Ttd,
    #[serde(rename = "TVD")]
    Tvd,
    #[serde(rename = "TWD")]
    Twd,
    #[serde(rename = "TZS")]
    Tzs,
    #[serde(rename = "UAH")]
    Uah,
    #[serde(rename = "UGX")]
    Ugx,
    #[serde(rename = "USD")]
    Usd,
    #[serde(rename = "UYU")]
    Uyu,
    #[serde(rename = "UZS")]
    Uzs,
    #[serde(rename = "VEF")]
    Vef,
    #[serde(rename = "VND")]
    Vnd,
    #[serde(rename = "VUV")]
    Vuv,
    #[serde(rename = "WST")]
    Wst,
    #[serde(rename = "XAF")]
    Xaf,
    #[serde(rename = "XCD")]
    Xcd,
    #[serde(rename = "XDR")]
    Xdr,
    #[serde(rename = "XOF")]
    Xof,
    #[serde(rename = "XPF")]
    Xpf,
    #[serde(rename = "YER")]
    Yer,
    #[serde(rename = "ZAR")]
    Zar,
    #[serde(rename = "ZMW")]
    Zmw,
    #[serde(rename = "ZWD")]
    Zwd,
    #[serde(rename = "null")]
    Null,
}

impl std::fmt::Display for NullableCurrency {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NullableCurrency::Aed => write!(f, "AED"),
            NullableCurrency::Afn => write!(f, "AFN"),
            NullableCurrency::All => write!(f, "ALL"),
            NullableCurrency::Amd => write!(f, "AMD"),
            NullableCurrency::Ang => write!(f, "ANG"),
            NullableCurrency::Aoa => write!(f, "AOA"),
            NullableCurrency::Ars => write!(f, "ARS"),
            NullableCurrency::Aud => write!(f, "AUD"),
            NullableCurrency::Awg => write!(f, "AWG"),
            NullableCurrency::Azn => write!(f, "AZN"),
            NullableCurrency::Bam => write!(f, "BAM"),
            NullableCurrency::Bbd => write!(f, "BBD"),
            NullableCurrency::Bdt => write!(f, "BDT"),
            NullableCurrency::Bgn => write!(f, "BGN"),
            NullableCurrency::Bhd => write!(f, "BHD"),
            NullableCurrency::Bif => write!(f, "BIF"),
            NullableCurrency::Bmd => write!(f, "BMD"),
            NullableCurrency::Bnd => write!(f, "BND"),
            NullableCurrency::Bob => write!(f, "BOB"),
            NullableCurrency::Brl => write!(f, "BRL"),
            NullableCurrency::Bsd => write!(f, "BSD"),
            NullableCurrency::Btn => write!(f, "BTN"),
            NullableCurrency::Bwp => write!(f, "BWP"),
            NullableCurrency::Byn => write!(f, "BYN"),
            NullableCurrency::Byr => write!(f, "BYR"),
            NullableCurrency::Bzd => write!(f, "BZD"),
            NullableCurrency::Cad => write!(f, "CAD"),
            NullableCurrency::Cdf => write!(f, "CDF"),
            NullableCurrency::Chf => write!(f, "CHF"),
            NullableCurrency::Clp => write!(f, "CLP"),
            NullableCurrency::Cny => write!(f, "CNY"),
            NullableCurrency::Cop => write!(f, "COP"),
            NullableCurrency::Crc => write!(f, "CRC"),
            NullableCurrency::Cuc => write!(f, "CUC"),
            NullableCurrency::Cup => write!(f, "CUP"),
            NullableCurrency::Cve => write!(f, "CVE"),
            NullableCurrency::Czk => write!(f, "CZK"),
            NullableCurrency::Djf => write!(f, "DJF"),
            NullableCurrency::Dkk => write!(f, "DKK"),
            NullableCurrency::Dop => write!(f, "DOP"),
            NullableCurrency::Dzd => write!(f, "DZD"),
            NullableCurrency::Egp => write!(f, "EGP"),
            NullableCurrency::Ern => write!(f, "ERN"),
            NullableCurrency::Etb => write!(f, "ETB"),
            NullableCurrency::Eur => write!(f, "EUR"),
            NullableCurrency::Fjd => write!(f, "FJD"),
            NullableCurrency::Fkp => write!(f, "FKP"),
            NullableCurrency::Gbp => write!(f, "GBP"),
            NullableCurrency::Gel => write!(f, "GEL"),
            NullableCurrency::Ggp => write!(f, "GGP"),
            NullableCurrency::Ghs => write!(f, "GHS"),
            NullableCurrency::Gip => write!(f, "GIP"),
            NullableCurrency::Gmd => write!(f, "GMD"),
            NullableCurrency::Gnf => write!(f, "GNF"),
            NullableCurrency::Gtq => write!(f, "GTQ"),
            NullableCurrency::Gyd => write!(f, "GYD"),
            NullableCurrency::Hkd => write!(f, "HKD"),
            NullableCurrency::Hnl => write!(f, "HNL"),
            NullableCurrency::Hrk => write!(f, "HRK"),
            NullableCurrency::Htg => write!(f, "HTG"),
            NullableCurrency::Huf => write!(f, "HUF"),
            NullableCurrency::Idr => write!(f, "IDR"),
            NullableCurrency::Ils => write!(f, "ILS"),
            NullableCurrency::Imp => write!(f, "IMP"),
            NullableCurrency::Inr => write!(f, "INR"),
            NullableCurrency::Iqd => write!(f, "IQD"),
            NullableCurrency::Irr => write!(f, "IRR"),
            NullableCurrency::Isk => write!(f, "ISK"),
            NullableCurrency::Jep => write!(f, "JEP"),
            NullableCurrency::Jmd => write!(f, "JMD"),
            NullableCurrency::Jod => write!(f, "JOD"),
            NullableCurrency::Jpy => write!(f, "JPY"),
            NullableCurrency::Kes => write!(f, "KES"),
            NullableCurrency::Kgs => write!(f, "KGS"),
            NullableCurrency::Khr => write!(f, "KHR"),
            NullableCurrency::Kmf => write!(f, "KMF"),
            NullableCurrency::Kpw => write!(f, "KPW"),
            NullableCurrency::Krw => write!(f, "KRW"),
            NullableCurrency::Kwd => write!(f, "KWD"),
            NullableCurrency::Kyd => write!(f, "KYD"),
            NullableCurrency::Kzt => write!(f, "KZT"),
            NullableCurrency::Lak => write!(f, "LAK"),
            NullableCurrency::Lbp => write!(f, "LBP"),
            NullableCurrency::Lkr => write!(f, "LKR"),
            NullableCurrency::Lrd => write!(f, "LRD"),
            NullableCurrency::Lsl => write!(f, "LSL"),
            NullableCurrency::Lyd => write!(f, "LYD"),
            NullableCurrency::Mad => write!(f, "MAD"),
            NullableCurrency::Mdl => write!(f, "MDL"),
            NullableCurrency::Mga => write!(f, "MGA"),
            NullableCurrency::Mkd => write!(f, "MKD"),
            NullableCurrency::Mmk => write!(f, "MMK"),
            NullableCurrency::Mnt => write!(f, "MNT"),
            NullableCurrency::Mop => write!(f, "MOP"),
            NullableCurrency::Mro => write!(f, "MRO"),
            NullableCurrency::Mur => write!(f, "MUR"),
            NullableCurrency::Mvr => write!(f, "MVR"),
            NullableCurrency::Mwk => write!(f, "MWK"),
            NullableCurrency::Mxn => write!(f, "MXN"),
            NullableCurrency::Myr => write!(f, "MYR"),
            NullableCurrency::Mzn => write!(f, "MZN"),
            NullableCurrency::Nad => write!(f, "NAD"),
            NullableCurrency::Ngn => write!(f, "NGN"),
            NullableCurrency::Nio => write!(f, "NIO"),
            NullableCurrency::Nok => write!(f, "NOK"),
            NullableCurrency::Npr => write!(f, "NPR"),
            NullableCurrency::Nzd => write!(f, "NZD"),
            NullableCurrency::Omr => write!(f, "OMR"),
            NullableCurrency::Pab => write!(f, "PAB"),
            NullableCurrency::Pen => write!(f, "PEN"),
            NullableCurrency::Pgk => write!(f, "PGK"),
            NullableCurrency::Php => write!(f, "PHP"),
            NullableCurrency::Pkr => write!(f, "PKR"),
            NullableCurrency::Pln => write!(f, "PLN"),
            NullableCurrency::Pyg => write!(f, "PYG"),
            NullableCurrency::Qar => write!(f, "QAR"),
            NullableCurrency::Ron => write!(f, "RON"),
            NullableCurrency::Rsd => write!(f, "RSD"),
            NullableCurrency::Rub => write!(f, "RUB"),
            NullableCurrency::Rwf => write!(f, "RWF"),
            NullableCurrency::Sar => write!(f, "SAR"),
            NullableCurrency::Sbd => write!(f, "SBD"),
            NullableCurrency::Scr => write!(f, "SCR"),
            NullableCurrency::Sdg => write!(f, "SDG"),
            NullableCurrency::Sek => write!(f, "SEK"),
            NullableCurrency::Sgd => write!(f, "SGD"),
            NullableCurrency::Shp => write!(f, "SHP"),
            NullableCurrency::Sll => write!(f, "SLL"),
            NullableCurrency::Sos => write!(f, "SOS"),
            NullableCurrency::Spl => write!(f, "SPL"),
            NullableCurrency::Srd => write!(f, "SRD"),
            NullableCurrency::Std => write!(f, "STD"),
            NullableCurrency::Svc => write!(f, "SVC"),
            NullableCurrency::Syp => write!(f, "SYP"),
            NullableCurrency::Szl => write!(f, "SZL"),
            NullableCurrency::Thb => write!(f, "THB"),
            NullableCurrency::Tjs => write!(f, "TJS"),
            NullableCurrency::Tmt => write!(f, "TMT"),
            NullableCurrency::Tnd => write!(f, "TND"),
            NullableCurrency::Top => write!(f, "TOP"),
            NullableCurrency::Try => write!(f, "TRY"),
            NullableCurrency::Ttd => write!(f, "TTD"),
            NullableCurrency::Tvd => write!(f, "TVD"),
            NullableCurrency::Twd => write!(f, "TWD"),
            NullableCurrency::Tzs => write!(f, "TZS"),
            NullableCurrency::Uah => write!(f, "UAH"),
            NullableCurrency::Ugx => write!(f, "UGX"),
            NullableCurrency::Usd => write!(f, "USD"),
            NullableCurrency::Uyu => write!(f, "UYU"),
            NullableCurrency::Uzs => write!(f, "UZS"),
            NullableCurrency::Vef => write!(f, "VEF"),
            NullableCurrency::Vnd => write!(f, "VND"),
            NullableCurrency::Vuv => write!(f, "VUV"),
            NullableCurrency::Wst => write!(f, "WST"),
            NullableCurrency::Xaf => write!(f, "XAF"),
            NullableCurrency::Xcd => write!(f, "XCD"),
            NullableCurrency::Xdr => write!(f, "XDR"),
            NullableCurrency::Xof => write!(f, "XOF"),
            NullableCurrency::Xpf => write!(f, "XPF"),
            NullableCurrency::Yer => write!(f, "YER"),
            NullableCurrency::Zar => write!(f, "ZAR"),
            NullableCurrency::Zmw => write!(f, "ZMW"),
            NullableCurrency::Zwd => write!(f, "ZWD"),
            NullableCurrency::Null => write!(f, "null"),
        }
    }
}

impl std::str::FromStr for NullableCurrency {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AED" => std::result::Result::Ok(NullableCurrency::Aed),
            "AFN" => std::result::Result::Ok(NullableCurrency::Afn),
            "ALL" => std::result::Result::Ok(NullableCurrency::All),
            "AMD" => std::result::Result::Ok(NullableCurrency::Amd),
            "ANG" => std::result::Result::Ok(NullableCurrency::Ang),
            "AOA" => std::result::Result::Ok(NullableCurrency::Aoa),
            "ARS" => std::result::Result::Ok(NullableCurrency::Ars),
            "AUD" => std::result::Result::Ok(NullableCurrency::Aud),
            "AWG" => std::result::Result::Ok(NullableCurrency::Awg),
            "AZN" => std::result::Result::Ok(NullableCurrency::Azn),
            "BAM" => std::result::Result::Ok(NullableCurrency::Bam),
            "BBD" => std::result::Result::Ok(NullableCurrency::Bbd),
            "BDT" => std::result::Result::Ok(NullableCurrency::Bdt),
            "BGN" => std::result::Result::Ok(NullableCurrency::Bgn),
            "BHD" => std::result::Result::Ok(NullableCurrency::Bhd),
            "BIF" => std::result::Result::Ok(NullableCurrency::Bif),
            "BMD" => std::result::Result::Ok(NullableCurrency::Bmd),
            "BND" => std::result::Result::Ok(NullableCurrency::Bnd),
            "BOB" => std::result::Result::Ok(NullableCurrency::Bob),
            "BRL" => std::result::Result::Ok(NullableCurrency::Brl),
            "BSD" => std::result::Result::Ok(NullableCurrency::Bsd),
            "BTN" => std::result::Result::Ok(NullableCurrency::Btn),
            "BWP" => std::result::Result::Ok(NullableCurrency::Bwp),
            "BYN" => std::result::Result::Ok(NullableCurrency::Byn),
            "BYR" => std::result::Result::Ok(NullableCurrency::Byr),
            "BZD" => std::result::Result::Ok(NullableCurrency::Bzd),
            "CAD" => std::result::Result::Ok(NullableCurrency::Cad),
            "CDF" => std::result::Result::Ok(NullableCurrency::Cdf),
            "CHF" => std::result::Result::Ok(NullableCurrency::Chf),
            "CLP" => std::result::Result::Ok(NullableCurrency::Clp),
            "CNY" => std::result::Result::Ok(NullableCurrency::Cny),
            "COP" => std::result::Result::Ok(NullableCurrency::Cop),
            "CRC" => std::result::Result::Ok(NullableCurrency::Crc),
            "CUC" => std::result::Result::Ok(NullableCurrency::Cuc),
            "CUP" => std::result::Result::Ok(NullableCurrency::Cup),
            "CVE" => std::result::Result::Ok(NullableCurrency::Cve),
            "CZK" => std::result::Result::Ok(NullableCurrency::Czk),
            "DJF" => std::result::Result::Ok(NullableCurrency::Djf),
            "DKK" => std::result::Result::Ok(NullableCurrency::Dkk),
            "DOP" => std::result::Result::Ok(NullableCurrency::Dop),
            "DZD" => std::result::Result::Ok(NullableCurrency::Dzd),
            "EGP" => std::result::Result::Ok(NullableCurrency::Egp),
            "ERN" => std::result::Result::Ok(NullableCurrency::Ern),
            "ETB" => std::result::Result::Ok(NullableCurrency::Etb),
            "EUR" => std::result::Result::Ok(NullableCurrency::Eur),
            "FJD" => std::result::Result::Ok(NullableCurrency::Fjd),
            "FKP" => std::result::Result::Ok(NullableCurrency::Fkp),
            "GBP" => std::result::Result::Ok(NullableCurrency::Gbp),
            "GEL" => std::result::Result::Ok(NullableCurrency::Gel),
            "GGP" => std::result::Result::Ok(NullableCurrency::Ggp),
            "GHS" => std::result::Result::Ok(NullableCurrency::Ghs),
            "GIP" => std::result::Result::Ok(NullableCurrency::Gip),
            "GMD" => std::result::Result::Ok(NullableCurrency::Gmd),
            "GNF" => std::result::Result::Ok(NullableCurrency::Gnf),
            "GTQ" => std::result::Result::Ok(NullableCurrency::Gtq),
            "GYD" => std::result::Result::Ok(NullableCurrency::Gyd),
            "HKD" => std::result::Result::Ok(NullableCurrency::Hkd),
            "HNL" => std::result::Result::Ok(NullableCurrency::Hnl),
            "HRK" => std::result::Result::Ok(NullableCurrency::Hrk),
            "HTG" => std::result::Result::Ok(NullableCurrency::Htg),
            "HUF" => std::result::Result::Ok(NullableCurrency::Huf),
            "IDR" => std::result::Result::Ok(NullableCurrency::Idr),
            "ILS" => std::result::Result::Ok(NullableCurrency::Ils),
            "IMP" => std::result::Result::Ok(NullableCurrency::Imp),
            "INR" => std::result::Result::Ok(NullableCurrency::Inr),
            "IQD" => std::result::Result::Ok(NullableCurrency::Iqd),
            "IRR" => std::result::Result::Ok(NullableCurrency::Irr),
            "ISK" => std::result::Result::Ok(NullableCurrency::Isk),
            "JEP" => std::result::Result::Ok(NullableCurrency::Jep),
            "JMD" => std::result::Result::Ok(NullableCurrency::Jmd),
            "JOD" => std::result::Result::Ok(NullableCurrency::Jod),
            "JPY" => std::result::Result::Ok(NullableCurrency::Jpy),
            "KES" => std::result::Result::Ok(NullableCurrency::Kes),
            "KGS" => std::result::Result::Ok(NullableCurrency::Kgs),
            "KHR" => std::result::Result::Ok(NullableCurrency::Khr),
            "KMF" => std::result::Result::Ok(NullableCurrency::Kmf),
            "KPW" => std::result::Result::Ok(NullableCurrency::Kpw),
            "KRW" => std::result::Result::Ok(NullableCurrency::Krw),
            "KWD" => std::result::Result::Ok(NullableCurrency::Kwd),
            "KYD" => std::result::Result::Ok(NullableCurrency::Kyd),
            "KZT" => std::result::Result::Ok(NullableCurrency::Kzt),
            "LAK" => std::result::Result::Ok(NullableCurrency::Lak),
            "LBP" => std::result::Result::Ok(NullableCurrency::Lbp),
            "LKR" => std::result::Result::Ok(NullableCurrency::Lkr),
            "LRD" => std::result::Result::Ok(NullableCurrency::Lrd),
            "LSL" => std::result::Result::Ok(NullableCurrency::Lsl),
            "LYD" => std::result::Result::Ok(NullableCurrency::Lyd),
            "MAD" => std::result::Result::Ok(NullableCurrency::Mad),
            "MDL" => std::result::Result::Ok(NullableCurrency::Mdl),
            "MGA" => std::result::Result::Ok(NullableCurrency::Mga),
            "MKD" => std::result::Result::Ok(NullableCurrency::Mkd),
            "MMK" => std::result::Result::Ok(NullableCurrency::Mmk),
            "MNT" => std::result::Result::Ok(NullableCurrency::Mnt),
            "MOP" => std::result::Result::Ok(NullableCurrency::Mop),
            "MRO" => std::result::Result::Ok(NullableCurrency::Mro),
            "MUR" => std::result::Result::Ok(NullableCurrency::Mur),
            "MVR" => std::result::Result::Ok(NullableCurrency::Mvr),
            "MWK" => std::result::Result::Ok(NullableCurrency::Mwk),
            "MXN" => std::result::Result::Ok(NullableCurrency::Mxn),
            "MYR" => std::result::Result::Ok(NullableCurrency::Myr),
            "MZN" => std::result::Result::Ok(NullableCurrency::Mzn),
            "NAD" => std::result::Result::Ok(NullableCurrency::Nad),
            "NGN" => std::result::Result::Ok(NullableCurrency::Ngn),
            "NIO" => std::result::Result::Ok(NullableCurrency::Nio),
            "NOK" => std::result::Result::Ok(NullableCurrency::Nok),
            "NPR" => std::result::Result::Ok(NullableCurrency::Npr),
            "NZD" => std::result::Result::Ok(NullableCurrency::Nzd),
            "OMR" => std::result::Result::Ok(NullableCurrency::Omr),
            "PAB" => std::result::Result::Ok(NullableCurrency::Pab),
            "PEN" => std::result::Result::Ok(NullableCurrency::Pen),
            "PGK" => std::result::Result::Ok(NullableCurrency::Pgk),
            "PHP" => std::result::Result::Ok(NullableCurrency::Php),
            "PKR" => std::result::Result::Ok(NullableCurrency::Pkr),
            "PLN" => std::result::Result::Ok(NullableCurrency::Pln),
            "PYG" => std::result::Result::Ok(NullableCurrency::Pyg),
            "QAR" => std::result::Result::Ok(NullableCurrency::Qar),
            "RON" => std::result::Result::Ok(NullableCurrency::Ron),
            "RSD" => std::result::Result::Ok(NullableCurrency::Rsd),
            "RUB" => std::result::Result::Ok(NullableCurrency::Rub),
            "RWF" => std::result::Result::Ok(NullableCurrency::Rwf),
            "SAR" => std::result::Result::Ok(NullableCurrency::Sar),
            "SBD" => std::result::Result::Ok(NullableCurrency::Sbd),
            "SCR" => std::result::Result::Ok(NullableCurrency::Scr),
            "SDG" => std::result::Result::Ok(NullableCurrency::Sdg),
            "SEK" => std::result::Result::Ok(NullableCurrency::Sek),
            "SGD" => std::result::Result::Ok(NullableCurrency::Sgd),
            "SHP" => std::result::Result::Ok(NullableCurrency::Shp),
            "SLL" => std::result::Result::Ok(NullableCurrency::Sll),
            "SOS" => std::result::Result::Ok(NullableCurrency::Sos),
            "SPL" => std::result::Result::Ok(NullableCurrency::Spl),
            "SRD" => std::result::Result::Ok(NullableCurrency::Srd),
            "STD" => std::result::Result::Ok(NullableCurrency::Std),
            "SVC" => std::result::Result::Ok(NullableCurrency::Svc),
            "SYP" => std::result::Result::Ok(NullableCurrency::Syp),
            "SZL" => std::result::Result::Ok(NullableCurrency::Szl),
            "THB" => std::result::Result::Ok(NullableCurrency::Thb),
            "TJS" => std::result::Result::Ok(NullableCurrency::Tjs),
            "TMT" => std::result::Result::Ok(NullableCurrency::Tmt),
            "TND" => std::result::Result::Ok(NullableCurrency::Tnd),
            "TOP" => std::result::Result::Ok(NullableCurrency::Top),
            "TRY" => std::result::Result::Ok(NullableCurrency::Try),
            "TTD" => std::result::Result::Ok(NullableCurrency::Ttd),
            "TVD" => std::result::Result::Ok(NullableCurrency::Tvd),
            "TWD" => std::result::Result::Ok(NullableCurrency::Twd),
            "TZS" => std::result::Result::Ok(NullableCurrency::Tzs),
            "UAH" => std::result::Result::Ok(NullableCurrency::Uah),
            "UGX" => std::result::Result::Ok(NullableCurrency::Ugx),
            "USD" => std::result::Result::Ok(NullableCurrency::Usd),
            "UYU" => std::result::Result::Ok(NullableCurrency::Uyu),
            "UZS" => std::result::Result::Ok(NullableCurrency::Uzs),
            "VEF" => std::result::Result::Ok(NullableCurrency::Vef),
            "VND" => std::result::Result::Ok(NullableCurrency::Vnd),
            "VUV" => std::result::Result::Ok(NullableCurrency::Vuv),
            "WST" => std::result::Result::Ok(NullableCurrency::Wst),
            "XAF" => std::result::Result::Ok(NullableCurrency::Xaf),
            "XCD" => std::result::Result::Ok(NullableCurrency::Xcd),
            "XDR" => std::result::Result::Ok(NullableCurrency::Xdr),
            "XOF" => std::result::Result::Ok(NullableCurrency::Xof),
            "XPF" => std::result::Result::Ok(NullableCurrency::Xpf),
            "YER" => std::result::Result::Ok(NullableCurrency::Yer),
            "ZAR" => std::result::Result::Ok(NullableCurrency::Zar),
            "ZMW" => std::result::Result::Ok(NullableCurrency::Zmw),
            "ZWD" => std::result::Result::Ok(NullableCurrency::Zwd),
            "null" => std::result::Result::Ok(NullableCurrency::Null),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// A request to exchange an authorization code for an access token.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OauthAccessTokenRequestCode {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "grant_type")]
    pub grant_type: String,

    #[serde(rename = "code")]
    pub code: String,

    #[serde(rename = "redirect_uri")]
    pub redirect_uri: String,

}


impl OauthAccessTokenRequestCode {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(grant_type: String, code: String, redirect_uri: String, ) -> OauthAccessTokenRequestCode {
        OauthAccessTokenRequestCode {
            grant_type,
            code,
            redirect_uri,
        }
    }
}

/// Converts the OauthAccessTokenRequestCode value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OauthAccessTokenRequestCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("grant_type".to_string()),
            Some(self.grant_type.to_string()),


            Some("code".to_string()),
            Some(self.code.to_string()),


            Some("redirect_uri".to_string()),
            Some(self.redirect_uri.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OauthAccessTokenRequestCode value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OauthAccessTokenRequestCode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub grant_type: Vec<String>,
            pub code: Vec<String>,
            pub redirect_uri: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OauthAccessTokenRequestCode".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "grant_type" => intermediate_rep.grant_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "redirect_uri" => intermediate_rep.redirect_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OauthAccessTokenRequestCode".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OauthAccessTokenRequestCode {
            grant_type: intermediate_rep.grant_type.into_iter().next().ok_or_else(|| "grant_type missing in OauthAccessTokenRequestCode".to_string())?,
            code: intermediate_rep.code.into_iter().next().ok_or_else(|| "code missing in OauthAccessTokenRequestCode".to_string())?,
            redirect_uri: intermediate_rep.redirect_uri.into_iter().next().ok_or_else(|| "redirect_uri missing in OauthAccessTokenRequestCode".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OauthAccessTokenRequestCode> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OauthAccessTokenRequestCode>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OauthAccessTokenRequestCode>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OauthAccessTokenRequestCode - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OauthAccessTokenRequestCode> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OauthAccessTokenRequestCode as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OauthAccessTokenRequestCode - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A request to exchange a refresh token for a new access token.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OauthAccessTokenRequestRefresh {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "grant_type")]
    pub grant_type: String,

    #[serde(rename = "refresh_token")]
    pub refresh_token: String,

    #[serde(rename = "scope")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scope: Option<String>,

/// Setting this field to <code>true</code> will add a new refresh token to your 200 response, as well as the refresh_token_expires_in and refresh_token_expires_at fields. To see the structure of this payload, set the 200 response_type to \"everlasting_refresh\".
    #[serde(rename = "refresh_on")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub refresh_on: Option<bool>,

}


impl OauthAccessTokenRequestRefresh {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(grant_type: String, refresh_token: String, ) -> OauthAccessTokenRequestRefresh {
        OauthAccessTokenRequestRefresh {
            grant_type,
            refresh_token,
            scope: None,
            refresh_on: None,
        }
    }
}

/// Converts the OauthAccessTokenRequestRefresh value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OauthAccessTokenRequestRefresh {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("grant_type".to_string()),
            Some(self.grant_type.to_string()),


            Some("refresh_token".to_string()),
            Some(self.refresh_token.to_string()),


            self.scope.as_ref().map(|scope| {
                [
                    "scope".to_string(),
                    scope.to_string(),
                ].join(",")
            }),


            self.refresh_on.as_ref().map(|refresh_on| {
                [
                    "refresh_on".to_string(),
                    refresh_on.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OauthAccessTokenRequestRefresh value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OauthAccessTokenRequestRefresh {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub grant_type: Vec<String>,
            pub refresh_token: Vec<String>,
            pub scope: Vec<String>,
            pub refresh_on: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OauthAccessTokenRequestRefresh".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "grant_type" => intermediate_rep.grant_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "refresh_token" => intermediate_rep.refresh_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "refresh_on" => intermediate_rep.refresh_on.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OauthAccessTokenRequestRefresh".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OauthAccessTokenRequestRefresh {
            grant_type: intermediate_rep.grant_type.into_iter().next().ok_or_else(|| "grant_type missing in OauthAccessTokenRequestRefresh".to_string())?,
            refresh_token: intermediate_rep.refresh_token.into_iter().next().ok_or_else(|| "refresh_token missing in OauthAccessTokenRequestRefresh".to_string())?,
            scope: intermediate_rep.scope.into_iter().next(),
            refresh_on: intermediate_rep.refresh_on.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OauthAccessTokenRequestRefresh> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OauthAccessTokenRequestRefresh>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OauthAccessTokenRequestRefresh>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OauthAccessTokenRequestRefresh - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OauthAccessTokenRequestRefresh> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OauthAccessTokenRequestRefresh as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OauthAccessTokenRequestRefresh - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A successful OAuth access token response.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OauthAccessTokenResponse {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "response_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_type: Option<String>,

    #[serde(rename = "access_token")]
    pub access_token: String,

    #[serde(rename = "token_type")]
    pub token_type: String,

    #[serde(rename = "expires_in")]
    pub expires_in: i32,

    #[serde(rename = "scope")]
    pub scope: String,

}


impl OauthAccessTokenResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(access_token: String, expires_in: i32, scope: String, ) -> OauthAccessTokenResponse {
        OauthAccessTokenResponse {
            response_type: None,
            access_token,
            token_type: "bearer".to_string(),
            expires_in,
            scope,
        }
    }
}

/// Converts the OauthAccessTokenResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OauthAccessTokenResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.response_type.as_ref().map(|response_type| {
                [
                    "response_type".to_string(),
                    response_type.to_string(),
                ].join(",")
            }),


            Some("access_token".to_string()),
            Some(self.access_token.to_string()),


            Some("token_type".to_string()),
            Some(self.token_type.to_string()),


            Some("expires_in".to_string()),
            Some(self.expires_in.to_string()),


            Some("scope".to_string()),
            Some(self.scope.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OauthAccessTokenResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OauthAccessTokenResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub response_type: Vec<String>,
            pub access_token: Vec<String>,
            pub token_type: Vec<String>,
            pub expires_in: Vec<i32>,
            pub scope: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OauthAccessTokenResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "response_type" => intermediate_rep.response_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "access_token" => intermediate_rep.access_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "token_type" => intermediate_rep.token_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expires_in" => intermediate_rep.expires_in.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OauthAccessTokenResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OauthAccessTokenResponse {
            response_type: intermediate_rep.response_type.into_iter().next(),
            access_token: intermediate_rep.access_token.into_iter().next().ok_or_else(|| "access_token missing in OauthAccessTokenResponse".to_string())?,
            token_type: intermediate_rep.token_type.into_iter().next().ok_or_else(|| "token_type missing in OauthAccessTokenResponse".to_string())?,
            expires_in: intermediate_rep.expires_in.into_iter().next().ok_or_else(|| "expires_in missing in OauthAccessTokenResponse".to_string())?,
            scope: intermediate_rep.scope.into_iter().next().ok_or_else(|| "scope missing in OauthAccessTokenResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OauthAccessTokenResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OauthAccessTokenResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OauthAccessTokenResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OauthAccessTokenResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OauthAccessTokenResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OauthAccessTokenResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OauthAccessTokenResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A successful OAuth access token response for the authorization code flow.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OauthAccessTokenResponseCode {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "response_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_type: Option<String>,

    #[serde(rename = "access_token")]
    pub access_token: String,

    #[serde(rename = "token_type")]
    pub token_type: String,

    #[serde(rename = "expires_in")]
    pub expires_in: i32,

    #[serde(rename = "scope")]
    pub scope: String,

    #[serde(rename = "refresh_token")]
    pub refresh_token: String,

    #[serde(rename = "refresh_token_expires_in")]
    pub refresh_token_expires_in: i32,

}


impl OauthAccessTokenResponseCode {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(access_token: String, expires_in: i32, scope: String, refresh_token: String, refresh_token_expires_in: i32, ) -> OauthAccessTokenResponseCode {
        OauthAccessTokenResponseCode {
            response_type: None,
            access_token,
            token_type: "bearer".to_string(),
            expires_in,
            scope,
            refresh_token,
            refresh_token_expires_in,
        }
    }
}

/// Converts the OauthAccessTokenResponseCode value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OauthAccessTokenResponseCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.response_type.as_ref().map(|response_type| {
                [
                    "response_type".to_string(),
                    response_type.to_string(),
                ].join(",")
            }),


            Some("access_token".to_string()),
            Some(self.access_token.to_string()),


            Some("token_type".to_string()),
            Some(self.token_type.to_string()),


            Some("expires_in".to_string()),
            Some(self.expires_in.to_string()),


            Some("scope".to_string()),
            Some(self.scope.to_string()),


            Some("refresh_token".to_string()),
            Some(self.refresh_token.to_string()),


            Some("refresh_token_expires_in".to_string()),
            Some(self.refresh_token_expires_in.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OauthAccessTokenResponseCode value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OauthAccessTokenResponseCode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub response_type: Vec<String>,
            pub access_token: Vec<String>,
            pub token_type: Vec<String>,
            pub expires_in: Vec<i32>,
            pub scope: Vec<String>,
            pub refresh_token: Vec<String>,
            pub refresh_token_expires_in: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OauthAccessTokenResponseCode".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "response_type" => intermediate_rep.response_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "access_token" => intermediate_rep.access_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "token_type" => intermediate_rep.token_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expires_in" => intermediate_rep.expires_in.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "refresh_token" => intermediate_rep.refresh_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "refresh_token_expires_in" => intermediate_rep.refresh_token_expires_in.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OauthAccessTokenResponseCode".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OauthAccessTokenResponseCode {
            response_type: intermediate_rep.response_type.into_iter().next(),
            access_token: intermediate_rep.access_token.into_iter().next().ok_or_else(|| "access_token missing in OauthAccessTokenResponseCode".to_string())?,
            token_type: intermediate_rep.token_type.into_iter().next().ok_or_else(|| "token_type missing in OauthAccessTokenResponseCode".to_string())?,
            expires_in: intermediate_rep.expires_in.into_iter().next().ok_or_else(|| "expires_in missing in OauthAccessTokenResponseCode".to_string())?,
            scope: intermediate_rep.scope.into_iter().next().ok_or_else(|| "scope missing in OauthAccessTokenResponseCode".to_string())?,
            refresh_token: intermediate_rep.refresh_token.into_iter().next().ok_or_else(|| "refresh_token missing in OauthAccessTokenResponseCode".to_string())?,
            refresh_token_expires_in: intermediate_rep.refresh_token_expires_in.into_iter().next().ok_or_else(|| "refresh_token_expires_in missing in OauthAccessTokenResponseCode".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OauthAccessTokenResponseCode> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OauthAccessTokenResponseCode>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OauthAccessTokenResponseCode>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OauthAccessTokenResponseCode - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OauthAccessTokenResponseCode> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OauthAccessTokenResponseCode as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OauthAccessTokenResponseCode - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A successful OAuth access token response for the refresh token flow, with an added everlasting refresh token.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OauthAccessTokenResponseEverlastingRefresh {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "response_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_type: Option<String>,

    #[serde(rename = "access_token")]
    pub access_token: String,

    #[serde(rename = "token_type")]
    pub token_type: String,

    #[serde(rename = "expires_in")]
    pub expires_in: i32,

    #[serde(rename = "scope")]
    pub scope: String,

    #[serde(rename = "refresh_token")]
    pub refresh_token: String,

    #[serde(rename = "refresh_token_expires_in")]
    pub refresh_token_expires_in: i32,

    #[serde(rename = "refresh_token_expires_at")]
    pub refresh_token_expires_at: i32,

}


impl OauthAccessTokenResponseEverlastingRefresh {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(access_token: String, expires_in: i32, scope: String, refresh_token: String, refresh_token_expires_in: i32, refresh_token_expires_at: i32, ) -> OauthAccessTokenResponseEverlastingRefresh {
        OauthAccessTokenResponseEverlastingRefresh {
            response_type: None,
            access_token,
            token_type: "bearer".to_string(),
            expires_in,
            scope,
            refresh_token,
            refresh_token_expires_in,
            refresh_token_expires_at,
        }
    }
}

/// Converts the OauthAccessTokenResponseEverlastingRefresh value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OauthAccessTokenResponseEverlastingRefresh {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.response_type.as_ref().map(|response_type| {
                [
                    "response_type".to_string(),
                    response_type.to_string(),
                ].join(",")
            }),


            Some("access_token".to_string()),
            Some(self.access_token.to_string()),


            Some("token_type".to_string()),
            Some(self.token_type.to_string()),


            Some("expires_in".to_string()),
            Some(self.expires_in.to_string()),


            Some("scope".to_string()),
            Some(self.scope.to_string()),


            Some("refresh_token".to_string()),
            Some(self.refresh_token.to_string()),


            Some("refresh_token_expires_in".to_string()),
            Some(self.refresh_token_expires_in.to_string()),


            Some("refresh_token_expires_at".to_string()),
            Some(self.refresh_token_expires_at.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OauthAccessTokenResponseEverlastingRefresh value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OauthAccessTokenResponseEverlastingRefresh {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub response_type: Vec<String>,
            pub access_token: Vec<String>,
            pub token_type: Vec<String>,
            pub expires_in: Vec<i32>,
            pub scope: Vec<String>,
            pub refresh_token: Vec<String>,
            pub refresh_token_expires_in: Vec<i32>,
            pub refresh_token_expires_at: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OauthAccessTokenResponseEverlastingRefresh".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "response_type" => intermediate_rep.response_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "access_token" => intermediate_rep.access_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "token_type" => intermediate_rep.token_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expires_in" => intermediate_rep.expires_in.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "refresh_token" => intermediate_rep.refresh_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "refresh_token_expires_in" => intermediate_rep.refresh_token_expires_in.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "refresh_token_expires_at" => intermediate_rep.refresh_token_expires_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OauthAccessTokenResponseEverlastingRefresh".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OauthAccessTokenResponseEverlastingRefresh {
            response_type: intermediate_rep.response_type.into_iter().next(),
            access_token: intermediate_rep.access_token.into_iter().next().ok_or_else(|| "access_token missing in OauthAccessTokenResponseEverlastingRefresh".to_string())?,
            token_type: intermediate_rep.token_type.into_iter().next().ok_or_else(|| "token_type missing in OauthAccessTokenResponseEverlastingRefresh".to_string())?,
            expires_in: intermediate_rep.expires_in.into_iter().next().ok_or_else(|| "expires_in missing in OauthAccessTokenResponseEverlastingRefresh".to_string())?,
            scope: intermediate_rep.scope.into_iter().next().ok_or_else(|| "scope missing in OauthAccessTokenResponseEverlastingRefresh".to_string())?,
            refresh_token: intermediate_rep.refresh_token.into_iter().next().ok_or_else(|| "refresh_token missing in OauthAccessTokenResponseEverlastingRefresh".to_string())?,
            refresh_token_expires_in: intermediate_rep.refresh_token_expires_in.into_iter().next().ok_or_else(|| "refresh_token_expires_in missing in OauthAccessTokenResponseEverlastingRefresh".to_string())?,
            refresh_token_expires_at: intermediate_rep.refresh_token_expires_at.into_iter().next().ok_or_else(|| "refresh_token_expires_at missing in OauthAccessTokenResponseEverlastingRefresh".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OauthAccessTokenResponseEverlastingRefresh> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OauthAccessTokenResponseEverlastingRefresh>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OauthAccessTokenResponseEverlastingRefresh>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OauthAccessTokenResponseEverlastingRefresh - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OauthAccessTokenResponseEverlastingRefresh> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OauthAccessTokenResponseEverlastingRefresh as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OauthAccessTokenResponseEverlastingRefresh - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A successful OAuth access token response for the refresh token flow, with an added refresh token.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OauthAccessTokenResponseIntegrationRefresh {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "response_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_type: Option<String>,

    #[serde(rename = "access_token")]
    pub access_token: String,

    #[serde(rename = "token_type")]
    pub token_type: String,

    #[serde(rename = "expires_in")]
    pub expires_in: i32,

    #[serde(rename = "scope")]
    pub scope: String,

    #[serde(rename = "refresh_token")]
    pub refresh_token: String,

    #[serde(rename = "refresh_token_expires_in")]
    pub refresh_token_expires_in: i32,

}


impl OauthAccessTokenResponseIntegrationRefresh {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(access_token: String, expires_in: i32, scope: String, refresh_token: String, refresh_token_expires_in: i32, ) -> OauthAccessTokenResponseIntegrationRefresh {
        OauthAccessTokenResponseIntegrationRefresh {
            response_type: None,
            access_token,
            token_type: "bearer".to_string(),
            expires_in,
            scope,
            refresh_token,
            refresh_token_expires_in,
        }
    }
}

/// Converts the OauthAccessTokenResponseIntegrationRefresh value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OauthAccessTokenResponseIntegrationRefresh {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.response_type.as_ref().map(|response_type| {
                [
                    "response_type".to_string(),
                    response_type.to_string(),
                ].join(",")
            }),


            Some("access_token".to_string()),
            Some(self.access_token.to_string()),


            Some("token_type".to_string()),
            Some(self.token_type.to_string()),


            Some("expires_in".to_string()),
            Some(self.expires_in.to_string()),


            Some("scope".to_string()),
            Some(self.scope.to_string()),


            Some("refresh_token".to_string()),
            Some(self.refresh_token.to_string()),


            Some("refresh_token_expires_in".to_string()),
            Some(self.refresh_token_expires_in.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OauthAccessTokenResponseIntegrationRefresh value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OauthAccessTokenResponseIntegrationRefresh {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub response_type: Vec<String>,
            pub access_token: Vec<String>,
            pub token_type: Vec<String>,
            pub expires_in: Vec<i32>,
            pub scope: Vec<String>,
            pub refresh_token: Vec<String>,
            pub refresh_token_expires_in: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OauthAccessTokenResponseIntegrationRefresh".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "response_type" => intermediate_rep.response_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "access_token" => intermediate_rep.access_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "token_type" => intermediate_rep.token_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expires_in" => intermediate_rep.expires_in.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "refresh_token" => intermediate_rep.refresh_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "refresh_token_expires_in" => intermediate_rep.refresh_token_expires_in.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OauthAccessTokenResponseIntegrationRefresh".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OauthAccessTokenResponseIntegrationRefresh {
            response_type: intermediate_rep.response_type.into_iter().next(),
            access_token: intermediate_rep.access_token.into_iter().next().ok_or_else(|| "access_token missing in OauthAccessTokenResponseIntegrationRefresh".to_string())?,
            token_type: intermediate_rep.token_type.into_iter().next().ok_or_else(|| "token_type missing in OauthAccessTokenResponseIntegrationRefresh".to_string())?,
            expires_in: intermediate_rep.expires_in.into_iter().next().ok_or_else(|| "expires_in missing in OauthAccessTokenResponseIntegrationRefresh".to_string())?,
            scope: intermediate_rep.scope.into_iter().next().ok_or_else(|| "scope missing in OauthAccessTokenResponseIntegrationRefresh".to_string())?,
            refresh_token: intermediate_rep.refresh_token.into_iter().next().ok_or_else(|| "refresh_token missing in OauthAccessTokenResponseIntegrationRefresh".to_string())?,
            refresh_token_expires_in: intermediate_rep.refresh_token_expires_in.into_iter().next().ok_or_else(|| "refresh_token_expires_in missing in OauthAccessTokenResponseIntegrationRefresh".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OauthAccessTokenResponseIntegrationRefresh> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OauthAccessTokenResponseIntegrationRefresh>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OauthAccessTokenResponseIntegrationRefresh>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OauthAccessTokenResponseIntegrationRefresh - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OauthAccessTokenResponseIntegrationRefresh> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OauthAccessTokenResponseIntegrationRefresh as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OauthAccessTokenResponseIntegrationRefresh - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A successful OAuth access token response for the refresh token flow.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OauthAccessTokenResponseRefresh {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "response_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_type: Option<String>,

    #[serde(rename = "access_token")]
    pub access_token: String,

    #[serde(rename = "token_type")]
    pub token_type: String,

    #[serde(rename = "expires_in")]
    pub expires_in: i32,

    #[serde(rename = "scope")]
    pub scope: String,

}


impl OauthAccessTokenResponseRefresh {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(access_token: String, expires_in: i32, scope: String, ) -> OauthAccessTokenResponseRefresh {
        OauthAccessTokenResponseRefresh {
            response_type: None,
            access_token,
            token_type: "bearer".to_string(),
            expires_in,
            scope,
        }
    }
}

/// Converts the OauthAccessTokenResponseRefresh value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OauthAccessTokenResponseRefresh {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.response_type.as_ref().map(|response_type| {
                [
                    "response_type".to_string(),
                    response_type.to_string(),
                ].join(",")
            }),


            Some("access_token".to_string()),
            Some(self.access_token.to_string()),


            Some("token_type".to_string()),
            Some(self.token_type.to_string()),


            Some("expires_in".to_string()),
            Some(self.expires_in.to_string()),


            Some("scope".to_string()),
            Some(self.scope.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OauthAccessTokenResponseRefresh value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OauthAccessTokenResponseRefresh {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub response_type: Vec<String>,
            pub access_token: Vec<String>,
            pub token_type: Vec<String>,
            pub expires_in: Vec<i32>,
            pub scope: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OauthAccessTokenResponseRefresh".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "response_type" => intermediate_rep.response_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "access_token" => intermediate_rep.access_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "token_type" => intermediate_rep.token_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expires_in" => intermediate_rep.expires_in.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OauthAccessTokenResponseRefresh".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OauthAccessTokenResponseRefresh {
            response_type: intermediate_rep.response_type.into_iter().next(),
            access_token: intermediate_rep.access_token.into_iter().next().ok_or_else(|| "access_token missing in OauthAccessTokenResponseRefresh".to_string())?,
            token_type: intermediate_rep.token_type.into_iter().next().ok_or_else(|| "token_type missing in OauthAccessTokenResponseRefresh".to_string())?,
            expires_in: intermediate_rep.expires_in.into_iter().next().ok_or_else(|| "expires_in missing in OauthAccessTokenResponseRefresh".to_string())?,
            scope: intermediate_rep.scope.into_iter().next().ok_or_else(|| "scope missing in OauthAccessTokenResponseRefresh".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OauthAccessTokenResponseRefresh> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OauthAccessTokenResponseRefresh>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OauthAccessTokenResponseRefresh>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OauthAccessTokenResponseRefresh - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OauthAccessTokenResponseRefresh> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OauthAccessTokenResponseRefresh as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OauthAccessTokenResponseRefresh - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Campaign objective type. If set as one of [\"AWARENESS\", \"CONSIDERATION\", \"WEB_CONVERSION\", \"CATALOG_SALES\"] the campaign is considered as a Campaign Budget Optimization (CBO) campaign, meaning budget needs to be set at the campaign level rather than at the ad group level. [\"WEB_SESSIONS\"] in BETA. For update, only draft campaigns may update objective type.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ObjectiveType {
    #[serde(rename = "AWARENESS")]
    Awareness,
    #[serde(rename = "CONSIDERATION")]
    Consideration,
    #[serde(rename = "VIDEO_VIEW")]
    VideoView,
    #[serde(rename = "WEB_CONVERSION")]
    WebConversion,
    #[serde(rename = "CATALOG_SALES")]
    CatalogSales,
    #[serde(rename = "WEB_SESSIONS")]
    WebSessions,
}

impl std::fmt::Display for ObjectiveType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ObjectiveType::Awareness => write!(f, "AWARENESS"),
            ObjectiveType::Consideration => write!(f, "CONSIDERATION"),
            ObjectiveType::VideoView => write!(f, "VIDEO_VIEW"),
            ObjectiveType::WebConversion => write!(f, "WEB_CONVERSION"),
            ObjectiveType::CatalogSales => write!(f, "CATALOG_SALES"),
            ObjectiveType::WebSessions => write!(f, "WEB_SESSIONS"),
        }
    }
}

impl std::str::FromStr for ObjectiveType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AWARENESS" => std::result::Result::Ok(ObjectiveType::Awareness),
            "CONSIDERATION" => std::result::Result::Ok(ObjectiveType::Consideration),
            "VIDEO_VIEW" => std::result::Result::Ok(ObjectiveType::VideoView),
            "WEB_CONVERSION" => std::result::Result::Ok(ObjectiveType::WebConversion),
            "CATALOG_SALES" => std::result::Result::Ok(ObjectiveType::CatalogSales),
            "WEB_SESSIONS" => std::result::Result::Ok(ObjectiveType::WebSessions),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OptimizationGoalMetadata {
    #[serde(rename = "conversion_tag_v3_goal_metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conversion_tag_v3_goal_metadata: Option<models::OptimizationGoalMetadataConversionTagV3GoalMetadata>,

    #[serde(rename = "frequency_goal_metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub frequency_goal_metadata: Option<models::OptimizationGoalMetadataFrequencyGoalMetadata>,

    #[serde(rename = "scrollup_goal_metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scrollup_goal_metadata: Option<models::OptimizationGoalMetadataScrollupGoalMetadata>,

}


impl OptimizationGoalMetadata {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> OptimizationGoalMetadata {
        OptimizationGoalMetadata {
            conversion_tag_v3_goal_metadata: None,
            frequency_goal_metadata: None,
            scrollup_goal_metadata: None,
        }
    }
}

/// Converts the OptimizationGoalMetadata value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OptimizationGoalMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping conversion_tag_v3_goal_metadata in query parameter serialization

            // Skipping frequency_goal_metadata in query parameter serialization

            // Skipping scrollup_goal_metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OptimizationGoalMetadata value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OptimizationGoalMetadata {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub conversion_tag_v3_goal_metadata: Vec<models::OptimizationGoalMetadataConversionTagV3GoalMetadata>,
            pub frequency_goal_metadata: Vec<models::OptimizationGoalMetadataFrequencyGoalMetadata>,
            pub scrollup_goal_metadata: Vec<models::OptimizationGoalMetadataScrollupGoalMetadata>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OptimizationGoalMetadata".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "conversion_tag_v3_goal_metadata" => intermediate_rep.conversion_tag_v3_goal_metadata.push(<models::OptimizationGoalMetadataConversionTagV3GoalMetadata as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "frequency_goal_metadata" => intermediate_rep.frequency_goal_metadata.push(<models::OptimizationGoalMetadataFrequencyGoalMetadata as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scrollup_goal_metadata" => intermediate_rep.scrollup_goal_metadata.push(<models::OptimizationGoalMetadataScrollupGoalMetadata as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OptimizationGoalMetadata".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OptimizationGoalMetadata {
            conversion_tag_v3_goal_metadata: intermediate_rep.conversion_tag_v3_goal_metadata.into_iter().next(),
            frequency_goal_metadata: intermediate_rep.frequency_goal_metadata.into_iter().next(),
            scrollup_goal_metadata: intermediate_rep.scrollup_goal_metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OptimizationGoalMetadata> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OptimizationGoalMetadata>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OptimizationGoalMetadata>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OptimizationGoalMetadata - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OptimizationGoalMetadata> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OptimizationGoalMetadata as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OptimizationGoalMetadata - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OptimizationGoalMetadataConversionTagV3GoalMetadata {
    #[serde(rename = "attribution_windows")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attribution_windows: Option<models::OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows>,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "conversion_event")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conversion_event: Option<String>,

    #[serde(rename = "conversion_tag_id")]
    #[validate(
           regex = "RE_OPTIMIZATIONGOALMETADATACONVERSIONTAGV3GOALMETADATA_CONVERSION_TAG_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conversion_tag_id: Option<String>,

    #[serde(rename = "cpa_goal_value_in_micro_currency")]
    #[validate(
           regex = "RE_OPTIMIZATIONGOALMETADATACONVERSIONTAGV3GOALMETADATA_CPA_GOAL_VALUE_IN_MICRO_CURRENCY",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpa_goal_value_in_micro_currency: Option<String>,

/// Ad group is ROAS optimized
    #[serde(rename = "is_roas_optimized")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_roas_optimized: Option<Nullable<bool>>,

/// Conversion learning model type
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "learning_mode_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub learning_mode_type: Option<Nullable<String>>,

}

lazy_static::lazy_static! {
    static ref RE_OPTIMIZATIONGOALMETADATACONVERSIONTAGV3GOALMETADATA_CONVERSION_TAG_ID: regex::Regex = regex::Regex::new(r"^[0-9]+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_OPTIMIZATIONGOALMETADATACONVERSIONTAGV3GOALMETADATA_CPA_GOAL_VALUE_IN_MICRO_CURRENCY: regex::Regex = regex::Regex::new(r"^[0-9]+$").unwrap();
}

impl OptimizationGoalMetadataConversionTagV3GoalMetadata {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> OptimizationGoalMetadataConversionTagV3GoalMetadata {
        OptimizationGoalMetadataConversionTagV3GoalMetadata {
            attribution_windows: None,
            conversion_event: None,
            conversion_tag_id: None,
            cpa_goal_value_in_micro_currency: None,
            is_roas_optimized: None,
            learning_mode_type: None,
        }
    }
}

/// Converts the OptimizationGoalMetadataConversionTagV3GoalMetadata value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OptimizationGoalMetadataConversionTagV3GoalMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping attribution_windows in query parameter serialization


            self.conversion_event.as_ref().map(|conversion_event| {
                [
                    "conversion_event".to_string(),
                    conversion_event.to_string(),
                ].join(",")
            }),


            self.conversion_tag_id.as_ref().map(|conversion_tag_id| {
                [
                    "conversion_tag_id".to_string(),
                    conversion_tag_id.to_string(),
                ].join(",")
            }),


            self.cpa_goal_value_in_micro_currency.as_ref().map(|cpa_goal_value_in_micro_currency| {
                [
                    "cpa_goal_value_in_micro_currency".to_string(),
                    cpa_goal_value_in_micro_currency.to_string(),
                ].join(",")
            }),


            self.is_roas_optimized.as_ref().map(|is_roas_optimized| {
                [
                    "is_roas_optimized".to_string(),
                    is_roas_optimized.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.learning_mode_type.as_ref().map(|learning_mode_type| {
                [
                    "learning_mode_type".to_string(),
                    learning_mode_type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OptimizationGoalMetadataConversionTagV3GoalMetadata value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OptimizationGoalMetadataConversionTagV3GoalMetadata {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub attribution_windows: Vec<models::OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows>,
            pub conversion_event: Vec<String>,
            pub conversion_tag_id: Vec<String>,
            pub cpa_goal_value_in_micro_currency: Vec<String>,
            pub is_roas_optimized: Vec<bool>,
            pub learning_mode_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OptimizationGoalMetadataConversionTagV3GoalMetadata".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "attribution_windows" => intermediate_rep.attribution_windows.push(<models::OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "conversion_event" => intermediate_rep.conversion_event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "conversion_tag_id" => intermediate_rep.conversion_tag_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpa_goal_value_in_micro_currency" => intermediate_rep.cpa_goal_value_in_micro_currency.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "is_roas_optimized" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OptimizationGoalMetadataConversionTagV3GoalMetadata".to_string()),
                    "learning_mode_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OptimizationGoalMetadataConversionTagV3GoalMetadata".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OptimizationGoalMetadataConversionTagV3GoalMetadata".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OptimizationGoalMetadataConversionTagV3GoalMetadata {
            attribution_windows: intermediate_rep.attribution_windows.into_iter().next(),
            conversion_event: intermediate_rep.conversion_event.into_iter().next(),
            conversion_tag_id: intermediate_rep.conversion_tag_id.into_iter().next(),
            cpa_goal_value_in_micro_currency: intermediate_rep.cpa_goal_value_in_micro_currency.into_iter().next(),
            is_roas_optimized: std::result::Result::Err("Nullable types not supported in OptimizationGoalMetadataConversionTagV3GoalMetadata".to_string())?,
            learning_mode_type: std::result::Result::Err("Nullable types not supported in OptimizationGoalMetadataConversionTagV3GoalMetadata".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OptimizationGoalMetadataConversionTagV3GoalMetadata> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OptimizationGoalMetadataConversionTagV3GoalMetadata>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OptimizationGoalMetadataConversionTagV3GoalMetadata>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OptimizationGoalMetadataConversionTagV3GoalMetadata - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OptimizationGoalMetadataConversionTagV3GoalMetadata> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OptimizationGoalMetadataConversionTagV3GoalMetadata as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OptimizationGoalMetadataConversionTagV3GoalMetadata - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows {
    #[serde(rename = "click_window_days")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub click_window_days: Option<i32>,

    #[serde(rename = "engagement_window_days")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub engagement_window_days: Option<i32>,

    #[serde(rename = "view_window_days")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub view_window_days: Option<i32>,

}


impl OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows {
        OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows {
            click_window_days: None,
            engagement_window_days: None,
            view_window_days: None,
        }
    }
}

/// Converts the OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.click_window_days.as_ref().map(|click_window_days| {
                [
                    "click_window_days".to_string(),
                    click_window_days.to_string(),
                ].join(",")
            }),


            self.engagement_window_days.as_ref().map(|engagement_window_days| {
                [
                    "engagement_window_days".to_string(),
                    engagement_window_days.to_string(),
                ].join(",")
            }),


            self.view_window_days.as_ref().map(|view_window_days| {
                [
                    "view_window_days".to_string(),
                    view_window_days.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub click_window_days: Vec<i32>,
            pub engagement_window_days: Vec<i32>,
            pub view_window_days: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "click_window_days" => intermediate_rep.click_window_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "engagement_window_days" => intermediate_rep.engagement_window_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "view_window_days" => intermediate_rep.view_window_days.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows {
            click_window_days: intermediate_rep.click_window_days.into_iter().next(),
            engagement_window_days: intermediate_rep.engagement_window_days.into_iter().next(),
            view_window_days: intermediate_rep.view_window_days.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OptimizationGoalMetadataFrequencyGoalMetadata {
    #[serde(rename = "frequency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub frequency: Option<i32>,

/// User entity counts time range
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "timerange")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timerange: Option<String>,

}


impl OptimizationGoalMetadataFrequencyGoalMetadata {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> OptimizationGoalMetadataFrequencyGoalMetadata {
        OptimizationGoalMetadataFrequencyGoalMetadata {
            frequency: None,
            timerange: None,
        }
    }
}

/// Converts the OptimizationGoalMetadataFrequencyGoalMetadata value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OptimizationGoalMetadataFrequencyGoalMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.frequency.as_ref().map(|frequency| {
                [
                    "frequency".to_string(),
                    frequency.to_string(),
                ].join(",")
            }),


            self.timerange.as_ref().map(|timerange| {
                [
                    "timerange".to_string(),
                    timerange.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OptimizationGoalMetadataFrequencyGoalMetadata value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OptimizationGoalMetadataFrequencyGoalMetadata {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub frequency: Vec<i32>,
            pub timerange: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OptimizationGoalMetadataFrequencyGoalMetadata".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "frequency" => intermediate_rep.frequency.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "timerange" => intermediate_rep.timerange.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OptimizationGoalMetadataFrequencyGoalMetadata".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OptimizationGoalMetadataFrequencyGoalMetadata {
            frequency: intermediate_rep.frequency.into_iter().next(),
            timerange: intermediate_rep.timerange.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OptimizationGoalMetadataFrequencyGoalMetadata> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OptimizationGoalMetadataFrequencyGoalMetadata>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OptimizationGoalMetadataFrequencyGoalMetadata>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OptimizationGoalMetadataFrequencyGoalMetadata - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OptimizationGoalMetadataFrequencyGoalMetadata> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OptimizationGoalMetadataFrequencyGoalMetadata as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OptimizationGoalMetadataFrequencyGoalMetadata - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OptimizationGoalMetadataScrollupGoalMetadata {
    #[serde(rename = "scrollup_goal_value_in_micro_currency")]
    #[validate(
           regex = "RE_OPTIMIZATIONGOALMETADATASCROLLUPGOALMETADATA_SCROLLUP_GOAL_VALUE_IN_MICRO_CURRENCY",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scrollup_goal_value_in_micro_currency: Option<Nullable<String>>,

}

lazy_static::lazy_static! {
    static ref RE_OPTIMIZATIONGOALMETADATASCROLLUPGOALMETADATA_SCROLLUP_GOAL_VALUE_IN_MICRO_CURRENCY: regex::Regex = regex::Regex::new(r"^[0-9]+$").unwrap();
}

impl OptimizationGoalMetadataScrollupGoalMetadata {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> OptimizationGoalMetadataScrollupGoalMetadata {
        OptimizationGoalMetadataScrollupGoalMetadata {
            scrollup_goal_value_in_micro_currency: None,
        }
    }
}

/// Converts the OptimizationGoalMetadataScrollupGoalMetadata value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OptimizationGoalMetadataScrollupGoalMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.scrollup_goal_value_in_micro_currency.as_ref().map(|scrollup_goal_value_in_micro_currency| {
                [
                    "scrollup_goal_value_in_micro_currency".to_string(),
                    scrollup_goal_value_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OptimizationGoalMetadataScrollupGoalMetadata value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OptimizationGoalMetadataScrollupGoalMetadata {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub scrollup_goal_value_in_micro_currency: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OptimizationGoalMetadataScrollupGoalMetadata".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "scrollup_goal_value_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OptimizationGoalMetadataScrollupGoalMetadata".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OptimizationGoalMetadataScrollupGoalMetadata".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OptimizationGoalMetadataScrollupGoalMetadata {
            scrollup_goal_value_in_micro_currency: std::result::Result::Err("Nullable types not supported in OptimizationGoalMetadataScrollupGoalMetadata".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OptimizationGoalMetadataScrollupGoalMetadata> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OptimizationGoalMetadataScrollupGoalMetadata>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OptimizationGoalMetadataScrollupGoalMetadata>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OptimizationGoalMetadataScrollupGoalMetadata - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OptimizationGoalMetadataScrollupGoalMetadata> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OptimizationGoalMetadataScrollupGoalMetadata as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OptimizationGoalMetadataScrollupGoalMetadata - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderLine {
/// Order line ID.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_ORDERLINE_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Always \"orderline\".
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

/// Ad account ID.
    #[serde(rename = "ad_account_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// Purchase order ID.
    #[serde(rename = "purchase_order_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub purchase_order_id: Option<Nullable<String>>,

/// Start time. Unix timestamp.
    #[serde(rename = "start_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<f64>,

/// End time. Unix timestamp.
    #[serde(rename = "end_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<Nullable<f64>>,

/// Order line budget in micro currency.
    #[serde(rename = "budget")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget: Option<Nullable<f64>>,

/// Order line paid budget in micro currency.
    #[serde(rename = "paid_budget")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paid_budget: Option<Nullable<f64>>,

/// Order line status.
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::OrderLineStatus>,

/// Order line name.
    #[serde(rename = "name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

/// Order line paid type.
    #[serde(rename = "paid_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paid_type: Option<Nullable<models::OrderLinePaidType>>,

/// Associated List of campaign IDs.
    #[serde(rename = "campaign_ids")]
    pub campaign_ids: Vec<String>,

}

lazy_static::lazy_static! {
    static ref RE_ORDERLINE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl OrderLine {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(campaign_ids: Vec<String>, ) -> OrderLine {
        OrderLine {
            id: None,
            r#type: None,
            ad_account_id: None,
            purchase_order_id: None,
            start_time: None,
            end_time: None,
            budget: None,
            paid_budget: None,
            status: None,
            name: None,
            paid_type: None,
            campaign_ids,
        }
    }
}

/// Converts the OrderLine value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OrderLine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.purchase_order_id.as_ref().map(|purchase_order_id| {
                [
                    "purchase_order_id".to_string(),
                    purchase_order_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.start_time.as_ref().map(|start_time| {
                [
                    "start_time".to_string(),
                    start_time.to_string(),
                ].join(",")
            }),


            self.end_time.as_ref().map(|end_time| {
                [
                    "end_time".to_string(),
                    end_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.budget.as_ref().map(|budget| {
                [
                    "budget".to_string(),
                    budget.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.paid_budget.as_ref().map(|paid_budget| {
                [
                    "paid_budget".to_string(),
                    paid_budget.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping paid_type in query parameter serialization


            Some("campaign_ids".to_string()),
            Some(self.campaign_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderLine value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderLine {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub r#type: Vec<String>,
            pub ad_account_id: Vec<String>,
            pub purchase_order_id: Vec<String>,
            pub start_time: Vec<f64>,
            pub end_time: Vec<f64>,
            pub budget: Vec<f64>,
            pub paid_budget: Vec<f64>,
            pub status: Vec<models::OrderLineStatus>,
            pub name: Vec<String>,
            pub paid_type: Vec<models::OrderLinePaidType>,
            pub campaign_ids: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderLine".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "purchase_order_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OrderLine".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "start_time" => intermediate_rep.start_time.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "end_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OrderLine".to_string()),
                    "budget" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OrderLine".to_string()),
                    "paid_budget" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OrderLine".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::OrderLineStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OrderLine".to_string()),
                    "paid_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OrderLine".to_string()),
                    "campaign_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderLine".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderLine".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderLine {
            id: intermediate_rep.id.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            purchase_order_id: std::result::Result::Err("Nullable types not supported in OrderLine".to_string())?,
            start_time: intermediate_rep.start_time.into_iter().next(),
            end_time: std::result::Result::Err("Nullable types not supported in OrderLine".to_string())?,
            budget: std::result::Result::Err("Nullable types not supported in OrderLine".to_string())?,
            paid_budget: std::result::Result::Err("Nullable types not supported in OrderLine".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
            name: std::result::Result::Err("Nullable types not supported in OrderLine".to_string())?,
            paid_type: std::result::Result::Err("Nullable types not supported in OrderLine".to_string())?,
            campaign_ids: intermediate_rep.campaign_ids.into_iter().next().ok_or_else(|| "campaign_ids missing in OrderLine".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderLine> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderLine>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderLine>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderLine - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OrderLine> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderLine as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderLine - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderLineError {
    #[serde(rename = "data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<models::OrderLine>,

    #[serde(rename = "error_messages")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_messages: Option<Vec<String>>,

}


impl OrderLineError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> OrderLineError {
        OrderLineError {
            data: None,
            error_messages: None,
        }
    }
}

/// Converts the OrderLineError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OrderLineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization


            self.error_messages.as_ref().map(|error_messages| {
                [
                    "error_messages".to_string(),
                    error_messages.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderLineError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderLineError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<models::OrderLine>,
            pub error_messages: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderLineError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::OrderLine as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "error_messages" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderLineError".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderLineError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderLineError {
            data: intermediate_rep.data.into_iter().next(),
            error_messages: intermediate_rep.error_messages.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderLineError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderLineError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderLineError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderLineError - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OrderLineError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderLineError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderLineError - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Order Line Paid Type
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderLinePaidType {
    #[serde(rename = "PAID")]
    Paid,
    #[serde(rename = "BONUS")]
    Bonus,
    #[serde(rename = "MAKE_GOOD")]
    MakeGood,
    #[serde(rename = "TEST")]
    Test,
    #[serde(rename = "null")]
    Null,
}

impl std::fmt::Display for OrderLinePaidType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderLinePaidType::Paid => write!(f, "PAID"),
            OrderLinePaidType::Bonus => write!(f, "BONUS"),
            OrderLinePaidType::MakeGood => write!(f, "MAKE_GOOD"),
            OrderLinePaidType::Test => write!(f, "TEST"),
            OrderLinePaidType::Null => write!(f, "null"),
        }
    }
}

impl std::str::FromStr for OrderLinePaidType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PAID" => std::result::Result::Ok(OrderLinePaidType::Paid),
            "BONUS" => std::result::Result::Ok(OrderLinePaidType::Bonus),
            "MAKE_GOOD" => std::result::Result::Ok(OrderLinePaidType::MakeGood),
            "TEST" => std::result::Result::Ok(OrderLinePaidType::Test),
            "null" => std::result::Result::Ok(OrderLinePaidType::Null),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderLineResponse {
/// Error list if update(s) fail.
    #[serde(rename = "errors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<models::OrderLineError>>,

/// Order Line object array.
    #[serde(rename = "order_line")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_line: Option<Vec<models::OrderLine>>,

}


impl OrderLineResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> OrderLineResponse {
        OrderLineResponse {
            errors: None,
            order_line: None,
        }
    }
}

/// Converts the OrderLineResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OrderLineResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping errors in query parameter serialization

            // Skipping order_line in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderLineResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderLineResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub errors: Vec<Vec<models::OrderLineError>>,
            pub order_line: Vec<Vec<models::OrderLine>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderLineResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderLineResponse".to_string()),
                    "order_line" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderLineResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderLineResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderLineResponse {
            errors: intermediate_rep.errors.into_iter().next(),
            order_line: intermediate_rep.order_line.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderLineResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderLineResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderLineResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderLineResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OrderLineResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderLineResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderLineResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderLineSingleResponse {
    #[serde(rename = "data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<models::OrderLineResponse>,

}


impl OrderLineSingleResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> OrderLineSingleResponse {
        OrderLineSingleResponse {
            data: None,
        }
    }
}

/// Converts the OrderLineSingleResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OrderLineSingleResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderLineSingleResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderLineSingleResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<models::OrderLineResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderLineSingleResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::OrderLineResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderLineSingleResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderLineSingleResponse {
            data: intermediate_rep.data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderLineSingleResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderLineSingleResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderLineSingleResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderLineSingleResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OrderLineSingleResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderLineSingleResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderLineSingleResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Order Line Status
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OrderLineStatus {
    #[serde(rename = "ACTIVE")]
    Active,
    #[serde(rename = "PAUSED")]
    Paused,
    #[serde(rename = "DELETED")]
    Deleted,
}

impl std::fmt::Display for OrderLineStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OrderLineStatus::Active => write!(f, "ACTIVE"),
            OrderLineStatus::Paused => write!(f, "PAUSED"),
            OrderLineStatus::Deleted => write!(f, "DELETED"),
        }
    }
}

impl std::str::FromStr for OrderLineStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ACTIVE" => std::result::Result::Ok(OrderLineStatus::Active),
            "PAUSED" => std::result::Result::Ok(OrderLineStatus::Paused),
            "DELETED" => std::result::Result::Ok(OrderLineStatus::Deleted),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Order Line



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderLines {
/// Order line ID.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_ORDERLINES_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Always \"orderline\".
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

/// Ad account ID.
    #[serde(rename = "ad_account_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// Purchase order ID.
    #[serde(rename = "purchase_order_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub purchase_order_id: Option<Nullable<String>>,

/// Start time. Unix timestamp.
    #[serde(rename = "start_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<f64>,

/// End time. Unix timestamp.
    #[serde(rename = "end_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<Nullable<f64>>,

/// Order line budget in micro currency.
    #[serde(rename = "budget")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget: Option<Nullable<f64>>,

/// Order line paid budget in micro currency.
    #[serde(rename = "paid_budget")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paid_budget: Option<Nullable<f64>>,

/// Order line status.
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::OrderLineStatus>,

/// Order line name.
    #[serde(rename = "name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

/// Order line paid type.
    #[serde(rename = "paid_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paid_type: Option<Nullable<models::OrderLinePaidType>>,

}

lazy_static::lazy_static! {
    static ref RE_ORDERLINES_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl OrderLines {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> OrderLines {
        OrderLines {
            id: None,
            r#type: None,
            ad_account_id: None,
            purchase_order_id: None,
            start_time: None,
            end_time: None,
            budget: None,
            paid_budget: None,
            status: None,
            name: None,
            paid_type: None,
        }
    }
}

/// Converts the OrderLines value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OrderLines {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.purchase_order_id.as_ref().map(|purchase_order_id| {
                [
                    "purchase_order_id".to_string(),
                    purchase_order_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.start_time.as_ref().map(|start_time| {
                [
                    "start_time".to_string(),
                    start_time.to_string(),
                ].join(",")
            }),


            self.end_time.as_ref().map(|end_time| {
                [
                    "end_time".to_string(),
                    end_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.budget.as_ref().map(|budget| {
                [
                    "budget".to_string(),
                    budget.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.paid_budget.as_ref().map(|paid_budget| {
                [
                    "paid_budget".to_string(),
                    paid_budget.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping paid_type in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderLines value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderLines {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub r#type: Vec<String>,
            pub ad_account_id: Vec<String>,
            pub purchase_order_id: Vec<String>,
            pub start_time: Vec<f64>,
            pub end_time: Vec<f64>,
            pub budget: Vec<f64>,
            pub paid_budget: Vec<f64>,
            pub status: Vec<models::OrderLineStatus>,
            pub name: Vec<String>,
            pub paid_type: Vec<models::OrderLinePaidType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderLines".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "purchase_order_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OrderLines".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "start_time" => intermediate_rep.start_time.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "end_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OrderLines".to_string()),
                    "budget" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OrderLines".to_string()),
                    "paid_budget" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OrderLines".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::OrderLineStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OrderLines".to_string()),
                    "paid_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OrderLines".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderLines".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderLines {
            id: intermediate_rep.id.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            purchase_order_id: std::result::Result::Err("Nullable types not supported in OrderLines".to_string())?,
            start_time: intermediate_rep.start_time.into_iter().next(),
            end_time: std::result::Result::Err("Nullable types not supported in OrderLines".to_string())?,
            budget: std::result::Result::Err("Nullable types not supported in OrderLines".to_string())?,
            paid_budget: std::result::Result::Err("Nullable types not supported in OrderLines".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
            name: std::result::Result::Err("Nullable types not supported in OrderLines".to_string())?,
            paid_type: std::result::Result::Err("Nullable types not supported in OrderLines".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderLines> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderLines>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderLines>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderLines - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OrderLines> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderLines as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderLines - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderLinesArrayResponse {
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::OrderLines>>,

}


impl OrderLinesArrayResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> OrderLinesArrayResponse {
        OrderLinesArrayResponse {
            items: None,
        }
    }
}

/// Converts the OrderLinesArrayResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OrderLinesArrayResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderLinesArrayResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderLinesArrayResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::OrderLines>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderLinesArrayResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderLinesArrayResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderLinesArrayResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderLinesArrayResponse {
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderLinesArrayResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderLinesArrayResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderLinesArrayResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderLinesArrayResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OrderLinesArrayResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderLinesArrayResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderLinesArrayResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OrderLinesList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::OrderLine>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl OrderLinesList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::OrderLine>, ) -> OrderLinesList200Response {
        OrderLinesList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the OrderLinesList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OrderLinesList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OrderLinesList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OrderLinesList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::OrderLine>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OrderLinesList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in OrderLinesList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in OrderLinesList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OrderLinesList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OrderLinesList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in OrderLinesList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in OrderLinesList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OrderLinesList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OrderLinesList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OrderLinesList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OrderLinesList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OrderLinesList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OrderLinesList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OrderLinesList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Ad group pacing delivery type. With ACCELERATED, an ad group budget is spent as fast as possible. With STANDARD, an ad group budget is spent smoothly over a day. When using CBO, only the STANDARD pacing delivery type is allowed.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PacingDeliveryType {
    #[serde(rename = "STANDARD")]
    Standard,
    #[serde(rename = "ACCELERATED")]
    Accelerated,
}

impl std::fmt::Display for PacingDeliveryType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PacingDeliveryType::Standard => write!(f, "STANDARD"),
            PacingDeliveryType::Accelerated => write!(f, "ACCELERATED"),
        }
    }
}

impl std::str::FromStr for PacingDeliveryType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "STANDARD" => std::result::Result::Ok(PacingDeliveryType::Standard),
            "ACCELERATED" => std::result::Result::Ok(PacingDeliveryType::Accelerated),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PageVisitConversionTagsGet200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::ConversionEventResponse>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl PageVisitConversionTagsGet200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::ConversionEventResponse>, ) -> PageVisitConversionTagsGet200Response {
        PageVisitConversionTagsGet200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the PageVisitConversionTagsGet200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PageVisitConversionTagsGet200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PageVisitConversionTagsGet200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PageVisitConversionTagsGet200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::ConversionEventResponse>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PageVisitConversionTagsGet200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in PageVisitConversionTagsGet200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PageVisitConversionTagsGet200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PageVisitConversionTagsGet200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PageVisitConversionTagsGet200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in PageVisitConversionTagsGet200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in PageVisitConversionTagsGet200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PageVisitConversionTagsGet200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PageVisitConversionTagsGet200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PageVisitConversionTagsGet200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PageVisitConversionTagsGet200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PageVisitConversionTagsGet200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PageVisitConversionTagsGet200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PageVisitConversionTagsGet200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Paginated {
    #[serde(rename = "items")]
    pub items: Vec<crate::types::Object>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl Paginated {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<crate::types::Object>, ) -> Paginated {
        Paginated {
            items,
            bookmark: None,
        }
    }
}

/// Converts the Paginated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Paginated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Paginated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Paginated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<crate::types::Object>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Paginated".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in Paginated".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Paginated".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Paginated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Paginated {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in Paginated".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in Paginated".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Paginated> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Paginated>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Paginated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Paginated - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Paginated> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Paginated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Paginated - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PartnerType {
    #[serde(rename = "INTERNAL")]
    Internal,
    #[serde(rename = "EXTERNAL")]
    External,
}

impl std::fmt::Display for PartnerType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PartnerType::Internal => write!(f, "INTERNAL"),
            PartnerType::External => write!(f, "EXTERNAL"),
        }
    }
}

impl std::str::FromStr for PartnerType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "INTERNAL" => std::result::Result::Ok(PartnerType::Internal),
            "EXTERNAL" => std::result::Result::Ok(PartnerType::External),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Pin



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Pin {
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_PIN_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "link")]
    #[validate(
            length(max = 2048),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link: Option<Nullable<String>>,

    #[serde(rename = "title")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<Nullable<String>>,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

/// Dominant pin color. Hex number, e.g. \\\"#6E7874\\\".
    #[serde(rename = "dominant_color")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dominant_color: Option<Nullable<String>>,

    #[serde(rename = "alt_text")]
    #[validate(
            length(max = 500),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub alt_text: Option<Nullable<String>>,

    #[serde(rename = "creative_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creative_type: Option<Nullable<models::CreativeType>>,

/// The board to which this Pin belongs.
    #[serde(rename = "board_id")]
    #[validate(
           regex = "RE_PIN_BOARD_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub board_id: Option<String>,

/// The board section to which this Pin belongs.
    #[serde(rename = "board_section_id")]
    #[validate(
           regex = "RE_PIN_BOARD_SECTION_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub board_section_id: Option<Nullable<String>>,

    #[serde(rename = "board_owner")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub board_owner: Option<models::BoardOwner>,

/// Whether the \"operation user_account\" is the Pin owner.
    #[serde(rename = "is_owner")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_owner: Option<bool>,

    #[serde(rename = "media")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media: Option<models::SummaryPinMedia>,

    #[serde(rename = "media_source")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_source: Option<models::PinMediaSource>,

/// The source pin id if this pin was saved from another pin. <a href=\"https://help.pinterest.com/article/save-pins-on-pinterest\">Learn more</a>.
    #[serde(rename = "parent_pin_id")]
    #[validate(
           regex = "RE_PIN_PARENT_PIN_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_pin_id: Option<Nullable<String>>,

/// Whether the Pin is standard or not. See documentation on <a href=\"https://developers.pinterest.com/docs/content/update/\">Changes to Pin creation</a> for more information.
    #[serde(rename = "is_standard")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_standard: Option<bool>,

/// Whether the Pin has been promoted or not.
    #[serde(rename = "has_been_promoted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_been_promoted: Option<bool>,

/// Private note for this Pin. <a href=\"https://help.pinterest.com/en/article/add-notes-to-your-pins\">Learn more</a>.
    #[serde(rename = "note")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub note: Option<Nullable<String>>,

/// Pin metrics with associated time intervals if any.
    #[serde(rename = "pin_metrics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pin_metrics: Option<crate::types::Object>,

}

lazy_static::lazy_static! {
    static ref RE_PIN_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_PIN_BOARD_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_PIN_BOARD_SECTION_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_PIN_PARENT_PIN_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl Pin {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Pin {
        Pin {
            id: None,
            created_at: None,
            link: None,
            title: None,
            description: None,
            dominant_color: None,
            alt_text: None,
            creative_type: None,
            board_id: None,
            board_section_id: None,
            board_owner: None,
            is_owner: None,
            media: None,
            media_source: None,
            parent_pin_id: None,
            is_standard: None,
            has_been_promoted: None,
            note: None,
            pin_metrics: None,
        }
    }
}

/// Converts the Pin value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Pin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping created_at in query parameter serialization


            self.link.as_ref().map(|link| {
                [
                    "link".to_string(),
                    link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.title.as_ref().map(|title| {
                [
                    "title".to_string(),
                    title.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.dominant_color.as_ref().map(|dominant_color| {
                [
                    "dominant_color".to_string(),
                    dominant_color.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.alt_text.as_ref().map(|alt_text| {
                [
                    "alt_text".to_string(),
                    alt_text.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping creative_type in query parameter serialization


            self.board_id.as_ref().map(|board_id| {
                [
                    "board_id".to_string(),
                    board_id.to_string(),
                ].join(",")
            }),


            self.board_section_id.as_ref().map(|board_section_id| {
                [
                    "board_section_id".to_string(),
                    board_section_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping board_owner in query parameter serialization


            self.is_owner.as_ref().map(|is_owner| {
                [
                    "is_owner".to_string(),
                    is_owner.to_string(),
                ].join(",")
            }),

            // Skipping media in query parameter serialization

            // Skipping media_source in query parameter serialization


            self.parent_pin_id.as_ref().map(|parent_pin_id| {
                [
                    "parent_pin_id".to_string(),
                    parent_pin_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_standard.as_ref().map(|is_standard| {
                [
                    "is_standard".to_string(),
                    is_standard.to_string(),
                ].join(",")
            }),


            self.has_been_promoted.as_ref().map(|has_been_promoted| {
                [
                    "has_been_promoted".to_string(),
                    has_been_promoted.to_string(),
                ].join(",")
            }),


            self.note.as_ref().map(|note| {
                [
                    "note".to_string(),
                    note.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping pin_metrics in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Pin value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Pin {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub link: Vec<String>,
            pub title: Vec<String>,
            pub description: Vec<String>,
            pub dominant_color: Vec<String>,
            pub alt_text: Vec<String>,
            pub creative_type: Vec<models::CreativeType>,
            pub board_id: Vec<String>,
            pub board_section_id: Vec<String>,
            pub board_owner: Vec<models::BoardOwner>,
            pub is_owner: Vec<bool>,
            pub media: Vec<models::SummaryPinMedia>,
            pub media_source: Vec<models::PinMediaSource>,
            pub parent_pin_id: Vec<String>,
            pub is_standard: Vec<bool>,
            pub has_been_promoted: Vec<bool>,
            pub note: Vec<String>,
            pub pin_metrics: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Pin".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Pin".to_string()),
                    "title" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Pin".to_string()),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Pin".to_string()),
                    "dominant_color" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Pin".to_string()),
                    "alt_text" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Pin".to_string()),
                    "creative_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Pin".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "board_id" => intermediate_rep.board_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "board_section_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Pin".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "board_owner" => intermediate_rep.board_owner.push(<models::BoardOwner as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_owner" => intermediate_rep.is_owner.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media" => intermediate_rep.media.push(<models::SummaryPinMedia as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media_source" => intermediate_rep.media_source.push(<models::PinMediaSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "parent_pin_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Pin".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "is_standard" => intermediate_rep.is_standard.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_been_promoted" => intermediate_rep.has_been_promoted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "note" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Pin".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pin_metrics" => intermediate_rep.pin_metrics.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Pin".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Pin {
            id: intermediate_rep.id.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            link: std::result::Result::Err("Nullable types not supported in Pin".to_string())?,
            title: std::result::Result::Err("Nullable types not supported in Pin".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in Pin".to_string())?,
            dominant_color: std::result::Result::Err("Nullable types not supported in Pin".to_string())?,
            alt_text: std::result::Result::Err("Nullable types not supported in Pin".to_string())?,
            creative_type: std::result::Result::Err("Nullable types not supported in Pin".to_string())?,
            board_id: intermediate_rep.board_id.into_iter().next(),
            board_section_id: std::result::Result::Err("Nullable types not supported in Pin".to_string())?,
            board_owner: intermediate_rep.board_owner.into_iter().next(),
            is_owner: intermediate_rep.is_owner.into_iter().next(),
            media: intermediate_rep.media.into_iter().next(),
            media_source: intermediate_rep.media_source.into_iter().next(),
            parent_pin_id: std::result::Result::Err("Nullable types not supported in Pin".to_string())?,
            is_standard: intermediate_rep.is_standard.into_iter().next(),
            has_been_promoted: intermediate_rep.has_been_promoted.into_iter().next(),
            note: std::result::Result::Err("Nullable types not supported in Pin".to_string())?,
            pin_metrics: intermediate_rep.pin_metrics.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Pin> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Pin>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Pin>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Pin - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Pin> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Pin as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Pin - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinAnalyticsMetricsResponse {
/// The lifetime metric name and value.
    #[serde(rename = "lifetime_metrics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifetime_metrics: Option<std::collections::HashMap<String, i32>>,

/// Array with the requested daily metric records
    #[serde(rename = "daily_metrics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub daily_metrics: Option<Vec<models::PinAnalyticsMetricsResponseDailyMetricsInner>>,

/// The metric name and value over the requested period for each requested metric
    #[serde(rename = "summary_metrics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary_metrics: Option<std::collections::HashMap<String, f64>>,

}


impl PinAnalyticsMetricsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PinAnalyticsMetricsResponse {
        PinAnalyticsMetricsResponse {
            lifetime_metrics: None,
            daily_metrics: None,
            summary_metrics: None,
        }
    }
}

/// Converts the PinAnalyticsMetricsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinAnalyticsMetricsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping lifetime_metrics in query parameter serialization

            // Skipping daily_metrics in query parameter serialization

            // Skipping summary_metrics in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinAnalyticsMetricsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinAnalyticsMetricsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub lifetime_metrics: Vec<std::collections::HashMap<String, i32>>,
            pub daily_metrics: Vec<Vec<models::PinAnalyticsMetricsResponseDailyMetricsInner>>,
            pub summary_metrics: Vec<std::collections::HashMap<String, f64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinAnalyticsMetricsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "lifetime_metrics" => return std::result::Result::Err("Parsing a container in this style is not supported in PinAnalyticsMetricsResponse".to_string()),
                    "daily_metrics" => return std::result::Result::Err("Parsing a container in this style is not supported in PinAnalyticsMetricsResponse".to_string()),
                    "summary_metrics" => return std::result::Result::Err("Parsing a container in this style is not supported in PinAnalyticsMetricsResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinAnalyticsMetricsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinAnalyticsMetricsResponse {
            lifetime_metrics: intermediate_rep.lifetime_metrics.into_iter().next(),
            daily_metrics: intermediate_rep.daily_metrics.into_iter().next(),
            summary_metrics: intermediate_rep.summary_metrics.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinAnalyticsMetricsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinAnalyticsMetricsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinAnalyticsMetricsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinAnalyticsMetricsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinAnalyticsMetricsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinAnalyticsMetricsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinAnalyticsMetricsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinAnalyticsMetricsResponseDailyMetricsInner {
    #[serde(rename = "data_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data_status: Option<models::DataStatus>,

/// Metrics date (UTC): YYYY-MM-DD.
    #[serde(rename = "date")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<String>,

/// The metric name and daily value for each requested metric
    #[serde(rename = "metrics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metrics: Option<std::collections::HashMap<String, f64>>,

}


impl PinAnalyticsMetricsResponseDailyMetricsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PinAnalyticsMetricsResponseDailyMetricsInner {
        PinAnalyticsMetricsResponseDailyMetricsInner {
            data_status: None,
            date: None,
            metrics: None,
        }
    }
}

/// Converts the PinAnalyticsMetricsResponseDailyMetricsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinAnalyticsMetricsResponseDailyMetricsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data_status in query parameter serialization


            self.date.as_ref().map(|date| {
                [
                    "date".to_string(),
                    date.to_string(),
                ].join(",")
            }),

            // Skipping metrics in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinAnalyticsMetricsResponseDailyMetricsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinAnalyticsMetricsResponseDailyMetricsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data_status: Vec<models::DataStatus>,
            pub date: Vec<String>,
            pub metrics: Vec<std::collections::HashMap<String, f64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinAnalyticsMetricsResponseDailyMetricsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "data_status" => intermediate_rep.data_status.push(<models::DataStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "date" => intermediate_rep.date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "metrics" => return std::result::Result::Err("Parsing a container in this style is not supported in PinAnalyticsMetricsResponseDailyMetricsInner".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinAnalyticsMetricsResponseDailyMetricsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinAnalyticsMetricsResponseDailyMetricsInner {
            data_status: intermediate_rep.data_status.into_iter().next(),
            date: intermediate_rep.date.into_iter().next(),
            metrics: intermediate_rep.metrics.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinAnalyticsMetricsResponseDailyMetricsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinAnalyticsMetricsResponseDailyMetricsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinAnalyticsMetricsResponseDailyMetricsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinAnalyticsMetricsResponseDailyMetricsInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinAnalyticsMetricsResponseDailyMetricsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinAnalyticsMetricsResponseDailyMetricsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinAnalyticsMetricsResponseDailyMetricsInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Pin



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinCreate {
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_PINCREATE_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "link")]
    #[validate(
            length(max = 2048),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link: Option<Nullable<String>>,

    #[serde(rename = "title")]
    #[validate(
            length(max = 100),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<Nullable<String>>,

    #[serde(rename = "description")]
    #[validate(
            length(max = 800),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

/// Dominant pin color. Hex number, e.g. \\\"#6E7874\\\".
    #[serde(rename = "dominant_color")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dominant_color: Option<Nullable<String>>,

    #[serde(rename = "alt_text")]
    #[validate(
            length(max = 500),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub alt_text: Option<Nullable<String>>,

/// The board to which this Pin belongs.
    #[serde(rename = "board_id")]
    #[validate(
           regex = "RE_PINCREATE_BOARD_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub board_id: Option<String>,

/// The board section to which this Pin belongs.
    #[serde(rename = "board_section_id")]
    #[validate(
           regex = "RE_PINCREATE_BOARD_SECTION_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub board_section_id: Option<Nullable<String>>,

    #[serde(rename = "board_owner")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub board_owner: Option<models::BoardOwner>,

    #[serde(rename = "media")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media: Option<models::SummaryPinMedia>,

    #[serde(rename = "media_source")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_source: Option<models::PinMediaSource>,

/// The source pin id if this pin was saved from another pin. <a href=\"https://help.pinterest.com/article/save-pins-on-pinterest\">Learn more</a>.
    #[serde(rename = "parent_pin_id")]
    #[validate(
           regex = "RE_PINCREATE_PARENT_PIN_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_pin_id: Option<Nullable<String>>,

/// Private note for this Pin. <a href=\"https://help.pinterest.com/en/article/add-notes-to-your-pins\">Learn more</a>.
    #[serde(rename = "note")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub note: Option<Nullable<String>>,

}

lazy_static::lazy_static! {
    static ref RE_PINCREATE_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_PINCREATE_BOARD_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_PINCREATE_BOARD_SECTION_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_PINCREATE_PARENT_PIN_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl PinCreate {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PinCreate {
        PinCreate {
            id: None,
            created_at: None,
            link: None,
            title: None,
            description: None,
            dominant_color: None,
            alt_text: None,
            board_id: None,
            board_section_id: None,
            board_owner: None,
            media: None,
            media_source: None,
            parent_pin_id: None,
            note: None,
        }
    }
}

/// Converts the PinCreate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping created_at in query parameter serialization


            self.link.as_ref().map(|link| {
                [
                    "link".to_string(),
                    link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.title.as_ref().map(|title| {
                [
                    "title".to_string(),
                    title.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.dominant_color.as_ref().map(|dominant_color| {
                [
                    "dominant_color".to_string(),
                    dominant_color.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.alt_text.as_ref().map(|alt_text| {
                [
                    "alt_text".to_string(),
                    alt_text.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.board_id.as_ref().map(|board_id| {
                [
                    "board_id".to_string(),
                    board_id.to_string(),
                ].join(",")
            }),


            self.board_section_id.as_ref().map(|board_section_id| {
                [
                    "board_section_id".to_string(),
                    board_section_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping board_owner in query parameter serialization

            // Skipping media in query parameter serialization

            // Skipping media_source in query parameter serialization


            self.parent_pin_id.as_ref().map(|parent_pin_id| {
                [
                    "parent_pin_id".to_string(),
                    parent_pin_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.note.as_ref().map(|note| {
                [
                    "note".to_string(),
                    note.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinCreate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinCreate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub link: Vec<String>,
            pub title: Vec<String>,
            pub description: Vec<String>,
            pub dominant_color: Vec<String>,
            pub alt_text: Vec<String>,
            pub board_id: Vec<String>,
            pub board_section_id: Vec<String>,
            pub board_owner: Vec<models::BoardOwner>,
            pub media: Vec<models::SummaryPinMedia>,
            pub media_source: Vec<models::PinMediaSource>,
            pub parent_pin_id: Vec<String>,
            pub note: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinCreate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinCreate".to_string()),
                    "title" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinCreate".to_string()),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinCreate".to_string()),
                    "dominant_color" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinCreate".to_string()),
                    "alt_text" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinCreate".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "board_id" => intermediate_rep.board_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "board_section_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinCreate".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "board_owner" => intermediate_rep.board_owner.push(<models::BoardOwner as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media" => intermediate_rep.media.push(<models::SummaryPinMedia as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media_source" => intermediate_rep.media_source.push(<models::PinMediaSource as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "parent_pin_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinCreate".to_string()),
                    "note" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinCreate".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinCreate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinCreate {
            id: intermediate_rep.id.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            link: std::result::Result::Err("Nullable types not supported in PinCreate".to_string())?,
            title: std::result::Result::Err("Nullable types not supported in PinCreate".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in PinCreate".to_string())?,
            dominant_color: std::result::Result::Err("Nullable types not supported in PinCreate".to_string())?,
            alt_text: std::result::Result::Err("Nullable types not supported in PinCreate".to_string())?,
            board_id: intermediate_rep.board_id.into_iter().next(),
            board_section_id: std::result::Result::Err("Nullable types not supported in PinCreate".to_string())?,
            board_owner: intermediate_rep.board_owner.into_iter().next(),
            media: intermediate_rep.media.into_iter().next(),
            media_source: intermediate_rep.media_source.into_iter().next(),
            parent_pin_id: std::result::Result::Err("Nullable types not supported in PinCreate".to_string())?,
            note: std::result::Result::Err("Nullable types not supported in PinCreate".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinCreate> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinCreate>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinCreate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinCreate - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinCreate> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinCreate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinCreate - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Pin media objects.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMedia {
    #[serde(rename = "media_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<String>,

}


impl PinMedia {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PinMedia {
        PinMedia {
            media_type: None,
        }
    }
}

/// Converts the PinMedia value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinMedia {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.media_type.as_ref().map(|media_type| {
                [
                    "media_type".to_string(),
                    media_type.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMedia value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMedia {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub media_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMedia".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "media_type" => intermediate_rep.media_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMedia".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMedia {
            media_type: intermediate_rep.media_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMedia> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMedia>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMedia>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMedia - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinMedia> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMedia as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMedia - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}





/// Any of:
/// - ImageMetadata
/// - VideoMetadata
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PinMediaMetadata(Box<serde_json::value::RawValue>);

impl validator::Validate for PinMediaMetadata
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaMetadata value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaMetadata {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for PinMediaMetadata {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}






/// Pin media source.


/// One of:
/// - PinMediaSourceImageBase64
/// - PinMediaSourceImageUrl
/// - PinMediaSourceImagesBase64
/// - PinMediaSourceImagesUrl
/// - PinMediaSourcePinUrl
/// - PinMediaSourceVideoId
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PinMediaSource(Box<serde_json::value::RawValue>);

impl validator::Validate for PinMediaSource
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaSource {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for PinMediaSource {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Base64-encoded image media source



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaSourceImageBase64 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "source_type")]
    pub source_type: String,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "content_type")]
    pub content_type: String,

    #[serde(rename = "data")]
    #[validate(
           regex = "RE_PINMEDIASOURCEIMAGEBASE64_DATA",
        )]
    pub data: String,

/// Set the parameter to false to create the new simplified Pin instead of the standard pin. Currently the field is only available to a list of beta users.
    #[serde(rename = "is_standard")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_standard: Option<bool>,

}

lazy_static::lazy_static! {
    static ref RE_PINMEDIASOURCEIMAGEBASE64_DATA: regex::Regex = regex::Regex::new(r"[a-zA-Z0-9+/&#x3D;]+").unwrap();
}

impl PinMediaSourceImageBase64 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(source_type: String, content_type: String, data: String, ) -> PinMediaSourceImageBase64 {
        PinMediaSourceImageBase64 {
            source_type,
            content_type,
            data,
            is_standard: Some(true),
        }
    }
}

/// Converts the PinMediaSourceImageBase64 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinMediaSourceImageBase64 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("source_type".to_string()),
            Some(self.source_type.to_string()),


            Some("content_type".to_string()),
            Some(self.content_type.to_string()),


            Some("data".to_string()),
            Some(self.data.to_string()),


            self.is_standard.as_ref().map(|is_standard| {
                [
                    "is_standard".to_string(),
                    is_standard.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaSourceImageBase64 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaSourceImageBase64 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub source_type: Vec<String>,
            pub content_type: Vec<String>,
            pub data: Vec<String>,
            pub is_standard: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaSourceImageBase64".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "source_type" => intermediate_rep.source_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content_type" => intermediate_rep.content_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_standard" => intermediate_rep.is_standard.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaSourceImageBase64".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaSourceImageBase64 {
            source_type: intermediate_rep.source_type.into_iter().next().ok_or_else(|| "source_type missing in PinMediaSourceImageBase64".to_string())?,
            content_type: intermediate_rep.content_type.into_iter().next().ok_or_else(|| "content_type missing in PinMediaSourceImageBase64".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in PinMediaSourceImageBase64".to_string())?,
            is_standard: intermediate_rep.is_standard.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaSourceImageBase64> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaSourceImageBase64>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaSourceImageBase64>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaSourceImageBase64 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinMediaSourceImageBase64> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaSourceImageBase64 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaSourceImageBase64 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Image URL-based media source



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaSourceImageUrl {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "source_type")]
    pub source_type: String,

    #[serde(rename = "url")]
    pub url: String,

/// Set the parameter to false to create the new simplified Pin instead of the standard pin. Currently the field is only available to a list of beta users.
    #[serde(rename = "is_standard")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_standard: Option<bool>,

}


impl PinMediaSourceImageUrl {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(source_type: String, url: String, ) -> PinMediaSourceImageUrl {
        PinMediaSourceImageUrl {
            source_type,
            url,
            is_standard: Some(true),
        }
    }
}

/// Converts the PinMediaSourceImageUrl value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinMediaSourceImageUrl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("source_type".to_string()),
            Some(self.source_type.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),


            self.is_standard.as_ref().map(|is_standard| {
                [
                    "is_standard".to_string(),
                    is_standard.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaSourceImageUrl value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaSourceImageUrl {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub source_type: Vec<String>,
            pub url: Vec<String>,
            pub is_standard: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaSourceImageUrl".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "source_type" => intermediate_rep.source_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_standard" => intermediate_rep.is_standard.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaSourceImageUrl".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaSourceImageUrl {
            source_type: intermediate_rep.source_type.into_iter().next().ok_or_else(|| "source_type missing in PinMediaSourceImageUrl".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in PinMediaSourceImageUrl".to_string())?,
            is_standard: intermediate_rep.is_standard.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaSourceImageUrl> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaSourceImageUrl>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaSourceImageUrl>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaSourceImageUrl - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinMediaSourceImageUrl> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaSourceImageUrl as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaSourceImageUrl - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Multiple Base64-encoded images media source



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaSourceImagesBase64 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "source_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub source_type: Option<String>,

/// Array with image objects.
    #[serde(rename = "items")]
    #[validate(
            length(min = 2, max = 5),
        )]
    pub items: Vec<models::PinMediaSourceImagesBase64ItemsInner>,

    #[serde(rename = "index")]
    #[validate(
            range(min = 0),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index: Option<u32>,

}


impl PinMediaSourceImagesBase64 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::PinMediaSourceImagesBase64ItemsInner>, ) -> PinMediaSourceImagesBase64 {
        PinMediaSourceImagesBase64 {
            source_type: None,
            items,
            index: None,
        }
    }
}

/// Converts the PinMediaSourceImagesBase64 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinMediaSourceImagesBase64 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.source_type.as_ref().map(|source_type| {
                [
                    "source_type".to_string(),
                    source_type.to_string(),
                ].join(",")
            }),

            // Skipping items in query parameter serialization


            self.index.as_ref().map(|index| {
                [
                    "index".to_string(),
                    index.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaSourceImagesBase64 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaSourceImagesBase64 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub source_type: Vec<String>,
            pub items: Vec<Vec<models::PinMediaSourceImagesBase64ItemsInner>>,
            pub index: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaSourceImagesBase64".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "source_type" => intermediate_rep.source_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in PinMediaSourceImagesBase64".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaSourceImagesBase64".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaSourceImagesBase64 {
            source_type: intermediate_rep.source_type.into_iter().next(),
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in PinMediaSourceImagesBase64".to_string())?,
            index: intermediate_rep.index.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaSourceImagesBase64> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaSourceImagesBase64>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaSourceImagesBase64>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaSourceImagesBase64 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinMediaSourceImagesBase64> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaSourceImagesBase64 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaSourceImagesBase64 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaSourceImagesBase64ItemsInner {
    #[serde(rename = "title")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

/// Destination link for the image.
    #[serde(rename = "link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link: Option<String>,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "content_type")]
    pub content_type: String,

/// Image to upload as base64 string.
    #[serde(rename = "data")]
    #[validate(
           regex = "RE_PINMEDIASOURCEIMAGESBASE64ITEMSINNER_DATA",
        )]
    pub data: String,

}

lazy_static::lazy_static! {
    static ref RE_PINMEDIASOURCEIMAGESBASE64ITEMSINNER_DATA: regex::Regex = regex::Regex::new(r"[a-zA-Z0-9+/&#x3D;]+").unwrap();
}

impl PinMediaSourceImagesBase64ItemsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(content_type: String, data: String, ) -> PinMediaSourceImagesBase64ItemsInner {
        PinMediaSourceImagesBase64ItemsInner {
            title: None,
            description: None,
            link: None,
            content_type,
            data,
        }
    }
}

/// Converts the PinMediaSourceImagesBase64ItemsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinMediaSourceImagesBase64ItemsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.title.as_ref().map(|title| {
                [
                    "title".to_string(),
                    title.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.link.as_ref().map(|link| {
                [
                    "link".to_string(),
                    link.to_string(),
                ].join(",")
            }),


            Some("content_type".to_string()),
            Some(self.content_type.to_string()),


            Some("data".to_string()),
            Some(self.data.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaSourceImagesBase64ItemsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaSourceImagesBase64ItemsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub title: Vec<String>,
            pub description: Vec<String>,
            pub link: Vec<String>,
            pub content_type: Vec<String>,
            pub data: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaSourceImagesBase64ItemsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "link" => intermediate_rep.link.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content_type" => intermediate_rep.content_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaSourceImagesBase64ItemsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaSourceImagesBase64ItemsInner {
            title: intermediate_rep.title.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            link: intermediate_rep.link.into_iter().next(),
            content_type: intermediate_rep.content_type.into_iter().next().ok_or_else(|| "content_type missing in PinMediaSourceImagesBase64ItemsInner".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in PinMediaSourceImagesBase64ItemsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaSourceImagesBase64ItemsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaSourceImagesBase64ItemsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaSourceImagesBase64ItemsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaSourceImagesBase64ItemsInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinMediaSourceImagesBase64ItemsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaSourceImagesBase64ItemsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaSourceImagesBase64ItemsInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Multiple images urls-based media source



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaSourceImagesUrl {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "source_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub source_type: Option<String>,

/// Array with image objects.
    #[serde(rename = "items")]
    #[validate(
            length(min = 2, max = 5),
        )]
    pub items: Vec<models::PinMediaSourceImagesUrlItemsInner>,

    #[serde(rename = "index")]
    #[validate(
            range(min = 0),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index: Option<u32>,

}


impl PinMediaSourceImagesUrl {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::PinMediaSourceImagesUrlItemsInner>, ) -> PinMediaSourceImagesUrl {
        PinMediaSourceImagesUrl {
            source_type: None,
            items,
            index: None,
        }
    }
}

/// Converts the PinMediaSourceImagesUrl value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinMediaSourceImagesUrl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.source_type.as_ref().map(|source_type| {
                [
                    "source_type".to_string(),
                    source_type.to_string(),
                ].join(",")
            }),

            // Skipping items in query parameter serialization


            self.index.as_ref().map(|index| {
                [
                    "index".to_string(),
                    index.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaSourceImagesUrl value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaSourceImagesUrl {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub source_type: Vec<String>,
            pub items: Vec<Vec<models::PinMediaSourceImagesUrlItemsInner>>,
            pub index: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaSourceImagesUrl".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "source_type" => intermediate_rep.source_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in PinMediaSourceImagesUrl".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaSourceImagesUrl".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaSourceImagesUrl {
            source_type: intermediate_rep.source_type.into_iter().next(),
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in PinMediaSourceImagesUrl".to_string())?,
            index: intermediate_rep.index.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaSourceImagesUrl> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaSourceImagesUrl>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaSourceImagesUrl>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaSourceImagesUrl - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinMediaSourceImagesUrl> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaSourceImagesUrl as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaSourceImagesUrl - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaSourceImagesUrlItemsInner {
    #[serde(rename = "title")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

/// Destination link for the image.
    #[serde(rename = "link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link: Option<String>,

/// URL of image to upload.
    #[serde(rename = "url")]
    pub url: String,

}


impl PinMediaSourceImagesUrlItemsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(url: String, ) -> PinMediaSourceImagesUrlItemsInner {
        PinMediaSourceImagesUrlItemsInner {
            title: None,
            description: None,
            link: None,
            url,
        }
    }
}

/// Converts the PinMediaSourceImagesUrlItemsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinMediaSourceImagesUrlItemsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.title.as_ref().map(|title| {
                [
                    "title".to_string(),
                    title.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.link.as_ref().map(|link| {
                [
                    "link".to_string(),
                    link.to_string(),
                ].join(",")
            }),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaSourceImagesUrlItemsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaSourceImagesUrlItemsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub title: Vec<String>,
            pub description: Vec<String>,
            pub link: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaSourceImagesUrlItemsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "link" => intermediate_rep.link.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaSourceImagesUrlItemsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaSourceImagesUrlItemsInner {
            title: intermediate_rep.title.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            link: intermediate_rep.link.into_iter().next(),
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in PinMediaSourceImagesUrlItemsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaSourceImagesUrlItemsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaSourceImagesUrlItemsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaSourceImagesUrlItemsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaSourceImagesUrlItemsInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinMediaSourceImagesUrlItemsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaSourceImagesUrlItemsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaSourceImagesUrlItemsInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Pin URL-based media source for product pin creation. Currently the field is only available to a list of beta users.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaSourcePinUrl {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "source_type")]
    pub source_type: String,

/// This is an affiliate link or sponsored product. The FTC requires disclosure for paid partnerships and affiliate products.
    #[serde(rename = "is_affiliate_link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_affiliate_link: Option<bool>,

}


impl PinMediaSourcePinUrl {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(source_type: String, ) -> PinMediaSourcePinUrl {
        PinMediaSourcePinUrl {
            source_type,
            is_affiliate_link: Some(false),
        }
    }
}

/// Converts the PinMediaSourcePinUrl value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinMediaSourcePinUrl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("source_type".to_string()),
            Some(self.source_type.to_string()),


            self.is_affiliate_link.as_ref().map(|is_affiliate_link| {
                [
                    "is_affiliate_link".to_string(),
                    is_affiliate_link.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaSourcePinUrl value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaSourcePinUrl {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub source_type: Vec<String>,
            pub is_affiliate_link: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaSourcePinUrl".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "source_type" => intermediate_rep.source_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_affiliate_link" => intermediate_rep.is_affiliate_link.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaSourcePinUrl".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaSourcePinUrl {
            source_type: intermediate_rep.source_type.into_iter().next().ok_or_else(|| "source_type missing in PinMediaSourcePinUrl".to_string())?,
            is_affiliate_link: intermediate_rep.is_affiliate_link.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaSourcePinUrl> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaSourcePinUrl>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaSourcePinUrl>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaSourcePinUrl - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinMediaSourcePinUrl> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaSourcePinUrl as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaSourcePinUrl - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Video ID-based media source



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaSourceVideoId {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "source_type")]
    pub source_type: String,

/// Cover image url.
    #[serde(rename = "cover_image_url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cover_image_url: Option<String>,

/// Content type for cover image Base64.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "cover_image_content_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cover_image_content_type: Option<String>,

/// Cover image Base64.
    #[serde(rename = "cover_image_data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cover_image_data: Option<String>,

    #[serde(rename = "media_id")]
    #[validate(
           regex = "RE_PINMEDIASOURCEVIDEOID_MEDIA_ID",
        )]
    pub media_id: String,

/// Set the parameter to false to create the new simplified Pin instead of the standard pin. Currently the field is only available to a list of beta users.
    #[serde(rename = "is_standard")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_standard: Option<bool>,

}

lazy_static::lazy_static! {
    static ref RE_PINMEDIASOURCEVIDEOID_MEDIA_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl PinMediaSourceVideoId {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(source_type: String, media_id: String, ) -> PinMediaSourceVideoId {
        PinMediaSourceVideoId {
            source_type,
            cover_image_url: None,
            cover_image_content_type: None,
            cover_image_data: None,
            media_id,
            is_standard: Some(true),
        }
    }
}

/// Converts the PinMediaSourceVideoId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinMediaSourceVideoId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("source_type".to_string()),
            Some(self.source_type.to_string()),


            self.cover_image_url.as_ref().map(|cover_image_url| {
                [
                    "cover_image_url".to_string(),
                    cover_image_url.to_string(),
                ].join(",")
            }),


            self.cover_image_content_type.as_ref().map(|cover_image_content_type| {
                [
                    "cover_image_content_type".to_string(),
                    cover_image_content_type.to_string(),
                ].join(",")
            }),


            self.cover_image_data.as_ref().map(|cover_image_data| {
                [
                    "cover_image_data".to_string(),
                    cover_image_data.to_string(),
                ].join(",")
            }),


            Some("media_id".to_string()),
            Some(self.media_id.to_string()),


            self.is_standard.as_ref().map(|is_standard| {
                [
                    "is_standard".to_string(),
                    is_standard.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaSourceVideoId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaSourceVideoId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub source_type: Vec<String>,
            pub cover_image_url: Vec<String>,
            pub cover_image_content_type: Vec<String>,
            pub cover_image_data: Vec<String>,
            pub media_id: Vec<String>,
            pub is_standard: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaSourceVideoId".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "source_type" => intermediate_rep.source_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cover_image_url" => intermediate_rep.cover_image_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cover_image_content_type" => intermediate_rep.cover_image_content_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cover_image_data" => intermediate_rep.cover_image_data.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media_id" => intermediate_rep.media_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_standard" => intermediate_rep.is_standard.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaSourceVideoId".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaSourceVideoId {
            source_type: intermediate_rep.source_type.into_iter().next().ok_or_else(|| "source_type missing in PinMediaSourceVideoId".to_string())?,
            cover_image_url: intermediate_rep.cover_image_url.into_iter().next(),
            cover_image_content_type: intermediate_rep.cover_image_content_type.into_iter().next(),
            cover_image_data: intermediate_rep.cover_image_data.into_iter().next(),
            media_id: intermediate_rep.media_id.into_iter().next().ok_or_else(|| "media_id missing in PinMediaSourceVideoId".to_string())?,
            is_standard: intermediate_rep.is_standard.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaSourceVideoId> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaSourceVideoId>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaSourceVideoId>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaSourceVideoId - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinMediaSourceVideoId> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaSourceVideoId as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaSourceVideoId - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Pin with image.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaWithImage {
    #[serde(rename = "media_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<String>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub images: Option<models::ImageMetadataImages>,

}


impl PinMediaWithImage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PinMediaWithImage {
        PinMediaWithImage {
            media_type: None,
            images: None,
        }
    }
}

/// Converts the PinMediaWithImage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinMediaWithImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.media_type.as_ref().map(|media_type| {
                [
                    "media_type".to_string(),
                    media_type.to_string(),
                ].join(",")
            }),

            // Skipping images in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaWithImage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaWithImage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub media_type: Vec<String>,
            pub images: Vec<models::ImageMetadataImages>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaWithImage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "media_type" => intermediate_rep.media_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "images" => intermediate_rep.images.push(<models::ImageMetadataImages as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaWithImage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaWithImage {
            media_type: intermediate_rep.media_type.into_iter().next(),
            images: intermediate_rep.images.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaWithImage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaWithImage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaWithImage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaWithImage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinMediaWithImage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaWithImage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaWithImage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Pin with a mix of images and videos.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaWithImageAndVideo {
    #[serde(rename = "media_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<String>,

    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::PinMediaMetadata>>,

}


impl PinMediaWithImageAndVideo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PinMediaWithImageAndVideo {
        PinMediaWithImageAndVideo {
            media_type: None,
            items: None,
        }
    }
}

/// Converts the PinMediaWithImageAndVideo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinMediaWithImageAndVideo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.media_type.as_ref().map(|media_type| {
                [
                    "media_type".to_string(),
                    media_type.to_string(),
                ].join(",")
            }),

            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaWithImageAndVideo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaWithImageAndVideo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub media_type: Vec<String>,
            pub items: Vec<Vec<models::PinMediaMetadata>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaWithImageAndVideo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "media_type" => intermediate_rep.media_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in PinMediaWithImageAndVideo".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaWithImageAndVideo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaWithImageAndVideo {
            media_type: intermediate_rep.media_type.into_iter().next(),
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaWithImageAndVideo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaWithImageAndVideo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaWithImageAndVideo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaWithImageAndVideo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinMediaWithImageAndVideo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaWithImageAndVideo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaWithImageAndVideo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Pin with multiple images.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaWithImages {
    #[serde(rename = "media_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<String>,

    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::ImageMetadata>>,

}


impl PinMediaWithImages {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PinMediaWithImages {
        PinMediaWithImages {
            media_type: None,
            items: None,
        }
    }
}

/// Converts the PinMediaWithImages value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinMediaWithImages {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.media_type.as_ref().map(|media_type| {
                [
                    "media_type".to_string(),
                    media_type.to_string(),
                ].join(",")
            }),

            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaWithImages value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaWithImages {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub media_type: Vec<String>,
            pub items: Vec<Vec<models::ImageMetadata>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaWithImages".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "media_type" => intermediate_rep.media_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in PinMediaWithImages".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaWithImages".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaWithImages {
            media_type: intermediate_rep.media_type.into_iter().next(),
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaWithImages> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaWithImages>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaWithImages>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaWithImages - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinMediaWithImages> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaWithImages as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaWithImages - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Pin with video.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaWithVideo {
    #[serde(rename = "media_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<String>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub images: Option<models::ImageMetadataImages>,

    #[serde(rename = "cover_image_url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cover_image_url: Option<String>,

/// Video url (720p). </p><strong>Note:</strong> This field is limited and not available to all apps.
    #[serde(rename = "video_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub video_url: Option<Nullable<String>>,

/// Duration (in milliseconds)
    #[serde(rename = "duration")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub duration: Option<f64>,

/// Height (in pixels)
    #[serde(rename = "height")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub height: Option<i32>,

/// Width (in pixels)
    #[serde(rename = "width")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub width: Option<i32>,

}


impl PinMediaWithVideo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PinMediaWithVideo {
        PinMediaWithVideo {
            media_type: None,
            images: None,
            cover_image_url: None,
            video_url: None,
            duration: None,
            height: None,
            width: None,
        }
    }
}

/// Converts the PinMediaWithVideo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinMediaWithVideo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.media_type.as_ref().map(|media_type| {
                [
                    "media_type".to_string(),
                    media_type.to_string(),
                ].join(",")
            }),

            // Skipping images in query parameter serialization


            self.cover_image_url.as_ref().map(|cover_image_url| {
                [
                    "cover_image_url".to_string(),
                    cover_image_url.to_string(),
                ].join(",")
            }),


            self.video_url.as_ref().map(|video_url| {
                [
                    "video_url".to_string(),
                    video_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.duration.as_ref().map(|duration| {
                [
                    "duration".to_string(),
                    duration.to_string(),
                ].join(",")
            }),


            self.height.as_ref().map(|height| {
                [
                    "height".to_string(),
                    height.to_string(),
                ].join(",")
            }),


            self.width.as_ref().map(|width| {
                [
                    "width".to_string(),
                    width.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaWithVideo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaWithVideo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub media_type: Vec<String>,
            pub images: Vec<models::ImageMetadataImages>,
            pub cover_image_url: Vec<String>,
            pub video_url: Vec<String>,
            pub duration: Vec<f64>,
            pub height: Vec<i32>,
            pub width: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaWithVideo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "media_type" => intermediate_rep.media_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "images" => intermediate_rep.images.push(<models::ImageMetadataImages as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cover_image_url" => intermediate_rep.cover_image_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "video_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinMediaWithVideo".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "duration" => intermediate_rep.duration.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "height" => intermediate_rep.height.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "width" => intermediate_rep.width.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaWithVideo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaWithVideo {
            media_type: intermediate_rep.media_type.into_iter().next(),
            images: intermediate_rep.images.into_iter().next(),
            cover_image_url: intermediate_rep.cover_image_url.into_iter().next(),
            video_url: std::result::Result::Err("Nullable types not supported in PinMediaWithVideo".to_string())?,
            duration: intermediate_rep.duration.into_iter().next(),
            height: intermediate_rep.height.into_iter().next(),
            width: intermediate_rep.width.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaWithVideo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaWithVideo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaWithVideo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaWithVideo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinMediaWithVideo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaWithVideo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaWithVideo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Pin with multiple videos.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaWithVideos {
    #[serde(rename = "media_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<String>,

    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::VideoMetadata>>,

}


impl PinMediaWithVideos {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PinMediaWithVideos {
        PinMediaWithVideos {
            media_type: None,
            items: None,
        }
    }
}

/// Converts the PinMediaWithVideos value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinMediaWithVideos {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.media_type.as_ref().map(|media_type| {
                [
                    "media_type".to_string(),
                    media_type.to_string(),
                ].join(",")
            }),

            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaWithVideos value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaWithVideos {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub media_type: Vec<String>,
            pub items: Vec<Vec<models::VideoMetadata>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaWithVideos".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "media_type" => intermediate_rep.media_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in PinMediaWithVideos".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaWithVideos".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaWithVideos {
            media_type: intermediate_rep.media_type.into_iter().next(),
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaWithVideos> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaWithVideos>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaWithVideos>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaWithVideos - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinMediaWithVideos> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaWithVideos as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaWithVideos - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Summary status for pin promotions
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PinPromotionSummaryStatus {
    #[serde(rename = "APPROVED")]
    Approved,
    #[serde(rename = "PAUSED")]
    Paused,
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "REJECTED")]
    Rejected,
    #[serde(rename = "ADVERTISER_DISABLED")]
    AdvertiserDisabled,
    #[serde(rename = "ARCHIVED")]
    Archived,
    #[serde(rename = "DRAFT")]
    Draft,
    #[serde(rename = "DELETED_DRAFT")]
    DeletedDraft,
}

impl std::fmt::Display for PinPromotionSummaryStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PinPromotionSummaryStatus::Approved => write!(f, "APPROVED"),
            PinPromotionSummaryStatus::Paused => write!(f, "PAUSED"),
            PinPromotionSummaryStatus::Pending => write!(f, "PENDING"),
            PinPromotionSummaryStatus::Rejected => write!(f, "REJECTED"),
            PinPromotionSummaryStatus::AdvertiserDisabled => write!(f, "ADVERTISER_DISABLED"),
            PinPromotionSummaryStatus::Archived => write!(f, "ARCHIVED"),
            PinPromotionSummaryStatus::Draft => write!(f, "DRAFT"),
            PinPromotionSummaryStatus::DeletedDraft => write!(f, "DELETED_DRAFT"),
        }
    }
}

impl std::str::FromStr for PinPromotionSummaryStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "APPROVED" => std::result::Result::Ok(PinPromotionSummaryStatus::Approved),
            "PAUSED" => std::result::Result::Ok(PinPromotionSummaryStatus::Paused),
            "PENDING" => std::result::Result::Ok(PinPromotionSummaryStatus::Pending),
            "REJECTED" => std::result::Result::Ok(PinPromotionSummaryStatus::Rejected),
            "ADVERTISER_DISABLED" => std::result::Result::Ok(PinPromotionSummaryStatus::AdvertiserDisabled),
            "ARCHIVED" => std::result::Result::Ok(PinPromotionSummaryStatus::Archived),
            "DRAFT" => std::result::Result::Ok(PinPromotionSummaryStatus::Draft),
            "DELETED_DRAFT" => std::result::Result::Ok(PinPromotionSummaryStatus::DeletedDraft),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Pin fields for updates



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinUpdate {
/// Pin's alternative text.
    #[serde(rename = "alt_text")]
    #[validate(
            length(max = 500),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub alt_text: Option<Nullable<String>>,

/// The id of the board to move the Pin onto.
    #[serde(rename = "board_id")]
    #[validate(
           regex = "RE_PINUPDATE_BOARD_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub board_id: Option<Nullable<String>>,

/// <a href=\"https://help.pinterest.com/en/article/create-a-board-section\">Board section</a> ID.
    #[serde(rename = "board_section_id")]
    #[validate(
           regex = "RE_PINUPDATE_BOARD_SECTION_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub board_section_id: Option<Nullable<String>>,

/// Pin description - 800 characters maximum.
    #[serde(rename = "description")]
    #[validate(
            length(max = 800),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

/// URL viewer is taken to when they click pin.
    #[serde(rename = "link")]
    #[validate(
            length(max = 2048),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link: Option<Nullable<String>>,

/// The native pin title that creators explicitly prefer to display.
    #[serde(rename = "title")]
    #[validate(
            length(max = 100),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<Nullable<String>>,

/// Carousel Pin slots data.
    #[serde(rename = "carousel_slots")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_slots: Option<Vec<models::PinUpdateCarouselSlotsInner>>,

/// Private note for this Pin. <a href=\"https://help.pinterest.com/en/article/add-notes-to-your-pins\">Learn more</a>.
    #[serde(rename = "note")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub note: Option<Nullable<String>>,

}

lazy_static::lazy_static! {
    static ref RE_PINUPDATE_BOARD_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_PINUPDATE_BOARD_SECTION_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl PinUpdate {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PinUpdate {
        PinUpdate {
            alt_text: None,
            board_id: None,
            board_section_id: None,
            description: None,
            link: None,
            title: None,
            carousel_slots: None,
            note: None,
        }
    }
}

/// Converts the PinUpdate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.alt_text.as_ref().map(|alt_text| {
                [
                    "alt_text".to_string(),
                    alt_text.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.board_id.as_ref().map(|board_id| {
                [
                    "board_id".to_string(),
                    board_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.board_section_id.as_ref().map(|board_section_id| {
                [
                    "board_section_id".to_string(),
                    board_section_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.link.as_ref().map(|link| {
                [
                    "link".to_string(),
                    link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.title.as_ref().map(|title| {
                [
                    "title".to_string(),
                    title.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping carousel_slots in query parameter serialization


            self.note.as_ref().map(|note| {
                [
                    "note".to_string(),
                    note.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinUpdate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinUpdate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub alt_text: Vec<String>,
            pub board_id: Vec<String>,
            pub board_section_id: Vec<String>,
            pub description: Vec<String>,
            pub link: Vec<String>,
            pub title: Vec<String>,
            pub carousel_slots: Vec<Vec<models::PinUpdateCarouselSlotsInner>>,
            pub note: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinUpdate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "alt_text" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinUpdate".to_string()),
                    "board_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinUpdate".to_string()),
                    "board_section_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinUpdate".to_string()),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinUpdate".to_string()),
                    "link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinUpdate".to_string()),
                    "title" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinUpdate".to_string()),
                    "carousel_slots" => return std::result::Result::Err("Parsing a container in this style is not supported in PinUpdate".to_string()),
                    "note" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinUpdate".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinUpdate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinUpdate {
            alt_text: std::result::Result::Err("Nullable types not supported in PinUpdate".to_string())?,
            board_id: std::result::Result::Err("Nullable types not supported in PinUpdate".to_string())?,
            board_section_id: std::result::Result::Err("Nullable types not supported in PinUpdate".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in PinUpdate".to_string())?,
            link: std::result::Result::Err("Nullable types not supported in PinUpdate".to_string())?,
            title: std::result::Result::Err("Nullable types not supported in PinUpdate".to_string())?,
            carousel_slots: intermediate_rep.carousel_slots.into_iter().next(),
            note: std::result::Result::Err("Nullable types not supported in PinUpdate".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinUpdate> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinUpdate>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinUpdate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinUpdate - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinUpdate> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinUpdate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinUpdate - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinUpdateCarouselSlotsInner {
/// Carousel Pin slot title.
    #[serde(rename = "title")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,

/// Carousel Pin slot description.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

/// Carousel Pin slot link.
    #[serde(rename = "link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link: Option<String>,

}


impl PinUpdateCarouselSlotsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PinUpdateCarouselSlotsInner {
        PinUpdateCarouselSlotsInner {
            title: None,
            description: None,
            link: None,
        }
    }
}

/// Converts the PinUpdateCarouselSlotsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinUpdateCarouselSlotsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.title.as_ref().map(|title| {
                [
                    "title".to_string(),
                    title.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.link.as_ref().map(|link| {
                [
                    "link".to_string(),
                    link.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinUpdateCarouselSlotsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinUpdateCarouselSlotsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub title: Vec<String>,
            pub description: Vec<String>,
            pub link: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinUpdateCarouselSlotsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "link" => intermediate_rep.link.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinUpdateCarouselSlotsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinUpdateCarouselSlotsInner {
            title: intermediate_rep.title.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            link: intermediate_rep.link.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinUpdateCarouselSlotsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinUpdateCarouselSlotsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinUpdateCarouselSlotsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinUpdateCarouselSlotsInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinUpdateCarouselSlotsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinUpdateCarouselSlotsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinUpdateCarouselSlotsInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PinsAnalyticsMetricTypesParameterInner(Box<serde_json::value::RawValue>);

impl validator::Validate for PinsAnalyticsMetricTypesParameterInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinsAnalyticsMetricTypesParameterInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinsAnalyticsMetricTypesParameterInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for PinsAnalyticsMetricTypesParameterInner {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinsList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::Pin>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl PinsList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::Pin>, ) -> PinsList200Response {
        PinsList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the PinsList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinsList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinsList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinsList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::Pin>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinsList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in PinsList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinsList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinsList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinsList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in PinsList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in PinsList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinsList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinsList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinsList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinsList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinsList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinsList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinsList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinsSaveRequest {
/// Unique identifier of the board to which the pin will be saved.
    #[serde(rename = "board_id")]
    #[validate(
           regex = "RE_PINSSAVEREQUEST_BOARD_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub board_id: Option<Nullable<String>>,

/// Unique identifier of the board section to which the pin will be saved.
    #[serde(rename = "board_section_id")]
    #[validate(
           regex = "RE_PINSSAVEREQUEST_BOARD_SECTION_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub board_section_id: Option<Nullable<String>>,

}

lazy_static::lazy_static! {
    static ref RE_PINSSAVEREQUEST_BOARD_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_PINSSAVEREQUEST_BOARD_SECTION_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl PinsSaveRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PinsSaveRequest {
        PinsSaveRequest {
            board_id: None,
            board_section_id: None,
        }
    }
}

/// Converts the PinsSaveRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinsSaveRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.board_id.as_ref().map(|board_id| {
                [
                    "board_id".to_string(),
                    board_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.board_section_id.as_ref().map(|board_section_id| {
                [
                    "board_section_id".to_string(),
                    board_section_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinsSaveRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinsSaveRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub board_id: Vec<String>,
            pub board_section_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinsSaveRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "board_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinsSaveRequest".to_string()),
                    "board_section_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PinsSaveRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinsSaveRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinsSaveRequest {
            board_id: std::result::Result::Err("Nullable types not supported in PinsSaveRequest".to_string())?,
            board_section_id: std::result::Result::Err("Nullable types not supported in PinsSaveRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinsSaveRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinsSaveRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinsSaveRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinsSaveRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinsSaveRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinsSaveRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinsSaveRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Optional for VISITOR `audience_type`. With the Pinterest tag, you can use event data to capture event details from your website. This object lists all the available predefined event data fields in the Pinterest tag. You can include these event data fields as part of a VISITOR audience’s `rule`; however, you **must** specify an `event` for the `event_data` fields to be evaluated. Besides what’s listed, you can also create your own set of `event_data` fields and define their usages or purposes according to your website needs. However, the benefit of using the predefined event data fields is that we can provide various metrics based on those fields' data.<br>Examples per `event` type:<br>`pagevisit`<br>\"event_data\": { \"page_name\": \"My online store 123 | view items | shoe\" }<br>`signup`<br>\"event_data\": { \"lead_type\": \"New release promotion\" }<br>`checkout`<br>\"event_data\": { \"value\": 116, \"order_quantity\": 2, \"currency\": \"USD\", \"line_items\": [ { \"product_name\": \"Pillows (Set of 2)\", \"product_id\": \"11\", \"product_price\": 48, \"product_quantity\": 1 }, { \"product_name\": \"Pillows, Large (Set of 2)\", \"product_id\": \"15\", \"product_price\": 68, \"product_quantity\": 1 } ] }<br>`addtocart`<br>\"event_data\": { \"value\": 499, \"order_quantity\": 1, \"currency\": \"USD\", \"line_items\": [ { \"product_name\": \"Red leather boots\", \"product_id\": \"3486\", \"product_category\": \"shoe\", \"product_variant_id\": \"JB11103000\", \"product_price\": 499, \"product_quantity\": \"1\", \"product_brand\": \"My brand\" }]}<br>`watchvideo`<br>\"event_data\": { \"video_title\": \"My Product Video 01\" }<br>`lead`<br>\"event_data\": { \"lead_type\": \"Newsletter\" }



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinterestTagEventData {
    #[serde(rename = "currency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency: Option<models::Currency>,

/// Promotion code. For example, \"Newsletter\".
    #[serde(rename = "lead_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lead_type: Option<String>,

    #[serde(rename = "line_items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub line_items: Option<models::LineItem>,

/// Order ID. For example, \"X-151481\".
    #[serde(rename = "order_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_id: Option<String>,

/// Order quantity. For example, 1.
    #[serde(rename = "order_quantity")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_quantity: Option<i32>,

/// Page name. For example, \"Our Favorite Pins on Pinterest\".
    #[serde(rename = "page_name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub page_name: Option<String>,

/// Promotion code. For example, \"WINTER10\".
    #[serde(rename = "promo_code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub promo_code: Option<String>,

/// Property. For example, \"Athleta\".
    #[serde(rename = "property")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub property: Option<String>,

/// Search query string. For example, \"boots\".
    #[serde(rename = "search_query")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub search_query: Option<String>,

/// Product value. For example, \"199.98\"
    #[serde(rename = "value")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,

/// Video title. For example, \"How to style your Parker Boots\".
    #[serde(rename = "video_title")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub video_title: Option<String>,

}


impl PinterestTagEventData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PinterestTagEventData {
        PinterestTagEventData {
            currency: None,
            lead_type: None,
            line_items: None,
            order_id: None,
            order_quantity: None,
            page_name: None,
            promo_code: None,
            property: None,
            search_query: None,
            value: None,
            video_title: None,
        }
    }
}

/// Converts the PinterestTagEventData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PinterestTagEventData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping currency in query parameter serialization


            self.lead_type.as_ref().map(|lead_type| {
                [
                    "lead_type".to_string(),
                    lead_type.to_string(),
                ].join(",")
            }),

            // Skipping line_items in query parameter serialization


            self.order_id.as_ref().map(|order_id| {
                [
                    "order_id".to_string(),
                    order_id.to_string(),
                ].join(",")
            }),


            self.order_quantity.as_ref().map(|order_quantity| {
                [
                    "order_quantity".to_string(),
                    order_quantity.to_string(),
                ].join(",")
            }),


            self.page_name.as_ref().map(|page_name| {
                [
                    "page_name".to_string(),
                    page_name.to_string(),
                ].join(",")
            }),


            self.promo_code.as_ref().map(|promo_code| {
                [
                    "promo_code".to_string(),
                    promo_code.to_string(),
                ].join(",")
            }),


            self.property.as_ref().map(|property| {
                [
                    "property".to_string(),
                    property.to_string(),
                ].join(",")
            }),


            self.search_query.as_ref().map(|search_query| {
                [
                    "search_query".to_string(),
                    search_query.to_string(),
                ].join(",")
            }),


            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.to_string(),
                ].join(",")
            }),


            self.video_title.as_ref().map(|video_title| {
                [
                    "video_title".to_string(),
                    video_title.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinterestTagEventData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinterestTagEventData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub currency: Vec<models::Currency>,
            pub lead_type: Vec<String>,
            pub line_items: Vec<models::LineItem>,
            pub order_id: Vec<String>,
            pub order_quantity: Vec<i32>,
            pub page_name: Vec<String>,
            pub promo_code: Vec<String>,
            pub property: Vec<String>,
            pub search_query: Vec<String>,
            pub value: Vec<String>,
            pub video_title: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinterestTagEventData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "currency" => intermediate_rep.currency.push(<models::Currency as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lead_type" => intermediate_rep.lead_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "line_items" => intermediate_rep.line_items.push(<models::LineItem as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "order_id" => intermediate_rep.order_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "order_quantity" => intermediate_rep.order_quantity.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "page_name" => intermediate_rep.page_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "promo_code" => intermediate_rep.promo_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "property" => intermediate_rep.property.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "search_query" => intermediate_rep.search_query.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "video_title" => intermediate_rep.video_title.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinterestTagEventData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinterestTagEventData {
            currency: intermediate_rep.currency.into_iter().next(),
            lead_type: intermediate_rep.lead_type.into_iter().next(),
            line_items: intermediate_rep.line_items.into_iter().next(),
            order_id: intermediate_rep.order_id.into_iter().next(),
            order_quantity: intermediate_rep.order_quantity.into_iter().next(),
            page_name: intermediate_rep.page_name.into_iter().next(),
            promo_code: intermediate_rep.promo_code.into_iter().next(),
            property: intermediate_rep.property.into_iter().next(),
            search_query: intermediate_rep.search_query.into_iter().next(),
            value: intermediate_rep.value.into_iter().next(),
            video_title: intermediate_rep.video_title.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinterestTagEventData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PinterestTagEventData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinterestTagEventData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinterestTagEventData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PinterestTagEventData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinterestTagEventData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinterestTagEventData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Campaign placement group type
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PlacementGroupType {
    #[serde(rename = "ALL")]
    All,
    #[serde(rename = "SEARCH")]
    Search,
    #[serde(rename = "BROWSE")]
    Browse,
    #[serde(rename = "OTHER")]
    Other,
}

impl std::fmt::Display for PlacementGroupType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PlacementGroupType::All => write!(f, "ALL"),
            PlacementGroupType::Search => write!(f, "SEARCH"),
            PlacementGroupType::Browse => write!(f, "BROWSE"),
            PlacementGroupType::Other => write!(f, "OTHER"),
        }
    }
}

impl std::str::FromStr for PlacementGroupType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ALL" => std::result::Result::Ok(PlacementGroupType::All),
            "SEARCH" => std::result::Result::Ok(PlacementGroupType::Search),
            "BROWSE" => std::result::Result::Ok(PlacementGroupType::Browse),
            "OTHER" => std::result::Result::Ok(PlacementGroupType::Other),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PriceFilter {
    #[serde(rename = "PRICE")]
    pub price: models::CatalogsProductGroupPricingCurrencyCriteria,

}


impl PriceFilter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(price: models::CatalogsProductGroupPricingCurrencyCriteria, ) -> PriceFilter {
        PriceFilter {
            price,
        }
    }
}

/// Converts the PriceFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PriceFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping PRICE in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PriceFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PriceFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub price: Vec<models::CatalogsProductGroupPricingCurrencyCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PriceFilter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "PRICE" => intermediate_rep.price.push(<models::CatalogsProductGroupPricingCurrencyCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PriceFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PriceFilter {
            price: intermediate_rep.price.into_iter().next().ok_or_else(|| "PRICE missing in PriceFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PriceFilter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PriceFilter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PriceFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PriceFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PriceFilter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PriceFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PriceFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Default availability for products in a feed.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ProductAvailabilityType {
    #[serde(rename = "IN_STOCK")]
    InStock,
    #[serde(rename = "OUT_OF_STOCK")]
    OutOfStock,
    #[serde(rename = "PREORDER")]
    Preorder,
    #[serde(rename = "null")]
    Null,
}

impl std::fmt::Display for ProductAvailabilityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ProductAvailabilityType::InStock => write!(f, "IN_STOCK"),
            ProductAvailabilityType::OutOfStock => write!(f, "OUT_OF_STOCK"),
            ProductAvailabilityType::Preorder => write!(f, "PREORDER"),
            ProductAvailabilityType::Null => write!(f, "null"),
        }
    }
}

impl std::str::FromStr for ProductAvailabilityType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "IN_STOCK" => std::result::Result::Ok(ProductAvailabilityType::InStock),
            "OUT_OF_STOCK" => std::result::Result::Ok(ProductAvailabilityType::OutOfStock),
            "PREORDER" => std::result::Result::Ok(ProductAvailabilityType::Preorder),
            "null" => std::result::Result::Ok(ProductAvailabilityType::Null),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProductGroupAnalyticsResponseInner {
/// The ID of the product group that this metrics belongs to.
    #[serde(rename = "PRODUCT_GROUP_ID")]
    #[validate(
           regex = "RE_PRODUCTGROUPANALYTICSRESPONSEINNER_PRODUCT_GROUP_ID",
        )]
    pub product_group_id: String,

/// Current metrics date. Only returned when granularity is a time-based value (`DAY`, `HOUR`, `WEEK`, `MONTH`)
    #[serde(rename = "DATE")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::naive::NaiveDate>,

}

lazy_static::lazy_static! {
    static ref RE_PRODUCTGROUPANALYTICSRESPONSEINNER_PRODUCT_GROUP_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl ProductGroupAnalyticsResponseInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(product_group_id: String, ) -> ProductGroupAnalyticsResponseInner {
        ProductGroupAnalyticsResponseInner {
            product_group_id,
            date: None,
        }
    }
}

/// Converts the ProductGroupAnalyticsResponseInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProductGroupAnalyticsResponseInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("PRODUCT_GROUP_ID".to_string()),
            Some(self.product_group_id.to_string()),

            // Skipping DATE in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProductGroupAnalyticsResponseInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProductGroupAnalyticsResponseInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub product_group_id: Vec<String>,
            pub date: Vec<chrono::naive::NaiveDate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProductGroupAnalyticsResponseInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "PRODUCT_GROUP_ID" => intermediate_rep.product_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DATE" => intermediate_rep.date.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProductGroupAnalyticsResponseInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProductGroupAnalyticsResponseInner {
            product_group_id: intermediate_rep.product_group_id.into_iter().next().ok_or_else(|| "PRODUCT_GROUP_ID missing in ProductGroupAnalyticsResponseInner".to_string())?,
            date: intermediate_rep.date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProductGroupAnalyticsResponseInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProductGroupAnalyticsResponseInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProductGroupAnalyticsResponseInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProductGroupAnalyticsResponseInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProductGroupAnalyticsResponseInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProductGroupAnalyticsResponseInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProductGroupAnalyticsResponseInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProductGroupPromotion {
/// ID of the product group promotion.
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_PRODUCTGROUPPROMOTION_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// ID of the ad group the product group belongs to.
    #[serde(rename = "ad_group_id")]
    #[validate(
           regex = "RE_PRODUCTGROUPPROMOTION_AD_GROUP_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_group_id: Option<String>,

/// The bid in micro currency.
    #[serde(rename = "bid_in_micro_currency")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid_in_micro_currency: Option<Nullable<i32>>,

/// True if the group is BIDDABLE, false if it should be EXCLUDED from serving ads.
    #[serde(rename = "included")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub included: Option<Nullable<bool>>,

/// The full product group definition path
    #[serde(rename = "definition")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub definition: Option<Nullable<String>>,

/// The definition of the product group, relative to its parent - an attribute name/value pair
    #[serde(rename = "relative_definition")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub relative_definition: Option<Nullable<String>>,

/// The parent Product Group ID of this Product Group
    #[serde(rename = "parent_id")]
    #[validate(
           regex = "RE_PRODUCTGROUPPROMOTION_PARENT_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_id: Option<Nullable<String>>,

/// Slideshow Collections Title
    #[serde(rename = "slideshow_collections_title")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub slideshow_collections_title: Option<Nullable<String>>,

/// Slideshow Collections Description
    #[serde(rename = "slideshow_collections_description")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub slideshow_collections_description: Option<Nullable<String>>,

/// If set to true products promoted in this product group will use the Mobile Deep Link specified in your catalog
    #[serde(rename = "is_mdl")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_mdl: Option<Nullable<bool>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

/// Tracking template for proudct group promotions. 4000 limit
    #[serde(rename = "tracking_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_url: Option<Nullable<String>>,

/// ID of the catalogs product group that this product group promotion references
    #[serde(rename = "catalog_product_group_id")]
    #[validate(
           regex = "RE_PRODUCTGROUPPROMOTION_CATALOG_PRODUCT_GROUP_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub catalog_product_group_id: Option<Nullable<String>>,

/// Catalogs product group name
    #[serde(rename = "catalog_product_group_name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub catalog_product_group_name: Option<Nullable<String>>,

    #[serde(rename = "creative_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creative_type: Option<models::CreativeType>,

/// Hero Pin ID if this PG is promoted as a Collection
    #[serde(rename = "collections_hero_pin_id")]
    #[validate(
           regex = "RE_PRODUCTGROUPPROMOTION_COLLECTIONS_HERO_PIN_ID",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub collections_hero_pin_id: Option<Nullable<String>>,

/// Collections Hero Destination Url
    #[serde(rename = "collections_hero_destination_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub collections_hero_destination_url: Option<Nullable<String>>,

    #[serde(rename = "grid_click_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub grid_click_type: Option<Nullable<models::GridClickType>>,

}

lazy_static::lazy_static! {
    static ref RE_PRODUCTGROUPPROMOTION_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_PRODUCTGROUPPROMOTION_AD_GROUP_ID: regex::Regex = regex::Regex::new(r"^(AG)?\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_PRODUCTGROUPPROMOTION_PARENT_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_PRODUCTGROUPPROMOTION_CATALOG_PRODUCT_GROUP_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_PRODUCTGROUPPROMOTION_COLLECTIONS_HERO_PIN_ID: regex::Regex = regex::Regex::new(r"^\\d+$").unwrap();
}

impl ProductGroupPromotion {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ProductGroupPromotion {
        ProductGroupPromotion {
            id: None,
            ad_group_id: None,
            bid_in_micro_currency: None,
            included: None,
            definition: None,
            relative_definition: None,
            parent_id: None,
            slideshow_collections_title: None,
            slideshow_collections_description: None,
            is_mdl: None,
            status: None,
            tracking_url: None,
            catalog_product_group_id: None,
            catalog_product_group_name: None,
            creative_type: None,
            collections_hero_pin_id: None,
            collections_hero_destination_url: None,
            grid_click_type: None,
        }
    }
}

/// Converts the ProductGroupPromotion value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProductGroupPromotion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.ad_group_id.as_ref().map(|ad_group_id| {
                [
                    "ad_group_id".to_string(),
                    ad_group_id.to_string(),
                ].join(",")
            }),


            self.bid_in_micro_currency.as_ref().map(|bid_in_micro_currency| {
                [
                    "bid_in_micro_currency".to_string(),
                    bid_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.included.as_ref().map(|included| {
                [
                    "included".to_string(),
                    included.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.definition.as_ref().map(|definition| {
                [
                    "definition".to_string(),
                    definition.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.relative_definition.as_ref().map(|relative_definition| {
                [
                    "relative_definition".to_string(),
                    relative_definition.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.parent_id.as_ref().map(|parent_id| {
                [
                    "parent_id".to_string(),
                    parent_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.slideshow_collections_title.as_ref().map(|slideshow_collections_title| {
                [
                    "slideshow_collections_title".to_string(),
                    slideshow_collections_title.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.slideshow_collections_description.as_ref().map(|slideshow_collections_description| {
                [
                    "slideshow_collections_description".to_string(),
                    slideshow_collections_description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_mdl.as_ref().map(|is_mdl| {
                [
                    "is_mdl".to_string(),
                    is_mdl.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping status in query parameter serialization


            self.tracking_url.as_ref().map(|tracking_url| {
                [
                    "tracking_url".to_string(),
                    tracking_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.catalog_product_group_id.as_ref().map(|catalog_product_group_id| {
                [
                    "catalog_product_group_id".to_string(),
                    catalog_product_group_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.catalog_product_group_name.as_ref().map(|catalog_product_group_name| {
                [
                    "catalog_product_group_name".to_string(),
                    catalog_product_group_name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping creative_type in query parameter serialization


            self.collections_hero_pin_id.as_ref().map(|collections_hero_pin_id| {
                [
                    "collections_hero_pin_id".to_string(),
                    collections_hero_pin_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.collections_hero_destination_url.as_ref().map(|collections_hero_destination_url| {
                [
                    "collections_hero_destination_url".to_string(),
                    collections_hero_destination_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping grid_click_type in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProductGroupPromotion value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProductGroupPromotion {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub ad_group_id: Vec<String>,
            pub bid_in_micro_currency: Vec<i32>,
            pub included: Vec<bool>,
            pub definition: Vec<String>,
            pub relative_definition: Vec<String>,
            pub parent_id: Vec<String>,
            pub slideshow_collections_title: Vec<String>,
            pub slideshow_collections_description: Vec<String>,
            pub is_mdl: Vec<bool>,
            pub status: Vec<models::EntityStatus>,
            pub tracking_url: Vec<String>,
            pub catalog_product_group_id: Vec<String>,
            pub catalog_product_group_name: Vec<String>,
            pub creative_type: Vec<models::CreativeType>,
            pub collections_hero_pin_id: Vec<String>,
            pub collections_hero_destination_url: Vec<String>,
            pub grid_click_type: Vec<models::GridClickType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProductGroupPromotion".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ad_group_id" => intermediate_rep.ad_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "bid_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ProductGroupPromotion".to_string()),
                    "included" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ProductGroupPromotion".to_string()),
                    "definition" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ProductGroupPromotion".to_string()),
                    "relative_definition" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ProductGroupPromotion".to_string()),
                    "parent_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ProductGroupPromotion".to_string()),
                    "slideshow_collections_title" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ProductGroupPromotion".to_string()),
                    "slideshow_collections_description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ProductGroupPromotion".to_string()),
                    "is_mdl" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ProductGroupPromotion".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tracking_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ProductGroupPromotion".to_string()),
                    "catalog_product_group_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ProductGroupPromotion".to_string()),
                    "catalog_product_group_name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ProductGroupPromotion".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "creative_type" => intermediate_rep.creative_type.push(<models::CreativeType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "collections_hero_pin_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ProductGroupPromotion".to_string()),
                    "collections_hero_destination_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ProductGroupPromotion".to_string()),
                    "grid_click_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ProductGroupPromotion".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProductGroupPromotion".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProductGroupPromotion {
            id: intermediate_rep.id.into_iter().next(),
            ad_group_id: intermediate_rep.ad_group_id.into_iter().next(),
            bid_in_micro_currency: std::result::Result::Err("Nullable types not supported in ProductGroupPromotion".to_string())?,
            included: std::result::Result::Err("Nullable types not supported in ProductGroupPromotion".to_string())?,
            definition: std::result::Result::Err("Nullable types not supported in ProductGroupPromotion".to_string())?,
            relative_definition: std::result::Result::Err("Nullable types not supported in ProductGroupPromotion".to_string())?,
            parent_id: std::result::Result::Err("Nullable types not supported in ProductGroupPromotion".to_string())?,
            slideshow_collections_title: std::result::Result::Err("Nullable types not supported in ProductGroupPromotion".to_string())?,
            slideshow_collections_description: std::result::Result::Err("Nullable types not supported in ProductGroupPromotion".to_string())?,
            is_mdl: std::result::Result::Err("Nullable types not supported in ProductGroupPromotion".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
            tracking_url: std::result::Result::Err("Nullable types not supported in ProductGroupPromotion".to_string())?,
            catalog_product_group_id: std::result::Result::Err("Nullable types not supported in ProductGroupPromotion".to_string())?,
            catalog_product_group_name: std::result::Result::Err("Nullable types not supported in ProductGroupPromotion".to_string())?,
            creative_type: intermediate_rep.creative_type.into_iter().next(),
            collections_hero_pin_id: std::result::Result::Err("Nullable types not supported in ProductGroupPromotion".to_string())?,
            collections_hero_destination_url: std::result::Result::Err("Nullable types not supported in ProductGroupPromotion".to_string())?,
            grid_click_type: std::result::Result::Err("Nullable types not supported in ProductGroupPromotion".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProductGroupPromotion> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProductGroupPromotion>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProductGroupPromotion>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProductGroupPromotion - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProductGroupPromotion> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProductGroupPromotion as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProductGroupPromotion - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProductGroupPromotionCreateRequest {
/// ID of the Ad Group the Product Group Promotion belongs to.
    #[serde(rename = "ad_group_id")]
    #[validate(
           regex = "RE_PRODUCTGROUPPROMOTIONCREATEREQUEST_AD_GROUP_ID",
        )]
    pub ad_group_id: String,

    #[serde(rename = "product_group_promotion")]
    pub product_group_promotion: Vec<models::ProductGroupPromotion>,

}

lazy_static::lazy_static! {
    static ref RE_PRODUCTGROUPPROMOTIONCREATEREQUEST_AD_GROUP_ID: regex::Regex = regex::Regex::new(r"^(AG)?\\d+$").unwrap();
}

impl ProductGroupPromotionCreateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(ad_group_id: String, product_group_promotion: Vec<models::ProductGroupPromotion>, ) -> ProductGroupPromotionCreateRequest {
        ProductGroupPromotionCreateRequest {
            ad_group_id,
            product_group_promotion,
        }
    }
}

/// Converts the ProductGroupPromotionCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProductGroupPromotionCreateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("ad_group_id".to_string()),
            Some(self.ad_group_id.to_string()),

            // Skipping product_group_promotion in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProductGroupPromotionCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProductGroupPromotionCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_group_id: Vec<String>,
            pub product_group_promotion: Vec<Vec<models::ProductGroupPromotion>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProductGroupPromotionCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_group_id" => intermediate_rep.ad_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "product_group_promotion" => return std::result::Result::Err("Parsing a container in this style is not supported in ProductGroupPromotionCreateRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProductGroupPromotionCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProductGroupPromotionCreateRequest {
            ad_group_id: intermediate_rep.ad_group_id.into_iter().next().ok_or_else(|| "ad_group_id missing in ProductGroupPromotionCreateRequest".to_string())?,
            product_group_promotion: intermediate_rep.product_group_promotion.into_iter().next().ok_or_else(|| "product_group_promotion missing in ProductGroupPromotionCreateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProductGroupPromotionCreateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProductGroupPromotionCreateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProductGroupPromotionCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProductGroupPromotionCreateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProductGroupPromotionCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProductGroupPromotionCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProductGroupPromotionCreateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProductGroupPromotionResponse {
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::ProductGroupPromotionResponseItem>>,

}


impl ProductGroupPromotionResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ProductGroupPromotionResponse {
        ProductGroupPromotionResponse {
            items: None,
        }
    }
}

/// Converts the ProductGroupPromotionResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProductGroupPromotionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProductGroupPromotionResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProductGroupPromotionResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::ProductGroupPromotionResponseItem>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProductGroupPromotionResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in ProductGroupPromotionResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProductGroupPromotionResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProductGroupPromotionResponse {
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProductGroupPromotionResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProductGroupPromotionResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProductGroupPromotionResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProductGroupPromotionResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProductGroupPromotionResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProductGroupPromotionResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProductGroupPromotionResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProductGroupPromotionResponseItem {
    #[serde(rename = "data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<models::ProductGroupPromotion>,

    #[serde(rename = "exceptions")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exceptions: Option<Nullable<Vec<models::Exception>>>,

}


impl ProductGroupPromotionResponseItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ProductGroupPromotionResponseItem {
        ProductGroupPromotionResponseItem {
            data: None,
            exceptions: None,
        }
    }
}

/// Converts the ProductGroupPromotionResponseItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProductGroupPromotionResponseItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization

            // Skipping exceptions in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProductGroupPromotionResponseItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProductGroupPromotionResponseItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<models::ProductGroupPromotion>,
            pub exceptions: Vec<Vec<models::Exception>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProductGroupPromotionResponseItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::ProductGroupPromotion as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "exceptions" => return std::result::Result::Err("Parsing a container in this style is not supported in ProductGroupPromotionResponseItem".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProductGroupPromotionResponseItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProductGroupPromotionResponseItem {
            data: intermediate_rep.data.into_iter().next(),
            exceptions: std::result::Result::Err("Nullable types not supported in ProductGroupPromotionResponseItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProductGroupPromotionResponseItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProductGroupPromotionResponseItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProductGroupPromotionResponseItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProductGroupPromotionResponseItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProductGroupPromotionResponseItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProductGroupPromotionResponseItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProductGroupPromotionResponseItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProductGroupPromotionUpdateRequest {
/// ID of the ad group the product group belongs to.
    #[serde(rename = "ad_group_id")]
    #[validate(
           regex = "RE_PRODUCTGROUPPROMOTIONUPDATEREQUEST_AD_GROUP_ID",
        )]
    pub ad_group_id: String,

    #[serde(rename = "product_group_promotion")]
    pub product_group_promotion: Vec<models::ProductGroupPromotion>,

}

lazy_static::lazy_static! {
    static ref RE_PRODUCTGROUPPROMOTIONUPDATEREQUEST_AD_GROUP_ID: regex::Regex = regex::Regex::new(r"^(AG)?\\d+$").unwrap();
}

impl ProductGroupPromotionUpdateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(ad_group_id: String, product_group_promotion: Vec<models::ProductGroupPromotion>, ) -> ProductGroupPromotionUpdateRequest {
        ProductGroupPromotionUpdateRequest {
            ad_group_id,
            product_group_promotion,
        }
    }
}

/// Converts the ProductGroupPromotionUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProductGroupPromotionUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("ad_group_id".to_string()),
            Some(self.ad_group_id.to_string()),

            // Skipping product_group_promotion in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProductGroupPromotionUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProductGroupPromotionUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_group_id: Vec<String>,
            pub product_group_promotion: Vec<Vec<models::ProductGroupPromotion>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProductGroupPromotionUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ad_group_id" => intermediate_rep.ad_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "product_group_promotion" => return std::result::Result::Err("Parsing a container in this style is not supported in ProductGroupPromotionUpdateRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProductGroupPromotionUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProductGroupPromotionUpdateRequest {
            ad_group_id: intermediate_rep.ad_group_id.into_iter().next().ok_or_else(|| "ad_group_id missing in ProductGroupPromotionUpdateRequest".to_string())?,
            product_group_promotion: intermediate_rep.product_group_promotion.into_iter().next().ok_or_else(|| "product_group_promotion missing in ProductGroupPromotionUpdateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProductGroupPromotionUpdateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProductGroupPromotionUpdateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProductGroupPromotionUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProductGroupPromotionUpdateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProductGroupPromotionUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProductGroupPromotionUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProductGroupPromotionUpdateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProductGroupPromotionsList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::ProductGroupPromotionResponseItem>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl ProductGroupPromotionsList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::ProductGroupPromotionResponseItem>, ) -> ProductGroupPromotionsList200Response {
        ProductGroupPromotionsList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the ProductGroupPromotionsList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProductGroupPromotionsList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProductGroupPromotionsList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProductGroupPromotionsList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::ProductGroupPromotionResponseItem>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProductGroupPromotionsList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in ProductGroupPromotionsList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ProductGroupPromotionsList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProductGroupPromotionsList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProductGroupPromotionsList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in ProductGroupPromotionsList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in ProductGroupPromotionsList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProductGroupPromotionsList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProductGroupPromotionsList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProductGroupPromotionsList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProductGroupPromotionsList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProductGroupPromotionsList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProductGroupPromotionsList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProductGroupPromotionsList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Summary status for product group
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ProductGroupSummaryStatus {
    #[serde(rename = "RUNNING")]
    Running,
    #[serde(rename = "PAUSED")]
    Paused,
    #[serde(rename = "EXCLUDED")]
    Excluded,
    #[serde(rename = "ARCHIVED")]
    Archived,
}

impl std::fmt::Display for ProductGroupSummaryStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ProductGroupSummaryStatus::Running => write!(f, "RUNNING"),
            ProductGroupSummaryStatus::Paused => write!(f, "PAUSED"),
            ProductGroupSummaryStatus::Excluded => write!(f, "EXCLUDED"),
            ProductGroupSummaryStatus::Archived => write!(f, "ARCHIVED"),
        }
    }
}

impl std::str::FromStr for ProductGroupSummaryStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "RUNNING" => std::result::Result::Ok(ProductGroupSummaryStatus::Running),
            "PAUSED" => std::result::Result::Ok(ProductGroupSummaryStatus::Paused),
            "EXCLUDED" => std::result::Result::Ok(ProductGroupSummaryStatus::Excluded),
            "ARCHIVED" => std::result::Result::Ok(ProductGroupSummaryStatus::Archived),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProductType0Filter {
    #[serde(rename = "PRODUCT_TYPE_0")]
    pub product_type_0: models::CatalogsProductGroupMultipleStringListCriteria,

}


impl ProductType0Filter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(product_type_0: models::CatalogsProductGroupMultipleStringListCriteria, ) -> ProductType0Filter {
        ProductType0Filter {
            product_type_0,
        }
    }
}

/// Converts the ProductType0Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProductType0Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping PRODUCT_TYPE_0 in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProductType0Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProductType0Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub product_type_0: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProductType0Filter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "PRODUCT_TYPE_0" => intermediate_rep.product_type_0.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProductType0Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProductType0Filter {
            product_type_0: intermediate_rep.product_type_0.into_iter().next().ok_or_else(|| "PRODUCT_TYPE_0 missing in ProductType0Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProductType0Filter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProductType0Filter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProductType0Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProductType0Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProductType0Filter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProductType0Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProductType0Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProductType1Filter {
    #[serde(rename = "PRODUCT_TYPE_1")]
    pub product_type_1: models::CatalogsProductGroupMultipleStringListCriteria,

}


impl ProductType1Filter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(product_type_1: models::CatalogsProductGroupMultipleStringListCriteria, ) -> ProductType1Filter {
        ProductType1Filter {
            product_type_1,
        }
    }
}

/// Converts the ProductType1Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProductType1Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping PRODUCT_TYPE_1 in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProductType1Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProductType1Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub product_type_1: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProductType1Filter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "PRODUCT_TYPE_1" => intermediate_rep.product_type_1.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProductType1Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProductType1Filter {
            product_type_1: intermediate_rep.product_type_1.into_iter().next().ok_or_else(|| "PRODUCT_TYPE_1 missing in ProductType1Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProductType1Filter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProductType1Filter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProductType1Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProductType1Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProductType1Filter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProductType1Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProductType1Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProductType2Filter {
    #[serde(rename = "PRODUCT_TYPE_2")]
    pub product_type_2: models::CatalogsProductGroupMultipleStringListCriteria,

}


impl ProductType2Filter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(product_type_2: models::CatalogsProductGroupMultipleStringListCriteria, ) -> ProductType2Filter {
        ProductType2Filter {
            product_type_2,
        }
    }
}

/// Converts the ProductType2Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProductType2Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping PRODUCT_TYPE_2 in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProductType2Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProductType2Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub product_type_2: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProductType2Filter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "PRODUCT_TYPE_2" => intermediate_rep.product_type_2.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProductType2Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProductType2Filter {
            product_type_2: intermediate_rep.product_type_2.into_iter().next().ok_or_else(|| "PRODUCT_TYPE_2 missing in ProductType2Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProductType2Filter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProductType2Filter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProductType2Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProductType2Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProductType2Filter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProductType2Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProductType2Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProductType3Filter {
    #[serde(rename = "PRODUCT_TYPE_3")]
    pub product_type_3: models::CatalogsProductGroupMultipleStringListCriteria,

}


impl ProductType3Filter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(product_type_3: models::CatalogsProductGroupMultipleStringListCriteria, ) -> ProductType3Filter {
        ProductType3Filter {
            product_type_3,
        }
    }
}

/// Converts the ProductType3Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProductType3Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping PRODUCT_TYPE_3 in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProductType3Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProductType3Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub product_type_3: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProductType3Filter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "PRODUCT_TYPE_3" => intermediate_rep.product_type_3.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProductType3Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProductType3Filter {
            product_type_3: intermediate_rep.product_type_3.into_iter().next().ok_or_else(|| "PRODUCT_TYPE_3 missing in ProductType3Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProductType3Filter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProductType3Filter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProductType3Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProductType3Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProductType3Filter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProductType3Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProductType3Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProductType4Filter {
    #[serde(rename = "PRODUCT_TYPE_4")]
    pub product_type_4: models::CatalogsProductGroupMultipleStringListCriteria,

}


impl ProductType4Filter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(product_type_4: models::CatalogsProductGroupMultipleStringListCriteria, ) -> ProductType4Filter {
        ProductType4Filter {
            product_type_4,
        }
    }
}

/// Converts the ProductType4Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProductType4Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping PRODUCT_TYPE_4 in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProductType4Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProductType4Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub product_type_4: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProductType4Filter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "PRODUCT_TYPE_4" => intermediate_rep.product_type_4.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProductType4Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProductType4Filter {
            product_type_4: intermediate_rep.product_type_4.into_iter().next().ok_or_else(|| "PRODUCT_TYPE_4 missing in ProductType4Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProductType4Filter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProductType4Filter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProductType4Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProductType4Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProductType4Filter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProductType4Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProductType4Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// This field includes all quiz data including questions, options, and results.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QuizPinData {
    #[serde(rename = "questions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub questions: Option<Vec<models::QuizPinQuestion>>,

    #[serde(rename = "results")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::QuizPinResult>>,

}


impl QuizPinData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> QuizPinData {
        QuizPinData {
            questions: None,
            results: None,
        }
    }
}

/// Converts the QuizPinData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for QuizPinData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping questions in query parameter serialization

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QuizPinData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QuizPinData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub questions: Vec<Vec<models::QuizPinQuestion>>,
            pub results: Vec<Vec<models::QuizPinResult>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing QuizPinData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "questions" => return std::result::Result::Err("Parsing a container in this style is not supported in QuizPinData".to_string()),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in QuizPinData".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing QuizPinData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QuizPinData {
            questions: intermediate_rep.questions.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QuizPinData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<QuizPinData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<QuizPinData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for QuizPinData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<QuizPinData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <QuizPinData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into QuizPinData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




///  This field contains multiple options to a quiz question.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QuizPinOption {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<f64>,

    #[serde(rename = "text")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,

}


impl QuizPinOption {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> QuizPinOption {
        QuizPinOption {
            id: None,
            text: None,
        }
    }
}

/// Converts the QuizPinOption value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for QuizPinOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.text.as_ref().map(|text| {
                [
                    "text".to_string(),
                    text.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QuizPinOption value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QuizPinOption {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<f64>,
            pub text: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing QuizPinOption".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing QuizPinOption".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QuizPinOption {
            id: intermediate_rep.id.into_iter().next(),
            text: intermediate_rep.text.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QuizPinOption> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<QuizPinOption>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<QuizPinOption>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for QuizPinOption - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<QuizPinOption> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <QuizPinOption as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into QuizPinOption - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A specific quiz inquiry.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QuizPinQuestion {
    #[serde(rename = "question_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub question_id: Option<f64>,

    #[serde(rename = "question_text")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub question_text: Option<String>,

    #[serde(rename = "options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<Vec<models::QuizPinOption>>,

}


impl QuizPinQuestion {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> QuizPinQuestion {
        QuizPinQuestion {
            question_id: None,
            question_text: None,
            options: None,
        }
    }
}

/// Converts the QuizPinQuestion value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for QuizPinQuestion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.question_id.as_ref().map(|question_id| {
                [
                    "question_id".to_string(),
                    question_id.to_string(),
                ].join(",")
            }),


            self.question_text.as_ref().map(|question_text| {
                [
                    "question_text".to_string(),
                    question_text.to_string(),
                ].join(",")
            }),

            // Skipping options in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QuizPinQuestion value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QuizPinQuestion {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub question_id: Vec<f64>,
            pub question_text: Vec<String>,
            pub options: Vec<Vec<models::QuizPinOption>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing QuizPinQuestion".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "question_id" => intermediate_rep.question_id.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "question_text" => intermediate_rep.question_text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "options" => return std::result::Result::Err("Parsing a container in this style is not supported in QuizPinQuestion".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing QuizPinQuestion".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QuizPinQuestion {
            question_id: intermediate_rep.question_id.into_iter().next(),
            question_text: intermediate_rep.question_text.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QuizPinQuestion> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<QuizPinQuestion>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<QuizPinQuestion>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for QuizPinQuestion - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<QuizPinQuestion> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <QuizPinQuestion as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into QuizPinQuestion - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The result, and link out, based on the user’s choice.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QuizPinResult {
    #[serde(rename = "organic_pin_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organic_pin_id: Option<String>,

    #[serde(rename = "android_deep_link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub android_deep_link: Option<String>,

    #[serde(rename = "ios_deep_link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ios_deep_link: Option<String>,

    #[serde(rename = "destination_url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub destination_url: Option<String>,

    #[serde(rename = "result_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub result_id: Option<f64>,

}


impl QuizPinResult {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> QuizPinResult {
        QuizPinResult {
            organic_pin_id: None,
            android_deep_link: None,
            ios_deep_link: None,
            destination_url: None,
            result_id: None,
        }
    }
}

/// Converts the QuizPinResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for QuizPinResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.organic_pin_id.as_ref().map(|organic_pin_id| {
                [
                    "organic_pin_id".to_string(),
                    organic_pin_id.to_string(),
                ].join(",")
            }),


            self.android_deep_link.as_ref().map(|android_deep_link| {
                [
                    "android_deep_link".to_string(),
                    android_deep_link.to_string(),
                ].join(",")
            }),


            self.ios_deep_link.as_ref().map(|ios_deep_link| {
                [
                    "ios_deep_link".to_string(),
                    ios_deep_link.to_string(),
                ].join(",")
            }),


            self.destination_url.as_ref().map(|destination_url| {
                [
                    "destination_url".to_string(),
                    destination_url.to_string(),
                ].join(",")
            }),


            self.result_id.as_ref().map(|result_id| {
                [
                    "result_id".to_string(),
                    result_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QuizPinResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QuizPinResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub organic_pin_id: Vec<String>,
            pub android_deep_link: Vec<String>,
            pub ios_deep_link: Vec<String>,
            pub destination_url: Vec<String>,
            pub result_id: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing QuizPinResult".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "organic_pin_id" => intermediate_rep.organic_pin_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "android_deep_link" => intermediate_rep.android_deep_link.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ios_deep_link" => intermediate_rep.ios_deep_link.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "destination_url" => intermediate_rep.destination_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "result_id" => intermediate_rep.result_id.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing QuizPinResult".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QuizPinResult {
            organic_pin_id: intermediate_rep.organic_pin_id.into_iter().next(),
            android_deep_link: intermediate_rep.android_deep_link.into_iter().next(),
            ios_deep_link: intermediate_rep.ios_deep_link.into_iter().next(),
            destination_url: intermediate_rep.destination_url.into_iter().next(),
            result_id: intermediate_rep.result_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QuizPinResult> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<QuizPinResult>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<QuizPinResult>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for QuizPinResult - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<QuizPinResult> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <QuizPinResult as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into QuizPinResult - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RelatedTerms {
/// First input term. For example, if you pass \"?terms=clothes,workout\", then id will be \"clothes\"
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Total number of related terms returned
    #[serde(rename = "related_term_count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub related_term_count: Option<i32>,

/// The id of the advertiser.
    #[serde(rename = "related_terms_list")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub related_terms_list: Option<Vec<models::RelatedTermsRelatedTermsListInner>>,

}


impl RelatedTerms {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RelatedTerms {
        RelatedTerms {
            id: None,
            related_term_count: None,
            related_terms_list: None,
        }
    }
}

/// Converts the RelatedTerms value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RelatedTerms {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.related_term_count.as_ref().map(|related_term_count| {
                [
                    "related_term_count".to_string(),
                    related_term_count.to_string(),
                ].join(",")
            }),

            // Skipping related_terms_list in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RelatedTerms value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RelatedTerms {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub related_term_count: Vec<i32>,
            pub related_terms_list: Vec<Vec<models::RelatedTermsRelatedTermsListInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RelatedTerms".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "related_term_count" => intermediate_rep.related_term_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "related_terms_list" => return std::result::Result::Err("Parsing a container in this style is not supported in RelatedTerms".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RelatedTerms".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RelatedTerms {
            id: intermediate_rep.id.into_iter().next(),
            related_term_count: intermediate_rep.related_term_count.into_iter().next(),
            related_terms_list: intermediate_rep.related_terms_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RelatedTerms> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RelatedTerms>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RelatedTerms>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RelatedTerms - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RelatedTerms> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RelatedTerms as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RelatedTerms - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RelatedTermsRelatedTermsListInner {
    #[serde(rename = "term")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub term: Option<String>,

    #[serde(rename = "related_terms")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub related_terms: Option<Vec<String>>,

}


impl RelatedTermsRelatedTermsListInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RelatedTermsRelatedTermsListInner {
        RelatedTermsRelatedTermsListInner {
            term: None,
            related_terms: None,
        }
    }
}

/// Converts the RelatedTermsRelatedTermsListInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RelatedTermsRelatedTermsListInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.term.as_ref().map(|term| {
                [
                    "term".to_string(),
                    term.to_string(),
                ].join(",")
            }),


            self.related_terms.as_ref().map(|related_terms| {
                [
                    "related_terms".to_string(),
                    related_terms.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RelatedTermsRelatedTermsListInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RelatedTermsRelatedTermsListInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub term: Vec<String>,
            pub related_terms: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RelatedTermsRelatedTermsListInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "term" => intermediate_rep.term.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "related_terms" => return std::result::Result::Err("Parsing a container in this style is not supported in RelatedTermsRelatedTermsListInner".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RelatedTermsRelatedTermsListInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RelatedTermsRelatedTermsListInner {
            term: intermediate_rep.term.into_iter().next(),
            related_terms: intermediate_rep.related_terms.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RelatedTermsRelatedTermsListInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RelatedTermsRelatedTermsListInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RelatedTermsRelatedTermsListInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RelatedTermsRelatedTermsListInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RelatedTermsRelatedTermsListInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RelatedTermsRelatedTermsListInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RelatedTermsRelatedTermsListInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Reporting columns
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReportingColumnAsync {
    #[serde(rename = "SPEND_IN_MICRO_DOLLAR")]
    SpendInMicroDollar,
    #[serde(rename = "PAID_IMPRESSION")]
    PaidImpression,
    #[serde(rename = "SPEND_IN_DOLLAR")]
    SpendInDollar,
    #[serde(rename = "CPC_IN_MICRO_DOLLAR")]
    CpcInMicroDollar,
    #[serde(rename = "ECPC_IN_MICRO_DOLLAR")]
    EcpcInMicroDollar,
    #[serde(rename = "ECPC_IN_DOLLAR")]
    EcpcInDollar,
    #[serde(rename = "CTR")]
    Ctr,
    #[serde(rename = "ECTR")]
    Ectr,
    #[serde(rename = "OUTBOUND_CTR")]
    OutboundCtr,
    #[serde(rename = "COST_PER_OUTBOUND_CLICK")]
    CostPerOutboundClick,
    #[serde(rename = "CAMPAIGN_NAME")]
    CampaignName,
    #[serde(rename = "CAMPAIGN_STATUS")]
    CampaignStatus,
    #[serde(rename = "PIN_PROMOTION_STATUS")]
    PinPromotionStatus,
    #[serde(rename = "AD_STATUS")]
    AdStatus,
    #[serde(rename = "PIN_ID")]
    PinId,
    #[serde(rename = "TOTAL_ENGAGEMENT")]
    TotalEngagement,
    #[serde(rename = "ENGAGEMENT_1")]
    Engagement1,
    #[serde(rename = "ENGAGEMENT_2")]
    Engagement2,
    #[serde(rename = "ECPE_IN_DOLLAR")]
    EcpeInDollar,
    #[serde(rename = "ENGAGEMENT_RATE")]
    EngagementRate,
    #[serde(rename = "EENGAGEMENT_RATE")]
    EengagementRate,
    #[serde(rename = "ECPM_IN_MICRO_DOLLAR")]
    EcpmInMicroDollar,
    #[serde(rename = "REPIN_RATE")]
    RepinRate,
    #[serde(rename = "CTR_2")]
    Ctr2,
    #[serde(rename = "CAMPAIGN_ID")]
    CampaignId,
    #[serde(rename = "ADVERTISER_ID")]
    AdvertiserId,
    #[serde(rename = "AD_ACCOUNT_ID")]
    AdAccountId,
    #[serde(rename = "PIN_PROMOTION_ID")]
    PinPromotionId,
    #[serde(rename = "AD_ID")]
    AdId,
    #[serde(rename = "AD_GROUP_ID")]
    AdGroupId,
    #[serde(rename = "CAMPAIGN_ENTITY_STATUS")]
    CampaignEntityStatus,
    #[serde(rename = "CAMPAIGN_MANAGED_STATUS")]
    CampaignManagedStatus,
    #[serde(rename = "CAMPAIGN_OBJECTIVE_TYPE")]
    CampaignObjectiveType,
    #[serde(rename = "CPM_IN_MICRO_DOLLAR")]
    CpmInMicroDollar,
    #[serde(rename = "CPM_IN_DOLLAR")]
    CpmInDollar,
    #[serde(rename = "AD_GROUP_NAME")]
    AdGroupName,
    #[serde(rename = "AD_GROUP_STATUS")]
    AdGroupStatus,
    #[serde(rename = "AD_GROUP_ENTITY_STATUS")]
    AdGroupEntityStatus,
    #[serde(rename = "PRODUCT_GROUP_ID")]
    ProductGroupId,
    #[serde(rename = "PRODUCT_GROUP_STATUS")]
    ProductGroupStatus,
    #[serde(rename = "ORDER_LINE_ID")]
    OrderLineId,
    #[serde(rename = "ORDER_LINE_NAME")]
    OrderLineName,
    #[serde(rename = "CLICKTHROUGH_1")]
    Clickthrough1,
    #[serde(rename = "REPIN_1")]
    Repin1,
    #[serde(rename = "IMPRESSION_1")]
    Impression1,
    #[serde(rename = "IMPRESSION_1_GROSS")]
    Impression1Gross,
    #[serde(rename = "CLICKTHROUGH_1_GROSS")]
    Clickthrough1Gross,
    #[serde(rename = "OUTBOUND_CLICK_1")]
    OutboundClick1,
    #[serde(rename = "CLICKTHROUGH_2")]
    Clickthrough2,
    #[serde(rename = "REPIN_2")]
    Repin2,
    #[serde(rename = "IMPRESSION_2")]
    Impression2,
    #[serde(rename = "OUTBOUND_CLICK_2")]
    OutboundClick2,
    #[serde(rename = "TOTAL_CLICKTHROUGH")]
    TotalClickthrough,
    #[serde(rename = "TOTAL_IMPRESSION")]
    TotalImpression,
    #[serde(rename = "TOTAL_IMPRESSION_USER")]
    TotalImpressionUser,
    #[serde(rename = "TOTAL_IMPRESSION_FREQUENCY")]
    TotalImpressionFrequency,
    #[serde(rename = "COST_PER_OUTBOUND_CLICK_IN_DOLLAR")]
    CostPerOutboundClickInDollar,
    #[serde(rename = "TOTAL_ENGAGEMENT_PAGE_VISIT")]
    TotalEngagementPageVisit,
    #[serde(rename = "TOTAL_ENGAGEMENT_SIGNUP")]
    TotalEngagementSignup,
    #[serde(rename = "TOTAL_ENGAGEMENT_CHECKOUT")]
    TotalEngagementCheckout,
    #[serde(rename = "TOTAL_ENGAGEMENT_CUSTOM")]
    TotalEngagementCustom,
    #[serde(rename = "TOTAL_ENGAGEMENT_ADD_TO_CART")]
    TotalEngagementAddToCart,
    #[serde(rename = "TOTAL_ENGAGEMENT_LEAD")]
    TotalEngagementLead,
    #[serde(rename = "TOTAL_ENGAGEMENT_SEARCH")]
    TotalEngagementSearch,
    #[serde(rename = "TOTAL_ENGAGEMENT_WATCH_VIDEO")]
    TotalEngagementWatchVideo,
    #[serde(rename = "TOTAL_ENGAGEMENT_VIEW_CATEGORY")]
    TotalEngagementViewCategory,
    #[serde(rename = "TOTAL_ENGAGEMENT_APP_INSTALL")]
    TotalEngagementAppInstall,
    #[serde(rename = "TOTAL_ENGAGEMENT_UNKNOWN")]
    TotalEngagementUnknown,
    #[serde(rename = "TOTAL_CLICK_PAGE_VISIT")]
    TotalClickPageVisit,
    #[serde(rename = "TOTAL_CLICK_SIGNUP")]
    TotalClickSignup,
    #[serde(rename = "TOTAL_CLICK_CHECKOUT")]
    TotalClickCheckout,
    #[serde(rename = "TOTAL_CLICK_CUSTOM")]
    TotalClickCustom,
    #[serde(rename = "TOTAL_CLICK_ADD_TO_CART")]
    TotalClickAddToCart,
    #[serde(rename = "TOTAL_CLICK_LEAD")]
    TotalClickLead,
    #[serde(rename = "TOTAL_CLICK_SEARCH")]
    TotalClickSearch,
    #[serde(rename = "TOTAL_CLICK_WATCH_VIDEO")]
    TotalClickWatchVideo,
    #[serde(rename = "TOTAL_CLICK_VIEW_CATEGORY")]
    TotalClickViewCategory,
    #[serde(rename = "TOTAL_CLICK_APP_INSTALL")]
    TotalClickAppInstall,
    #[serde(rename = "TOTAL_CLICK_UNKNOWN")]
    TotalClickUnknown,
    #[serde(rename = "TOTAL_VIEW_PAGE_VISIT")]
    TotalViewPageVisit,
    #[serde(rename = "TOTAL_VIEW_SIGNUP")]
    TotalViewSignup,
    #[serde(rename = "TOTAL_VIEW_CHECKOUT")]
    TotalViewCheckout,
    #[serde(rename = "TOTAL_VIEW_CUSTOM")]
    TotalViewCustom,
    #[serde(rename = "TOTAL_VIEW_ADD_TO_CART")]
    TotalViewAddToCart,
    #[serde(rename = "TOTAL_VIEW_LEAD")]
    TotalViewLead,
    #[serde(rename = "TOTAL_VIEW_SEARCH")]
    TotalViewSearch,
    #[serde(rename = "TOTAL_VIEW_WATCH_VIDEO")]
    TotalViewWatchVideo,
    #[serde(rename = "TOTAL_VIEW_VIEW_CATEGORY")]
    TotalViewViewCategory,
    #[serde(rename = "TOTAL_VIEW_APP_INSTALL")]
    TotalViewAppInstall,
    #[serde(rename = "TOTAL_VIEW_UNKNOWN")]
    TotalViewUnknown,
    #[serde(rename = "TOTAL_CONVERSIONS")]
    TotalConversions,
    #[serde(rename = "TOTAL_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR")]
    TotalEngagementPageVisitValueInMicroDollar,
    #[serde(rename = "TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TotalEngagementSignupValueInMicroDollar,
    #[serde(rename = "TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TotalEngagementCheckoutValueInMicroDollar,
    #[serde(rename = "TOTAL_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TotalEngagementCustomValueInMicroDollar,
    #[serde(rename = "TOTAL_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TotalEngagementAddToCartValueInMicroDollar,
    #[serde(rename = "TOTAL_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TotalEngagementLeadValueInMicroDollar,
    #[serde(rename = "TOTAL_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TotalEngagementSearchValueInMicroDollar,
    #[serde(rename = "TOTAL_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR")]
    TotalEngagementWatchVideoValueInMicroDollar,
    #[serde(rename = "TOTAL_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR")]
    TotalEngagementViewCategoryValueInMicroDollar,
    #[serde(rename = "TOTAL_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR")]
    TotalEngagementAppInstallValueInMicroDollar,
    #[serde(rename = "TOTAL_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TotalEngagementUnknownValueInMicroDollar,
    #[serde(rename = "TOTAL_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR")]
    TotalClickPageVisitValueInMicroDollar,
    #[serde(rename = "TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TotalClickSignupValueInMicroDollar,
    #[serde(rename = "TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TotalClickCheckoutValueInMicroDollar,
    #[serde(rename = "TOTAL_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TotalClickCustomValueInMicroDollar,
    #[serde(rename = "TOTAL_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TotalClickAddToCartValueInMicroDollar,
    #[serde(rename = "TOTAL_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TotalClickLeadValueInMicroDollar,
    #[serde(rename = "TOTAL_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TotalClickSearchValueInMicroDollar,
    #[serde(rename = "TOTAL_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR")]
    TotalClickWatchVideoValueInMicroDollar,
    #[serde(rename = "TOTAL_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR")]
    TotalClickViewCategoryValueInMicroDollar,
    #[serde(rename = "TOTAL_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR")]
    TotalClickAppInstallValueInMicroDollar,
    #[serde(rename = "TOTAL_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TotalClickUnknownValueInMicroDollar,
    #[serde(rename = "TOTAL_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR")]
    TotalViewPageVisitValueInMicroDollar,
    #[serde(rename = "TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TotalViewSignupValueInMicroDollar,
    #[serde(rename = "TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TotalViewCheckoutValueInMicroDollar,
    #[serde(rename = "TOTAL_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TotalViewCustomValueInMicroDollar,
    #[serde(rename = "TOTAL_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TotalViewAddToCartValueInMicroDollar,
    #[serde(rename = "TOTAL_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TotalViewLeadValueInMicroDollar,
    #[serde(rename = "TOTAL_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TotalViewSearchValueInMicroDollar,
    #[serde(rename = "TOTAL_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR")]
    TotalViewWatchVideoValueInMicroDollar,
    #[serde(rename = "TOTAL_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR")]
    TotalViewViewCategoryValueInMicroDollar,
    #[serde(rename = "TOTAL_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR")]
    TotalViewAppInstallValueInMicroDollar,
    #[serde(rename = "TOTAL_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TotalViewUnknownValueInMicroDollar,
    #[serde(rename = "TOTAL_CONVERSIONS_VALUE_IN_MICRO_DOLLAR")]
    TotalConversionsValueInMicroDollar,
    #[serde(rename = "TOTAL_ENGAGEMENT_PAGE_VISIT_QUANTITY")]
    TotalEngagementPageVisitQuantity,
    #[serde(rename = "TOTAL_ENGAGEMENT_SIGNUP_QUANTITY")]
    TotalEngagementSignupQuantity,
    #[serde(rename = "TOTAL_ENGAGEMENT_CHECKOUT_QUANTITY")]
    TotalEngagementCheckoutQuantity,
    #[serde(rename = "TOTAL_ENGAGEMENT_CUSTOM_QUANTITY")]
    TotalEngagementCustomQuantity,
    #[serde(rename = "TOTAL_ENGAGEMENT_ADD_TO_CART_QUANTITY")]
    TotalEngagementAddToCartQuantity,
    #[serde(rename = "TOTAL_ENGAGEMENT_LEAD_QUANTITY")]
    TotalEngagementLeadQuantity,
    #[serde(rename = "TOTAL_ENGAGEMENT_SEARCH_QUANTITY")]
    TotalEngagementSearchQuantity,
    #[serde(rename = "TOTAL_ENGAGEMENT_WATCH_VIDEO_QUANTITY")]
    TotalEngagementWatchVideoQuantity,
    #[serde(rename = "TOTAL_ENGAGEMENT_VIEW_CATEGORY_QUANTITY")]
    TotalEngagementViewCategoryQuantity,
    #[serde(rename = "TOTAL_ENGAGEMENT_UNKNOWN_QUANTITY")]
    TotalEngagementUnknownQuantity,
    #[serde(rename = "TOTAL_CLICK_PAGE_VISIT_QUANTITY")]
    TotalClickPageVisitQuantity,
    #[serde(rename = "TOTAL_CLICK_SIGNUP_QUANTITY")]
    TotalClickSignupQuantity,
    #[serde(rename = "TOTAL_CLICK_CHECKOUT_QUANTITY")]
    TotalClickCheckoutQuantity,
    #[serde(rename = "TOTAL_CLICK_CUSTOM_QUANTITY")]
    TotalClickCustomQuantity,
    #[serde(rename = "TOTAL_CLICK_ADD_TO_CART_QUANTITY")]
    TotalClickAddToCartQuantity,
    #[serde(rename = "TOTAL_CLICK_LEAD_QUANTITY")]
    TotalClickLeadQuantity,
    #[serde(rename = "TOTAL_CLICK_SEARCH_QUANTITY")]
    TotalClickSearchQuantity,
    #[serde(rename = "TOTAL_CLICK_WATCH_VIDEO_QUANTITY")]
    TotalClickWatchVideoQuantity,
    #[serde(rename = "TOTAL_CLICK_VIEW_CATEGORY_QUANTITY")]
    TotalClickViewCategoryQuantity,
    #[serde(rename = "TOTAL_CLICK_UNKNOWN_QUANTITY")]
    TotalClickUnknownQuantity,
    #[serde(rename = "TOTAL_VIEW_PAGE_VISIT_QUANTITY")]
    TotalViewPageVisitQuantity,
    #[serde(rename = "TOTAL_VIEW_SIGNUP_QUANTITY")]
    TotalViewSignupQuantity,
    #[serde(rename = "TOTAL_VIEW_CHECKOUT_QUANTITY")]
    TotalViewCheckoutQuantity,
    #[serde(rename = "TOTAL_VIEW_CUSTOM_QUANTITY")]
    TotalViewCustomQuantity,
    #[serde(rename = "TOTAL_VIEW_ADD_TO_CART_QUANTITY")]
    TotalViewAddToCartQuantity,
    #[serde(rename = "TOTAL_VIEW_LEAD_QUANTITY")]
    TotalViewLeadQuantity,
    #[serde(rename = "TOTAL_VIEW_SEARCH_QUANTITY")]
    TotalViewSearchQuantity,
    #[serde(rename = "TOTAL_VIEW_WATCH_VIDEO_QUANTITY")]
    TotalViewWatchVideoQuantity,
    #[serde(rename = "TOTAL_VIEW_VIEW_CATEGORY_QUANTITY")]
    TotalViewViewCategoryQuantity,
    #[serde(rename = "TOTAL_VIEW_UNKNOWN_QUANTITY")]
    TotalViewUnknownQuantity,
    #[serde(rename = "TOTAL_CONVERSIONS_QUANTITY")]
    TotalConversionsQuantity,
    #[serde(rename = "TOTAL_WEB_SESSIONS")]
    TotalWebSessions,
    #[serde(rename = "WEB_SESSIONS_1")]
    WebSessions1,
    #[serde(rename = "WEB_SESSIONS_2")]
    WebSessions2,
    #[serde(rename = "ONSITE_CHECKOUTS_1")]
    OnsiteCheckouts1,
    #[serde(rename = "PIN_PROMOTION_NAME")]
    PinPromotionName,
    #[serde(rename = "AD_NAME")]
    AdName,
    #[serde(rename = "CAMPAIGN_LIFETIME_SPEND_CAP")]
    CampaignLifetimeSpendCap,
    #[serde(rename = "CAMPAIGN_DAILY_SPEND_CAP")]
    CampaignDailySpendCap,
    #[serde(rename = "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TotalPageVisitDesktopActionToDesktopConversion,
    #[serde(rename = "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TotalPageVisitDesktopActionToMobileConversion,
    #[serde(rename = "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TotalPageVisitDesktopActionToTabletConversion,
    #[serde(rename = "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TotalPageVisitMobileActionToDesktopConversion,
    #[serde(rename = "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TotalPageVisitMobileActionToMobileConversion,
    #[serde(rename = "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TotalPageVisitMobileActionToTabletConversion,
    #[serde(rename = "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TotalPageVisitTabletActionToDesktopConversion,
    #[serde(rename = "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TotalPageVisitTabletActionToMobileConversion,
    #[serde(rename = "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TotalPageVisitTabletActionToTabletConversion,
    #[serde(rename = "TOTAL_SIGNUP_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TotalSignupDesktopActionToDesktopConversion,
    #[serde(rename = "TOTAL_SIGNUP_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TotalSignupDesktopActionToMobileConversion,
    #[serde(rename = "TOTAL_SIGNUP_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TotalSignupDesktopActionToTabletConversion,
    #[serde(rename = "TOTAL_SIGNUP_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TotalSignupMobileActionToDesktopConversion,
    #[serde(rename = "TOTAL_SIGNUP_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TotalSignupMobileActionToMobileConversion,
    #[serde(rename = "TOTAL_SIGNUP_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TotalSignupMobileActionToTabletConversion,
    #[serde(rename = "TOTAL_SIGNUP_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TotalSignupTabletActionToDesktopConversion,
    #[serde(rename = "TOTAL_SIGNUP_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TotalSignupTabletActionToMobileConversion,
    #[serde(rename = "TOTAL_SIGNUP_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TotalSignupTabletActionToTabletConversion,
    #[serde(rename = "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TotalCheckoutDesktopActionToDesktopConversion,
    #[serde(rename = "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TotalCheckoutDesktopActionToMobileConversion,
    #[serde(rename = "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TotalCheckoutDesktopActionToTabletConversion,
    #[serde(rename = "TOTAL_CHECKOUT_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TotalCheckoutMobileActionToDesktopConversion,
    #[serde(rename = "TOTAL_CHECKOUT_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TotalCheckoutMobileActionToMobileConversion,
    #[serde(rename = "TOTAL_CHECKOUT_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TotalCheckoutMobileActionToTabletConversion,
    #[serde(rename = "TOTAL_CHECKOUT_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TotalCheckoutTabletActionToDesktopConversion,
    #[serde(rename = "TOTAL_CHECKOUT_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TotalCheckoutTabletActionToMobileConversion,
    #[serde(rename = "TOTAL_CHECKOUT_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TotalCheckoutTabletActionToTabletConversion,
    #[serde(rename = "TOTAL_CUSTOM_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TotalCustomDesktopActionToDesktopConversion,
    #[serde(rename = "TOTAL_CUSTOM_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TotalCustomDesktopActionToMobileConversion,
    #[serde(rename = "TOTAL_CUSTOM_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TotalCustomDesktopActionToTabletConversion,
    #[serde(rename = "TOTAL_CUSTOM_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TotalCustomMobileActionToDesktopConversion,
    #[serde(rename = "TOTAL_CUSTOM_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TotalCustomMobileActionToMobileConversion,
    #[serde(rename = "TOTAL_CUSTOM_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TotalCustomMobileActionToTabletConversion,
    #[serde(rename = "TOTAL_CUSTOM_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TotalCustomTabletActionToDesktopConversion,
    #[serde(rename = "TOTAL_CUSTOM_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TotalCustomTabletActionToMobileConversion,
    #[serde(rename = "TOTAL_CUSTOM_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TotalCustomTabletActionToTabletConversion,
    #[serde(rename = "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TotalAddToCartDesktopActionToDesktopConversion,
    #[serde(rename = "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TotalAddToCartDesktopActionToMobileConversion,
    #[serde(rename = "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TotalAddToCartDesktopActionToTabletConversion,
    #[serde(rename = "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TotalAddToCartMobileActionToDesktopConversion,
    #[serde(rename = "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TotalAddToCartMobileActionToMobileConversion,
    #[serde(rename = "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TotalAddToCartMobileActionToTabletConversion,
    #[serde(rename = "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TotalAddToCartTabletActionToDesktopConversion,
    #[serde(rename = "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TotalAddToCartTabletActionToMobileConversion,
    #[serde(rename = "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TotalAddToCartTabletActionToTabletConversion,
    #[serde(rename = "TOTAL_LEAD_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TotalLeadDesktopActionToDesktopConversion,
    #[serde(rename = "TOTAL_LEAD_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TotalLeadDesktopActionToMobileConversion,
    #[serde(rename = "TOTAL_LEAD_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TotalLeadDesktopActionToTabletConversion,
    #[serde(rename = "TOTAL_LEAD_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TotalLeadMobileActionToDesktopConversion,
    #[serde(rename = "TOTAL_LEAD_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TotalLeadMobileActionToMobileConversion,
    #[serde(rename = "TOTAL_LEAD_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TotalLeadMobileActionToTabletConversion,
    #[serde(rename = "TOTAL_LEAD_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TotalLeadTabletActionToDesktopConversion,
    #[serde(rename = "TOTAL_LEAD_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TotalLeadTabletActionToMobileConversion,
    #[serde(rename = "TOTAL_LEAD_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TotalLeadTabletActionToTabletConversion,
    #[serde(rename = "TOTAL_SEARCH_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TotalSearchDesktopActionToDesktopConversion,
    #[serde(rename = "TOTAL_SEARCH_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TotalSearchDesktopActionToMobileConversion,
    #[serde(rename = "TOTAL_SEARCH_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TotalSearchDesktopActionToTabletConversion,
    #[serde(rename = "TOTAL_SEARCH_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TotalSearchMobileActionToDesktopConversion,
    #[serde(rename = "TOTAL_SEARCH_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TotalSearchMobileActionToMobileConversion,
    #[serde(rename = "TOTAL_SEARCH_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TotalSearchMobileActionToTabletConversion,
    #[serde(rename = "TOTAL_SEARCH_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TotalSearchTabletActionToDesktopConversion,
    #[serde(rename = "TOTAL_SEARCH_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TotalSearchTabletActionToMobileConversion,
    #[serde(rename = "TOTAL_SEARCH_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TotalSearchTabletActionToTabletConversion,
    #[serde(rename = "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TotalWatchVideoDesktopActionToDesktopConversion,
    #[serde(rename = "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TotalWatchVideoDesktopActionToMobileConversion,
    #[serde(rename = "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TotalWatchVideoDesktopActionToTabletConversion,
    #[serde(rename = "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TotalWatchVideoMobileActionToDesktopConversion,
    #[serde(rename = "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TotalWatchVideoMobileActionToMobileConversion,
    #[serde(rename = "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TotalWatchVideoMobileActionToTabletConversion,
    #[serde(rename = "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TotalWatchVideoTabletActionToDesktopConversion,
    #[serde(rename = "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TotalWatchVideoTabletActionToMobileConversion,
    #[serde(rename = "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TotalWatchVideoTabletActionToTabletConversion,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TotalViewCategoryDesktopActionToDesktopConversion,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TotalViewCategoryDesktopActionToMobileConversion,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TotalViewCategoryDesktopActionToTabletConversion,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TotalViewCategoryMobileActionToDesktopConversion,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TotalViewCategoryMobileActionToMobileConversion,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TotalViewCategoryMobileActionToTabletConversion,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TotalViewCategoryTabletActionToDesktopConversion,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TotalViewCategoryTabletActionToMobileConversion,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TotalViewCategoryTabletActionToTabletConversion,
    #[serde(rename = "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TotalAppInstallDesktopActionToDesktopConversion,
    #[serde(rename = "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TotalAppInstallDesktopActionToMobileConversion,
    #[serde(rename = "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TotalAppInstallDesktopActionToTabletConversion,
    #[serde(rename = "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TotalAppInstallMobileActionToDesktopConversion,
    #[serde(rename = "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TotalAppInstallMobileActionToMobileConversion,
    #[serde(rename = "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TotalAppInstallMobileActionToTabletConversion,
    #[serde(rename = "TOTAL_APP_INSTALL_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TotalAppInstallTabletActionToDesktopConversion,
    #[serde(rename = "TOTAL_APP_INSTALL_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TotalAppInstallTabletActionToMobileConversion,
    #[serde(rename = "TOTAL_APP_INSTALL_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TotalAppInstallTabletActionToTabletConversion,
    #[serde(rename = "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TotalUnknownDesktopActionToDesktopConversion,
    #[serde(rename = "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TotalUnknownDesktopActionToMobileConversion,
    #[serde(rename = "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TotalUnknownDesktopActionToTabletConversion,
    #[serde(rename = "TOTAL_UNKNOWN_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TotalUnknownMobileActionToDesktopConversion,
    #[serde(rename = "TOTAL_UNKNOWN_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TotalUnknownMobileActionToMobileConversion,
    #[serde(rename = "TOTAL_UNKNOWN_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TotalUnknownMobileActionToTabletConversion,
    #[serde(rename = "TOTAL_UNKNOWN_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TotalUnknownTabletActionToDesktopConversion,
    #[serde(rename = "TOTAL_UNKNOWN_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TotalUnknownTabletActionToMobileConversion,
    #[serde(rename = "TOTAL_UNKNOWN_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TotalUnknownTabletActionToTabletConversion,
    #[serde(rename = "TOTAL_PAGE_VISIT")]
    TotalPageVisit,
    #[serde(rename = "TOTAL_SIGNUP")]
    TotalSignup,
    #[serde(rename = "TOTAL_CHECKOUT")]
    TotalCheckout,
    #[serde(rename = "TOTAL_CUSTOM")]
    TotalCustom,
    #[serde(rename = "TOTAL_LEAD")]
    TotalLead,
    #[serde(rename = "TOTAL_APP_INSTALL")]
    TotalAppInstall,
    #[serde(rename = "TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TotalSignupValueInMicroDollar,
    #[serde(rename = "TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TotalCheckoutValueInMicroDollar,
    #[serde(rename = "TOTAL_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TotalCustomValueInMicroDollar,
    #[serde(rename = "TOTAL_APP_INSTALL_VALUE_IN_MICRO_DOLLAR")]
    TotalAppInstallValueInMicroDollar,
    #[serde(rename = "TOTAL_CHECKOUT_QUANTITY")]
    TotalCheckoutQuantity,
    #[serde(rename = "PAGE_VISIT_COST_PER_ACTION")]
    PageVisitCostPerAction,
    #[serde(rename = "APP_INSTALL_COST_PER_ACTION")]
    AppInstallCostPerAction,
    #[serde(rename = "PAGE_VISIT_ROAS")]
    PageVisitRoas,
    #[serde(rename = "CHECKOUT_ROAS")]
    CheckoutRoas,
    #[serde(rename = "CUSTOM_ROAS")]
    CustomRoas,
    #[serde(rename = "VIDEO_3SEC_VIEWS_1")]
    Video3SecViews1,
    #[serde(rename = "VIDEO_P100_COMPLETE_1")]
    VideoP100Complete1,
    #[serde(rename = "VIDEO_P0_COMBINED_1")]
    VideoP0Combined1,
    #[serde(rename = "VIDEO_P25_COMBINED_1")]
    VideoP25Combined1,
    #[serde(rename = "VIDEO_P50_COMBINED_1")]
    VideoP50Combined1,
    #[serde(rename = "VIDEO_P75_COMBINED_1")]
    VideoP75Combined1,
    #[serde(rename = "VIDEO_P95_COMBINED_1")]
    VideoP95Combined1,
    #[serde(rename = "VIDEO_MRC_VIEWS_1")]
    VideoMrcViews1,
    #[serde(rename = "VIDEO_3SEC_VIEWS_2")]
    Video3SecViews2,
    #[serde(rename = "VIDEO_P100_COMPLETE_2")]
    VideoP100Complete2,
    #[serde(rename = "VIDEO_P0_COMBINED_2")]
    VideoP0Combined2,
    #[serde(rename = "VIDEO_P25_COMBINED_2")]
    VideoP25Combined2,
    #[serde(rename = "VIDEO_P50_COMBINED_2")]
    VideoP50Combined2,
    #[serde(rename = "VIDEO_P75_COMBINED_2")]
    VideoP75Combined2,
    #[serde(rename = "VIDEO_P95_COMBINED_2")]
    VideoP95Combined2,
    #[serde(rename = "VIDEO_MRC_VIEWS_2")]
    VideoMrcViews2,
    #[serde(rename = "VIDEO_LENGTH")]
    VideoLength,
    #[serde(rename = "CPV_IN_MICRO_DOLLAR")]
    CpvInMicroDollar,
    #[serde(rename = "ECPV_IN_DOLLAR")]
    EcpvInDollar,
    #[serde(rename = "CPCV_IN_MICRO_DOLLAR")]
    CpcvInMicroDollar,
    #[serde(rename = "ECPCV_IN_DOLLAR")]
    EcpcvInDollar,
    #[serde(rename = "CPCV_P95_IN_MICRO_DOLLAR")]
    CpcvP95InMicroDollar,
    #[serde(rename = "ECPCV_P95_IN_DOLLAR")]
    EcpcvP95InDollar,
    #[serde(rename = "TOTAL_VIDEO_3SEC_VIEWS")]
    TotalVideo3SecViews,
    #[serde(rename = "TOTAL_VIDEO_P100_COMPLETE")]
    TotalVideoP100Complete,
    #[serde(rename = "TOTAL_VIDEO_P0_COMBINED")]
    TotalVideoP0Combined,
    #[serde(rename = "TOTAL_VIDEO_P25_COMBINED")]
    TotalVideoP25Combined,
    #[serde(rename = "TOTAL_VIDEO_P50_COMBINED")]
    TotalVideoP50Combined,
    #[serde(rename = "TOTAL_VIDEO_P75_COMBINED")]
    TotalVideoP75Combined,
    #[serde(rename = "TOTAL_VIDEO_P95_COMBINED")]
    TotalVideoP95Combined,
    #[serde(rename = "TOTAL_VIDEO_MRC_VIEWS")]
    TotalVideoMrcViews,
    #[serde(rename = "VIDEO_AVG_WATCHTIME_IN_SECOND_1")]
    VideoAvgWatchtimeInSecond1,
    #[serde(rename = "VIDEO_AVG_WATCHTIME_IN_SECOND_2")]
    VideoAvgWatchtimeInSecond2,
    #[serde(rename = "TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND")]
    TotalVideoAvgWatchtimeInSecond,
    #[serde(rename = "TOTAL_REPIN_RATE")]
    TotalRepinRate,
    #[serde(rename = "WEB_CHECKOUT_COST_PER_ACTION")]
    WebCheckoutCostPerAction,
    #[serde(rename = "WEB_CHECKOUT_ROAS")]
    WebCheckoutRoas,
    #[serde(rename = "TOTAL_WEB_CHECKOUT")]
    TotalWebCheckout,
    #[serde(rename = "TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TotalWebCheckoutValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_CLICK_CHECKOUT")]
    TotalWebClickCheckout,
    #[serde(rename = "TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TotalWebClickCheckoutValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_CHECKOUT")]
    TotalWebEngagementCheckout,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TotalWebEngagementCheckoutValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_VIEW_CHECKOUT")]
    TotalWebViewCheckout,
    #[serde(rename = "TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TotalWebViewCheckoutValueInMicroDollar,
    #[serde(rename = "INAPP_CHECKOUT_COST_PER_ACTION")]
    InappCheckoutCostPerAction,
    #[serde(rename = "INAPP_CHECKOUT_ROAS")]
    InappCheckoutRoas,
    #[serde(rename = "TOTAL_INAPP_CHECKOUT")]
    TotalInappCheckout,
    #[serde(rename = "TOTAL_INAPP_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TotalInappCheckoutValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_CLICK_CHECKOUT")]
    TotalInappClickCheckout,
    #[serde(rename = "TOTAL_INAPP_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TotalInappClickCheckoutValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_CHECKOUT")]
    TotalInappEngagementCheckout,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TotalInappEngagementCheckoutValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_VIEW_CHECKOUT")]
    TotalInappViewCheckout,
    #[serde(rename = "TOTAL_INAPP_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TotalInappViewCheckoutValueInMicroDollar,
    #[serde(rename = "OFFLINE_CHECKOUT_COST_PER_ACTION")]
    OfflineCheckoutCostPerAction,
    #[serde(rename = "OFFLINE_CHECKOUT_ROAS")]
    OfflineCheckoutRoas,
    #[serde(rename = "TOTAL_OFFLINE_CHECKOUT")]
    TotalOfflineCheckout,
    #[serde(rename = "TOTAL_OFFLINE_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineCheckoutValueInMicroDollar,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_CHECKOUT")]
    TotalOfflineClickCheckout,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineClickCheckoutValueInMicroDollar,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT")]
    TotalOfflineEngagementCheckout,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineEngagementCheckoutValueInMicroDollar,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_CHECKOUT")]
    TotalOfflineViewCheckout,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineViewCheckoutValueInMicroDollar,
    #[serde(rename = "PINTEREST_CHECKOUT_COST_PER_ACTION")]
    PinterestCheckoutCostPerAction,
    #[serde(rename = "PINTEREST_CHECKOUT_ROAS")]
    PinterestCheckoutRoas,
    #[serde(rename = "TOTAL_PINTEREST_CHECKOUT")]
    TotalPinterestCheckout,
    #[serde(rename = "TOTAL_PINTEREST_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TotalPinterestCheckoutValueInMicroDollar,
    #[serde(rename = "WEB_ADD_TO_CART_COST_PER_ACTION")]
    WebAddToCartCostPerAction,
    #[serde(rename = "WEB_ADD_TO_CART_ROAS")]
    WebAddToCartRoas,
    #[serde(rename = "TOTAL_WEB_ADD_TO_CART")]
    TotalWebAddToCart,
    #[serde(rename = "TOTAL_WEB_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TotalWebAddToCartValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_CLICK_ADD_TO_CART")]
    TotalWebClickAddToCart,
    #[serde(rename = "TOTAL_WEB_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TotalWebClickAddToCartValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_ADD_TO_CART")]
    TotalWebEngagementAddToCart,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TotalWebEngagementAddToCartValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_VIEW_ADD_TO_CART")]
    TotalWebViewAddToCart,
    #[serde(rename = "TOTAL_WEB_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TotalWebViewAddToCartValueInMicroDollar,
    #[serde(rename = "INAPP_ADD_TO_CART_COST_PER_ACTION")]
    InappAddToCartCostPerAction,
    #[serde(rename = "INAPP_ADD_TO_CART_ROAS")]
    InappAddToCartRoas,
    #[serde(rename = "TOTAL_INAPP_ADD_TO_CART")]
    TotalInappAddToCart,
    #[serde(rename = "TOTAL_INAPP_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TotalInappAddToCartValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_CLICK_ADD_TO_CART")]
    TotalInappClickAddToCart,
    #[serde(rename = "TOTAL_INAPP_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TotalInappClickAddToCartValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART")]
    TotalInappEngagementAddToCart,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TotalInappEngagementAddToCartValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_VIEW_ADD_TO_CART")]
    TotalInappViewAddToCart,
    #[serde(rename = "TOTAL_INAPP_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TotalInappViewAddToCartValueInMicroDollar,
    #[serde(rename = "WEB_PAGE_VISIT_COST_PER_ACTION")]
    WebPageVisitCostPerAction,
    #[serde(rename = "WEB_PAGE_VISIT_ROAS")]
    WebPageVisitRoas,
    #[serde(rename = "TOTAL_WEB_PAGE_VISIT")]
    TotalWebPageVisit,
    #[serde(rename = "TOTAL_WEB_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR")]
    TotalWebPageVisitValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_CLICK_PAGE_VISIT")]
    TotalWebClickPageVisit,
    #[serde(rename = "TOTAL_WEB_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR")]
    TotalWebClickPageVisitValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_PAGE_VISIT")]
    TotalWebEngagementPageVisit,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR")]
    TotalWebEngagementPageVisitValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_VIEW_PAGE_VISIT")]
    TotalWebViewPageVisit,
    #[serde(rename = "TOTAL_WEB_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR")]
    TotalWebViewPageVisitValueInMicroDollar,
    #[serde(rename = "WEB_SIGNUP_COST_PER_ACTION")]
    WebSignupCostPerAction,
    #[serde(rename = "WEB_SIGNUP_ROAS")]
    WebSignupRoas,
    #[serde(rename = "TOTAL_WEB_SIGNUP")]
    TotalWebSignup,
    #[serde(rename = "TOTAL_WEB_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TotalWebSignupValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_CLICK_SIGNUP")]
    TotalWebClickSignup,
    #[serde(rename = "TOTAL_WEB_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TotalWebClickSignupValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_SIGNUP")]
    TotalWebEngagementSignup,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TotalWebEngagementSignupValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_VIEW_SIGNUP")]
    TotalWebViewSignup,
    #[serde(rename = "TOTAL_WEB_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TotalWebViewSignupValueInMicroDollar,
    #[serde(rename = "INAPP_SIGNUP_COST_PER_ACTION")]
    InappSignupCostPerAction,
    #[serde(rename = "INAPP_SIGNUP_ROAS")]
    InappSignupRoas,
    #[serde(rename = "TOTAL_INAPP_SIGNUP")]
    TotalInappSignup,
    #[serde(rename = "TOTAL_INAPP_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TotalInappSignupValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_CLICK_SIGNUP")]
    TotalInappClickSignup,
    #[serde(rename = "TOTAL_INAPP_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TotalInappClickSignupValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_SIGNUP")]
    TotalInappEngagementSignup,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TotalInappEngagementSignupValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_VIEW_SIGNUP")]
    TotalInappViewSignup,
    #[serde(rename = "TOTAL_INAPP_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TotalInappViewSignupValueInMicroDollar,
    #[serde(rename = "OFFLINE_SIGNUP_COST_PER_ACTION")]
    OfflineSignupCostPerAction,
    #[serde(rename = "OFFLINE_SIGNUP_ROAS")]
    OfflineSignupRoas,
    #[serde(rename = "TOTAL_OFFLINE_SIGNUP")]
    TotalOfflineSignup,
    #[serde(rename = "TOTAL_OFFLINE_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineSignupValueInMicroDollar,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_SIGNUP")]
    TotalOfflineClickSignup,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineClickSignupValueInMicroDollar,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_SIGNUP")]
    TotalOfflineEngagementSignup,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineEngagementSignupValueInMicroDollar,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_SIGNUP")]
    TotalOfflineViewSignup,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineViewSignupValueInMicroDollar,
    #[serde(rename = "WEB_WATCH_VIDEO_COST_PER_ACTION")]
    WebWatchVideoCostPerAction,
    #[serde(rename = "WEB_WATCH_VIDEO_ROAS")]
    WebWatchVideoRoas,
    #[serde(rename = "TOTAL_WEB_WATCH_VIDEO")]
    TotalWebWatchVideo,
    #[serde(rename = "TOTAL_WEB_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR")]
    TotalWebWatchVideoValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_CLICK_WATCH_VIDEO")]
    TotalWebClickWatchVideo,
    #[serde(rename = "TOTAL_WEB_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR")]
    TotalWebClickWatchVideoValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO")]
    TotalWebEngagementWatchVideo,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR")]
    TotalWebEngagementWatchVideoValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_VIEW_WATCH_VIDEO")]
    TotalWebViewWatchVideo,
    #[serde(rename = "TOTAL_WEB_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR")]
    TotalWebViewWatchVideoValueInMicroDollar,
    #[serde(rename = "WEB_LEAD_COST_PER_ACTION")]
    WebLeadCostPerAction,
    #[serde(rename = "WEB_LEAD_ROAS")]
    WebLeadRoas,
    #[serde(rename = "TOTAL_WEB_LEAD")]
    TotalWebLead,
    #[serde(rename = "TOTAL_WEB_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TotalWebLeadValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_CLICK_LEAD")]
    TotalWebClickLead,
    #[serde(rename = "TOTAL_WEB_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TotalWebClickLeadValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_LEAD")]
    TotalWebEngagementLead,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TotalWebEngagementLeadValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_VIEW_LEAD")]
    TotalWebViewLead,
    #[serde(rename = "TOTAL_WEB_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TotalWebViewLeadValueInMicroDollar,
    #[serde(rename = "OFFLINE_LEAD_COST_PER_ACTION")]
    OfflineLeadCostPerAction,
    #[serde(rename = "OFFLINE_LEAD_ROAS")]
    OfflineLeadRoas,
    #[serde(rename = "TOTAL_OFFLINE_LEAD")]
    TotalOfflineLead,
    #[serde(rename = "TOTAL_OFFLINE_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineLeadValueInMicroDollar,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_LEAD")]
    TotalOfflineClickLead,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineClickLeadValueInMicroDollar,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_LEAD")]
    TotalOfflineEngagementLead,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineEngagementLeadValueInMicroDollar,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_LEAD")]
    TotalOfflineViewLead,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineViewLeadValueInMicroDollar,
    #[serde(rename = "WEB_SEARCH_COST_PER_ACTION")]
    WebSearchCostPerAction,
    #[serde(rename = "WEB_SEARCH_ROAS")]
    WebSearchRoas,
    #[serde(rename = "TOTAL_WEB_SEARCH")]
    TotalWebSearch,
    #[serde(rename = "TOTAL_WEB_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TotalWebSearchValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_CLICK_SEARCH")]
    TotalWebClickSearch,
    #[serde(rename = "TOTAL_WEB_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TotalWebClickSearchValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_SEARCH")]
    TotalWebEngagementSearch,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TotalWebEngagementSearchValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_VIEW_SEARCH")]
    TotalWebViewSearch,
    #[serde(rename = "TOTAL_WEB_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TotalWebViewSearchValueInMicroDollar,
    #[serde(rename = "INAPP_SEARCH_COST_PER_ACTION")]
    InappSearchCostPerAction,
    #[serde(rename = "INAPP_SEARCH_ROAS")]
    InappSearchRoas,
    #[serde(rename = "TOTAL_INAPP_SEARCH")]
    TotalInappSearch,
    #[serde(rename = "TOTAL_INAPP_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TotalInappSearchValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_CLICK_SEARCH")]
    TotalInappClickSearch,
    #[serde(rename = "TOTAL_INAPP_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TotalInappClickSearchValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_SEARCH")]
    TotalInappEngagementSearch,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TotalInappEngagementSearchValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_VIEW_SEARCH")]
    TotalInappViewSearch,
    #[serde(rename = "TOTAL_INAPP_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TotalInappViewSearchValueInMicroDollar,
    #[serde(rename = "WEB_VIEW_CATEGORY_COST_PER_ACTION")]
    WebViewCategoryCostPerAction,
    #[serde(rename = "WEB_VIEW_CATEGORY_ROAS")]
    WebViewCategoryRoas,
    #[serde(rename = "TOTAL_WEB_VIEW_CATEGORY")]
    TotalWebViewCategory,
    #[serde(rename = "TOTAL_WEB_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR")]
    TotalWebViewCategoryValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_CLICK_VIEW_CATEGORY")]
    TotalWebClickViewCategory,
    #[serde(rename = "TOTAL_WEB_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR")]
    TotalWebClickViewCategoryValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY")]
    TotalWebEngagementViewCategory,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR")]
    TotalWebEngagementViewCategoryValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_VIEW_VIEW_CATEGORY")]
    TotalWebViewViewCategory,
    #[serde(rename = "TOTAL_WEB_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR")]
    TotalWebViewViewCategoryValueInMicroDollar,
    #[serde(rename = "WEB_CUSTOM_COST_PER_ACTION")]
    WebCustomCostPerAction,
    #[serde(rename = "WEB_CUSTOM_ROAS")]
    WebCustomRoas,
    #[serde(rename = "TOTAL_WEB_CUSTOM")]
    TotalWebCustom,
    #[serde(rename = "TOTAL_WEB_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TotalWebCustomValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_CLICK_CUSTOM")]
    TotalWebClickCustom,
    #[serde(rename = "TOTAL_WEB_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TotalWebClickCustomValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_CUSTOM")]
    TotalWebEngagementCustom,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TotalWebEngagementCustomValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_VIEW_CUSTOM")]
    TotalWebViewCustom,
    #[serde(rename = "TOTAL_WEB_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TotalWebViewCustomValueInMicroDollar,
    #[serde(rename = "OFFLINE_CUSTOM_COST_PER_ACTION")]
    OfflineCustomCostPerAction,
    #[serde(rename = "OFFLINE_CUSTOM_ROAS")]
    OfflineCustomRoas,
    #[serde(rename = "TOTAL_OFFLINE_CUSTOM")]
    TotalOfflineCustom,
    #[serde(rename = "TOTAL_OFFLINE_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineCustomValueInMicroDollar,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_CUSTOM")]
    TotalOfflineClickCustom,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineClickCustomValueInMicroDollar,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_CUSTOM")]
    TotalOfflineEngagementCustom,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineEngagementCustomValueInMicroDollar,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_CUSTOM")]
    TotalOfflineViewCustom,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineViewCustomValueInMicroDollar,
    #[serde(rename = "WEB_UNKNOWN_COST_PER_ACTION")]
    WebUnknownCostPerAction,
    #[serde(rename = "WEB_UNKNOWN_ROAS")]
    WebUnknownRoas,
    #[serde(rename = "TOTAL_WEB_UNKNOWN")]
    TotalWebUnknown,
    #[serde(rename = "TOTAL_WEB_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TotalWebUnknownValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_CLICK_UNKNOWN")]
    TotalWebClickUnknown,
    #[serde(rename = "TOTAL_WEB_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TotalWebClickUnknownValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_UNKNOWN")]
    TotalWebEngagementUnknown,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TotalWebEngagementUnknownValueInMicroDollar,
    #[serde(rename = "TOTAL_WEB_VIEW_UNKNOWN")]
    TotalWebViewUnknown,
    #[serde(rename = "TOTAL_WEB_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TotalWebViewUnknownValueInMicroDollar,
    #[serde(rename = "INAPP_UNKNOWN_COST_PER_ACTION")]
    InappUnknownCostPerAction,
    #[serde(rename = "INAPP_UNKNOWN_ROAS")]
    InappUnknownRoas,
    #[serde(rename = "TOTAL_INAPP_UNKNOWN")]
    TotalInappUnknown,
    #[serde(rename = "TOTAL_INAPP_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TotalInappUnknownValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_CLICK_UNKNOWN")]
    TotalInappClickUnknown,
    #[serde(rename = "TOTAL_INAPP_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TotalInappClickUnknownValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_UNKNOWN")]
    TotalInappEngagementUnknown,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TotalInappEngagementUnknownValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_VIEW_UNKNOWN")]
    TotalInappViewUnknown,
    #[serde(rename = "TOTAL_INAPP_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TotalInappViewUnknownValueInMicroDollar,
    #[serde(rename = "OFFLINE_UNKNOWN_COST_PER_ACTION")]
    OfflineUnknownCostPerAction,
    #[serde(rename = "OFFLINE_UNKNOWN_ROAS")]
    OfflineUnknownRoas,
    #[serde(rename = "TOTAL_OFFLINE_UNKNOWN")]
    TotalOfflineUnknown,
    #[serde(rename = "TOTAL_OFFLINE_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineUnknownValueInMicroDollar,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_UNKNOWN")]
    TotalOfflineClickUnknown,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineClickUnknownValueInMicroDollar,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN")]
    TotalOfflineEngagementUnknown,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineEngagementUnknownValueInMicroDollar,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_UNKNOWN")]
    TotalOfflineViewUnknown,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TotalOfflineViewUnknownValueInMicroDollar,
    #[serde(rename = "INAPP_APP_INSTALL_COST_PER_ACTION")]
    InappAppInstallCostPerAction,
    #[serde(rename = "INAPP_APP_INSTALL_ROAS")]
    InappAppInstallRoas,
    #[serde(rename = "TOTAL_INAPP_APP_INSTALL")]
    TotalInappAppInstall,
    #[serde(rename = "TOTAL_INAPP_APP_INSTALL_VALUE_IN_MICRO_DOLLAR")]
    TotalInappAppInstallValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_CLICK_APP_INSTALL")]
    TotalInappClickAppInstall,
    #[serde(rename = "TOTAL_INAPP_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR")]
    TotalInappClickAppInstallValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_APP_INSTALL")]
    TotalInappEngagementAppInstall,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR")]
    TotalInappEngagementAppInstallValueInMicroDollar,
    #[serde(rename = "TOTAL_INAPP_VIEW_APP_INSTALL")]
    TotalInappViewAppInstall,
    #[serde(rename = "TOTAL_INAPP_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR")]
    TotalInappViewAppInstallValueInMicroDollar,
    #[serde(rename = "IDEA_PIN_PRODUCT_TAG_VISIT_1")]
    IdeaPinProductTagVisit1,
    #[serde(rename = "IDEA_PIN_PRODUCT_TAG_VISIT_2")]
    IdeaPinProductTagVisit2,
    #[serde(rename = "TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT")]
    TotalIdeaPinProductTagVisit,
    #[serde(rename = "LEADS")]
    Leads,
    #[serde(rename = "COST_PER_LEAD")]
    CostPerLead,
    #[serde(rename = "QUIZ_COMPLETED")]
    QuizCompleted,
    #[serde(rename = "QUIZ_COMPLETION_RATE")]
    QuizCompletionRate,
    #[serde(rename = "SHOWCASE_PIN_CLICKTHROUGH")]
    ShowcasePinClickthrough,
    #[serde(rename = "SHOWCASE_SUBPAGE_CLICKTHROUGH")]
    ShowcaseSubpageClickthrough,
    #[serde(rename = "SHOWCASE_SUBPIN_CLICKTHROUGH")]
    ShowcaseSubpinClickthrough,
    #[serde(rename = "SHOWCASE_SUBPAGE_IMPRESSION")]
    ShowcaseSubpageImpression,
    #[serde(rename = "SHOWCASE_SUBPIN_IMPRESSION")]
    ShowcaseSubpinImpression,
    #[serde(rename = "SHOWCASE_SUBPAGE_SWIPE_LEFT")]
    ShowcaseSubpageSwipeLeft,
    #[serde(rename = "SHOWCASE_SUBPAGE_SWIPE_RIGHT")]
    ShowcaseSubpageSwipeRight,
    #[serde(rename = "SHOWCASE_SUBPIN_SWIPE_LEFT")]
    ShowcaseSubpinSwipeLeft,
    #[serde(rename = "SHOWCASE_SUBPIN_SWIPE_RIGHT")]
    ShowcaseSubpinSwipeRight,
    #[serde(rename = "SHOWCASE_SUBPAGE_REPIN")]
    ShowcaseSubpageRepin,
    #[serde(rename = "SHOWCASE_SUBPIN_REPIN")]
    ShowcaseSubpinRepin,
    #[serde(rename = "SHOWCASE_SUBPAGE_CLOSEUP")]
    ShowcaseSubpageCloseup,
    #[serde(rename = "SHOWCASE_CARD_THUMBNAIL_SWIPE_FORWARD")]
    ShowcaseCardThumbnailSwipeForward,
    #[serde(rename = "SHOWCASE_CARD_THUMBNAIL_SWIPE_BACKWARD")]
    ShowcaseCardThumbnailSwipeBackward,
    #[serde(rename = "SHOWCASE_AVERAGE_SUBPAGE_CLOSEUP_PER_SESSION")]
    ShowcaseAverageSubpageCloseupPerSession,
    #[serde(rename = "TOTAL_CHECKOUT_CONVERSION_RATE")]
    TotalCheckoutConversionRate,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_CONVERSION_RATE")]
    TotalViewCategoryConversionRate,
    #[serde(rename = "TOTAL_ADD_TO_CART_CONVERSION_RATE")]
    TotalAddToCartConversionRate,
    #[serde(rename = "TOTAL_SIGNUP_CONVERSION_RATE")]
    TotalSignupConversionRate,
    #[serde(rename = "TOTAL_PAGE_VISIT_CONVERSION_RATE")]
    TotalPageVisitConversionRate,
    #[serde(rename = "TOTAL_LEAD_CONVERSION_RATE")]
    TotalLeadConversionRate,
    #[serde(rename = "TOTAL_SEARCH_CONVERSION_RATE")]
    TotalSearchConversionRate,
    #[serde(rename = "TOTAL_WATCH_VIDEO_CONVERSION_RATE")]
    TotalWatchVideoConversionRate,
    #[serde(rename = "TOTAL_UNKNOWN_CONVERSION_RATE")]
    TotalUnknownConversionRate,
    #[serde(rename = "TOTAL_CUSTOM_CONVERSION_RATE")]
    TotalCustomConversionRate,
    #[serde(rename = "STANDARD_AD_FEED_ITEM_ID")]
    StandardAdFeedItemId,
}

impl std::fmt::Display for ReportingColumnAsync {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReportingColumnAsync::SpendInMicroDollar => write!(f, "SPEND_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::PaidImpression => write!(f, "PAID_IMPRESSION"),
            ReportingColumnAsync::SpendInDollar => write!(f, "SPEND_IN_DOLLAR"),
            ReportingColumnAsync::CpcInMicroDollar => write!(f, "CPC_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::EcpcInMicroDollar => write!(f, "ECPC_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::EcpcInDollar => write!(f, "ECPC_IN_DOLLAR"),
            ReportingColumnAsync::Ctr => write!(f, "CTR"),
            ReportingColumnAsync::Ectr => write!(f, "ECTR"),
            ReportingColumnAsync::OutboundCtr => write!(f, "OUTBOUND_CTR"),
            ReportingColumnAsync::CostPerOutboundClick => write!(f, "COST_PER_OUTBOUND_CLICK"),
            ReportingColumnAsync::CampaignName => write!(f, "CAMPAIGN_NAME"),
            ReportingColumnAsync::CampaignStatus => write!(f, "CAMPAIGN_STATUS"),
            ReportingColumnAsync::PinPromotionStatus => write!(f, "PIN_PROMOTION_STATUS"),
            ReportingColumnAsync::AdStatus => write!(f, "AD_STATUS"),
            ReportingColumnAsync::PinId => write!(f, "PIN_ID"),
            ReportingColumnAsync::TotalEngagement => write!(f, "TOTAL_ENGAGEMENT"),
            ReportingColumnAsync::Engagement1 => write!(f, "ENGAGEMENT_1"),
            ReportingColumnAsync::Engagement2 => write!(f, "ENGAGEMENT_2"),
            ReportingColumnAsync::EcpeInDollar => write!(f, "ECPE_IN_DOLLAR"),
            ReportingColumnAsync::EngagementRate => write!(f, "ENGAGEMENT_RATE"),
            ReportingColumnAsync::EengagementRate => write!(f, "EENGAGEMENT_RATE"),
            ReportingColumnAsync::EcpmInMicroDollar => write!(f, "ECPM_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::RepinRate => write!(f, "REPIN_RATE"),
            ReportingColumnAsync::Ctr2 => write!(f, "CTR_2"),
            ReportingColumnAsync::CampaignId => write!(f, "CAMPAIGN_ID"),
            ReportingColumnAsync::AdvertiserId => write!(f, "ADVERTISER_ID"),
            ReportingColumnAsync::AdAccountId => write!(f, "AD_ACCOUNT_ID"),
            ReportingColumnAsync::PinPromotionId => write!(f, "PIN_PROMOTION_ID"),
            ReportingColumnAsync::AdId => write!(f, "AD_ID"),
            ReportingColumnAsync::AdGroupId => write!(f, "AD_GROUP_ID"),
            ReportingColumnAsync::CampaignEntityStatus => write!(f, "CAMPAIGN_ENTITY_STATUS"),
            ReportingColumnAsync::CampaignManagedStatus => write!(f, "CAMPAIGN_MANAGED_STATUS"),
            ReportingColumnAsync::CampaignObjectiveType => write!(f, "CAMPAIGN_OBJECTIVE_TYPE"),
            ReportingColumnAsync::CpmInMicroDollar => write!(f, "CPM_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::CpmInDollar => write!(f, "CPM_IN_DOLLAR"),
            ReportingColumnAsync::AdGroupName => write!(f, "AD_GROUP_NAME"),
            ReportingColumnAsync::AdGroupStatus => write!(f, "AD_GROUP_STATUS"),
            ReportingColumnAsync::AdGroupEntityStatus => write!(f, "AD_GROUP_ENTITY_STATUS"),
            ReportingColumnAsync::ProductGroupId => write!(f, "PRODUCT_GROUP_ID"),
            ReportingColumnAsync::ProductGroupStatus => write!(f, "PRODUCT_GROUP_STATUS"),
            ReportingColumnAsync::OrderLineId => write!(f, "ORDER_LINE_ID"),
            ReportingColumnAsync::OrderLineName => write!(f, "ORDER_LINE_NAME"),
            ReportingColumnAsync::Clickthrough1 => write!(f, "CLICKTHROUGH_1"),
            ReportingColumnAsync::Repin1 => write!(f, "REPIN_1"),
            ReportingColumnAsync::Impression1 => write!(f, "IMPRESSION_1"),
            ReportingColumnAsync::Impression1Gross => write!(f, "IMPRESSION_1_GROSS"),
            ReportingColumnAsync::Clickthrough1Gross => write!(f, "CLICKTHROUGH_1_GROSS"),
            ReportingColumnAsync::OutboundClick1 => write!(f, "OUTBOUND_CLICK_1"),
            ReportingColumnAsync::Clickthrough2 => write!(f, "CLICKTHROUGH_2"),
            ReportingColumnAsync::Repin2 => write!(f, "REPIN_2"),
            ReportingColumnAsync::Impression2 => write!(f, "IMPRESSION_2"),
            ReportingColumnAsync::OutboundClick2 => write!(f, "OUTBOUND_CLICK_2"),
            ReportingColumnAsync::TotalClickthrough => write!(f, "TOTAL_CLICKTHROUGH"),
            ReportingColumnAsync::TotalImpression => write!(f, "TOTAL_IMPRESSION"),
            ReportingColumnAsync::TotalImpressionUser => write!(f, "TOTAL_IMPRESSION_USER"),
            ReportingColumnAsync::TotalImpressionFrequency => write!(f, "TOTAL_IMPRESSION_FREQUENCY"),
            ReportingColumnAsync::CostPerOutboundClickInDollar => write!(f, "COST_PER_OUTBOUND_CLICK_IN_DOLLAR"),
            ReportingColumnAsync::TotalEngagementPageVisit => write!(f, "TOTAL_ENGAGEMENT_PAGE_VISIT"),
            ReportingColumnAsync::TotalEngagementSignup => write!(f, "TOTAL_ENGAGEMENT_SIGNUP"),
            ReportingColumnAsync::TotalEngagementCheckout => write!(f, "TOTAL_ENGAGEMENT_CHECKOUT"),
            ReportingColumnAsync::TotalEngagementCustom => write!(f, "TOTAL_ENGAGEMENT_CUSTOM"),
            ReportingColumnAsync::TotalEngagementAddToCart => write!(f, "TOTAL_ENGAGEMENT_ADD_TO_CART"),
            ReportingColumnAsync::TotalEngagementLead => write!(f, "TOTAL_ENGAGEMENT_LEAD"),
            ReportingColumnAsync::TotalEngagementSearch => write!(f, "TOTAL_ENGAGEMENT_SEARCH"),
            ReportingColumnAsync::TotalEngagementWatchVideo => write!(f, "TOTAL_ENGAGEMENT_WATCH_VIDEO"),
            ReportingColumnAsync::TotalEngagementViewCategory => write!(f, "TOTAL_ENGAGEMENT_VIEW_CATEGORY"),
            ReportingColumnAsync::TotalEngagementAppInstall => write!(f, "TOTAL_ENGAGEMENT_APP_INSTALL"),
            ReportingColumnAsync::TotalEngagementUnknown => write!(f, "TOTAL_ENGAGEMENT_UNKNOWN"),
            ReportingColumnAsync::TotalClickPageVisit => write!(f, "TOTAL_CLICK_PAGE_VISIT"),
            ReportingColumnAsync::TotalClickSignup => write!(f, "TOTAL_CLICK_SIGNUP"),
            ReportingColumnAsync::TotalClickCheckout => write!(f, "TOTAL_CLICK_CHECKOUT"),
            ReportingColumnAsync::TotalClickCustom => write!(f, "TOTAL_CLICK_CUSTOM"),
            ReportingColumnAsync::TotalClickAddToCart => write!(f, "TOTAL_CLICK_ADD_TO_CART"),
            ReportingColumnAsync::TotalClickLead => write!(f, "TOTAL_CLICK_LEAD"),
            ReportingColumnAsync::TotalClickSearch => write!(f, "TOTAL_CLICK_SEARCH"),
            ReportingColumnAsync::TotalClickWatchVideo => write!(f, "TOTAL_CLICK_WATCH_VIDEO"),
            ReportingColumnAsync::TotalClickViewCategory => write!(f, "TOTAL_CLICK_VIEW_CATEGORY"),
            ReportingColumnAsync::TotalClickAppInstall => write!(f, "TOTAL_CLICK_APP_INSTALL"),
            ReportingColumnAsync::TotalClickUnknown => write!(f, "TOTAL_CLICK_UNKNOWN"),
            ReportingColumnAsync::TotalViewPageVisit => write!(f, "TOTAL_VIEW_PAGE_VISIT"),
            ReportingColumnAsync::TotalViewSignup => write!(f, "TOTAL_VIEW_SIGNUP"),
            ReportingColumnAsync::TotalViewCheckout => write!(f, "TOTAL_VIEW_CHECKOUT"),
            ReportingColumnAsync::TotalViewCustom => write!(f, "TOTAL_VIEW_CUSTOM"),
            ReportingColumnAsync::TotalViewAddToCart => write!(f, "TOTAL_VIEW_ADD_TO_CART"),
            ReportingColumnAsync::TotalViewLead => write!(f, "TOTAL_VIEW_LEAD"),
            ReportingColumnAsync::TotalViewSearch => write!(f, "TOTAL_VIEW_SEARCH"),
            ReportingColumnAsync::TotalViewWatchVideo => write!(f, "TOTAL_VIEW_WATCH_VIDEO"),
            ReportingColumnAsync::TotalViewViewCategory => write!(f, "TOTAL_VIEW_VIEW_CATEGORY"),
            ReportingColumnAsync::TotalViewAppInstall => write!(f, "TOTAL_VIEW_APP_INSTALL"),
            ReportingColumnAsync::TotalViewUnknown => write!(f, "TOTAL_VIEW_UNKNOWN"),
            ReportingColumnAsync::TotalConversions => write!(f, "TOTAL_CONVERSIONS"),
            ReportingColumnAsync::TotalEngagementPageVisitValueInMicroDollar => write!(f, "TOTAL_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalEngagementSignupValueInMicroDollar => write!(f, "TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalEngagementCheckoutValueInMicroDollar => write!(f, "TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalEngagementCustomValueInMicroDollar => write!(f, "TOTAL_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalEngagementAddToCartValueInMicroDollar => write!(f, "TOTAL_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalEngagementLeadValueInMicroDollar => write!(f, "TOTAL_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalEngagementSearchValueInMicroDollar => write!(f, "TOTAL_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalEngagementWatchVideoValueInMicroDollar => write!(f, "TOTAL_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalEngagementViewCategoryValueInMicroDollar => write!(f, "TOTAL_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalEngagementAppInstallValueInMicroDollar => write!(f, "TOTAL_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalEngagementUnknownValueInMicroDollar => write!(f, "TOTAL_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalClickPageVisitValueInMicroDollar => write!(f, "TOTAL_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalClickSignupValueInMicroDollar => write!(f, "TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalClickCheckoutValueInMicroDollar => write!(f, "TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalClickCustomValueInMicroDollar => write!(f, "TOTAL_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalClickAddToCartValueInMicroDollar => write!(f, "TOTAL_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalClickLeadValueInMicroDollar => write!(f, "TOTAL_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalClickSearchValueInMicroDollar => write!(f, "TOTAL_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalClickWatchVideoValueInMicroDollar => write!(f, "TOTAL_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalClickViewCategoryValueInMicroDollar => write!(f, "TOTAL_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalClickAppInstallValueInMicroDollar => write!(f, "TOTAL_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalClickUnknownValueInMicroDollar => write!(f, "TOTAL_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalViewPageVisitValueInMicroDollar => write!(f, "TOTAL_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalViewSignupValueInMicroDollar => write!(f, "TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalViewCheckoutValueInMicroDollar => write!(f, "TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalViewCustomValueInMicroDollar => write!(f, "TOTAL_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalViewAddToCartValueInMicroDollar => write!(f, "TOTAL_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalViewLeadValueInMicroDollar => write!(f, "TOTAL_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalViewSearchValueInMicroDollar => write!(f, "TOTAL_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalViewWatchVideoValueInMicroDollar => write!(f, "TOTAL_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalViewViewCategoryValueInMicroDollar => write!(f, "TOTAL_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalViewAppInstallValueInMicroDollar => write!(f, "TOTAL_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalViewUnknownValueInMicroDollar => write!(f, "TOTAL_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalConversionsValueInMicroDollar => write!(f, "TOTAL_CONVERSIONS_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalEngagementPageVisitQuantity => write!(f, "TOTAL_ENGAGEMENT_PAGE_VISIT_QUANTITY"),
            ReportingColumnAsync::TotalEngagementSignupQuantity => write!(f, "TOTAL_ENGAGEMENT_SIGNUP_QUANTITY"),
            ReportingColumnAsync::TotalEngagementCheckoutQuantity => write!(f, "TOTAL_ENGAGEMENT_CHECKOUT_QUANTITY"),
            ReportingColumnAsync::TotalEngagementCustomQuantity => write!(f, "TOTAL_ENGAGEMENT_CUSTOM_QUANTITY"),
            ReportingColumnAsync::TotalEngagementAddToCartQuantity => write!(f, "TOTAL_ENGAGEMENT_ADD_TO_CART_QUANTITY"),
            ReportingColumnAsync::TotalEngagementLeadQuantity => write!(f, "TOTAL_ENGAGEMENT_LEAD_QUANTITY"),
            ReportingColumnAsync::TotalEngagementSearchQuantity => write!(f, "TOTAL_ENGAGEMENT_SEARCH_QUANTITY"),
            ReportingColumnAsync::TotalEngagementWatchVideoQuantity => write!(f, "TOTAL_ENGAGEMENT_WATCH_VIDEO_QUANTITY"),
            ReportingColumnAsync::TotalEngagementViewCategoryQuantity => write!(f, "TOTAL_ENGAGEMENT_VIEW_CATEGORY_QUANTITY"),
            ReportingColumnAsync::TotalEngagementUnknownQuantity => write!(f, "TOTAL_ENGAGEMENT_UNKNOWN_QUANTITY"),
            ReportingColumnAsync::TotalClickPageVisitQuantity => write!(f, "TOTAL_CLICK_PAGE_VISIT_QUANTITY"),
            ReportingColumnAsync::TotalClickSignupQuantity => write!(f, "TOTAL_CLICK_SIGNUP_QUANTITY"),
            ReportingColumnAsync::TotalClickCheckoutQuantity => write!(f, "TOTAL_CLICK_CHECKOUT_QUANTITY"),
            ReportingColumnAsync::TotalClickCustomQuantity => write!(f, "TOTAL_CLICK_CUSTOM_QUANTITY"),
            ReportingColumnAsync::TotalClickAddToCartQuantity => write!(f, "TOTAL_CLICK_ADD_TO_CART_QUANTITY"),
            ReportingColumnAsync::TotalClickLeadQuantity => write!(f, "TOTAL_CLICK_LEAD_QUANTITY"),
            ReportingColumnAsync::TotalClickSearchQuantity => write!(f, "TOTAL_CLICK_SEARCH_QUANTITY"),
            ReportingColumnAsync::TotalClickWatchVideoQuantity => write!(f, "TOTAL_CLICK_WATCH_VIDEO_QUANTITY"),
            ReportingColumnAsync::TotalClickViewCategoryQuantity => write!(f, "TOTAL_CLICK_VIEW_CATEGORY_QUANTITY"),
            ReportingColumnAsync::TotalClickUnknownQuantity => write!(f, "TOTAL_CLICK_UNKNOWN_QUANTITY"),
            ReportingColumnAsync::TotalViewPageVisitQuantity => write!(f, "TOTAL_VIEW_PAGE_VISIT_QUANTITY"),
            ReportingColumnAsync::TotalViewSignupQuantity => write!(f, "TOTAL_VIEW_SIGNUP_QUANTITY"),
            ReportingColumnAsync::TotalViewCheckoutQuantity => write!(f, "TOTAL_VIEW_CHECKOUT_QUANTITY"),
            ReportingColumnAsync::TotalViewCustomQuantity => write!(f, "TOTAL_VIEW_CUSTOM_QUANTITY"),
            ReportingColumnAsync::TotalViewAddToCartQuantity => write!(f, "TOTAL_VIEW_ADD_TO_CART_QUANTITY"),
            ReportingColumnAsync::TotalViewLeadQuantity => write!(f, "TOTAL_VIEW_LEAD_QUANTITY"),
            ReportingColumnAsync::TotalViewSearchQuantity => write!(f, "TOTAL_VIEW_SEARCH_QUANTITY"),
            ReportingColumnAsync::TotalViewWatchVideoQuantity => write!(f, "TOTAL_VIEW_WATCH_VIDEO_QUANTITY"),
            ReportingColumnAsync::TotalViewViewCategoryQuantity => write!(f, "TOTAL_VIEW_VIEW_CATEGORY_QUANTITY"),
            ReportingColumnAsync::TotalViewUnknownQuantity => write!(f, "TOTAL_VIEW_UNKNOWN_QUANTITY"),
            ReportingColumnAsync::TotalConversionsQuantity => write!(f, "TOTAL_CONVERSIONS_QUANTITY"),
            ReportingColumnAsync::TotalWebSessions => write!(f, "TOTAL_WEB_SESSIONS"),
            ReportingColumnAsync::WebSessions1 => write!(f, "WEB_SESSIONS_1"),
            ReportingColumnAsync::WebSessions2 => write!(f, "WEB_SESSIONS_2"),
            ReportingColumnAsync::OnsiteCheckouts1 => write!(f, "ONSITE_CHECKOUTS_1"),
            ReportingColumnAsync::PinPromotionName => write!(f, "PIN_PROMOTION_NAME"),
            ReportingColumnAsync::AdName => write!(f, "AD_NAME"),
            ReportingColumnAsync::CampaignLifetimeSpendCap => write!(f, "CAMPAIGN_LIFETIME_SPEND_CAP"),
            ReportingColumnAsync::CampaignDailySpendCap => write!(f, "CAMPAIGN_DAILY_SPEND_CAP"),
            ReportingColumnAsync::TotalPageVisitDesktopActionToDesktopConversion => write!(f, "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalPageVisitDesktopActionToMobileConversion => write!(f, "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalPageVisitDesktopActionToTabletConversion => write!(f, "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalPageVisitMobileActionToDesktopConversion => write!(f, "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalPageVisitMobileActionToMobileConversion => write!(f, "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalPageVisitMobileActionToTabletConversion => write!(f, "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalPageVisitTabletActionToDesktopConversion => write!(f, "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalPageVisitTabletActionToMobileConversion => write!(f, "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalPageVisitTabletActionToTabletConversion => write!(f, "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalSignupDesktopActionToDesktopConversion => write!(f, "TOTAL_SIGNUP_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalSignupDesktopActionToMobileConversion => write!(f, "TOTAL_SIGNUP_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalSignupDesktopActionToTabletConversion => write!(f, "TOTAL_SIGNUP_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalSignupMobileActionToDesktopConversion => write!(f, "TOTAL_SIGNUP_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalSignupMobileActionToMobileConversion => write!(f, "TOTAL_SIGNUP_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalSignupMobileActionToTabletConversion => write!(f, "TOTAL_SIGNUP_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalSignupTabletActionToDesktopConversion => write!(f, "TOTAL_SIGNUP_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalSignupTabletActionToMobileConversion => write!(f, "TOTAL_SIGNUP_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalSignupTabletActionToTabletConversion => write!(f, "TOTAL_SIGNUP_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalCheckoutDesktopActionToDesktopConversion => write!(f, "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalCheckoutDesktopActionToMobileConversion => write!(f, "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalCheckoutDesktopActionToTabletConversion => write!(f, "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalCheckoutMobileActionToDesktopConversion => write!(f, "TOTAL_CHECKOUT_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalCheckoutMobileActionToMobileConversion => write!(f, "TOTAL_CHECKOUT_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalCheckoutMobileActionToTabletConversion => write!(f, "TOTAL_CHECKOUT_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalCheckoutTabletActionToDesktopConversion => write!(f, "TOTAL_CHECKOUT_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalCheckoutTabletActionToMobileConversion => write!(f, "TOTAL_CHECKOUT_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalCheckoutTabletActionToTabletConversion => write!(f, "TOTAL_CHECKOUT_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalCustomDesktopActionToDesktopConversion => write!(f, "TOTAL_CUSTOM_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalCustomDesktopActionToMobileConversion => write!(f, "TOTAL_CUSTOM_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalCustomDesktopActionToTabletConversion => write!(f, "TOTAL_CUSTOM_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalCustomMobileActionToDesktopConversion => write!(f, "TOTAL_CUSTOM_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalCustomMobileActionToMobileConversion => write!(f, "TOTAL_CUSTOM_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalCustomMobileActionToTabletConversion => write!(f, "TOTAL_CUSTOM_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalCustomTabletActionToDesktopConversion => write!(f, "TOTAL_CUSTOM_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalCustomTabletActionToMobileConversion => write!(f, "TOTAL_CUSTOM_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalCustomTabletActionToTabletConversion => write!(f, "TOTAL_CUSTOM_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalAddToCartDesktopActionToDesktopConversion => write!(f, "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalAddToCartDesktopActionToMobileConversion => write!(f, "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalAddToCartDesktopActionToTabletConversion => write!(f, "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalAddToCartMobileActionToDesktopConversion => write!(f, "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalAddToCartMobileActionToMobileConversion => write!(f, "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalAddToCartMobileActionToTabletConversion => write!(f, "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalAddToCartTabletActionToDesktopConversion => write!(f, "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalAddToCartTabletActionToMobileConversion => write!(f, "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalAddToCartTabletActionToTabletConversion => write!(f, "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalLeadDesktopActionToDesktopConversion => write!(f, "TOTAL_LEAD_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalLeadDesktopActionToMobileConversion => write!(f, "TOTAL_LEAD_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalLeadDesktopActionToTabletConversion => write!(f, "TOTAL_LEAD_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalLeadMobileActionToDesktopConversion => write!(f, "TOTAL_LEAD_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalLeadMobileActionToMobileConversion => write!(f, "TOTAL_LEAD_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalLeadMobileActionToTabletConversion => write!(f, "TOTAL_LEAD_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalLeadTabletActionToDesktopConversion => write!(f, "TOTAL_LEAD_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalLeadTabletActionToMobileConversion => write!(f, "TOTAL_LEAD_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalLeadTabletActionToTabletConversion => write!(f, "TOTAL_LEAD_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalSearchDesktopActionToDesktopConversion => write!(f, "TOTAL_SEARCH_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalSearchDesktopActionToMobileConversion => write!(f, "TOTAL_SEARCH_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalSearchDesktopActionToTabletConversion => write!(f, "TOTAL_SEARCH_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalSearchMobileActionToDesktopConversion => write!(f, "TOTAL_SEARCH_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalSearchMobileActionToMobileConversion => write!(f, "TOTAL_SEARCH_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalSearchMobileActionToTabletConversion => write!(f, "TOTAL_SEARCH_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalSearchTabletActionToDesktopConversion => write!(f, "TOTAL_SEARCH_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalSearchTabletActionToMobileConversion => write!(f, "TOTAL_SEARCH_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalSearchTabletActionToTabletConversion => write!(f, "TOTAL_SEARCH_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalWatchVideoDesktopActionToDesktopConversion => write!(f, "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalWatchVideoDesktopActionToMobileConversion => write!(f, "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalWatchVideoDesktopActionToTabletConversion => write!(f, "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalWatchVideoMobileActionToDesktopConversion => write!(f, "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalWatchVideoMobileActionToMobileConversion => write!(f, "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalWatchVideoMobileActionToTabletConversion => write!(f, "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalWatchVideoTabletActionToDesktopConversion => write!(f, "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalWatchVideoTabletActionToMobileConversion => write!(f, "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalWatchVideoTabletActionToTabletConversion => write!(f, "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalViewCategoryDesktopActionToDesktopConversion => write!(f, "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalViewCategoryDesktopActionToMobileConversion => write!(f, "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalViewCategoryDesktopActionToTabletConversion => write!(f, "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalViewCategoryMobileActionToDesktopConversion => write!(f, "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalViewCategoryMobileActionToMobileConversion => write!(f, "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalViewCategoryMobileActionToTabletConversion => write!(f, "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalViewCategoryTabletActionToDesktopConversion => write!(f, "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalViewCategoryTabletActionToMobileConversion => write!(f, "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalViewCategoryTabletActionToTabletConversion => write!(f, "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalAppInstallDesktopActionToDesktopConversion => write!(f, "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalAppInstallDesktopActionToMobileConversion => write!(f, "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalAppInstallDesktopActionToTabletConversion => write!(f, "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalAppInstallMobileActionToDesktopConversion => write!(f, "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalAppInstallMobileActionToMobileConversion => write!(f, "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalAppInstallMobileActionToTabletConversion => write!(f, "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalAppInstallTabletActionToDesktopConversion => write!(f, "TOTAL_APP_INSTALL_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalAppInstallTabletActionToMobileConversion => write!(f, "TOTAL_APP_INSTALL_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalAppInstallTabletActionToTabletConversion => write!(f, "TOTAL_APP_INSTALL_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalUnknownDesktopActionToDesktopConversion => write!(f, "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalUnknownDesktopActionToMobileConversion => write!(f, "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalUnknownDesktopActionToTabletConversion => write!(f, "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalUnknownMobileActionToDesktopConversion => write!(f, "TOTAL_UNKNOWN_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalUnknownMobileActionToMobileConversion => write!(f, "TOTAL_UNKNOWN_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalUnknownMobileActionToTabletConversion => write!(f, "TOTAL_UNKNOWN_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalUnknownTabletActionToDesktopConversion => write!(f, "TOTAL_UNKNOWN_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TotalUnknownTabletActionToMobileConversion => write!(f, "TOTAL_UNKNOWN_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TotalUnknownTabletActionToTabletConversion => write!(f, "TOTAL_UNKNOWN_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TotalPageVisit => write!(f, "TOTAL_PAGE_VISIT"),
            ReportingColumnAsync::TotalSignup => write!(f, "TOTAL_SIGNUP"),
            ReportingColumnAsync::TotalCheckout => write!(f, "TOTAL_CHECKOUT"),
            ReportingColumnAsync::TotalCustom => write!(f, "TOTAL_CUSTOM"),
            ReportingColumnAsync::TotalLead => write!(f, "TOTAL_LEAD"),
            ReportingColumnAsync::TotalAppInstall => write!(f, "TOTAL_APP_INSTALL"),
            ReportingColumnAsync::TotalSignupValueInMicroDollar => write!(f, "TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalCheckoutValueInMicroDollar => write!(f, "TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalCustomValueInMicroDollar => write!(f, "TOTAL_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalAppInstallValueInMicroDollar => write!(f, "TOTAL_APP_INSTALL_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalCheckoutQuantity => write!(f, "TOTAL_CHECKOUT_QUANTITY"),
            ReportingColumnAsync::PageVisitCostPerAction => write!(f, "PAGE_VISIT_COST_PER_ACTION"),
            ReportingColumnAsync::AppInstallCostPerAction => write!(f, "APP_INSTALL_COST_PER_ACTION"),
            ReportingColumnAsync::PageVisitRoas => write!(f, "PAGE_VISIT_ROAS"),
            ReportingColumnAsync::CheckoutRoas => write!(f, "CHECKOUT_ROAS"),
            ReportingColumnAsync::CustomRoas => write!(f, "CUSTOM_ROAS"),
            ReportingColumnAsync::Video3SecViews1 => write!(f, "VIDEO_3SEC_VIEWS_1"),
            ReportingColumnAsync::VideoP100Complete1 => write!(f, "VIDEO_P100_COMPLETE_1"),
            ReportingColumnAsync::VideoP0Combined1 => write!(f, "VIDEO_P0_COMBINED_1"),
            ReportingColumnAsync::VideoP25Combined1 => write!(f, "VIDEO_P25_COMBINED_1"),
            ReportingColumnAsync::VideoP50Combined1 => write!(f, "VIDEO_P50_COMBINED_1"),
            ReportingColumnAsync::VideoP75Combined1 => write!(f, "VIDEO_P75_COMBINED_1"),
            ReportingColumnAsync::VideoP95Combined1 => write!(f, "VIDEO_P95_COMBINED_1"),
            ReportingColumnAsync::VideoMrcViews1 => write!(f, "VIDEO_MRC_VIEWS_1"),
            ReportingColumnAsync::Video3SecViews2 => write!(f, "VIDEO_3SEC_VIEWS_2"),
            ReportingColumnAsync::VideoP100Complete2 => write!(f, "VIDEO_P100_COMPLETE_2"),
            ReportingColumnAsync::VideoP0Combined2 => write!(f, "VIDEO_P0_COMBINED_2"),
            ReportingColumnAsync::VideoP25Combined2 => write!(f, "VIDEO_P25_COMBINED_2"),
            ReportingColumnAsync::VideoP50Combined2 => write!(f, "VIDEO_P50_COMBINED_2"),
            ReportingColumnAsync::VideoP75Combined2 => write!(f, "VIDEO_P75_COMBINED_2"),
            ReportingColumnAsync::VideoP95Combined2 => write!(f, "VIDEO_P95_COMBINED_2"),
            ReportingColumnAsync::VideoMrcViews2 => write!(f, "VIDEO_MRC_VIEWS_2"),
            ReportingColumnAsync::VideoLength => write!(f, "VIDEO_LENGTH"),
            ReportingColumnAsync::CpvInMicroDollar => write!(f, "CPV_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::EcpvInDollar => write!(f, "ECPV_IN_DOLLAR"),
            ReportingColumnAsync::CpcvInMicroDollar => write!(f, "CPCV_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::EcpcvInDollar => write!(f, "ECPCV_IN_DOLLAR"),
            ReportingColumnAsync::CpcvP95InMicroDollar => write!(f, "CPCV_P95_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::EcpcvP95InDollar => write!(f, "ECPCV_P95_IN_DOLLAR"),
            ReportingColumnAsync::TotalVideo3SecViews => write!(f, "TOTAL_VIDEO_3SEC_VIEWS"),
            ReportingColumnAsync::TotalVideoP100Complete => write!(f, "TOTAL_VIDEO_P100_COMPLETE"),
            ReportingColumnAsync::TotalVideoP0Combined => write!(f, "TOTAL_VIDEO_P0_COMBINED"),
            ReportingColumnAsync::TotalVideoP25Combined => write!(f, "TOTAL_VIDEO_P25_COMBINED"),
            ReportingColumnAsync::TotalVideoP50Combined => write!(f, "TOTAL_VIDEO_P50_COMBINED"),
            ReportingColumnAsync::TotalVideoP75Combined => write!(f, "TOTAL_VIDEO_P75_COMBINED"),
            ReportingColumnAsync::TotalVideoP95Combined => write!(f, "TOTAL_VIDEO_P95_COMBINED"),
            ReportingColumnAsync::TotalVideoMrcViews => write!(f, "TOTAL_VIDEO_MRC_VIEWS"),
            ReportingColumnAsync::VideoAvgWatchtimeInSecond1 => write!(f, "VIDEO_AVG_WATCHTIME_IN_SECOND_1"),
            ReportingColumnAsync::VideoAvgWatchtimeInSecond2 => write!(f, "VIDEO_AVG_WATCHTIME_IN_SECOND_2"),
            ReportingColumnAsync::TotalVideoAvgWatchtimeInSecond => write!(f, "TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND"),
            ReportingColumnAsync::TotalRepinRate => write!(f, "TOTAL_REPIN_RATE"),
            ReportingColumnAsync::WebCheckoutCostPerAction => write!(f, "WEB_CHECKOUT_COST_PER_ACTION"),
            ReportingColumnAsync::WebCheckoutRoas => write!(f, "WEB_CHECKOUT_ROAS"),
            ReportingColumnAsync::TotalWebCheckout => write!(f, "TOTAL_WEB_CHECKOUT"),
            ReportingColumnAsync::TotalWebCheckoutValueInMicroDollar => write!(f, "TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebClickCheckout => write!(f, "TOTAL_WEB_CLICK_CHECKOUT"),
            ReportingColumnAsync::TotalWebClickCheckoutValueInMicroDollar => write!(f, "TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebEngagementCheckout => write!(f, "TOTAL_WEB_ENGAGEMENT_CHECKOUT"),
            ReportingColumnAsync::TotalWebEngagementCheckoutValueInMicroDollar => write!(f, "TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebViewCheckout => write!(f, "TOTAL_WEB_VIEW_CHECKOUT"),
            ReportingColumnAsync::TotalWebViewCheckoutValueInMicroDollar => write!(f, "TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::InappCheckoutCostPerAction => write!(f, "INAPP_CHECKOUT_COST_PER_ACTION"),
            ReportingColumnAsync::InappCheckoutRoas => write!(f, "INAPP_CHECKOUT_ROAS"),
            ReportingColumnAsync::TotalInappCheckout => write!(f, "TOTAL_INAPP_CHECKOUT"),
            ReportingColumnAsync::TotalInappCheckoutValueInMicroDollar => write!(f, "TOTAL_INAPP_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappClickCheckout => write!(f, "TOTAL_INAPP_CLICK_CHECKOUT"),
            ReportingColumnAsync::TotalInappClickCheckoutValueInMicroDollar => write!(f, "TOTAL_INAPP_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappEngagementCheckout => write!(f, "TOTAL_INAPP_ENGAGEMENT_CHECKOUT"),
            ReportingColumnAsync::TotalInappEngagementCheckoutValueInMicroDollar => write!(f, "TOTAL_INAPP_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappViewCheckout => write!(f, "TOTAL_INAPP_VIEW_CHECKOUT"),
            ReportingColumnAsync::TotalInappViewCheckoutValueInMicroDollar => write!(f, "TOTAL_INAPP_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::OfflineCheckoutCostPerAction => write!(f, "OFFLINE_CHECKOUT_COST_PER_ACTION"),
            ReportingColumnAsync::OfflineCheckoutRoas => write!(f, "OFFLINE_CHECKOUT_ROAS"),
            ReportingColumnAsync::TotalOfflineCheckout => write!(f, "TOTAL_OFFLINE_CHECKOUT"),
            ReportingColumnAsync::TotalOfflineCheckoutValueInMicroDollar => write!(f, "TOTAL_OFFLINE_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalOfflineClickCheckout => write!(f, "TOTAL_OFFLINE_CLICK_CHECKOUT"),
            ReportingColumnAsync::TotalOfflineClickCheckoutValueInMicroDollar => write!(f, "TOTAL_OFFLINE_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalOfflineEngagementCheckout => write!(f, "TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT"),
            ReportingColumnAsync::TotalOfflineEngagementCheckoutValueInMicroDollar => write!(f, "TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalOfflineViewCheckout => write!(f, "TOTAL_OFFLINE_VIEW_CHECKOUT"),
            ReportingColumnAsync::TotalOfflineViewCheckoutValueInMicroDollar => write!(f, "TOTAL_OFFLINE_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::PinterestCheckoutCostPerAction => write!(f, "PINTEREST_CHECKOUT_COST_PER_ACTION"),
            ReportingColumnAsync::PinterestCheckoutRoas => write!(f, "PINTEREST_CHECKOUT_ROAS"),
            ReportingColumnAsync::TotalPinterestCheckout => write!(f, "TOTAL_PINTEREST_CHECKOUT"),
            ReportingColumnAsync::TotalPinterestCheckoutValueInMicroDollar => write!(f, "TOTAL_PINTEREST_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WebAddToCartCostPerAction => write!(f, "WEB_ADD_TO_CART_COST_PER_ACTION"),
            ReportingColumnAsync::WebAddToCartRoas => write!(f, "WEB_ADD_TO_CART_ROAS"),
            ReportingColumnAsync::TotalWebAddToCart => write!(f, "TOTAL_WEB_ADD_TO_CART"),
            ReportingColumnAsync::TotalWebAddToCartValueInMicroDollar => write!(f, "TOTAL_WEB_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebClickAddToCart => write!(f, "TOTAL_WEB_CLICK_ADD_TO_CART"),
            ReportingColumnAsync::TotalWebClickAddToCartValueInMicroDollar => write!(f, "TOTAL_WEB_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebEngagementAddToCart => write!(f, "TOTAL_WEB_ENGAGEMENT_ADD_TO_CART"),
            ReportingColumnAsync::TotalWebEngagementAddToCartValueInMicroDollar => write!(f, "TOTAL_WEB_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebViewAddToCart => write!(f, "TOTAL_WEB_VIEW_ADD_TO_CART"),
            ReportingColumnAsync::TotalWebViewAddToCartValueInMicroDollar => write!(f, "TOTAL_WEB_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::InappAddToCartCostPerAction => write!(f, "INAPP_ADD_TO_CART_COST_PER_ACTION"),
            ReportingColumnAsync::InappAddToCartRoas => write!(f, "INAPP_ADD_TO_CART_ROAS"),
            ReportingColumnAsync::TotalInappAddToCart => write!(f, "TOTAL_INAPP_ADD_TO_CART"),
            ReportingColumnAsync::TotalInappAddToCartValueInMicroDollar => write!(f, "TOTAL_INAPP_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappClickAddToCart => write!(f, "TOTAL_INAPP_CLICK_ADD_TO_CART"),
            ReportingColumnAsync::TotalInappClickAddToCartValueInMicroDollar => write!(f, "TOTAL_INAPP_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappEngagementAddToCart => write!(f, "TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART"),
            ReportingColumnAsync::TotalInappEngagementAddToCartValueInMicroDollar => write!(f, "TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappViewAddToCart => write!(f, "TOTAL_INAPP_VIEW_ADD_TO_CART"),
            ReportingColumnAsync::TotalInappViewAddToCartValueInMicroDollar => write!(f, "TOTAL_INAPP_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WebPageVisitCostPerAction => write!(f, "WEB_PAGE_VISIT_COST_PER_ACTION"),
            ReportingColumnAsync::WebPageVisitRoas => write!(f, "WEB_PAGE_VISIT_ROAS"),
            ReportingColumnAsync::TotalWebPageVisit => write!(f, "TOTAL_WEB_PAGE_VISIT"),
            ReportingColumnAsync::TotalWebPageVisitValueInMicroDollar => write!(f, "TOTAL_WEB_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebClickPageVisit => write!(f, "TOTAL_WEB_CLICK_PAGE_VISIT"),
            ReportingColumnAsync::TotalWebClickPageVisitValueInMicroDollar => write!(f, "TOTAL_WEB_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebEngagementPageVisit => write!(f, "TOTAL_WEB_ENGAGEMENT_PAGE_VISIT"),
            ReportingColumnAsync::TotalWebEngagementPageVisitValueInMicroDollar => write!(f, "TOTAL_WEB_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebViewPageVisit => write!(f, "TOTAL_WEB_VIEW_PAGE_VISIT"),
            ReportingColumnAsync::TotalWebViewPageVisitValueInMicroDollar => write!(f, "TOTAL_WEB_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WebSignupCostPerAction => write!(f, "WEB_SIGNUP_COST_PER_ACTION"),
            ReportingColumnAsync::WebSignupRoas => write!(f, "WEB_SIGNUP_ROAS"),
            ReportingColumnAsync::TotalWebSignup => write!(f, "TOTAL_WEB_SIGNUP"),
            ReportingColumnAsync::TotalWebSignupValueInMicroDollar => write!(f, "TOTAL_WEB_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebClickSignup => write!(f, "TOTAL_WEB_CLICK_SIGNUP"),
            ReportingColumnAsync::TotalWebClickSignupValueInMicroDollar => write!(f, "TOTAL_WEB_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebEngagementSignup => write!(f, "TOTAL_WEB_ENGAGEMENT_SIGNUP"),
            ReportingColumnAsync::TotalWebEngagementSignupValueInMicroDollar => write!(f, "TOTAL_WEB_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebViewSignup => write!(f, "TOTAL_WEB_VIEW_SIGNUP"),
            ReportingColumnAsync::TotalWebViewSignupValueInMicroDollar => write!(f, "TOTAL_WEB_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::InappSignupCostPerAction => write!(f, "INAPP_SIGNUP_COST_PER_ACTION"),
            ReportingColumnAsync::InappSignupRoas => write!(f, "INAPP_SIGNUP_ROAS"),
            ReportingColumnAsync::TotalInappSignup => write!(f, "TOTAL_INAPP_SIGNUP"),
            ReportingColumnAsync::TotalInappSignupValueInMicroDollar => write!(f, "TOTAL_INAPP_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappClickSignup => write!(f, "TOTAL_INAPP_CLICK_SIGNUP"),
            ReportingColumnAsync::TotalInappClickSignupValueInMicroDollar => write!(f, "TOTAL_INAPP_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappEngagementSignup => write!(f, "TOTAL_INAPP_ENGAGEMENT_SIGNUP"),
            ReportingColumnAsync::TotalInappEngagementSignupValueInMicroDollar => write!(f, "TOTAL_INAPP_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappViewSignup => write!(f, "TOTAL_INAPP_VIEW_SIGNUP"),
            ReportingColumnAsync::TotalInappViewSignupValueInMicroDollar => write!(f, "TOTAL_INAPP_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::OfflineSignupCostPerAction => write!(f, "OFFLINE_SIGNUP_COST_PER_ACTION"),
            ReportingColumnAsync::OfflineSignupRoas => write!(f, "OFFLINE_SIGNUP_ROAS"),
            ReportingColumnAsync::TotalOfflineSignup => write!(f, "TOTAL_OFFLINE_SIGNUP"),
            ReportingColumnAsync::TotalOfflineSignupValueInMicroDollar => write!(f, "TOTAL_OFFLINE_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalOfflineClickSignup => write!(f, "TOTAL_OFFLINE_CLICK_SIGNUP"),
            ReportingColumnAsync::TotalOfflineClickSignupValueInMicroDollar => write!(f, "TOTAL_OFFLINE_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalOfflineEngagementSignup => write!(f, "TOTAL_OFFLINE_ENGAGEMENT_SIGNUP"),
            ReportingColumnAsync::TotalOfflineEngagementSignupValueInMicroDollar => write!(f, "TOTAL_OFFLINE_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalOfflineViewSignup => write!(f, "TOTAL_OFFLINE_VIEW_SIGNUP"),
            ReportingColumnAsync::TotalOfflineViewSignupValueInMicroDollar => write!(f, "TOTAL_OFFLINE_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WebWatchVideoCostPerAction => write!(f, "WEB_WATCH_VIDEO_COST_PER_ACTION"),
            ReportingColumnAsync::WebWatchVideoRoas => write!(f, "WEB_WATCH_VIDEO_ROAS"),
            ReportingColumnAsync::TotalWebWatchVideo => write!(f, "TOTAL_WEB_WATCH_VIDEO"),
            ReportingColumnAsync::TotalWebWatchVideoValueInMicroDollar => write!(f, "TOTAL_WEB_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebClickWatchVideo => write!(f, "TOTAL_WEB_CLICK_WATCH_VIDEO"),
            ReportingColumnAsync::TotalWebClickWatchVideoValueInMicroDollar => write!(f, "TOTAL_WEB_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebEngagementWatchVideo => write!(f, "TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO"),
            ReportingColumnAsync::TotalWebEngagementWatchVideoValueInMicroDollar => write!(f, "TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebViewWatchVideo => write!(f, "TOTAL_WEB_VIEW_WATCH_VIDEO"),
            ReportingColumnAsync::TotalWebViewWatchVideoValueInMicroDollar => write!(f, "TOTAL_WEB_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WebLeadCostPerAction => write!(f, "WEB_LEAD_COST_PER_ACTION"),
            ReportingColumnAsync::WebLeadRoas => write!(f, "WEB_LEAD_ROAS"),
            ReportingColumnAsync::TotalWebLead => write!(f, "TOTAL_WEB_LEAD"),
            ReportingColumnAsync::TotalWebLeadValueInMicroDollar => write!(f, "TOTAL_WEB_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebClickLead => write!(f, "TOTAL_WEB_CLICK_LEAD"),
            ReportingColumnAsync::TotalWebClickLeadValueInMicroDollar => write!(f, "TOTAL_WEB_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebEngagementLead => write!(f, "TOTAL_WEB_ENGAGEMENT_LEAD"),
            ReportingColumnAsync::TotalWebEngagementLeadValueInMicroDollar => write!(f, "TOTAL_WEB_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebViewLead => write!(f, "TOTAL_WEB_VIEW_LEAD"),
            ReportingColumnAsync::TotalWebViewLeadValueInMicroDollar => write!(f, "TOTAL_WEB_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::OfflineLeadCostPerAction => write!(f, "OFFLINE_LEAD_COST_PER_ACTION"),
            ReportingColumnAsync::OfflineLeadRoas => write!(f, "OFFLINE_LEAD_ROAS"),
            ReportingColumnAsync::TotalOfflineLead => write!(f, "TOTAL_OFFLINE_LEAD"),
            ReportingColumnAsync::TotalOfflineLeadValueInMicroDollar => write!(f, "TOTAL_OFFLINE_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalOfflineClickLead => write!(f, "TOTAL_OFFLINE_CLICK_LEAD"),
            ReportingColumnAsync::TotalOfflineClickLeadValueInMicroDollar => write!(f, "TOTAL_OFFLINE_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalOfflineEngagementLead => write!(f, "TOTAL_OFFLINE_ENGAGEMENT_LEAD"),
            ReportingColumnAsync::TotalOfflineEngagementLeadValueInMicroDollar => write!(f, "TOTAL_OFFLINE_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalOfflineViewLead => write!(f, "TOTAL_OFFLINE_VIEW_LEAD"),
            ReportingColumnAsync::TotalOfflineViewLeadValueInMicroDollar => write!(f, "TOTAL_OFFLINE_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WebSearchCostPerAction => write!(f, "WEB_SEARCH_COST_PER_ACTION"),
            ReportingColumnAsync::WebSearchRoas => write!(f, "WEB_SEARCH_ROAS"),
            ReportingColumnAsync::TotalWebSearch => write!(f, "TOTAL_WEB_SEARCH"),
            ReportingColumnAsync::TotalWebSearchValueInMicroDollar => write!(f, "TOTAL_WEB_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebClickSearch => write!(f, "TOTAL_WEB_CLICK_SEARCH"),
            ReportingColumnAsync::TotalWebClickSearchValueInMicroDollar => write!(f, "TOTAL_WEB_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebEngagementSearch => write!(f, "TOTAL_WEB_ENGAGEMENT_SEARCH"),
            ReportingColumnAsync::TotalWebEngagementSearchValueInMicroDollar => write!(f, "TOTAL_WEB_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebViewSearch => write!(f, "TOTAL_WEB_VIEW_SEARCH"),
            ReportingColumnAsync::TotalWebViewSearchValueInMicroDollar => write!(f, "TOTAL_WEB_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::InappSearchCostPerAction => write!(f, "INAPP_SEARCH_COST_PER_ACTION"),
            ReportingColumnAsync::InappSearchRoas => write!(f, "INAPP_SEARCH_ROAS"),
            ReportingColumnAsync::TotalInappSearch => write!(f, "TOTAL_INAPP_SEARCH"),
            ReportingColumnAsync::TotalInappSearchValueInMicroDollar => write!(f, "TOTAL_INAPP_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappClickSearch => write!(f, "TOTAL_INAPP_CLICK_SEARCH"),
            ReportingColumnAsync::TotalInappClickSearchValueInMicroDollar => write!(f, "TOTAL_INAPP_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappEngagementSearch => write!(f, "TOTAL_INAPP_ENGAGEMENT_SEARCH"),
            ReportingColumnAsync::TotalInappEngagementSearchValueInMicroDollar => write!(f, "TOTAL_INAPP_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappViewSearch => write!(f, "TOTAL_INAPP_VIEW_SEARCH"),
            ReportingColumnAsync::TotalInappViewSearchValueInMicroDollar => write!(f, "TOTAL_INAPP_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WebViewCategoryCostPerAction => write!(f, "WEB_VIEW_CATEGORY_COST_PER_ACTION"),
            ReportingColumnAsync::WebViewCategoryRoas => write!(f, "WEB_VIEW_CATEGORY_ROAS"),
            ReportingColumnAsync::TotalWebViewCategory => write!(f, "TOTAL_WEB_VIEW_CATEGORY"),
            ReportingColumnAsync::TotalWebViewCategoryValueInMicroDollar => write!(f, "TOTAL_WEB_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebClickViewCategory => write!(f, "TOTAL_WEB_CLICK_VIEW_CATEGORY"),
            ReportingColumnAsync::TotalWebClickViewCategoryValueInMicroDollar => write!(f, "TOTAL_WEB_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebEngagementViewCategory => write!(f, "TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY"),
            ReportingColumnAsync::TotalWebEngagementViewCategoryValueInMicroDollar => write!(f, "TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebViewViewCategory => write!(f, "TOTAL_WEB_VIEW_VIEW_CATEGORY"),
            ReportingColumnAsync::TotalWebViewViewCategoryValueInMicroDollar => write!(f, "TOTAL_WEB_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WebCustomCostPerAction => write!(f, "WEB_CUSTOM_COST_PER_ACTION"),
            ReportingColumnAsync::WebCustomRoas => write!(f, "WEB_CUSTOM_ROAS"),
            ReportingColumnAsync::TotalWebCustom => write!(f, "TOTAL_WEB_CUSTOM"),
            ReportingColumnAsync::TotalWebCustomValueInMicroDollar => write!(f, "TOTAL_WEB_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebClickCustom => write!(f, "TOTAL_WEB_CLICK_CUSTOM"),
            ReportingColumnAsync::TotalWebClickCustomValueInMicroDollar => write!(f, "TOTAL_WEB_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebEngagementCustom => write!(f, "TOTAL_WEB_ENGAGEMENT_CUSTOM"),
            ReportingColumnAsync::TotalWebEngagementCustomValueInMicroDollar => write!(f, "TOTAL_WEB_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebViewCustom => write!(f, "TOTAL_WEB_VIEW_CUSTOM"),
            ReportingColumnAsync::TotalWebViewCustomValueInMicroDollar => write!(f, "TOTAL_WEB_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::OfflineCustomCostPerAction => write!(f, "OFFLINE_CUSTOM_COST_PER_ACTION"),
            ReportingColumnAsync::OfflineCustomRoas => write!(f, "OFFLINE_CUSTOM_ROAS"),
            ReportingColumnAsync::TotalOfflineCustom => write!(f, "TOTAL_OFFLINE_CUSTOM"),
            ReportingColumnAsync::TotalOfflineCustomValueInMicroDollar => write!(f, "TOTAL_OFFLINE_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalOfflineClickCustom => write!(f, "TOTAL_OFFLINE_CLICK_CUSTOM"),
            ReportingColumnAsync::TotalOfflineClickCustomValueInMicroDollar => write!(f, "TOTAL_OFFLINE_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalOfflineEngagementCustom => write!(f, "TOTAL_OFFLINE_ENGAGEMENT_CUSTOM"),
            ReportingColumnAsync::TotalOfflineEngagementCustomValueInMicroDollar => write!(f, "TOTAL_OFFLINE_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalOfflineViewCustom => write!(f, "TOTAL_OFFLINE_VIEW_CUSTOM"),
            ReportingColumnAsync::TotalOfflineViewCustomValueInMicroDollar => write!(f, "TOTAL_OFFLINE_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WebUnknownCostPerAction => write!(f, "WEB_UNKNOWN_COST_PER_ACTION"),
            ReportingColumnAsync::WebUnknownRoas => write!(f, "WEB_UNKNOWN_ROAS"),
            ReportingColumnAsync::TotalWebUnknown => write!(f, "TOTAL_WEB_UNKNOWN"),
            ReportingColumnAsync::TotalWebUnknownValueInMicroDollar => write!(f, "TOTAL_WEB_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebClickUnknown => write!(f, "TOTAL_WEB_CLICK_UNKNOWN"),
            ReportingColumnAsync::TotalWebClickUnknownValueInMicroDollar => write!(f, "TOTAL_WEB_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebEngagementUnknown => write!(f, "TOTAL_WEB_ENGAGEMENT_UNKNOWN"),
            ReportingColumnAsync::TotalWebEngagementUnknownValueInMicroDollar => write!(f, "TOTAL_WEB_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalWebViewUnknown => write!(f, "TOTAL_WEB_VIEW_UNKNOWN"),
            ReportingColumnAsync::TotalWebViewUnknownValueInMicroDollar => write!(f, "TOTAL_WEB_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::InappUnknownCostPerAction => write!(f, "INAPP_UNKNOWN_COST_PER_ACTION"),
            ReportingColumnAsync::InappUnknownRoas => write!(f, "INAPP_UNKNOWN_ROAS"),
            ReportingColumnAsync::TotalInappUnknown => write!(f, "TOTAL_INAPP_UNKNOWN"),
            ReportingColumnAsync::TotalInappUnknownValueInMicroDollar => write!(f, "TOTAL_INAPP_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappClickUnknown => write!(f, "TOTAL_INAPP_CLICK_UNKNOWN"),
            ReportingColumnAsync::TotalInappClickUnknownValueInMicroDollar => write!(f, "TOTAL_INAPP_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappEngagementUnknown => write!(f, "TOTAL_INAPP_ENGAGEMENT_UNKNOWN"),
            ReportingColumnAsync::TotalInappEngagementUnknownValueInMicroDollar => write!(f, "TOTAL_INAPP_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappViewUnknown => write!(f, "TOTAL_INAPP_VIEW_UNKNOWN"),
            ReportingColumnAsync::TotalInappViewUnknownValueInMicroDollar => write!(f, "TOTAL_INAPP_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::OfflineUnknownCostPerAction => write!(f, "OFFLINE_UNKNOWN_COST_PER_ACTION"),
            ReportingColumnAsync::OfflineUnknownRoas => write!(f, "OFFLINE_UNKNOWN_ROAS"),
            ReportingColumnAsync::TotalOfflineUnknown => write!(f, "TOTAL_OFFLINE_UNKNOWN"),
            ReportingColumnAsync::TotalOfflineUnknownValueInMicroDollar => write!(f, "TOTAL_OFFLINE_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalOfflineClickUnknown => write!(f, "TOTAL_OFFLINE_CLICK_UNKNOWN"),
            ReportingColumnAsync::TotalOfflineClickUnknownValueInMicroDollar => write!(f, "TOTAL_OFFLINE_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalOfflineEngagementUnknown => write!(f, "TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN"),
            ReportingColumnAsync::TotalOfflineEngagementUnknownValueInMicroDollar => write!(f, "TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalOfflineViewUnknown => write!(f, "TOTAL_OFFLINE_VIEW_UNKNOWN"),
            ReportingColumnAsync::TotalOfflineViewUnknownValueInMicroDollar => write!(f, "TOTAL_OFFLINE_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::InappAppInstallCostPerAction => write!(f, "INAPP_APP_INSTALL_COST_PER_ACTION"),
            ReportingColumnAsync::InappAppInstallRoas => write!(f, "INAPP_APP_INSTALL_ROAS"),
            ReportingColumnAsync::TotalInappAppInstall => write!(f, "TOTAL_INAPP_APP_INSTALL"),
            ReportingColumnAsync::TotalInappAppInstallValueInMicroDollar => write!(f, "TOTAL_INAPP_APP_INSTALL_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappClickAppInstall => write!(f, "TOTAL_INAPP_CLICK_APP_INSTALL"),
            ReportingColumnAsync::TotalInappClickAppInstallValueInMicroDollar => write!(f, "TOTAL_INAPP_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappEngagementAppInstall => write!(f, "TOTAL_INAPP_ENGAGEMENT_APP_INSTALL"),
            ReportingColumnAsync::TotalInappEngagementAppInstallValueInMicroDollar => write!(f, "TOTAL_INAPP_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TotalInappViewAppInstall => write!(f, "TOTAL_INAPP_VIEW_APP_INSTALL"),
            ReportingColumnAsync::TotalInappViewAppInstallValueInMicroDollar => write!(f, "TOTAL_INAPP_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::IdeaPinProductTagVisit1 => write!(f, "IDEA_PIN_PRODUCT_TAG_VISIT_1"),
            ReportingColumnAsync::IdeaPinProductTagVisit2 => write!(f, "IDEA_PIN_PRODUCT_TAG_VISIT_2"),
            ReportingColumnAsync::TotalIdeaPinProductTagVisit => write!(f, "TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT"),
            ReportingColumnAsync::Leads => write!(f, "LEADS"),
            ReportingColumnAsync::CostPerLead => write!(f, "COST_PER_LEAD"),
            ReportingColumnAsync::QuizCompleted => write!(f, "QUIZ_COMPLETED"),
            ReportingColumnAsync::QuizCompletionRate => write!(f, "QUIZ_COMPLETION_RATE"),
            ReportingColumnAsync::ShowcasePinClickthrough => write!(f, "SHOWCASE_PIN_CLICKTHROUGH"),
            ReportingColumnAsync::ShowcaseSubpageClickthrough => write!(f, "SHOWCASE_SUBPAGE_CLICKTHROUGH"),
            ReportingColumnAsync::ShowcaseSubpinClickthrough => write!(f, "SHOWCASE_SUBPIN_CLICKTHROUGH"),
            ReportingColumnAsync::ShowcaseSubpageImpression => write!(f, "SHOWCASE_SUBPAGE_IMPRESSION"),
            ReportingColumnAsync::ShowcaseSubpinImpression => write!(f, "SHOWCASE_SUBPIN_IMPRESSION"),
            ReportingColumnAsync::ShowcaseSubpageSwipeLeft => write!(f, "SHOWCASE_SUBPAGE_SWIPE_LEFT"),
            ReportingColumnAsync::ShowcaseSubpageSwipeRight => write!(f, "SHOWCASE_SUBPAGE_SWIPE_RIGHT"),
            ReportingColumnAsync::ShowcaseSubpinSwipeLeft => write!(f, "SHOWCASE_SUBPIN_SWIPE_LEFT"),
            ReportingColumnAsync::ShowcaseSubpinSwipeRight => write!(f, "SHOWCASE_SUBPIN_SWIPE_RIGHT"),
            ReportingColumnAsync::ShowcaseSubpageRepin => write!(f, "SHOWCASE_SUBPAGE_REPIN"),
            ReportingColumnAsync::ShowcaseSubpinRepin => write!(f, "SHOWCASE_SUBPIN_REPIN"),
            ReportingColumnAsync::ShowcaseSubpageCloseup => write!(f, "SHOWCASE_SUBPAGE_CLOSEUP"),
            ReportingColumnAsync::ShowcaseCardThumbnailSwipeForward => write!(f, "SHOWCASE_CARD_THUMBNAIL_SWIPE_FORWARD"),
            ReportingColumnAsync::ShowcaseCardThumbnailSwipeBackward => write!(f, "SHOWCASE_CARD_THUMBNAIL_SWIPE_BACKWARD"),
            ReportingColumnAsync::ShowcaseAverageSubpageCloseupPerSession => write!(f, "SHOWCASE_AVERAGE_SUBPAGE_CLOSEUP_PER_SESSION"),
            ReportingColumnAsync::TotalCheckoutConversionRate => write!(f, "TOTAL_CHECKOUT_CONVERSION_RATE"),
            ReportingColumnAsync::TotalViewCategoryConversionRate => write!(f, "TOTAL_VIEW_CATEGORY_CONVERSION_RATE"),
            ReportingColumnAsync::TotalAddToCartConversionRate => write!(f, "TOTAL_ADD_TO_CART_CONVERSION_RATE"),
            ReportingColumnAsync::TotalSignupConversionRate => write!(f, "TOTAL_SIGNUP_CONVERSION_RATE"),
            ReportingColumnAsync::TotalPageVisitConversionRate => write!(f, "TOTAL_PAGE_VISIT_CONVERSION_RATE"),
            ReportingColumnAsync::TotalLeadConversionRate => write!(f, "TOTAL_LEAD_CONVERSION_RATE"),
            ReportingColumnAsync::TotalSearchConversionRate => write!(f, "TOTAL_SEARCH_CONVERSION_RATE"),
            ReportingColumnAsync::TotalWatchVideoConversionRate => write!(f, "TOTAL_WATCH_VIDEO_CONVERSION_RATE"),
            ReportingColumnAsync::TotalUnknownConversionRate => write!(f, "TOTAL_UNKNOWN_CONVERSION_RATE"),
            ReportingColumnAsync::TotalCustomConversionRate => write!(f, "TOTAL_CUSTOM_CONVERSION_RATE"),
            ReportingColumnAsync::StandardAdFeedItemId => write!(f, "STANDARD_AD_FEED_ITEM_ID"),
        }
    }
}

impl std::str::FromStr for ReportingColumnAsync {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SPEND_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::SpendInMicroDollar),
            "PAID_IMPRESSION" => std::result::Result::Ok(ReportingColumnAsync::PaidImpression),
            "SPEND_IN_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::SpendInDollar),
            "CPC_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::CpcInMicroDollar),
            "ECPC_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::EcpcInMicroDollar),
            "ECPC_IN_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::EcpcInDollar),
            "CTR" => std::result::Result::Ok(ReportingColumnAsync::Ctr),
            "ECTR" => std::result::Result::Ok(ReportingColumnAsync::Ectr),
            "OUTBOUND_CTR" => std::result::Result::Ok(ReportingColumnAsync::OutboundCtr),
            "COST_PER_OUTBOUND_CLICK" => std::result::Result::Ok(ReportingColumnAsync::CostPerOutboundClick),
            "CAMPAIGN_NAME" => std::result::Result::Ok(ReportingColumnAsync::CampaignName),
            "CAMPAIGN_STATUS" => std::result::Result::Ok(ReportingColumnAsync::CampaignStatus),
            "PIN_PROMOTION_STATUS" => std::result::Result::Ok(ReportingColumnAsync::PinPromotionStatus),
            "AD_STATUS" => std::result::Result::Ok(ReportingColumnAsync::AdStatus),
            "PIN_ID" => std::result::Result::Ok(ReportingColumnAsync::PinId),
            "TOTAL_ENGAGEMENT" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagement),
            "ENGAGEMENT_1" => std::result::Result::Ok(ReportingColumnAsync::Engagement1),
            "ENGAGEMENT_2" => std::result::Result::Ok(ReportingColumnAsync::Engagement2),
            "ECPE_IN_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::EcpeInDollar),
            "ENGAGEMENT_RATE" => std::result::Result::Ok(ReportingColumnAsync::EngagementRate),
            "EENGAGEMENT_RATE" => std::result::Result::Ok(ReportingColumnAsync::EengagementRate),
            "ECPM_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::EcpmInMicroDollar),
            "REPIN_RATE" => std::result::Result::Ok(ReportingColumnAsync::RepinRate),
            "CTR_2" => std::result::Result::Ok(ReportingColumnAsync::Ctr2),
            "CAMPAIGN_ID" => std::result::Result::Ok(ReportingColumnAsync::CampaignId),
            "ADVERTISER_ID" => std::result::Result::Ok(ReportingColumnAsync::AdvertiserId),
            "AD_ACCOUNT_ID" => std::result::Result::Ok(ReportingColumnAsync::AdAccountId),
            "PIN_PROMOTION_ID" => std::result::Result::Ok(ReportingColumnAsync::PinPromotionId),
            "AD_ID" => std::result::Result::Ok(ReportingColumnAsync::AdId),
            "AD_GROUP_ID" => std::result::Result::Ok(ReportingColumnAsync::AdGroupId),
            "CAMPAIGN_ENTITY_STATUS" => std::result::Result::Ok(ReportingColumnAsync::CampaignEntityStatus),
            "CAMPAIGN_MANAGED_STATUS" => std::result::Result::Ok(ReportingColumnAsync::CampaignManagedStatus),
            "CAMPAIGN_OBJECTIVE_TYPE" => std::result::Result::Ok(ReportingColumnAsync::CampaignObjectiveType),
            "CPM_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::CpmInMicroDollar),
            "CPM_IN_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::CpmInDollar),
            "AD_GROUP_NAME" => std::result::Result::Ok(ReportingColumnAsync::AdGroupName),
            "AD_GROUP_STATUS" => std::result::Result::Ok(ReportingColumnAsync::AdGroupStatus),
            "AD_GROUP_ENTITY_STATUS" => std::result::Result::Ok(ReportingColumnAsync::AdGroupEntityStatus),
            "PRODUCT_GROUP_ID" => std::result::Result::Ok(ReportingColumnAsync::ProductGroupId),
            "PRODUCT_GROUP_STATUS" => std::result::Result::Ok(ReportingColumnAsync::ProductGroupStatus),
            "ORDER_LINE_ID" => std::result::Result::Ok(ReportingColumnAsync::OrderLineId),
            "ORDER_LINE_NAME" => std::result::Result::Ok(ReportingColumnAsync::OrderLineName),
            "CLICKTHROUGH_1" => std::result::Result::Ok(ReportingColumnAsync::Clickthrough1),
            "REPIN_1" => std::result::Result::Ok(ReportingColumnAsync::Repin1),
            "IMPRESSION_1" => std::result::Result::Ok(ReportingColumnAsync::Impression1),
            "IMPRESSION_1_GROSS" => std::result::Result::Ok(ReportingColumnAsync::Impression1Gross),
            "CLICKTHROUGH_1_GROSS" => std::result::Result::Ok(ReportingColumnAsync::Clickthrough1Gross),
            "OUTBOUND_CLICK_1" => std::result::Result::Ok(ReportingColumnAsync::OutboundClick1),
            "CLICKTHROUGH_2" => std::result::Result::Ok(ReportingColumnAsync::Clickthrough2),
            "REPIN_2" => std::result::Result::Ok(ReportingColumnAsync::Repin2),
            "IMPRESSION_2" => std::result::Result::Ok(ReportingColumnAsync::Impression2),
            "OUTBOUND_CLICK_2" => std::result::Result::Ok(ReportingColumnAsync::OutboundClick2),
            "TOTAL_CLICKTHROUGH" => std::result::Result::Ok(ReportingColumnAsync::TotalClickthrough),
            "TOTAL_IMPRESSION" => std::result::Result::Ok(ReportingColumnAsync::TotalImpression),
            "TOTAL_IMPRESSION_USER" => std::result::Result::Ok(ReportingColumnAsync::TotalImpressionUser),
            "TOTAL_IMPRESSION_FREQUENCY" => std::result::Result::Ok(ReportingColumnAsync::TotalImpressionFrequency),
            "COST_PER_OUTBOUND_CLICK_IN_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::CostPerOutboundClickInDollar),
            "TOTAL_ENGAGEMENT_PAGE_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementPageVisit),
            "TOTAL_ENGAGEMENT_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementSignup),
            "TOTAL_ENGAGEMENT_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementCheckout),
            "TOTAL_ENGAGEMENT_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementCustom),
            "TOTAL_ENGAGEMENT_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementAddToCart),
            "TOTAL_ENGAGEMENT_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementLead),
            "TOTAL_ENGAGEMENT_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementSearch),
            "TOTAL_ENGAGEMENT_WATCH_VIDEO" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementWatchVideo),
            "TOTAL_ENGAGEMENT_VIEW_CATEGORY" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementViewCategory),
            "TOTAL_ENGAGEMENT_APP_INSTALL" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementAppInstall),
            "TOTAL_ENGAGEMENT_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementUnknown),
            "TOTAL_CLICK_PAGE_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TotalClickPageVisit),
            "TOTAL_CLICK_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TotalClickSignup),
            "TOTAL_CLICK_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TotalClickCheckout),
            "TOTAL_CLICK_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TotalClickCustom),
            "TOTAL_CLICK_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TotalClickAddToCart),
            "TOTAL_CLICK_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TotalClickLead),
            "TOTAL_CLICK_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TotalClickSearch),
            "TOTAL_CLICK_WATCH_VIDEO" => std::result::Result::Ok(ReportingColumnAsync::TotalClickWatchVideo),
            "TOTAL_CLICK_VIEW_CATEGORY" => std::result::Result::Ok(ReportingColumnAsync::TotalClickViewCategory),
            "TOTAL_CLICK_APP_INSTALL" => std::result::Result::Ok(ReportingColumnAsync::TotalClickAppInstall),
            "TOTAL_CLICK_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TotalClickUnknown),
            "TOTAL_VIEW_PAGE_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TotalViewPageVisit),
            "TOTAL_VIEW_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TotalViewSignup),
            "TOTAL_VIEW_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TotalViewCheckout),
            "TOTAL_VIEW_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TotalViewCustom),
            "TOTAL_VIEW_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TotalViewAddToCart),
            "TOTAL_VIEW_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TotalViewLead),
            "TOTAL_VIEW_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TotalViewSearch),
            "TOTAL_VIEW_WATCH_VIDEO" => std::result::Result::Ok(ReportingColumnAsync::TotalViewWatchVideo),
            "TOTAL_VIEW_VIEW_CATEGORY" => std::result::Result::Ok(ReportingColumnAsync::TotalViewViewCategory),
            "TOTAL_VIEW_APP_INSTALL" => std::result::Result::Ok(ReportingColumnAsync::TotalViewAppInstall),
            "TOTAL_VIEW_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TotalViewUnknown),
            "TOTAL_CONVERSIONS" => std::result::Result::Ok(ReportingColumnAsync::TotalConversions),
            "TOTAL_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementPageVisitValueInMicroDollar),
            "TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementSignupValueInMicroDollar),
            "TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementCheckoutValueInMicroDollar),
            "TOTAL_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementCustomValueInMicroDollar),
            "TOTAL_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementAddToCartValueInMicroDollar),
            "TOTAL_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementLeadValueInMicroDollar),
            "TOTAL_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementSearchValueInMicroDollar),
            "TOTAL_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementWatchVideoValueInMicroDollar),
            "TOTAL_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementViewCategoryValueInMicroDollar),
            "TOTAL_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementAppInstallValueInMicroDollar),
            "TOTAL_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementUnknownValueInMicroDollar),
            "TOTAL_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalClickPageVisitValueInMicroDollar),
            "TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalClickSignupValueInMicroDollar),
            "TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalClickCheckoutValueInMicroDollar),
            "TOTAL_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalClickCustomValueInMicroDollar),
            "TOTAL_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalClickAddToCartValueInMicroDollar),
            "TOTAL_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalClickLeadValueInMicroDollar),
            "TOTAL_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalClickSearchValueInMicroDollar),
            "TOTAL_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalClickWatchVideoValueInMicroDollar),
            "TOTAL_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalClickViewCategoryValueInMicroDollar),
            "TOTAL_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalClickAppInstallValueInMicroDollar),
            "TOTAL_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalClickUnknownValueInMicroDollar),
            "TOTAL_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalViewPageVisitValueInMicroDollar),
            "TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalViewSignupValueInMicroDollar),
            "TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalViewCheckoutValueInMicroDollar),
            "TOTAL_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalViewCustomValueInMicroDollar),
            "TOTAL_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalViewAddToCartValueInMicroDollar),
            "TOTAL_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalViewLeadValueInMicroDollar),
            "TOTAL_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalViewSearchValueInMicroDollar),
            "TOTAL_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalViewWatchVideoValueInMicroDollar),
            "TOTAL_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalViewViewCategoryValueInMicroDollar),
            "TOTAL_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalViewAppInstallValueInMicroDollar),
            "TOTAL_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalViewUnknownValueInMicroDollar),
            "TOTAL_CONVERSIONS_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalConversionsValueInMicroDollar),
            "TOTAL_ENGAGEMENT_PAGE_VISIT_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementPageVisitQuantity),
            "TOTAL_ENGAGEMENT_SIGNUP_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementSignupQuantity),
            "TOTAL_ENGAGEMENT_CHECKOUT_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementCheckoutQuantity),
            "TOTAL_ENGAGEMENT_CUSTOM_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementCustomQuantity),
            "TOTAL_ENGAGEMENT_ADD_TO_CART_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementAddToCartQuantity),
            "TOTAL_ENGAGEMENT_LEAD_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementLeadQuantity),
            "TOTAL_ENGAGEMENT_SEARCH_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementSearchQuantity),
            "TOTAL_ENGAGEMENT_WATCH_VIDEO_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementWatchVideoQuantity),
            "TOTAL_ENGAGEMENT_VIEW_CATEGORY_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementViewCategoryQuantity),
            "TOTAL_ENGAGEMENT_UNKNOWN_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalEngagementUnknownQuantity),
            "TOTAL_CLICK_PAGE_VISIT_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalClickPageVisitQuantity),
            "TOTAL_CLICK_SIGNUP_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalClickSignupQuantity),
            "TOTAL_CLICK_CHECKOUT_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalClickCheckoutQuantity),
            "TOTAL_CLICK_CUSTOM_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalClickCustomQuantity),
            "TOTAL_CLICK_ADD_TO_CART_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalClickAddToCartQuantity),
            "TOTAL_CLICK_LEAD_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalClickLeadQuantity),
            "TOTAL_CLICK_SEARCH_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalClickSearchQuantity),
            "TOTAL_CLICK_WATCH_VIDEO_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalClickWatchVideoQuantity),
            "TOTAL_CLICK_VIEW_CATEGORY_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalClickViewCategoryQuantity),
            "TOTAL_CLICK_UNKNOWN_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalClickUnknownQuantity),
            "TOTAL_VIEW_PAGE_VISIT_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalViewPageVisitQuantity),
            "TOTAL_VIEW_SIGNUP_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalViewSignupQuantity),
            "TOTAL_VIEW_CHECKOUT_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalViewCheckoutQuantity),
            "TOTAL_VIEW_CUSTOM_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalViewCustomQuantity),
            "TOTAL_VIEW_ADD_TO_CART_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalViewAddToCartQuantity),
            "TOTAL_VIEW_LEAD_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalViewLeadQuantity),
            "TOTAL_VIEW_SEARCH_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalViewSearchQuantity),
            "TOTAL_VIEW_WATCH_VIDEO_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalViewWatchVideoQuantity),
            "TOTAL_VIEW_VIEW_CATEGORY_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalViewViewCategoryQuantity),
            "TOTAL_VIEW_UNKNOWN_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalViewUnknownQuantity),
            "TOTAL_CONVERSIONS_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalConversionsQuantity),
            "TOTAL_WEB_SESSIONS" => std::result::Result::Ok(ReportingColumnAsync::TotalWebSessions),
            "WEB_SESSIONS_1" => std::result::Result::Ok(ReportingColumnAsync::WebSessions1),
            "WEB_SESSIONS_2" => std::result::Result::Ok(ReportingColumnAsync::WebSessions2),
            "ONSITE_CHECKOUTS_1" => std::result::Result::Ok(ReportingColumnAsync::OnsiteCheckouts1),
            "PIN_PROMOTION_NAME" => std::result::Result::Ok(ReportingColumnAsync::PinPromotionName),
            "AD_NAME" => std::result::Result::Ok(ReportingColumnAsync::AdName),
            "CAMPAIGN_LIFETIME_SPEND_CAP" => std::result::Result::Ok(ReportingColumnAsync::CampaignLifetimeSpendCap),
            "CAMPAIGN_DAILY_SPEND_CAP" => std::result::Result::Ok(ReportingColumnAsync::CampaignDailySpendCap),
            "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalPageVisitDesktopActionToDesktopConversion),
            "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalPageVisitDesktopActionToMobileConversion),
            "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalPageVisitDesktopActionToTabletConversion),
            "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalPageVisitMobileActionToDesktopConversion),
            "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalPageVisitMobileActionToMobileConversion),
            "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalPageVisitMobileActionToTabletConversion),
            "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalPageVisitTabletActionToDesktopConversion),
            "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalPageVisitTabletActionToMobileConversion),
            "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalPageVisitTabletActionToTabletConversion),
            "TOTAL_SIGNUP_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSignupDesktopActionToDesktopConversion),
            "TOTAL_SIGNUP_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSignupDesktopActionToMobileConversion),
            "TOTAL_SIGNUP_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSignupDesktopActionToTabletConversion),
            "TOTAL_SIGNUP_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSignupMobileActionToDesktopConversion),
            "TOTAL_SIGNUP_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSignupMobileActionToMobileConversion),
            "TOTAL_SIGNUP_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSignupMobileActionToTabletConversion),
            "TOTAL_SIGNUP_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSignupTabletActionToDesktopConversion),
            "TOTAL_SIGNUP_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSignupTabletActionToMobileConversion),
            "TOTAL_SIGNUP_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSignupTabletActionToTabletConversion),
            "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCheckoutDesktopActionToDesktopConversion),
            "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCheckoutDesktopActionToMobileConversion),
            "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCheckoutDesktopActionToTabletConversion),
            "TOTAL_CHECKOUT_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCheckoutMobileActionToDesktopConversion),
            "TOTAL_CHECKOUT_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCheckoutMobileActionToMobileConversion),
            "TOTAL_CHECKOUT_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCheckoutMobileActionToTabletConversion),
            "TOTAL_CHECKOUT_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCheckoutTabletActionToDesktopConversion),
            "TOTAL_CHECKOUT_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCheckoutTabletActionToMobileConversion),
            "TOTAL_CHECKOUT_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCheckoutTabletActionToTabletConversion),
            "TOTAL_CUSTOM_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCustomDesktopActionToDesktopConversion),
            "TOTAL_CUSTOM_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCustomDesktopActionToMobileConversion),
            "TOTAL_CUSTOM_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCustomDesktopActionToTabletConversion),
            "TOTAL_CUSTOM_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCustomMobileActionToDesktopConversion),
            "TOTAL_CUSTOM_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCustomMobileActionToMobileConversion),
            "TOTAL_CUSTOM_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCustomMobileActionToTabletConversion),
            "TOTAL_CUSTOM_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCustomTabletActionToDesktopConversion),
            "TOTAL_CUSTOM_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCustomTabletActionToMobileConversion),
            "TOTAL_CUSTOM_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalCustomTabletActionToTabletConversion),
            "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAddToCartDesktopActionToDesktopConversion),
            "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAddToCartDesktopActionToMobileConversion),
            "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAddToCartDesktopActionToTabletConversion),
            "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAddToCartMobileActionToDesktopConversion),
            "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAddToCartMobileActionToMobileConversion),
            "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAddToCartMobileActionToTabletConversion),
            "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAddToCartTabletActionToDesktopConversion),
            "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAddToCartTabletActionToMobileConversion),
            "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAddToCartTabletActionToTabletConversion),
            "TOTAL_LEAD_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalLeadDesktopActionToDesktopConversion),
            "TOTAL_LEAD_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalLeadDesktopActionToMobileConversion),
            "TOTAL_LEAD_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalLeadDesktopActionToTabletConversion),
            "TOTAL_LEAD_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalLeadMobileActionToDesktopConversion),
            "TOTAL_LEAD_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalLeadMobileActionToMobileConversion),
            "TOTAL_LEAD_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalLeadMobileActionToTabletConversion),
            "TOTAL_LEAD_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalLeadTabletActionToDesktopConversion),
            "TOTAL_LEAD_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalLeadTabletActionToMobileConversion),
            "TOTAL_LEAD_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalLeadTabletActionToTabletConversion),
            "TOTAL_SEARCH_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSearchDesktopActionToDesktopConversion),
            "TOTAL_SEARCH_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSearchDesktopActionToMobileConversion),
            "TOTAL_SEARCH_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSearchDesktopActionToTabletConversion),
            "TOTAL_SEARCH_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSearchMobileActionToDesktopConversion),
            "TOTAL_SEARCH_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSearchMobileActionToMobileConversion),
            "TOTAL_SEARCH_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSearchMobileActionToTabletConversion),
            "TOTAL_SEARCH_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSearchTabletActionToDesktopConversion),
            "TOTAL_SEARCH_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSearchTabletActionToMobileConversion),
            "TOTAL_SEARCH_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalSearchTabletActionToTabletConversion),
            "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalWatchVideoDesktopActionToDesktopConversion),
            "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalWatchVideoDesktopActionToMobileConversion),
            "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalWatchVideoDesktopActionToTabletConversion),
            "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalWatchVideoMobileActionToDesktopConversion),
            "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalWatchVideoMobileActionToMobileConversion),
            "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalWatchVideoMobileActionToTabletConversion),
            "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalWatchVideoTabletActionToDesktopConversion),
            "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalWatchVideoTabletActionToMobileConversion),
            "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalWatchVideoTabletActionToTabletConversion),
            "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalViewCategoryDesktopActionToDesktopConversion),
            "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalViewCategoryDesktopActionToMobileConversion),
            "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalViewCategoryDesktopActionToTabletConversion),
            "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalViewCategoryMobileActionToDesktopConversion),
            "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalViewCategoryMobileActionToMobileConversion),
            "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalViewCategoryMobileActionToTabletConversion),
            "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalViewCategoryTabletActionToDesktopConversion),
            "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalViewCategoryTabletActionToMobileConversion),
            "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalViewCategoryTabletActionToTabletConversion),
            "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAppInstallDesktopActionToDesktopConversion),
            "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAppInstallDesktopActionToMobileConversion),
            "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAppInstallDesktopActionToTabletConversion),
            "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAppInstallMobileActionToDesktopConversion),
            "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAppInstallMobileActionToMobileConversion),
            "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAppInstallMobileActionToTabletConversion),
            "TOTAL_APP_INSTALL_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAppInstallTabletActionToDesktopConversion),
            "TOTAL_APP_INSTALL_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAppInstallTabletActionToMobileConversion),
            "TOTAL_APP_INSTALL_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalAppInstallTabletActionToTabletConversion),
            "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalUnknownDesktopActionToDesktopConversion),
            "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalUnknownDesktopActionToMobileConversion),
            "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalUnknownDesktopActionToTabletConversion),
            "TOTAL_UNKNOWN_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalUnknownMobileActionToDesktopConversion),
            "TOTAL_UNKNOWN_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalUnknownMobileActionToMobileConversion),
            "TOTAL_UNKNOWN_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalUnknownMobileActionToTabletConversion),
            "TOTAL_UNKNOWN_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalUnknownTabletActionToDesktopConversion),
            "TOTAL_UNKNOWN_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalUnknownTabletActionToMobileConversion),
            "TOTAL_UNKNOWN_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TotalUnknownTabletActionToTabletConversion),
            "TOTAL_PAGE_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TotalPageVisit),
            "TOTAL_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TotalSignup),
            "TOTAL_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TotalCheckout),
            "TOTAL_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TotalCustom),
            "TOTAL_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TotalLead),
            "TOTAL_APP_INSTALL" => std::result::Result::Ok(ReportingColumnAsync::TotalAppInstall),
            "TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalSignupValueInMicroDollar),
            "TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalCheckoutValueInMicroDollar),
            "TOTAL_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalCustomValueInMicroDollar),
            "TOTAL_APP_INSTALL_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalAppInstallValueInMicroDollar),
            "TOTAL_CHECKOUT_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TotalCheckoutQuantity),
            "PAGE_VISIT_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::PageVisitCostPerAction),
            "APP_INSTALL_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::AppInstallCostPerAction),
            "PAGE_VISIT_ROAS" => std::result::Result::Ok(ReportingColumnAsync::PageVisitRoas),
            "CHECKOUT_ROAS" => std::result::Result::Ok(ReportingColumnAsync::CheckoutRoas),
            "CUSTOM_ROAS" => std::result::Result::Ok(ReportingColumnAsync::CustomRoas),
            "VIDEO_3SEC_VIEWS_1" => std::result::Result::Ok(ReportingColumnAsync::Video3SecViews1),
            "VIDEO_P100_COMPLETE_1" => std::result::Result::Ok(ReportingColumnAsync::VideoP100Complete1),
            "VIDEO_P0_COMBINED_1" => std::result::Result::Ok(ReportingColumnAsync::VideoP0Combined1),
            "VIDEO_P25_COMBINED_1" => std::result::Result::Ok(ReportingColumnAsync::VideoP25Combined1),
            "VIDEO_P50_COMBINED_1" => std::result::Result::Ok(ReportingColumnAsync::VideoP50Combined1),
            "VIDEO_P75_COMBINED_1" => std::result::Result::Ok(ReportingColumnAsync::VideoP75Combined1),
            "VIDEO_P95_COMBINED_1" => std::result::Result::Ok(ReportingColumnAsync::VideoP95Combined1),
            "VIDEO_MRC_VIEWS_1" => std::result::Result::Ok(ReportingColumnAsync::VideoMrcViews1),
            "VIDEO_3SEC_VIEWS_2" => std::result::Result::Ok(ReportingColumnAsync::Video3SecViews2),
            "VIDEO_P100_COMPLETE_2" => std::result::Result::Ok(ReportingColumnAsync::VideoP100Complete2),
            "VIDEO_P0_COMBINED_2" => std::result::Result::Ok(ReportingColumnAsync::VideoP0Combined2),
            "VIDEO_P25_COMBINED_2" => std::result::Result::Ok(ReportingColumnAsync::VideoP25Combined2),
            "VIDEO_P50_COMBINED_2" => std::result::Result::Ok(ReportingColumnAsync::VideoP50Combined2),
            "VIDEO_P75_COMBINED_2" => std::result::Result::Ok(ReportingColumnAsync::VideoP75Combined2),
            "VIDEO_P95_COMBINED_2" => std::result::Result::Ok(ReportingColumnAsync::VideoP95Combined2),
            "VIDEO_MRC_VIEWS_2" => std::result::Result::Ok(ReportingColumnAsync::VideoMrcViews2),
            "VIDEO_LENGTH" => std::result::Result::Ok(ReportingColumnAsync::VideoLength),
            "CPV_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::CpvInMicroDollar),
            "ECPV_IN_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::EcpvInDollar),
            "CPCV_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::CpcvInMicroDollar),
            "ECPCV_IN_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::EcpcvInDollar),
            "CPCV_P95_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::CpcvP95InMicroDollar),
            "ECPCV_P95_IN_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::EcpcvP95InDollar),
            "TOTAL_VIDEO_3SEC_VIEWS" => std::result::Result::Ok(ReportingColumnAsync::TotalVideo3SecViews),
            "TOTAL_VIDEO_P100_COMPLETE" => std::result::Result::Ok(ReportingColumnAsync::TotalVideoP100Complete),
            "TOTAL_VIDEO_P0_COMBINED" => std::result::Result::Ok(ReportingColumnAsync::TotalVideoP0Combined),
            "TOTAL_VIDEO_P25_COMBINED" => std::result::Result::Ok(ReportingColumnAsync::TotalVideoP25Combined),
            "TOTAL_VIDEO_P50_COMBINED" => std::result::Result::Ok(ReportingColumnAsync::TotalVideoP50Combined),
            "TOTAL_VIDEO_P75_COMBINED" => std::result::Result::Ok(ReportingColumnAsync::TotalVideoP75Combined),
            "TOTAL_VIDEO_P95_COMBINED" => std::result::Result::Ok(ReportingColumnAsync::TotalVideoP95Combined),
            "TOTAL_VIDEO_MRC_VIEWS" => std::result::Result::Ok(ReportingColumnAsync::TotalVideoMrcViews),
            "VIDEO_AVG_WATCHTIME_IN_SECOND_1" => std::result::Result::Ok(ReportingColumnAsync::VideoAvgWatchtimeInSecond1),
            "VIDEO_AVG_WATCHTIME_IN_SECOND_2" => std::result::Result::Ok(ReportingColumnAsync::VideoAvgWatchtimeInSecond2),
            "TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND" => std::result::Result::Ok(ReportingColumnAsync::TotalVideoAvgWatchtimeInSecond),
            "TOTAL_REPIN_RATE" => std::result::Result::Ok(ReportingColumnAsync::TotalRepinRate),
            "WEB_CHECKOUT_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WebCheckoutCostPerAction),
            "WEB_CHECKOUT_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WebCheckoutRoas),
            "TOTAL_WEB_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TotalWebCheckout),
            "TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebCheckoutValueInMicroDollar),
            "TOTAL_WEB_CLICK_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickCheckout),
            "TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickCheckoutValueInMicroDollar),
            "TOTAL_WEB_ENGAGEMENT_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementCheckout),
            "TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementCheckoutValueInMicroDollar),
            "TOTAL_WEB_VIEW_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewCheckout),
            "TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewCheckoutValueInMicroDollar),
            "INAPP_CHECKOUT_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::InappCheckoutCostPerAction),
            "INAPP_CHECKOUT_ROAS" => std::result::Result::Ok(ReportingColumnAsync::InappCheckoutRoas),
            "TOTAL_INAPP_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TotalInappCheckout),
            "TOTAL_INAPP_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappCheckoutValueInMicroDollar),
            "TOTAL_INAPP_CLICK_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TotalInappClickCheckout),
            "TOTAL_INAPP_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappClickCheckoutValueInMicroDollar),
            "TOTAL_INAPP_ENGAGEMENT_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TotalInappEngagementCheckout),
            "TOTAL_INAPP_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappEngagementCheckoutValueInMicroDollar),
            "TOTAL_INAPP_VIEW_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TotalInappViewCheckout),
            "TOTAL_INAPP_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappViewCheckoutValueInMicroDollar),
            "OFFLINE_CHECKOUT_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::OfflineCheckoutCostPerAction),
            "OFFLINE_CHECKOUT_ROAS" => std::result::Result::Ok(ReportingColumnAsync::OfflineCheckoutRoas),
            "TOTAL_OFFLINE_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineCheckout),
            "TOTAL_OFFLINE_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineCheckoutValueInMicroDollar),
            "TOTAL_OFFLINE_CLICK_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineClickCheckout),
            "TOTAL_OFFLINE_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineClickCheckoutValueInMicroDollar),
            "TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineEngagementCheckout),
            "TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineEngagementCheckoutValueInMicroDollar),
            "TOTAL_OFFLINE_VIEW_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineViewCheckout),
            "TOTAL_OFFLINE_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineViewCheckoutValueInMicroDollar),
            "PINTEREST_CHECKOUT_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::PinterestCheckoutCostPerAction),
            "PINTEREST_CHECKOUT_ROAS" => std::result::Result::Ok(ReportingColumnAsync::PinterestCheckoutRoas),
            "TOTAL_PINTEREST_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TotalPinterestCheckout),
            "TOTAL_PINTEREST_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalPinterestCheckoutValueInMicroDollar),
            "WEB_ADD_TO_CART_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WebAddToCartCostPerAction),
            "WEB_ADD_TO_CART_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WebAddToCartRoas),
            "TOTAL_WEB_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TotalWebAddToCart),
            "TOTAL_WEB_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebAddToCartValueInMicroDollar),
            "TOTAL_WEB_CLICK_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickAddToCart),
            "TOTAL_WEB_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickAddToCartValueInMicroDollar),
            "TOTAL_WEB_ENGAGEMENT_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementAddToCart),
            "TOTAL_WEB_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementAddToCartValueInMicroDollar),
            "TOTAL_WEB_VIEW_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewAddToCart),
            "TOTAL_WEB_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewAddToCartValueInMicroDollar),
            "INAPP_ADD_TO_CART_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::InappAddToCartCostPerAction),
            "INAPP_ADD_TO_CART_ROAS" => std::result::Result::Ok(ReportingColumnAsync::InappAddToCartRoas),
            "TOTAL_INAPP_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TotalInappAddToCart),
            "TOTAL_INAPP_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappAddToCartValueInMicroDollar),
            "TOTAL_INAPP_CLICK_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TotalInappClickAddToCart),
            "TOTAL_INAPP_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappClickAddToCartValueInMicroDollar),
            "TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TotalInappEngagementAddToCart),
            "TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappEngagementAddToCartValueInMicroDollar),
            "TOTAL_INAPP_VIEW_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TotalInappViewAddToCart),
            "TOTAL_INAPP_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappViewAddToCartValueInMicroDollar),
            "WEB_PAGE_VISIT_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WebPageVisitCostPerAction),
            "WEB_PAGE_VISIT_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WebPageVisitRoas),
            "TOTAL_WEB_PAGE_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TotalWebPageVisit),
            "TOTAL_WEB_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebPageVisitValueInMicroDollar),
            "TOTAL_WEB_CLICK_PAGE_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickPageVisit),
            "TOTAL_WEB_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickPageVisitValueInMicroDollar),
            "TOTAL_WEB_ENGAGEMENT_PAGE_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementPageVisit),
            "TOTAL_WEB_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementPageVisitValueInMicroDollar),
            "TOTAL_WEB_VIEW_PAGE_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewPageVisit),
            "TOTAL_WEB_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewPageVisitValueInMicroDollar),
            "WEB_SIGNUP_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WebSignupCostPerAction),
            "WEB_SIGNUP_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WebSignupRoas),
            "TOTAL_WEB_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TotalWebSignup),
            "TOTAL_WEB_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebSignupValueInMicroDollar),
            "TOTAL_WEB_CLICK_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickSignup),
            "TOTAL_WEB_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickSignupValueInMicroDollar),
            "TOTAL_WEB_ENGAGEMENT_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementSignup),
            "TOTAL_WEB_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementSignupValueInMicroDollar),
            "TOTAL_WEB_VIEW_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewSignup),
            "TOTAL_WEB_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewSignupValueInMicroDollar),
            "INAPP_SIGNUP_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::InappSignupCostPerAction),
            "INAPP_SIGNUP_ROAS" => std::result::Result::Ok(ReportingColumnAsync::InappSignupRoas),
            "TOTAL_INAPP_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TotalInappSignup),
            "TOTAL_INAPP_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappSignupValueInMicroDollar),
            "TOTAL_INAPP_CLICK_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TotalInappClickSignup),
            "TOTAL_INAPP_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappClickSignupValueInMicroDollar),
            "TOTAL_INAPP_ENGAGEMENT_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TotalInappEngagementSignup),
            "TOTAL_INAPP_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappEngagementSignupValueInMicroDollar),
            "TOTAL_INAPP_VIEW_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TotalInappViewSignup),
            "TOTAL_INAPP_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappViewSignupValueInMicroDollar),
            "OFFLINE_SIGNUP_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::OfflineSignupCostPerAction),
            "OFFLINE_SIGNUP_ROAS" => std::result::Result::Ok(ReportingColumnAsync::OfflineSignupRoas),
            "TOTAL_OFFLINE_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineSignup),
            "TOTAL_OFFLINE_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineSignupValueInMicroDollar),
            "TOTAL_OFFLINE_CLICK_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineClickSignup),
            "TOTAL_OFFLINE_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineClickSignupValueInMicroDollar),
            "TOTAL_OFFLINE_ENGAGEMENT_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineEngagementSignup),
            "TOTAL_OFFLINE_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineEngagementSignupValueInMicroDollar),
            "TOTAL_OFFLINE_VIEW_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineViewSignup),
            "TOTAL_OFFLINE_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineViewSignupValueInMicroDollar),
            "WEB_WATCH_VIDEO_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WebWatchVideoCostPerAction),
            "WEB_WATCH_VIDEO_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WebWatchVideoRoas),
            "TOTAL_WEB_WATCH_VIDEO" => std::result::Result::Ok(ReportingColumnAsync::TotalWebWatchVideo),
            "TOTAL_WEB_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebWatchVideoValueInMicroDollar),
            "TOTAL_WEB_CLICK_WATCH_VIDEO" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickWatchVideo),
            "TOTAL_WEB_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickWatchVideoValueInMicroDollar),
            "TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementWatchVideo),
            "TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementWatchVideoValueInMicroDollar),
            "TOTAL_WEB_VIEW_WATCH_VIDEO" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewWatchVideo),
            "TOTAL_WEB_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewWatchVideoValueInMicroDollar),
            "WEB_LEAD_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WebLeadCostPerAction),
            "WEB_LEAD_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WebLeadRoas),
            "TOTAL_WEB_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TotalWebLead),
            "TOTAL_WEB_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebLeadValueInMicroDollar),
            "TOTAL_WEB_CLICK_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickLead),
            "TOTAL_WEB_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickLeadValueInMicroDollar),
            "TOTAL_WEB_ENGAGEMENT_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementLead),
            "TOTAL_WEB_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementLeadValueInMicroDollar),
            "TOTAL_WEB_VIEW_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewLead),
            "TOTAL_WEB_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewLeadValueInMicroDollar),
            "OFFLINE_LEAD_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::OfflineLeadCostPerAction),
            "OFFLINE_LEAD_ROAS" => std::result::Result::Ok(ReportingColumnAsync::OfflineLeadRoas),
            "TOTAL_OFFLINE_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineLead),
            "TOTAL_OFFLINE_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineLeadValueInMicroDollar),
            "TOTAL_OFFLINE_CLICK_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineClickLead),
            "TOTAL_OFFLINE_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineClickLeadValueInMicroDollar),
            "TOTAL_OFFLINE_ENGAGEMENT_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineEngagementLead),
            "TOTAL_OFFLINE_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineEngagementLeadValueInMicroDollar),
            "TOTAL_OFFLINE_VIEW_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineViewLead),
            "TOTAL_OFFLINE_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineViewLeadValueInMicroDollar),
            "WEB_SEARCH_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WebSearchCostPerAction),
            "WEB_SEARCH_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WebSearchRoas),
            "TOTAL_WEB_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TotalWebSearch),
            "TOTAL_WEB_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebSearchValueInMicroDollar),
            "TOTAL_WEB_CLICK_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickSearch),
            "TOTAL_WEB_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickSearchValueInMicroDollar),
            "TOTAL_WEB_ENGAGEMENT_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementSearch),
            "TOTAL_WEB_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementSearchValueInMicroDollar),
            "TOTAL_WEB_VIEW_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewSearch),
            "TOTAL_WEB_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewSearchValueInMicroDollar),
            "INAPP_SEARCH_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::InappSearchCostPerAction),
            "INAPP_SEARCH_ROAS" => std::result::Result::Ok(ReportingColumnAsync::InappSearchRoas),
            "TOTAL_INAPP_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TotalInappSearch),
            "TOTAL_INAPP_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappSearchValueInMicroDollar),
            "TOTAL_INAPP_CLICK_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TotalInappClickSearch),
            "TOTAL_INAPP_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappClickSearchValueInMicroDollar),
            "TOTAL_INAPP_ENGAGEMENT_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TotalInappEngagementSearch),
            "TOTAL_INAPP_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappEngagementSearchValueInMicroDollar),
            "TOTAL_INAPP_VIEW_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TotalInappViewSearch),
            "TOTAL_INAPP_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappViewSearchValueInMicroDollar),
            "WEB_VIEW_CATEGORY_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WebViewCategoryCostPerAction),
            "WEB_VIEW_CATEGORY_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WebViewCategoryRoas),
            "TOTAL_WEB_VIEW_CATEGORY" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewCategory),
            "TOTAL_WEB_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewCategoryValueInMicroDollar),
            "TOTAL_WEB_CLICK_VIEW_CATEGORY" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickViewCategory),
            "TOTAL_WEB_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickViewCategoryValueInMicroDollar),
            "TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementViewCategory),
            "TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementViewCategoryValueInMicroDollar),
            "TOTAL_WEB_VIEW_VIEW_CATEGORY" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewViewCategory),
            "TOTAL_WEB_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewViewCategoryValueInMicroDollar),
            "WEB_CUSTOM_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WebCustomCostPerAction),
            "WEB_CUSTOM_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WebCustomRoas),
            "TOTAL_WEB_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TotalWebCustom),
            "TOTAL_WEB_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebCustomValueInMicroDollar),
            "TOTAL_WEB_CLICK_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickCustom),
            "TOTAL_WEB_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickCustomValueInMicroDollar),
            "TOTAL_WEB_ENGAGEMENT_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementCustom),
            "TOTAL_WEB_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementCustomValueInMicroDollar),
            "TOTAL_WEB_VIEW_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewCustom),
            "TOTAL_WEB_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewCustomValueInMicroDollar),
            "OFFLINE_CUSTOM_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::OfflineCustomCostPerAction),
            "OFFLINE_CUSTOM_ROAS" => std::result::Result::Ok(ReportingColumnAsync::OfflineCustomRoas),
            "TOTAL_OFFLINE_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineCustom),
            "TOTAL_OFFLINE_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineCustomValueInMicroDollar),
            "TOTAL_OFFLINE_CLICK_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineClickCustom),
            "TOTAL_OFFLINE_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineClickCustomValueInMicroDollar),
            "TOTAL_OFFLINE_ENGAGEMENT_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineEngagementCustom),
            "TOTAL_OFFLINE_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineEngagementCustomValueInMicroDollar),
            "TOTAL_OFFLINE_VIEW_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineViewCustom),
            "TOTAL_OFFLINE_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineViewCustomValueInMicroDollar),
            "WEB_UNKNOWN_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WebUnknownCostPerAction),
            "WEB_UNKNOWN_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WebUnknownRoas),
            "TOTAL_WEB_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TotalWebUnknown),
            "TOTAL_WEB_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebUnknownValueInMicroDollar),
            "TOTAL_WEB_CLICK_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickUnknown),
            "TOTAL_WEB_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebClickUnknownValueInMicroDollar),
            "TOTAL_WEB_ENGAGEMENT_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementUnknown),
            "TOTAL_WEB_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebEngagementUnknownValueInMicroDollar),
            "TOTAL_WEB_VIEW_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewUnknown),
            "TOTAL_WEB_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalWebViewUnknownValueInMicroDollar),
            "INAPP_UNKNOWN_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::InappUnknownCostPerAction),
            "INAPP_UNKNOWN_ROAS" => std::result::Result::Ok(ReportingColumnAsync::InappUnknownRoas),
            "TOTAL_INAPP_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TotalInappUnknown),
            "TOTAL_INAPP_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappUnknownValueInMicroDollar),
            "TOTAL_INAPP_CLICK_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TotalInappClickUnknown),
            "TOTAL_INAPP_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappClickUnknownValueInMicroDollar),
            "TOTAL_INAPP_ENGAGEMENT_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TotalInappEngagementUnknown),
            "TOTAL_INAPP_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappEngagementUnknownValueInMicroDollar),
            "TOTAL_INAPP_VIEW_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TotalInappViewUnknown),
            "TOTAL_INAPP_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappViewUnknownValueInMicroDollar),
            "OFFLINE_UNKNOWN_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::OfflineUnknownCostPerAction),
            "OFFLINE_UNKNOWN_ROAS" => std::result::Result::Ok(ReportingColumnAsync::OfflineUnknownRoas),
            "TOTAL_OFFLINE_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineUnknown),
            "TOTAL_OFFLINE_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineUnknownValueInMicroDollar),
            "TOTAL_OFFLINE_CLICK_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineClickUnknown),
            "TOTAL_OFFLINE_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineClickUnknownValueInMicroDollar),
            "TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineEngagementUnknown),
            "TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineEngagementUnknownValueInMicroDollar),
            "TOTAL_OFFLINE_VIEW_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineViewUnknown),
            "TOTAL_OFFLINE_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalOfflineViewUnknownValueInMicroDollar),
            "INAPP_APP_INSTALL_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::InappAppInstallCostPerAction),
            "INAPP_APP_INSTALL_ROAS" => std::result::Result::Ok(ReportingColumnAsync::InappAppInstallRoas),
            "TOTAL_INAPP_APP_INSTALL" => std::result::Result::Ok(ReportingColumnAsync::TotalInappAppInstall),
            "TOTAL_INAPP_APP_INSTALL_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappAppInstallValueInMicroDollar),
            "TOTAL_INAPP_CLICK_APP_INSTALL" => std::result::Result::Ok(ReportingColumnAsync::TotalInappClickAppInstall),
            "TOTAL_INAPP_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappClickAppInstallValueInMicroDollar),
            "TOTAL_INAPP_ENGAGEMENT_APP_INSTALL" => std::result::Result::Ok(ReportingColumnAsync::TotalInappEngagementAppInstall),
            "TOTAL_INAPP_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappEngagementAppInstallValueInMicroDollar),
            "TOTAL_INAPP_VIEW_APP_INSTALL" => std::result::Result::Ok(ReportingColumnAsync::TotalInappViewAppInstall),
            "TOTAL_INAPP_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TotalInappViewAppInstallValueInMicroDollar),
            "IDEA_PIN_PRODUCT_TAG_VISIT_1" => std::result::Result::Ok(ReportingColumnAsync::IdeaPinProductTagVisit1),
            "IDEA_PIN_PRODUCT_TAG_VISIT_2" => std::result::Result::Ok(ReportingColumnAsync::IdeaPinProductTagVisit2),
            "TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TotalIdeaPinProductTagVisit),
            "LEADS" => std::result::Result::Ok(ReportingColumnAsync::Leads),
            "COST_PER_LEAD" => std::result::Result::Ok(ReportingColumnAsync::CostPerLead),
            "QUIZ_COMPLETED" => std::result::Result::Ok(ReportingColumnAsync::QuizCompleted),
            "QUIZ_COMPLETION_RATE" => std::result::Result::Ok(ReportingColumnAsync::QuizCompletionRate),
            "SHOWCASE_PIN_CLICKTHROUGH" => std::result::Result::Ok(ReportingColumnAsync::ShowcasePinClickthrough),
            "SHOWCASE_SUBPAGE_CLICKTHROUGH" => std::result::Result::Ok(ReportingColumnAsync::ShowcaseSubpageClickthrough),
            "SHOWCASE_SUBPIN_CLICKTHROUGH" => std::result::Result::Ok(ReportingColumnAsync::ShowcaseSubpinClickthrough),
            "SHOWCASE_SUBPAGE_IMPRESSION" => std::result::Result::Ok(ReportingColumnAsync::ShowcaseSubpageImpression),
            "SHOWCASE_SUBPIN_IMPRESSION" => std::result::Result::Ok(ReportingColumnAsync::ShowcaseSubpinImpression),
            "SHOWCASE_SUBPAGE_SWIPE_LEFT" => std::result::Result::Ok(ReportingColumnAsync::ShowcaseSubpageSwipeLeft),
            "SHOWCASE_SUBPAGE_SWIPE_RIGHT" => std::result::Result::Ok(ReportingColumnAsync::ShowcaseSubpageSwipeRight),
            "SHOWCASE_SUBPIN_SWIPE_LEFT" => std::result::Result::Ok(ReportingColumnAsync::ShowcaseSubpinSwipeLeft),
            "SHOWCASE_SUBPIN_SWIPE_RIGHT" => std::result::Result::Ok(ReportingColumnAsync::ShowcaseSubpinSwipeRight),
            "SHOWCASE_SUBPAGE_REPIN" => std::result::Result::Ok(ReportingColumnAsync::ShowcaseSubpageRepin),
            "SHOWCASE_SUBPIN_REPIN" => std::result::Result::Ok(ReportingColumnAsync::ShowcaseSubpinRepin),
            "SHOWCASE_SUBPAGE_CLOSEUP" => std::result::Result::Ok(ReportingColumnAsync::ShowcaseSubpageCloseup),
            "SHOWCASE_CARD_THUMBNAIL_SWIPE_FORWARD" => std::result::Result::Ok(ReportingColumnAsync::ShowcaseCardThumbnailSwipeForward),
            "SHOWCASE_CARD_THUMBNAIL_SWIPE_BACKWARD" => std::result::Result::Ok(ReportingColumnAsync::ShowcaseCardThumbnailSwipeBackward),
            "SHOWCASE_AVERAGE_SUBPAGE_CLOSEUP_PER_SESSION" => std::result::Result::Ok(ReportingColumnAsync::ShowcaseAverageSubpageCloseupPerSession),
            "TOTAL_CHECKOUT_CONVERSION_RATE" => std::result::Result::Ok(ReportingColumnAsync::TotalCheckoutConversionRate),
            "TOTAL_VIEW_CATEGORY_CONVERSION_RATE" => std::result::Result::Ok(ReportingColumnAsync::TotalViewCategoryConversionRate),
            "TOTAL_ADD_TO_CART_CONVERSION_RATE" => std::result::Result::Ok(ReportingColumnAsync::TotalAddToCartConversionRate),
            "TOTAL_SIGNUP_CONVERSION_RATE" => std::result::Result::Ok(ReportingColumnAsync::TotalSignupConversionRate),
            "TOTAL_PAGE_VISIT_CONVERSION_RATE" => std::result::Result::Ok(ReportingColumnAsync::TotalPageVisitConversionRate),
            "TOTAL_LEAD_CONVERSION_RATE" => std::result::Result::Ok(ReportingColumnAsync::TotalLeadConversionRate),
            "TOTAL_SEARCH_CONVERSION_RATE" => std::result::Result::Ok(ReportingColumnAsync::TotalSearchConversionRate),
            "TOTAL_WATCH_VIDEO_CONVERSION_RATE" => std::result::Result::Ok(ReportingColumnAsync::TotalWatchVideoConversionRate),
            "TOTAL_UNKNOWN_CONVERSION_RATE" => std::result::Result::Ok(ReportingColumnAsync::TotalUnknownConversionRate),
            "TOTAL_CUSTOM_CONVERSION_RATE" => std::result::Result::Ok(ReportingColumnAsync::TotalCustomConversionRate),
            "STANDARD_AD_FEED_ITEM_ID" => std::result::Result::Ok(ReportingColumnAsync::StandardAdFeedItemId),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// An internal role type used on business access, EMPLOYEE, ADMIN.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum Role {
    #[serde(rename = "UNKNOWN")]
    Unknown,
    #[serde(rename = "OWNER")]
    Owner,
    #[serde(rename = "ADMIN")]
    Admin,
    #[serde(rename = "ANALYST")]
    Analyst,
    #[serde(rename = "SOS_READER")]
    SosReader,
    #[serde(rename = "FINANCE_MANAGER")]
    FinanceManager,
    #[serde(rename = "AUDIENCE_MANAGER")]
    AudienceManager,
    #[serde(rename = "CAMPAIGN_MANAGER")]
    CampaignManager,
    #[serde(rename = "CATALOGS_MANAGER")]
    CatalogsManager,
    #[serde(rename = "RESTRICTED_OWNER")]
    RestrictedOwner,
    #[serde(rename = "PROFILE_MANAGER")]
    ProfileManager,
    #[serde(rename = "PROFILE_PUBLISHER")]
    ProfilePublisher,
    #[serde(rename = "RESOURCE_PINNER_LIST_OWNER")]
    ResourcePinnerListOwner,
    #[serde(rename = "RESOURCE_PINNER_LIST_READER")]
    ResourcePinnerListReader,
    #[serde(rename = "BIZ_PINNER_LIST_SHARER")]
    BizPinnerListSharer,
    #[serde(rename = "RESOURCE_CONVERSION_TAGS_READER")]
    ResourceConversionTagsReader,
}

impl std::fmt::Display for Role {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Role::Unknown => write!(f, "UNKNOWN"),
            Role::Owner => write!(f, "OWNER"),
            Role::Admin => write!(f, "ADMIN"),
            Role::Analyst => write!(f, "ANALYST"),
            Role::SosReader => write!(f, "SOS_READER"),
            Role::FinanceManager => write!(f, "FINANCE_MANAGER"),
            Role::AudienceManager => write!(f, "AUDIENCE_MANAGER"),
            Role::CampaignManager => write!(f, "CAMPAIGN_MANAGER"),
            Role::CatalogsManager => write!(f, "CATALOGS_MANAGER"),
            Role::RestrictedOwner => write!(f, "RESTRICTED_OWNER"),
            Role::ProfileManager => write!(f, "PROFILE_MANAGER"),
            Role::ProfilePublisher => write!(f, "PROFILE_PUBLISHER"),
            Role::ResourcePinnerListOwner => write!(f, "RESOURCE_PINNER_LIST_OWNER"),
            Role::ResourcePinnerListReader => write!(f, "RESOURCE_PINNER_LIST_READER"),
            Role::BizPinnerListSharer => write!(f, "BIZ_PINNER_LIST_SHARER"),
            Role::ResourceConversionTagsReader => write!(f, "RESOURCE_CONVERSION_TAGS_READER"),
        }
    }
}

impl std::str::FromStr for Role {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "UNKNOWN" => std::result::Result::Ok(Role::Unknown),
            "OWNER" => std::result::Result::Ok(Role::Owner),
            "ADMIN" => std::result::Result::Ok(Role::Admin),
            "ANALYST" => std::result::Result::Ok(Role::Analyst),
            "SOS_READER" => std::result::Result::Ok(Role::SosReader),
            "FINANCE_MANAGER" => std::result::Result::Ok(Role::FinanceManager),
            "AUDIENCE_MANAGER" => std::result::Result::Ok(Role::AudienceManager),
            "CAMPAIGN_MANAGER" => std::result::Result::Ok(Role::CampaignManager),
            "CATALOGS_MANAGER" => std::result::Result::Ok(Role::CatalogsManager),
            "RESTRICTED_OWNER" => std::result::Result::Ok(Role::RestrictedOwner),
            "PROFILE_MANAGER" => std::result::Result::Ok(Role::ProfileManager),
            "PROFILE_PUBLISHER" => std::result::Result::Ok(Role::ProfilePublisher),
            "RESOURCE_PINNER_LIST_OWNER" => std::result::Result::Ok(Role::ResourcePinnerListOwner),
            "RESOURCE_PINNER_LIST_READER" => std::result::Result::Ok(Role::ResourcePinnerListReader),
            "BIZ_PINNER_LIST_SHARER" => std::result::Result::Ok(Role::BizPinnerListSharer),
            "RESOURCE_CONVERSION_TAGS_READER" => std::result::Result::Ok(Role::ResourceConversionTagsReader),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SearchPartnerPins200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::SummaryPin>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl SearchPartnerPins200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::SummaryPin>, ) -> SearchPartnerPins200Response {
        SearchPartnerPins200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the SearchPartnerPins200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SearchPartnerPins200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SearchPartnerPins200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SearchPartnerPins200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::SummaryPin>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SearchPartnerPins200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in SearchPartnerPins200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SearchPartnerPins200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SearchPartnerPins200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SearchPartnerPins200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in SearchPartnerPins200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in SearchPartnerPins200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SearchPartnerPins200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SearchPartnerPins200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SearchPartnerPins200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SearchPartnerPins200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SearchPartnerPins200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SearchPartnerPins200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SearchPartnerPins200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SearchUserBoardsGet200Response {
/// items
    #[serde(rename = "items")]
    pub items: Vec<models::Board>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl SearchUserBoardsGet200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::Board>, ) -> SearchUserBoardsGet200Response {
        SearchUserBoardsGet200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the SearchUserBoardsGet200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SearchUserBoardsGet200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SearchUserBoardsGet200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SearchUserBoardsGet200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::Board>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SearchUserBoardsGet200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in SearchUserBoardsGet200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SearchUserBoardsGet200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SearchUserBoardsGet200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SearchUserBoardsGet200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in SearchUserBoardsGet200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in SearchUserBoardsGet200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SearchUserBoardsGet200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SearchUserBoardsGet200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SearchUserBoardsGet200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SearchUserBoardsGet200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SearchUserBoardsGet200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SearchUserBoardsGet200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SearchUserBoardsGet200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SingleInterestTargetingOptionResponse {
    #[serde(rename = "id")]
    #[validate(
           regex = "RE_SINGLEINTERESTTARGETINGOPTIONRESPONSE_ID",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "child_interests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub child_interests: Option<Vec<String>>,

    #[serde(rename = "level")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub level: Option<i32>,

}

lazy_static::lazy_static! {
    static ref RE_SINGLEINTERESTTARGETINGOPTIONRESPONSE_ID: regex::Regex = regex::Regex::new(r"\\d+").unwrap();
}

impl SingleInterestTargetingOptionResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SingleInterestTargetingOptionResponse {
        SingleInterestTargetingOptionResponse {
            id: None,
            name: None,
            child_interests: None,
            level: None,
        }
    }
}

/// Converts the SingleInterestTargetingOptionResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SingleInterestTargetingOptionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.child_interests.as_ref().map(|child_interests| {
                [
                    "child_interests".to_string(),
                    child_interests.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.level.as_ref().map(|level| {
                [
                    "level".to_string(),
                    level.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SingleInterestTargetingOptionResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SingleInterestTargetingOptionResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub child_interests: Vec<Vec<String>>,
            pub level: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SingleInterestTargetingOptionResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "child_interests" => return std::result::Result::Err("Parsing a container in this style is not supported in SingleInterestTargetingOptionResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "level" => intermediate_rep.level.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SingleInterestTargetingOptionResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SingleInterestTargetingOptionResponse {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            child_interests: intermediate_rep.child_interests.into_iter().next(),
            level: intermediate_rep.level.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SingleInterestTargetingOptionResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SingleInterestTargetingOptionResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SingleInterestTargetingOptionResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SingleInterestTargetingOptionResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SingleInterestTargetingOptionResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SingleInterestTargetingOptionResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SingleInterestTargetingOptionResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SsioAccountAddress {
/// Address display
    #[serde(rename = "display")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub display: Option<String>,

/// Purpose for which the address is used, usually Billing or Businness
    #[serde(rename = "purpose")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub purpose: Option<String>,

/// Salesforce id for address
    #[serde(rename = "address_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub address_id: Option<String>,

/// Legal entity for this insertion order
    #[serde(rename = "order_legal_entity")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_legal_entity: Option<String>,

}


impl SsioAccountAddress {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SsioAccountAddress {
        SsioAccountAddress {
            display: None,
            purpose: None,
            address_id: None,
            order_legal_entity: None,
        }
    }
}

/// Converts the SsioAccountAddress value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SsioAccountAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.display.as_ref().map(|display| {
                [
                    "display".to_string(),
                    display.to_string(),
                ].join(",")
            }),


            self.purpose.as_ref().map(|purpose| {
                [
                    "purpose".to_string(),
                    purpose.to_string(),
                ].join(",")
            }),


            self.address_id.as_ref().map(|address_id| {
                [
                    "address_id".to_string(),
                    address_id.to_string(),
                ].join(",")
            }),


            self.order_legal_entity.as_ref().map(|order_legal_entity| {
                [
                    "order_legal_entity".to_string(),
                    order_legal_entity.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SsioAccountAddress value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SsioAccountAddress {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub display: Vec<String>,
            pub purpose: Vec<String>,
            pub address_id: Vec<String>,
            pub order_legal_entity: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SsioAccountAddress".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "display" => intermediate_rep.display.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "purpose" => intermediate_rep.purpose.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "address_id" => intermediate_rep.address_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "order_legal_entity" => intermediate_rep.order_legal_entity.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SsioAccountAddress".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SsioAccountAddress {
            display: intermediate_rep.display.into_iter().next(),
            purpose: intermediate_rep.purpose.into_iter().next(),
            address_id: intermediate_rep.address_id.into_iter().next(),
            order_legal_entity: intermediate_rep.order_legal_entity.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SsioAccountAddress> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SsioAccountAddress>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SsioAccountAddress>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SsioAccountAddress - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SsioAccountAddress> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SsioAccountAddress as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SsioAccountAddress - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SsioAccountItem {
/// Salesforce id for billto_info
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Salesforce id for IO Terms and Conditions
    #[serde(rename = "io_terms_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub io_terms_id: Option<String>,

/// Salesforce text for IO Terms and Conditions
    #[serde(rename = "io_terms")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub io_terms: Option<String>,

/// Salesforce id for US Terms and Conditions
    #[serde(rename = "us_terms_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub us_terms_id: Option<String>,

/// Salesforce text for US Terms and Conditions
    #[serde(rename = "us_terms")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub us_terms: Option<String>,

/// Salesforce id for Rest of the World Terms and Conditions
    #[serde(rename = "row_terms_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub row_terms_id: Option<String>,

/// Salesforce text for Rest of the World Terms and Conditions
    #[serde(rename = "row_terms")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub row_terms: Option<String>,

/// Insertion Order Type - Pinterest Paper or Agency Paper
    #[serde(rename = "io_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub io_type: Option<String>,

/// Address information that is associated with this account.
    #[serde(rename = "addresses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub addresses: Option<Vec<models::SsioAccountAddress>>,

}


impl SsioAccountItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SsioAccountItem {
        SsioAccountItem {
            id: None,
            io_terms_id: None,
            io_terms: None,
            us_terms_id: None,
            us_terms: None,
            row_terms_id: None,
            row_terms: None,
            io_type: None,
            addresses: None,
        }
    }
}

/// Converts the SsioAccountItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SsioAccountItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.io_terms_id.as_ref().map(|io_terms_id| {
                [
                    "io_terms_id".to_string(),
                    io_terms_id.to_string(),
                ].join(",")
            }),


            self.io_terms.as_ref().map(|io_terms| {
                [
                    "io_terms".to_string(),
                    io_terms.to_string(),
                ].join(",")
            }),


            self.us_terms_id.as_ref().map(|us_terms_id| {
                [
                    "us_terms_id".to_string(),
                    us_terms_id.to_string(),
                ].join(",")
            }),


            self.us_terms.as_ref().map(|us_terms| {
                [
                    "us_terms".to_string(),
                    us_terms.to_string(),
                ].join(",")
            }),


            self.row_terms_id.as_ref().map(|row_terms_id| {
                [
                    "row_terms_id".to_string(),
                    row_terms_id.to_string(),
                ].join(",")
            }),


            self.row_terms.as_ref().map(|row_terms| {
                [
                    "row_terms".to_string(),
                    row_terms.to_string(),
                ].join(",")
            }),


            self.io_type.as_ref().map(|io_type| {
                [
                    "io_type".to_string(),
                    io_type.to_string(),
                ].join(",")
            }),

            // Skipping addresses in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SsioAccountItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SsioAccountItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub io_terms_id: Vec<String>,
            pub io_terms: Vec<String>,
            pub us_terms_id: Vec<String>,
            pub us_terms: Vec<String>,
            pub row_terms_id: Vec<String>,
            pub row_terms: Vec<String>,
            pub io_type: Vec<String>,
            pub addresses: Vec<Vec<models::SsioAccountAddress>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SsioAccountItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "io_terms_id" => intermediate_rep.io_terms_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "io_terms" => intermediate_rep.io_terms.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "us_terms_id" => intermediate_rep.us_terms_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "us_terms" => intermediate_rep.us_terms.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "row_terms_id" => intermediate_rep.row_terms_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "row_terms" => intermediate_rep.row_terms.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "io_type" => intermediate_rep.io_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "addresses" => return std::result::Result::Err("Parsing a container in this style is not supported in SsioAccountItem".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SsioAccountItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SsioAccountItem {
            id: intermediate_rep.id.into_iter().next(),
            io_terms_id: intermediate_rep.io_terms_id.into_iter().next(),
            io_terms: intermediate_rep.io_terms.into_iter().next(),
            us_terms_id: intermediate_rep.us_terms_id.into_iter().next(),
            us_terms: intermediate_rep.us_terms.into_iter().next(),
            row_terms_id: intermediate_rep.row_terms_id.into_iter().next(),
            row_terms: intermediate_rep.row_terms.into_iter().next(),
            io_type: intermediate_rep.io_type.into_iter().next(),
            addresses: intermediate_rep.addresses.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SsioAccountItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SsioAccountItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SsioAccountItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SsioAccountItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SsioAccountItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SsioAccountItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SsioAccountItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SsioAccountPmpName {
/// Display name
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Salesforce id for PMP
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}


impl SsioAccountPmpName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SsioAccountPmpName {
        SsioAccountPmpName {
            name: None,
            id: None,
        }
    }
}

/// Converts the SsioAccountPmpName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SsioAccountPmpName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SsioAccountPmpName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SsioAccountPmpName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SsioAccountPmpName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SsioAccountPmpName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SsioAccountPmpName {
            name: intermediate_rep.name.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SsioAccountPmpName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SsioAccountPmpName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SsioAccountPmpName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SsioAccountPmpName - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SsioAccountPmpName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SsioAccountPmpName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SsioAccountPmpName - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SsioAccountResponse {
/// Advertiser eligible to create order lines
    #[serde(rename = "eligible")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub eligible: Option<bool>,

/// Advertiser eligible to update order lines
    #[serde(rename = "can_edit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub can_edit: Option<bool>,

/// An array of Salesforce account information that includes address, io terms, etc.
    #[serde(rename = "billto_infos")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billto_infos: Option<Vec<models::SsioAccountItem>>,

    #[serde(rename = "currency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency: Option<String>,

    #[serde(rename = "pmp_names")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pmp_names: Option<Vec<models::SsioAccountPmpName>>,

/// Error indicator from Salesforce which could be \"No Error\"
    #[serde(rename = "error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<String>,

}


impl SsioAccountResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SsioAccountResponse {
        SsioAccountResponse {
            eligible: None,
            can_edit: None,
            billto_infos: None,
            currency: None,
            pmp_names: None,
            error: None,
        }
    }
}

/// Converts the SsioAccountResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SsioAccountResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.eligible.as_ref().map(|eligible| {
                [
                    "eligible".to_string(),
                    eligible.to_string(),
                ].join(",")
            }),


            self.can_edit.as_ref().map(|can_edit| {
                [
                    "can_edit".to_string(),
                    can_edit.to_string(),
                ].join(",")
            }),

            // Skipping billto_infos in query parameter serialization


            self.currency.as_ref().map(|currency| {
                [
                    "currency".to_string(),
                    currency.to_string(),
                ].join(",")
            }),

            // Skipping pmp_names in query parameter serialization


            self.error.as_ref().map(|error| {
                [
                    "error".to_string(),
                    error.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SsioAccountResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SsioAccountResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub eligible: Vec<bool>,
            pub can_edit: Vec<bool>,
            pub billto_infos: Vec<Vec<models::SsioAccountItem>>,
            pub currency: Vec<String>,
            pub pmp_names: Vec<Vec<models::SsioAccountPmpName>>,
            pub error: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SsioAccountResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "eligible" => intermediate_rep.eligible.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "can_edit" => intermediate_rep.can_edit.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "billto_infos" => return std::result::Result::Err("Parsing a container in this style is not supported in SsioAccountResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "currency" => intermediate_rep.currency.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pmp_names" => return std::result::Result::Err("Parsing a container in this style is not supported in SsioAccountResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SsioAccountResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SsioAccountResponse {
            eligible: intermediate_rep.eligible.into_iter().next(),
            can_edit: intermediate_rep.can_edit.into_iter().next(),
            billto_infos: intermediate_rep.billto_infos.into_iter().next(),
            currency: intermediate_rep.currency.into_iter().next(),
            pmp_names: intermediate_rep.pmp_names.into_iter().next(),
            error: intermediate_rep.error.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SsioAccountResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SsioAccountResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SsioAccountResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SsioAccountResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SsioAccountResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SsioAccountResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SsioAccountResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SsioCreateInsertionOrderRequest {
/// Starting date of time period. Format: YYYY-MM-DD
    #[serde(rename = "start_date")]
    #[validate(
           regex = "RE_SSIOCREATEINSERTIONORDERREQUEST_START_DATE",
        )]
    pub start_date: String,

/// End date of time period. Format: YYYY-MM-DD
    #[serde(rename = "end_date")]
    #[validate(
           regex = "RE_SSIOCREATEINSERTIONORDERREQUEST_END_DATE",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_date: Option<String>,

/// The po number
    #[serde(rename = "po_number")]
    pub po_number: String,

/// If Budget order line, the budget amount.
    #[serde(rename = "budget_amount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget_amount: Option<f64>,

/// The billing contact first name
    #[serde(rename = "billing_contact_firstname")]
    pub billing_contact_firstname: String,

/// The billing contact last name
    #[serde(rename = "billing_contact_lastname")]
    pub billing_contact_lastname: String,

/// The billing contact email
    #[serde(rename = "billing_contact_email")]
    pub billing_contact_email: String,

/// The media contact first name
    #[serde(rename = "media_contact_firstname")]
    pub media_contact_firstname: String,

/// The media contact last name
    #[serde(rename = "media_contact_lastname")]
    pub media_contact_lastname: String,

/// The media contact email
    #[serde(rename = "media_contact_email")]
    pub media_contact_email: String,

/// URL link for agency
    #[serde(rename = "agency_link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub agency_link: Option<String>,

/// The email of user submitting the insertion order
    #[serde(rename = "user_email")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_email: Option<String>,

/// The UTC timestamp (to the nearest sec) of when terms were accepted
    #[serde(rename = "accepted_terms_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub accepted_terms_time: Option<i32>,

/// The pmp id
    #[serde(rename = "pmp_id")]
    pub pmp_id: String,

/// The order name
    #[serde(rename = "order_name")]
    pub order_name: String,

/// Type can be Budget or Perpetual
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "order_line_type")]
    pub order_line_type: String,

/// The SFDC id for the terms
    #[serde(rename = "accepted_terms_id")]
    pub accepted_terms_id: String,

/// The bill-to company id
    #[serde(rename = "billto_company_id")]
    pub billto_company_id: String,

/// The bill-to business address id
    #[serde(rename = "billto_business_address_id")]
    pub billto_business_address_id: String,

/// The bill-to billing address id
    #[serde(rename = "billto_billing_address_id")]
    pub billto_billing_address_id: String,

/// If Ongoing (perpetual) order line, the estimated monthly spend
    #[serde(rename = "estimated_monthly_spend")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub estimated_monthly_spend: Option<f64>,

    #[serde(rename = "currency_info")]
    pub currency_info: models::Currency,

}

lazy_static::lazy_static! {
    static ref RE_SSIOCREATEINSERTIONORDERREQUEST_START_DATE: regex::Regex = regex::Regex::new(r"^(\\d{4})-(\\d{2})-(\\d{2})$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_SSIOCREATEINSERTIONORDERREQUEST_END_DATE: regex::Regex = regex::Regex::new(r"^(\\d{4})-(\\d{2})-(\\d{2})$").unwrap();
}

impl SsioCreateInsertionOrderRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(start_date: String, po_number: String, billing_contact_firstname: String, billing_contact_lastname: String, billing_contact_email: String, media_contact_firstname: String, media_contact_lastname: String, media_contact_email: String, pmp_id: String, order_name: String, order_line_type: String, accepted_terms_id: String, billto_company_id: String, billto_business_address_id: String, billto_billing_address_id: String, currency_info: models::Currency, ) -> SsioCreateInsertionOrderRequest {
        SsioCreateInsertionOrderRequest {
            start_date,
            end_date: None,
            po_number,
            budget_amount: None,
            billing_contact_firstname,
            billing_contact_lastname,
            billing_contact_email,
            media_contact_firstname,
            media_contact_lastname,
            media_contact_email,
            agency_link: None,
            user_email: None,
            accepted_terms_time: None,
            pmp_id,
            order_name,
            order_line_type,
            accepted_terms_id,
            billto_company_id,
            billto_business_address_id,
            billto_billing_address_id,
            estimated_monthly_spend: None,
            currency_info,
        }
    }
}

/// Converts the SsioCreateInsertionOrderRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SsioCreateInsertionOrderRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("start_date".to_string()),
            Some(self.start_date.to_string()),


            self.end_date.as_ref().map(|end_date| {
                [
                    "end_date".to_string(),
                    end_date.to_string(),
                ].join(",")
            }),


            Some("po_number".to_string()),
            Some(self.po_number.to_string()),


            self.budget_amount.as_ref().map(|budget_amount| {
                [
                    "budget_amount".to_string(),
                    budget_amount.to_string(),
                ].join(",")
            }),


            Some("billing_contact_firstname".to_string()),
            Some(self.billing_contact_firstname.to_string()),


            Some("billing_contact_lastname".to_string()),
            Some(self.billing_contact_lastname.to_string()),


            Some("billing_contact_email".to_string()),
            Some(self.billing_contact_email.to_string()),


            Some("media_contact_firstname".to_string()),
            Some(self.media_contact_firstname.to_string()),


            Some("media_contact_lastname".to_string()),
            Some(self.media_contact_lastname.to_string()),


            Some("media_contact_email".to_string()),
            Some(self.media_contact_email.to_string()),


            self.agency_link.as_ref().map(|agency_link| {
                [
                    "agency_link".to_string(),
                    agency_link.to_string(),
                ].join(",")
            }),


            self.user_email.as_ref().map(|user_email| {
                [
                    "user_email".to_string(),
                    user_email.to_string(),
                ].join(",")
            }),


            self.accepted_terms_time.as_ref().map(|accepted_terms_time| {
                [
                    "accepted_terms_time".to_string(),
                    accepted_terms_time.to_string(),
                ].join(",")
            }),


            Some("pmp_id".to_string()),
            Some(self.pmp_id.to_string()),


            Some("order_name".to_string()),
            Some(self.order_name.to_string()),


            Some("order_line_type".to_string()),
            Some(self.order_line_type.to_string()),


            Some("accepted_terms_id".to_string()),
            Some(self.accepted_terms_id.to_string()),


            Some("billto_company_id".to_string()),
            Some(self.billto_company_id.to_string()),


            Some("billto_business_address_id".to_string()),
            Some(self.billto_business_address_id.to_string()),


            Some("billto_billing_address_id".to_string()),
            Some(self.billto_billing_address_id.to_string()),


            self.estimated_monthly_spend.as_ref().map(|estimated_monthly_spend| {
                [
                    "estimated_monthly_spend".to_string(),
                    estimated_monthly_spend.to_string(),
                ].join(",")
            }),

            // Skipping currency_info in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SsioCreateInsertionOrderRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SsioCreateInsertionOrderRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub start_date: Vec<String>,
            pub end_date: Vec<String>,
            pub po_number: Vec<String>,
            pub budget_amount: Vec<f64>,
            pub billing_contact_firstname: Vec<String>,
            pub billing_contact_lastname: Vec<String>,
            pub billing_contact_email: Vec<String>,
            pub media_contact_firstname: Vec<String>,
            pub media_contact_lastname: Vec<String>,
            pub media_contact_email: Vec<String>,
            pub agency_link: Vec<String>,
            pub user_email: Vec<String>,
            pub accepted_terms_time: Vec<i32>,
            pub pmp_id: Vec<String>,
            pub order_name: Vec<String>,
            pub order_line_type: Vec<String>,
            pub accepted_terms_id: Vec<String>,
            pub billto_company_id: Vec<String>,
            pub billto_business_address_id: Vec<String>,
            pub billto_billing_address_id: Vec<String>,
            pub estimated_monthly_spend: Vec<f64>,
            pub currency_info: Vec<models::Currency>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SsioCreateInsertionOrderRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "start_date" => intermediate_rep.start_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end_date" => intermediate_rep.end_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "po_number" => intermediate_rep.po_number.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "budget_amount" => intermediate_rep.budget_amount.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billing_contact_firstname" => intermediate_rep.billing_contact_firstname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billing_contact_lastname" => intermediate_rep.billing_contact_lastname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billing_contact_email" => intermediate_rep.billing_contact_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media_contact_firstname" => intermediate_rep.media_contact_firstname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media_contact_lastname" => intermediate_rep.media_contact_lastname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media_contact_email" => intermediate_rep.media_contact_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "agency_link" => intermediate_rep.agency_link.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user_email" => intermediate_rep.user_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "accepted_terms_time" => intermediate_rep.accepted_terms_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pmp_id" => intermediate_rep.pmp_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "order_name" => intermediate_rep.order_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "order_line_type" => intermediate_rep.order_line_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "accepted_terms_id" => intermediate_rep.accepted_terms_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billto_company_id" => intermediate_rep.billto_company_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billto_business_address_id" => intermediate_rep.billto_business_address_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billto_billing_address_id" => intermediate_rep.billto_billing_address_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "estimated_monthly_spend" => intermediate_rep.estimated_monthly_spend.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currency_info" => intermediate_rep.currency_info.push(<models::Currency as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SsioCreateInsertionOrderRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SsioCreateInsertionOrderRequest {
            start_date: intermediate_rep.start_date.into_iter().next().ok_or_else(|| "start_date missing in SsioCreateInsertionOrderRequest".to_string())?,
            end_date: intermediate_rep.end_date.into_iter().next(),
            po_number: intermediate_rep.po_number.into_iter().next().ok_or_else(|| "po_number missing in SsioCreateInsertionOrderRequest".to_string())?,
            budget_amount: intermediate_rep.budget_amount.into_iter().next(),
            billing_contact_firstname: intermediate_rep.billing_contact_firstname.into_iter().next().ok_or_else(|| "billing_contact_firstname missing in SsioCreateInsertionOrderRequest".to_string())?,
            billing_contact_lastname: intermediate_rep.billing_contact_lastname.into_iter().next().ok_or_else(|| "billing_contact_lastname missing in SsioCreateInsertionOrderRequest".to_string())?,
            billing_contact_email: intermediate_rep.billing_contact_email.into_iter().next().ok_or_else(|| "billing_contact_email missing in SsioCreateInsertionOrderRequest".to_string())?,
            media_contact_firstname: intermediate_rep.media_contact_firstname.into_iter().next().ok_or_else(|| "media_contact_firstname missing in SsioCreateInsertionOrderRequest".to_string())?,
            media_contact_lastname: intermediate_rep.media_contact_lastname.into_iter().next().ok_or_else(|| "media_contact_lastname missing in SsioCreateInsertionOrderRequest".to_string())?,
            media_contact_email: intermediate_rep.media_contact_email.into_iter().next().ok_or_else(|| "media_contact_email missing in SsioCreateInsertionOrderRequest".to_string())?,
            agency_link: intermediate_rep.agency_link.into_iter().next(),
            user_email: intermediate_rep.user_email.into_iter().next(),
            accepted_terms_time: intermediate_rep.accepted_terms_time.into_iter().next(),
            pmp_id: intermediate_rep.pmp_id.into_iter().next().ok_or_else(|| "pmp_id missing in SsioCreateInsertionOrderRequest".to_string())?,
            order_name: intermediate_rep.order_name.into_iter().next().ok_or_else(|| "order_name missing in SsioCreateInsertionOrderRequest".to_string())?,
            order_line_type: intermediate_rep.order_line_type.into_iter().next().ok_or_else(|| "order_line_type missing in SsioCreateInsertionOrderRequest".to_string())?,
            accepted_terms_id: intermediate_rep.accepted_terms_id.into_iter().next().ok_or_else(|| "accepted_terms_id missing in SsioCreateInsertionOrderRequest".to_string())?,
            billto_company_id: intermediate_rep.billto_company_id.into_iter().next().ok_or_else(|| "billto_company_id missing in SsioCreateInsertionOrderRequest".to_string())?,
            billto_business_address_id: intermediate_rep.billto_business_address_id.into_iter().next().ok_or_else(|| "billto_business_address_id missing in SsioCreateInsertionOrderRequest".to_string())?,
            billto_billing_address_id: intermediate_rep.billto_billing_address_id.into_iter().next().ok_or_else(|| "billto_billing_address_id missing in SsioCreateInsertionOrderRequest".to_string())?,
            estimated_monthly_spend: intermediate_rep.estimated_monthly_spend.into_iter().next(),
            currency_info: intermediate_rep.currency_info.into_iter().next().ok_or_else(|| "currency_info missing in SsioCreateInsertionOrderRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SsioCreateInsertionOrderRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SsioCreateInsertionOrderRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SsioCreateInsertionOrderRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SsioCreateInsertionOrderRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SsioCreateInsertionOrderRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SsioCreateInsertionOrderRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SsioCreateInsertionOrderRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SsioCreateInsertionOrderResponse {
/// Salesforce order id
    #[serde(rename = "pin_order_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pin_order_id: Option<String>,

}


impl SsioCreateInsertionOrderResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SsioCreateInsertionOrderResponse {
        SsioCreateInsertionOrderResponse {
            pin_order_id: None,
        }
    }
}

/// Converts the SsioCreateInsertionOrderResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SsioCreateInsertionOrderResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.pin_order_id.as_ref().map(|pin_order_id| {
                [
                    "pin_order_id".to_string(),
                    pin_order_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SsioCreateInsertionOrderResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SsioCreateInsertionOrderResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pin_order_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SsioCreateInsertionOrderResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pin_order_id" => intermediate_rep.pin_order_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SsioCreateInsertionOrderResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SsioCreateInsertionOrderResponse {
            pin_order_id: intermediate_rep.pin_order_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SsioCreateInsertionOrderResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SsioCreateInsertionOrderResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SsioCreateInsertionOrderResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SsioCreateInsertionOrderResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SsioCreateInsertionOrderResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SsioCreateInsertionOrderResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SsioCreateInsertionOrderResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SsioEditInsertionOrderRequest {
/// Starting date of time period. Format: YYYY-MM-DD
    #[serde(rename = "start_date")]
    #[validate(
           regex = "RE_SSIOEDITINSERTIONORDERREQUEST_START_DATE",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_date: Option<String>,

/// End date of time period. Format: YYYY-MM-DD
    #[serde(rename = "end_date")]
    #[validate(
           regex = "RE_SSIOEDITINSERTIONORDERREQUEST_END_DATE",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_date: Option<String>,

/// The po number
    #[serde(rename = "po_number")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub po_number: Option<String>,

/// If Budget order line, the budget amount.
    #[serde(rename = "budget_amount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget_amount: Option<f64>,

/// The billing contact first name
    #[serde(rename = "billing_contact_firstname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_contact_firstname: Option<String>,

/// The billing contact last name
    #[serde(rename = "billing_contact_lastname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_contact_lastname: Option<String>,

/// The billing contact email
    #[serde(rename = "billing_contact_email")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_contact_email: Option<String>,

/// The media contact first name
    #[serde(rename = "media_contact_firstname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_contact_firstname: Option<String>,

/// The media contact last name
    #[serde(rename = "media_contact_lastname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_contact_lastname: Option<String>,

/// The media contact email
    #[serde(rename = "media_contact_email")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_contact_email: Option<String>,

/// URL link for agency
    #[serde(rename = "agency_link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub agency_link: Option<String>,

/// The email of user submitting the insertion order
    #[serde(rename = "user_email")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_email: Option<String>,

/// LineId in the Oracle DB
    #[serde(rename = "oracle_line_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oracle_line_id: Option<String>,

/// OrderId in SFDC
    #[serde(rename = "salesforce_order_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub salesforce_order_id: Option<String>,

/// OrderLineId in SFDC
    #[serde(rename = "salesforce_order_line_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub salesforce_order_line_id: Option<String>,

/// Ads manager OrderLineId
    #[serde(rename = "ads_manager_order_line_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ads_manager_order_line_id: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_SSIOEDITINSERTIONORDERREQUEST_START_DATE: regex::Regex = regex::Regex::new(r"^(\\d{4})-(\\d{2})-(\\d{2})$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_SSIOEDITINSERTIONORDERREQUEST_END_DATE: regex::Regex = regex::Regex::new(r"^(\\d{4})-(\\d{2})-(\\d{2})$").unwrap();
}

impl SsioEditInsertionOrderRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SsioEditInsertionOrderRequest {
        SsioEditInsertionOrderRequest {
            start_date: None,
            end_date: None,
            po_number: None,
            budget_amount: None,
            billing_contact_firstname: None,
            billing_contact_lastname: None,
            billing_contact_email: None,
            media_contact_firstname: None,
            media_contact_lastname: None,
            media_contact_email: None,
            agency_link: None,
            user_email: None,
            oracle_line_id: None,
            salesforce_order_id: None,
            salesforce_order_line_id: None,
            ads_manager_order_line_id: None,
        }
    }
}

/// Converts the SsioEditInsertionOrderRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SsioEditInsertionOrderRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.start_date.as_ref().map(|start_date| {
                [
                    "start_date".to_string(),
                    start_date.to_string(),
                ].join(",")
            }),


            self.end_date.as_ref().map(|end_date| {
                [
                    "end_date".to_string(),
                    end_date.to_string(),
                ].join(",")
            }),


            self.po_number.as_ref().map(|po_number| {
                [
                    "po_number".to_string(),
                    po_number.to_string(),
                ].join(",")
            }),


            self.budget_amount.as_ref().map(|budget_amount| {
                [
                    "budget_amount".to_string(),
                    budget_amount.to_string(),
                ].join(",")
            }),


            self.billing_contact_firstname.as_ref().map(|billing_contact_firstname| {
                [
                    "billing_contact_firstname".to_string(),
                    billing_contact_firstname.to_string(),
                ].join(",")
            }),


            self.billing_contact_lastname.as_ref().map(|billing_contact_lastname| {
                [
                    "billing_contact_lastname".to_string(),
                    billing_contact_lastname.to_string(),
                ].join(",")
            }),


            self.billing_contact_email.as_ref().map(|billing_contact_email| {
                [
                    "billing_contact_email".to_string(),
                    billing_contact_email.to_string(),
                ].join(",")
            }),


            self.media_contact_firstname.as_ref().map(|media_contact_firstname| {
                [
                    "media_contact_firstname".to_string(),
                    media_contact_firstname.to_string(),
                ].join(",")
            }),


            self.media_contact_lastname.as_ref().map(|media_contact_lastname| {
                [
                    "media_contact_lastname".to_string(),
                    media_contact_lastname.to_string(),
                ].join(",")
            }),


            self.media_contact_email.as_ref().map(|media_contact_email| {
                [
                    "media_contact_email".to_string(),
                    media_contact_email.to_string(),
                ].join(",")
            }),


            self.agency_link.as_ref().map(|agency_link| {
                [
                    "agency_link".to_string(),
                    agency_link.to_string(),
                ].join(",")
            }),


            self.user_email.as_ref().map(|user_email| {
                [
                    "user_email".to_string(),
                    user_email.to_string(),
                ].join(",")
            }),


            self.oracle_line_id.as_ref().map(|oracle_line_id| {
                [
                    "oracle_line_id".to_string(),
                    oracle_line_id.to_string(),
                ].join(",")
            }),


            self.salesforce_order_id.as_ref().map(|salesforce_order_id| {
                [
                    "salesforce_order_id".to_string(),
                    salesforce_order_id.to_string(),
                ].join(",")
            }),


            self.salesforce_order_line_id.as_ref().map(|salesforce_order_line_id| {
                [
                    "salesforce_order_line_id".to_string(),
                    salesforce_order_line_id.to_string(),
                ].join(",")
            }),


            self.ads_manager_order_line_id.as_ref().map(|ads_manager_order_line_id| {
                [
                    "ads_manager_order_line_id".to_string(),
                    ads_manager_order_line_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SsioEditInsertionOrderRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SsioEditInsertionOrderRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub start_date: Vec<String>,
            pub end_date: Vec<String>,
            pub po_number: Vec<String>,
            pub budget_amount: Vec<f64>,
            pub billing_contact_firstname: Vec<String>,
            pub billing_contact_lastname: Vec<String>,
            pub billing_contact_email: Vec<String>,
            pub media_contact_firstname: Vec<String>,
            pub media_contact_lastname: Vec<String>,
            pub media_contact_email: Vec<String>,
            pub agency_link: Vec<String>,
            pub user_email: Vec<String>,
            pub oracle_line_id: Vec<String>,
            pub salesforce_order_id: Vec<String>,
            pub salesforce_order_line_id: Vec<String>,
            pub ads_manager_order_line_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SsioEditInsertionOrderRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "start_date" => intermediate_rep.start_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end_date" => intermediate_rep.end_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "po_number" => intermediate_rep.po_number.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "budget_amount" => intermediate_rep.budget_amount.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billing_contact_firstname" => intermediate_rep.billing_contact_firstname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billing_contact_lastname" => intermediate_rep.billing_contact_lastname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billing_contact_email" => intermediate_rep.billing_contact_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media_contact_firstname" => intermediate_rep.media_contact_firstname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media_contact_lastname" => intermediate_rep.media_contact_lastname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media_contact_email" => intermediate_rep.media_contact_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "agency_link" => intermediate_rep.agency_link.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user_email" => intermediate_rep.user_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "oracle_line_id" => intermediate_rep.oracle_line_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "salesforce_order_id" => intermediate_rep.salesforce_order_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "salesforce_order_line_id" => intermediate_rep.salesforce_order_line_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ads_manager_order_line_id" => intermediate_rep.ads_manager_order_line_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SsioEditInsertionOrderRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SsioEditInsertionOrderRequest {
            start_date: intermediate_rep.start_date.into_iter().next(),
            end_date: intermediate_rep.end_date.into_iter().next(),
            po_number: intermediate_rep.po_number.into_iter().next(),
            budget_amount: intermediate_rep.budget_amount.into_iter().next(),
            billing_contact_firstname: intermediate_rep.billing_contact_firstname.into_iter().next(),
            billing_contact_lastname: intermediate_rep.billing_contact_lastname.into_iter().next(),
            billing_contact_email: intermediate_rep.billing_contact_email.into_iter().next(),
            media_contact_firstname: intermediate_rep.media_contact_firstname.into_iter().next(),
            media_contact_lastname: intermediate_rep.media_contact_lastname.into_iter().next(),
            media_contact_email: intermediate_rep.media_contact_email.into_iter().next(),
            agency_link: intermediate_rep.agency_link.into_iter().next(),
            user_email: intermediate_rep.user_email.into_iter().next(),
            oracle_line_id: intermediate_rep.oracle_line_id.into_iter().next(),
            salesforce_order_id: intermediate_rep.salesforce_order_id.into_iter().next(),
            salesforce_order_line_id: intermediate_rep.salesforce_order_line_id.into_iter().next(),
            ads_manager_order_line_id: intermediate_rep.ads_manager_order_line_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SsioEditInsertionOrderRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SsioEditInsertionOrderRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SsioEditInsertionOrderRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SsioEditInsertionOrderRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SsioEditInsertionOrderRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SsioEditInsertionOrderRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SsioEditInsertionOrderRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SsioEditInsertionOrderResponse {
/// Salesforce order id
    #[serde(rename = "pin_order_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pin_order_id: Option<String>,

}


impl SsioEditInsertionOrderResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SsioEditInsertionOrderResponse {
        SsioEditInsertionOrderResponse {
            pin_order_id: None,
        }
    }
}

/// Converts the SsioEditInsertionOrderResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SsioEditInsertionOrderResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.pin_order_id.as_ref().map(|pin_order_id| {
                [
                    "pin_order_id".to_string(),
                    pin_order_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SsioEditInsertionOrderResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SsioEditInsertionOrderResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pin_order_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SsioEditInsertionOrderResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pin_order_id" => intermediate_rep.pin_order_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SsioEditInsertionOrderResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SsioEditInsertionOrderResponse {
            pin_order_id: intermediate_rep.pin_order_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SsioEditInsertionOrderResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SsioEditInsertionOrderResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SsioEditInsertionOrderResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SsioEditInsertionOrderResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SsioEditInsertionOrderResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SsioEditInsertionOrderResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SsioEditInsertionOrderResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SsioInsertionOrderCommon {
/// Starting date of time period. Format: YYYY-MM-DD
    #[serde(rename = "start_date")]
    #[validate(
           regex = "RE_SSIOINSERTIONORDERCOMMON_START_DATE",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_date: Option<String>,

/// End date of time period. Format: YYYY-MM-DD
    #[serde(rename = "end_date")]
    #[validate(
           regex = "RE_SSIOINSERTIONORDERCOMMON_END_DATE",
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_date: Option<String>,

/// The po number
    #[serde(rename = "po_number")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub po_number: Option<String>,

/// If Budget order line, the budget amount.
    #[serde(rename = "budget_amount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget_amount: Option<f64>,

/// The billing contact first name
    #[serde(rename = "billing_contact_firstname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_contact_firstname: Option<String>,

/// The billing contact last name
    #[serde(rename = "billing_contact_lastname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_contact_lastname: Option<String>,

/// The billing contact email
    #[serde(rename = "billing_contact_email")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_contact_email: Option<String>,

/// The media contact first name
    #[serde(rename = "media_contact_firstname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_contact_firstname: Option<String>,

/// The media contact last name
    #[serde(rename = "media_contact_lastname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_contact_lastname: Option<String>,

/// The media contact email
    #[serde(rename = "media_contact_email")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_contact_email: Option<String>,

/// URL link for agency
    #[serde(rename = "agency_link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub agency_link: Option<String>,

/// The email of user submitting the insertion order
    #[serde(rename = "user_email")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_email: Option<String>,

}

lazy_static::lazy_static! {
    static ref RE_SSIOINSERTIONORDERCOMMON_START_DATE: regex::Regex = regex::Regex::new(r"^(\\d{4})-(\\d{2})-(\\d{2})$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_SSIOINSERTIONORDERCOMMON_END_DATE: regex::Regex = regex::Regex::new(r"^(\\d{4})-(\\d{2})-(\\d{2})$").unwrap();
}

impl SsioInsertionOrderCommon {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SsioInsertionOrderCommon {
        SsioInsertionOrderCommon {
            start_date: None,
            end_date: None,
            po_number: None,
            budget_amount: None,
            billing_contact_firstname: None,
            billing_contact_lastname: None,
            billing_contact_email: None,
            media_contact_firstname: None,
            media_contact_lastname: None,
            media_contact_email: None,
            agency_link: None,
            user_email: None,
        }
    }
}

/// Converts the SsioInsertionOrderCommon value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SsioInsertionOrderCommon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.start_date.as_ref().map(|start_date| {
                [
                    "start_date".to_string(),
                    start_date.to_string(),
                ].join(",")
            }),


            self.end_date.as_ref().map(|end_date| {
                [
                    "end_date".to_string(),
                    end_date.to_string(),
                ].join(",")
            }),


            self.po_number.as_ref().map(|po_number| {
                [
                    "po_number".to_string(),
                    po_number.to_string(),
                ].join(",")
            }),


            self.budget_amount.as_ref().map(|budget_amount| {
                [
                    "budget_amount".to_string(),
                    budget_amount.to_string(),
                ].join(",")
            }),


            self.billing_contact_firstname.as_ref().map(|billing_contact_firstname| {
                [
                    "billing_contact_firstname".to_string(),
                    billing_contact_firstname.to_string(),
                ].join(",")
            }),


            self.billing_contact_lastname.as_ref().map(|billing_contact_lastname| {
                [
                    "billing_contact_lastname".to_string(),
                    billing_contact_lastname.to_string(),
                ].join(",")
            }),


            self.billing_contact_email.as_ref().map(|billing_contact_email| {
                [
                    "billing_contact_email".to_string(),
                    billing_contact_email.to_string(),
                ].join(",")
            }),


            self.media_contact_firstname.as_ref().map(|media_contact_firstname| {
                [
                    "media_contact_firstname".to_string(),
                    media_contact_firstname.to_string(),
                ].join(",")
            }),


            self.media_contact_lastname.as_ref().map(|media_contact_lastname| {
                [
                    "media_contact_lastname".to_string(),
                    media_contact_lastname.to_string(),
                ].join(",")
            }),


            self.media_contact_email.as_ref().map(|media_contact_email| {
                [
                    "media_contact_email".to_string(),
                    media_contact_email.to_string(),
                ].join(",")
            }),


            self.agency_link.as_ref().map(|agency_link| {
                [
                    "agency_link".to_string(),
                    agency_link.to_string(),
                ].join(",")
            }),


            self.user_email.as_ref().map(|user_email| {
                [
                    "user_email".to_string(),
                    user_email.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SsioInsertionOrderCommon value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SsioInsertionOrderCommon {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub start_date: Vec<String>,
            pub end_date: Vec<String>,
            pub po_number: Vec<String>,
            pub budget_amount: Vec<f64>,
            pub billing_contact_firstname: Vec<String>,
            pub billing_contact_lastname: Vec<String>,
            pub billing_contact_email: Vec<String>,
            pub media_contact_firstname: Vec<String>,
            pub media_contact_lastname: Vec<String>,
            pub media_contact_email: Vec<String>,
            pub agency_link: Vec<String>,
            pub user_email: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SsioInsertionOrderCommon".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "start_date" => intermediate_rep.start_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end_date" => intermediate_rep.end_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "po_number" => intermediate_rep.po_number.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "budget_amount" => intermediate_rep.budget_amount.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billing_contact_firstname" => intermediate_rep.billing_contact_firstname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billing_contact_lastname" => intermediate_rep.billing_contact_lastname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "billing_contact_email" => intermediate_rep.billing_contact_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media_contact_firstname" => intermediate_rep.media_contact_firstname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media_contact_lastname" => intermediate_rep.media_contact_lastname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "media_contact_email" => intermediate_rep.media_contact_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "agency_link" => intermediate_rep.agency_link.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user_email" => intermediate_rep.user_email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SsioInsertionOrderCommon".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SsioInsertionOrderCommon {
            start_date: intermediate_rep.start_date.into_iter().next(),
            end_date: intermediate_rep.end_date.into_iter().next(),
            po_number: intermediate_rep.po_number.into_iter().next(),
            budget_amount: intermediate_rep.budget_amount.into_iter().next(),
            billing_contact_firstname: intermediate_rep.billing_contact_firstname.into_iter().next(),
            billing_contact_lastname: intermediate_rep.billing_contact_lastname.into_iter().next(),
            billing_contact_email: intermediate_rep.billing_contact_email.into_iter().next(),
            media_contact_firstname: intermediate_rep.media_contact_firstname.into_iter().next(),
            media_contact_lastname: intermediate_rep.media_contact_lastname.into_iter().next(),
            media_contact_email: intermediate_rep.media_contact_email.into_iter().next(),
            agency_link: intermediate_rep.agency_link.into_iter().next(),
            user_email: intermediate_rep.user_email.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SsioInsertionOrderCommon> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SsioInsertionOrderCommon>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SsioInsertionOrderCommon>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SsioInsertionOrderCommon - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SsioInsertionOrderCommon> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SsioInsertionOrderCommon as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SsioInsertionOrderCommon - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SsioInsertionOrderStatus {
/// Salesforce order id
    #[serde(rename = "pin_order_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pin_order_id: Option<String>,

/// Salesforce insertion order status
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

/// Salesforce insertion order creation time
    #[serde(rename = "creation_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creation_time: Option<Nullable<String>>,

}


impl SsioInsertionOrderStatus {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SsioInsertionOrderStatus {
        SsioInsertionOrderStatus {
            pin_order_id: None,
            status: None,
            creation_time: None,
        }
    }
}

/// Converts the SsioInsertionOrderStatus value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SsioInsertionOrderStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.pin_order_id.as_ref().map(|pin_order_id| {
                [
                    "pin_order_id".to_string(),
                    pin_order_id.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),


            self.creation_time.as_ref().map(|creation_time| {
                [
                    "creation_time".to_string(),
                    creation_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SsioInsertionOrderStatus value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SsioInsertionOrderStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pin_order_id: Vec<String>,
            pub status: Vec<String>,
            pub creation_time: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SsioInsertionOrderStatus".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pin_order_id" => intermediate_rep.pin_order_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "creation_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioInsertionOrderStatus".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SsioInsertionOrderStatus".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SsioInsertionOrderStatus {
            pin_order_id: intermediate_rep.pin_order_id.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            creation_time: std::result::Result::Err("Nullable types not supported in SsioInsertionOrderStatus".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SsioInsertionOrderStatus> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SsioInsertionOrderStatus>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SsioInsertionOrderStatus>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SsioInsertionOrderStatus - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SsioInsertionOrderStatus> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SsioInsertionOrderStatus as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SsioInsertionOrderStatus - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SsioInsertionOrderStatusResponse {
/// Salesforce order id
    #[serde(rename = "pin_order_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pin_order_id: Option<String>,

/// Salesforce insertion order status
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

/// Salesforce insertion order creation time
    #[serde(rename = "creation_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creation_time: Option<Nullable<String>>,

}


impl SsioInsertionOrderStatusResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SsioInsertionOrderStatusResponse {
        SsioInsertionOrderStatusResponse {
            pin_order_id: None,
            status: None,
            creation_time: None,
        }
    }
}

/// Converts the SsioInsertionOrderStatusResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SsioInsertionOrderStatusResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.pin_order_id.as_ref().map(|pin_order_id| {
                [
                    "pin_order_id".to_string(),
                    pin_order_id.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),


            self.creation_time.as_ref().map(|creation_time| {
                [
                    "creation_time".to_string(),
                    creation_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SsioInsertionOrderStatusResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SsioInsertionOrderStatusResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pin_order_id: Vec<String>,
            pub status: Vec<String>,
            pub creation_time: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SsioInsertionOrderStatusResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pin_order_id" => intermediate_rep.pin_order_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "creation_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioInsertionOrderStatusResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SsioInsertionOrderStatusResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SsioInsertionOrderStatusResponse {
            pin_order_id: intermediate_rep.pin_order_id.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            creation_time: std::result::Result::Err("Nullable types not supported in SsioInsertionOrderStatusResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SsioInsertionOrderStatusResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SsioInsertionOrderStatusResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SsioInsertionOrderStatusResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SsioInsertionOrderStatusResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SsioInsertionOrderStatusResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SsioInsertionOrderStatusResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SsioInsertionOrderStatusResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SsioInsertionOrdersStatusGetByAdAccount200Response {
/// Insertion orders status by ad acount id
    #[serde(rename = "items")]
    pub items: Vec<models::SsioInsertionOrderStatus>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl SsioInsertionOrdersStatusGetByAdAccount200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::SsioInsertionOrderStatus>, ) -> SsioInsertionOrdersStatusGetByAdAccount200Response {
        SsioInsertionOrdersStatusGetByAdAccount200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the SsioInsertionOrdersStatusGetByAdAccount200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SsioInsertionOrdersStatusGetByAdAccount200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SsioInsertionOrdersStatusGetByAdAccount200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SsioInsertionOrdersStatusGetByAdAccount200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::SsioInsertionOrderStatus>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SsioInsertionOrdersStatusGetByAdAccount200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in SsioInsertionOrdersStatusGetByAdAccount200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioInsertionOrdersStatusGetByAdAccount200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SsioInsertionOrdersStatusGetByAdAccount200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SsioInsertionOrdersStatusGetByAdAccount200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in SsioInsertionOrdersStatusGetByAdAccount200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in SsioInsertionOrdersStatusGetByAdAccount200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SsioInsertionOrdersStatusGetByAdAccount200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SsioInsertionOrdersStatusGetByAdAccount200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SsioInsertionOrdersStatusGetByAdAccount200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SsioInsertionOrdersStatusGetByAdAccount200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SsioInsertionOrdersStatusGetByAdAccount200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SsioInsertionOrdersStatusGetByAdAccount200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SsioInsertionOrdersStatusGetByAdAccount200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SsioOrderLine {
/// OrderLineId in SFDC
    #[serde(rename = "salesforce_order_line_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub salesforce_order_line_id: Option<Nullable<String>>,

/// Ads manager OrderLineId
    #[serde(rename = "ads_manager_order_line_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ads_manager_order_line_id: Option<Nullable<String>>,

/// The pin order id associated with the order line in SFDC
    #[serde(rename = "pin_order_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pin_order_id: Option<Nullable<String>>,

/// Last modified date.
    #[serde(rename = "last_modified_date_time")]
    #[validate(
           regex = "RE_SSIOORDERLINE_LAST_MODIFIED_DATE_TIME",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_modified_date_time: Option<Nullable<String>>,

/// Start date of the order line.
    #[serde(rename = "start_date")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_date: Option<Nullable<chrono::naive::NaiveDate>>,

/// End date of the order line.
    #[serde(rename = "end_date")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_date: Option<Nullable<chrono::naive::NaiveDate>>,

/// Bill To Company name
    #[serde(rename = "bill_to_company_name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bill_to_company_name: Option<Nullable<String>>,

/// Billing contact first name
    #[serde(rename = "billing_contact_firstname")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_contact_firstname: Option<Nullable<String>>,

/// Billing contact last name
    #[serde(rename = "billing_contact_lastname")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_contact_lastname: Option<Nullable<String>>,

/// Billing contact email
    #[serde(rename = "billing_contact_email")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_contact_email: Option<Nullable<String>>,

/// Billing media email
    #[serde(rename = "media_contact_email")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_contact_email: Option<Nullable<String>>,

/// Billing contact first name
    #[serde(rename = "media_contact_firstname")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_contact_firstname: Option<Nullable<String>>,

/// Billing contact first name
    #[serde(rename = "media_contact_lastname")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_contact_lastname: Option<Nullable<String>>,

    #[serde(rename = "currency_info")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency_info: Option<models::Currency>,

/// Agency link
    #[serde(rename = "agency_link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub agency_link: Option<Nullable<String>>,

/// The po number
    #[serde(rename = "po_number")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub po_number: Option<Nullable<String>>,

/// The order name
    #[serde(rename = "order_name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_name: Option<Nullable<String>>,

/// The Pinterest marketing partner name
    #[serde(rename = "pmp_name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pmp_name: Option<Nullable<String>>,

/// The SFDC id for the terms
    #[serde(rename = "accepted_terms_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub accepted_terms_id: Option<Nullable<String>>,

/// The UTC timestamp (to the nearest sec) of when terms were accepted
    #[serde(rename = "accepted_terms_time")]
    #[validate(
           regex = "RE_SSIOORDERLINE_ACCEPTED_TERMS_TIME",
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub accepted_terms_time: Option<Nullable<String>>,

/// If Budget order line, the budget amount.
    #[serde(rename = "budget_amount")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget_amount: Option<Nullable<f64>>,

/// If Ongoing (perpetual) order line, the estimated monthly spend
    #[serde(rename = "estimated_monthly_spend")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub estimated_monthly_spend: Option<Nullable<f64>>,

}

lazy_static::lazy_static! {
    static ref RE_SSIOORDERLINE_LAST_MODIFIED_DATE_TIME: regex::Regex = regex::Regex::new(r"^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}).(\\d{3})Z$").unwrap();
}
lazy_static::lazy_static! {
    static ref RE_SSIOORDERLINE_ACCEPTED_TERMS_TIME: regex::Regex = regex::Regex::new(r"^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}).(\\d{3})Z$").unwrap();
}

impl SsioOrderLine {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SsioOrderLine {
        SsioOrderLine {
            salesforce_order_line_id: None,
            ads_manager_order_line_id: None,
            pin_order_id: None,
            last_modified_date_time: None,
            start_date: None,
            end_date: None,
            bill_to_company_name: None,
            billing_contact_firstname: None,
            billing_contact_lastname: None,
            billing_contact_email: None,
            media_contact_email: None,
            media_contact_firstname: None,
            media_contact_lastname: None,
            currency_info: None,
            agency_link: None,
            po_number: None,
            order_name: None,
            pmp_name: None,
            accepted_terms_id: None,
            accepted_terms_time: None,
            budget_amount: None,
            estimated_monthly_spend: None,
        }
    }
}

/// Converts the SsioOrderLine value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SsioOrderLine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.salesforce_order_line_id.as_ref().map(|salesforce_order_line_id| {
                [
                    "salesforce_order_line_id".to_string(),
                    salesforce_order_line_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.ads_manager_order_line_id.as_ref().map(|ads_manager_order_line_id| {
                [
                    "ads_manager_order_line_id".to_string(),
                    ads_manager_order_line_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.pin_order_id.as_ref().map(|pin_order_id| {
                [
                    "pin_order_id".to_string(),
                    pin_order_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.last_modified_date_time.as_ref().map(|last_modified_date_time| {
                [
                    "last_modified_date_time".to_string(),
                    last_modified_date_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping start_date in query parameter serialization

            // Skipping end_date in query parameter serialization


            self.bill_to_company_name.as_ref().map(|bill_to_company_name| {
                [
                    "bill_to_company_name".to_string(),
                    bill_to_company_name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.billing_contact_firstname.as_ref().map(|billing_contact_firstname| {
                [
                    "billing_contact_firstname".to_string(),
                    billing_contact_firstname.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.billing_contact_lastname.as_ref().map(|billing_contact_lastname| {
                [
                    "billing_contact_lastname".to_string(),
                    billing_contact_lastname.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.billing_contact_email.as_ref().map(|billing_contact_email| {
                [
                    "billing_contact_email".to_string(),
                    billing_contact_email.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.media_contact_email.as_ref().map(|media_contact_email| {
                [
                    "media_contact_email".to_string(),
                    media_contact_email.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.media_contact_firstname.as_ref().map(|media_contact_firstname| {
                [
                    "media_contact_firstname".to_string(),
                    media_contact_firstname.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.media_contact_lastname.as_ref().map(|media_contact_lastname| {
                [
                    "media_contact_lastname".to_string(),
                    media_contact_lastname.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping currency_info in query parameter serialization


            self.agency_link.as_ref().map(|agency_link| {
                [
                    "agency_link".to_string(),
                    agency_link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.po_number.as_ref().map(|po_number| {
                [
                    "po_number".to_string(),
                    po_number.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.order_name.as_ref().map(|order_name| {
                [
                    "order_name".to_string(),
                    order_name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.pmp_name.as_ref().map(|pmp_name| {
                [
                    "pmp_name".to_string(),
                    pmp_name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.accepted_terms_id.as_ref().map(|accepted_terms_id| {
                [
                    "accepted_terms_id".to_string(),
                    accepted_terms_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.accepted_terms_time.as_ref().map(|accepted_terms_time| {
                [
                    "accepted_terms_time".to_string(),
                    accepted_terms_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.budget_amount.as_ref().map(|budget_amount| {
                [
                    "budget_amount".to_string(),
                    budget_amount.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.estimated_monthly_spend.as_ref().map(|estimated_monthly_spend| {
                [
                    "estimated_monthly_spend".to_string(),
                    estimated_monthly_spend.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SsioOrderLine value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SsioOrderLine {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub salesforce_order_line_id: Vec<String>,
            pub ads_manager_order_line_id: Vec<String>,
            pub pin_order_id: Vec<String>,
            pub last_modified_date_time: Vec<String>,
            pub start_date: Vec<chrono::naive::NaiveDate>,
            pub end_date: Vec<chrono::naive::NaiveDate>,
            pub bill_to_company_name: Vec<String>,
            pub billing_contact_firstname: Vec<String>,
            pub billing_contact_lastname: Vec<String>,
            pub billing_contact_email: Vec<String>,
            pub media_contact_email: Vec<String>,
            pub media_contact_firstname: Vec<String>,
            pub media_contact_lastname: Vec<String>,
            pub currency_info: Vec<models::Currency>,
            pub agency_link: Vec<String>,
            pub po_number: Vec<String>,
            pub order_name: Vec<String>,
            pub pmp_name: Vec<String>,
            pub accepted_terms_id: Vec<String>,
            pub accepted_terms_time: Vec<String>,
            pub budget_amount: Vec<f64>,
            pub estimated_monthly_spend: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SsioOrderLine".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "salesforce_order_line_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "ads_manager_order_line_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "pin_order_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "last_modified_date_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "start_date" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "end_date" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "bill_to_company_name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "billing_contact_firstname" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "billing_contact_lastname" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "billing_contact_email" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "media_contact_email" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "media_contact_firstname" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "media_contact_lastname" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "currency_info" => intermediate_rep.currency_info.push(<models::Currency as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "agency_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "po_number" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "order_name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "pmp_name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "accepted_terms_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "accepted_terms_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "budget_amount" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    "estimated_monthly_spend" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLine".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SsioOrderLine".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SsioOrderLine {
            salesforce_order_line_id: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            ads_manager_order_line_id: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            pin_order_id: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            last_modified_date_time: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            start_date: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            end_date: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            bill_to_company_name: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            billing_contact_firstname: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            billing_contact_lastname: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            billing_contact_email: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            media_contact_email: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            media_contact_firstname: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            media_contact_lastname: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            currency_info: intermediate_rep.currency_info.into_iter().next(),
            agency_link: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            po_number: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            order_name: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            pmp_name: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            accepted_terms_id: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            accepted_terms_time: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            budget_amount: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
            estimated_monthly_spend: std::result::Result::Err("Nullable types not supported in SsioOrderLine".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SsioOrderLine> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SsioOrderLine>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SsioOrderLine>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SsioOrderLine - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SsioOrderLine> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SsioOrderLine as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SsioOrderLine - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SsioOrderLinesGetByAdAccount200Response {
/// SSIO order lines by ad acount id
    #[serde(rename = "items")]
    pub items: Vec<models::SsioOrderLine>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl SsioOrderLinesGetByAdAccount200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::SsioOrderLine>, ) -> SsioOrderLinesGetByAdAccount200Response {
        SsioOrderLinesGetByAdAccount200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the SsioOrderLinesGetByAdAccount200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SsioOrderLinesGetByAdAccount200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SsioOrderLinesGetByAdAccount200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SsioOrderLinesGetByAdAccount200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::SsioOrderLine>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SsioOrderLinesGetByAdAccount200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in SsioOrderLinesGetByAdAccount200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SsioOrderLinesGetByAdAccount200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SsioOrderLinesGetByAdAccount200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SsioOrderLinesGetByAdAccount200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in SsioOrderLinesGetByAdAccount200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in SsioOrderLinesGetByAdAccount200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SsioOrderLinesGetByAdAccount200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SsioOrderLinesGetByAdAccount200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SsioOrderLinesGetByAdAccount200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SsioOrderLinesGetByAdAccount200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SsioOrderLinesGetByAdAccount200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SsioOrderLinesGetByAdAccount200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SsioOrderLinesGetByAdAccount200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Summarized pin information



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SummaryPin {
    #[serde(rename = "media")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media: Option<models::SummaryPinMedia>,

    #[serde(rename = "alt_text")]
    #[validate(
            length(max = 500),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub alt_text: Option<Nullable<String>>,

    #[serde(rename = "link")]
    #[validate(
            length(max = 2048),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link: Option<Nullable<String>>,

    #[serde(rename = "title")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<Nullable<String>>,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

}


impl SummaryPin {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SummaryPin {
        SummaryPin {
            media: None,
            alt_text: None,
            link: None,
            title: None,
            description: None,
        }
    }
}

/// Converts the SummaryPin value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SummaryPin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping media in query parameter serialization


            self.alt_text.as_ref().map(|alt_text| {
                [
                    "alt_text".to_string(),
                    alt_text.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.link.as_ref().map(|link| {
                [
                    "link".to_string(),
                    link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.title.as_ref().map(|title| {
                [
                    "title".to_string(),
                    title.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SummaryPin value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SummaryPin {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub media: Vec<models::SummaryPinMedia>,
            pub alt_text: Vec<String>,
            pub link: Vec<String>,
            pub title: Vec<String>,
            pub description: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SummaryPin".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "media" => intermediate_rep.media.push(<models::SummaryPinMedia as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "alt_text" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SummaryPin".to_string()),
                    "link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SummaryPin".to_string()),
                    "title" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SummaryPin".to_string()),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SummaryPin".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SummaryPin".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SummaryPin {
            media: intermediate_rep.media.into_iter().next(),
            alt_text: std::result::Result::Err("Nullable types not supported in SummaryPin".to_string())?,
            link: std::result::Result::Err("Nullable types not supported in SummaryPin".to_string())?,
            title: std::result::Result::Err("Nullable types not supported in SummaryPin".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in SummaryPin".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SummaryPin> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SummaryPin>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SummaryPin>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SummaryPin - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SummaryPin> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SummaryPin as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SummaryPin - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SummaryPinMedia {
    #[serde(rename = "media_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<String>,

}


impl SummaryPinMedia {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SummaryPinMedia {
        SummaryPinMedia {
            media_type: None,
        }
    }
}

/// Converts the SummaryPinMedia value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SummaryPinMedia {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.media_type.as_ref().map(|media_type| {
                [
                    "media_type".to_string(),
                    media_type.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SummaryPinMedia value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SummaryPinMedia {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub media_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SummaryPinMedia".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "media_type" => intermediate_rep.media_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SummaryPinMedia".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SummaryPinMedia {
            media_type: intermediate_rep.media_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SummaryPinMedia> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SummaryPinMedia>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SummaryPinMedia>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SummaryPinMedia - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SummaryPinMedia> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SummaryPinMedia as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SummaryPinMedia - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Advertiser's ISO two character country code.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum TargetingAdvertiserCountry {
    #[serde(rename = "US")]
    Us,
    #[serde(rename = "GB")]
    Gb,
    #[serde(rename = "CA")]
    Ca,
    #[serde(rename = "IE")]
    Ie,
    #[serde(rename = "AU")]
    Au,
    #[serde(rename = "NZ")]
    Nz,
    #[serde(rename = "FR")]
    Fr,
    #[serde(rename = "SE")]
    Se,
    #[serde(rename = "IL")]
    Il,
    #[serde(rename = "DE")]
    De,
    #[serde(rename = "AT")]
    At,
    #[serde(rename = "IT")]
    It,
    #[serde(rename = "ES")]
    Es,
    #[serde(rename = "NL")]
    Nl,
    #[serde(rename = "BE")]
    Be,
    #[serde(rename = "PT")]
    Pt,
    #[serde(rename = "CH")]
    Ch,
    #[serde(rename = "HK")]
    Hk,
    #[serde(rename = "JP")]
    Jp,
    #[serde(rename = "KR")]
    Kr,
    #[serde(rename = "SG")]
    Sg,
    #[serde(rename = "NO")]
    No,
    #[serde(rename = "DK")]
    Dk,
    #[serde(rename = "FI")]
    Fi,
    #[serde(rename = "CY")]
    Cy,
    #[serde(rename = "LU")]
    Lu,
    #[serde(rename = "MT")]
    Mt,
    #[serde(rename = "PL")]
    Pl,
    #[serde(rename = "RO")]
    Ro,
    #[serde(rename = "HU")]
    Hu,
    #[serde(rename = "CZ")]
    Cz,
    #[serde(rename = "GR")]
    Gr,
    #[serde(rename = "SK")]
    Sk,
    #[serde(rename = "BR")]
    Br,
    #[serde(rename = "MX")]
    Mx,
    #[serde(rename = "AR")]
    Ar,
    #[serde(rename = "CL")]
    Cl,
    #[serde(rename = "CO")]
    Co,
}

impl std::fmt::Display for TargetingAdvertiserCountry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TargetingAdvertiserCountry::Us => write!(f, "US"),
            TargetingAdvertiserCountry::Gb => write!(f, "GB"),
            TargetingAdvertiserCountry::Ca => write!(f, "CA"),
            TargetingAdvertiserCountry::Ie => write!(f, "IE"),
            TargetingAdvertiserCountry::Au => write!(f, "AU"),
            TargetingAdvertiserCountry::Nz => write!(f, "NZ"),
            TargetingAdvertiserCountry::Fr => write!(f, "FR"),
            TargetingAdvertiserCountry::Se => write!(f, "SE"),
            TargetingAdvertiserCountry::Il => write!(f, "IL"),
            TargetingAdvertiserCountry::De => write!(f, "DE"),
            TargetingAdvertiserCountry::At => write!(f, "AT"),
            TargetingAdvertiserCountry::It => write!(f, "IT"),
            TargetingAdvertiserCountry::Es => write!(f, "ES"),
            TargetingAdvertiserCountry::Nl => write!(f, "NL"),
            TargetingAdvertiserCountry::Be => write!(f, "BE"),
            TargetingAdvertiserCountry::Pt => write!(f, "PT"),
            TargetingAdvertiserCountry::Ch => write!(f, "CH"),
            TargetingAdvertiserCountry::Hk => write!(f, "HK"),
            TargetingAdvertiserCountry::Jp => write!(f, "JP"),
            TargetingAdvertiserCountry::Kr => write!(f, "KR"),
            TargetingAdvertiserCountry::Sg => write!(f, "SG"),
            TargetingAdvertiserCountry::No => write!(f, "NO"),
            TargetingAdvertiserCountry::Dk => write!(f, "DK"),
            TargetingAdvertiserCountry::Fi => write!(f, "FI"),
            TargetingAdvertiserCountry::Cy => write!(f, "CY"),
            TargetingAdvertiserCountry::Lu => write!(f, "LU"),
            TargetingAdvertiserCountry::Mt => write!(f, "MT"),
            TargetingAdvertiserCountry::Pl => write!(f, "PL"),
            TargetingAdvertiserCountry::Ro => write!(f, "RO"),
            TargetingAdvertiserCountry::Hu => write!(f, "HU"),
            TargetingAdvertiserCountry::Cz => write!(f, "CZ"),
            TargetingAdvertiserCountry::Gr => write!(f, "GR"),
            TargetingAdvertiserCountry::Sk => write!(f, "SK"),
            TargetingAdvertiserCountry::Br => write!(f, "BR"),
            TargetingAdvertiserCountry::Mx => write!(f, "MX"),
            TargetingAdvertiserCountry::Ar => write!(f, "AR"),
            TargetingAdvertiserCountry::Cl => write!(f, "CL"),
            TargetingAdvertiserCountry::Co => write!(f, "CO"),
        }
    }
}

impl std::str::FromStr for TargetingAdvertiserCountry {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "US" => std::result::Result::Ok(TargetingAdvertiserCountry::Us),
            "GB" => std::result::Result::Ok(TargetingAdvertiserCountry::Gb),
            "CA" => std::result::Result::Ok(TargetingAdvertiserCountry::Ca),
            "IE" => std::result::Result::Ok(TargetingAdvertiserCountry::Ie),
            "AU" => std::result::Result::Ok(TargetingAdvertiserCountry::Au),
            "NZ" => std::result::Result::Ok(TargetingAdvertiserCountry::Nz),
            "FR" => std::result::Result::Ok(TargetingAdvertiserCountry::Fr),
            "SE" => std::result::Result::Ok(TargetingAdvertiserCountry::Se),
            "IL" => std::result::Result::Ok(TargetingAdvertiserCountry::Il),
            "DE" => std::result::Result::Ok(TargetingAdvertiserCountry::De),
            "AT" => std::result::Result::Ok(TargetingAdvertiserCountry::At),
            "IT" => std::result::Result::Ok(TargetingAdvertiserCountry::It),
            "ES" => std::result::Result::Ok(TargetingAdvertiserCountry::Es),
            "NL" => std::result::Result::Ok(TargetingAdvertiserCountry::Nl),
            "BE" => std::result::Result::Ok(TargetingAdvertiserCountry::Be),
            "PT" => std::result::Result::Ok(TargetingAdvertiserCountry::Pt),
            "CH" => std::result::Result::Ok(TargetingAdvertiserCountry::Ch),
            "HK" => std::result::Result::Ok(TargetingAdvertiserCountry::Hk),
            "JP" => std::result::Result::Ok(TargetingAdvertiserCountry::Jp),
            "KR" => std::result::Result::Ok(TargetingAdvertiserCountry::Kr),
            "SG" => std::result::Result::Ok(TargetingAdvertiserCountry::Sg),
            "NO" => std::result::Result::Ok(TargetingAdvertiserCountry::No),
            "DK" => std::result::Result::Ok(TargetingAdvertiserCountry::Dk),
            "FI" => std::result::Result::Ok(TargetingAdvertiserCountry::Fi),
            "CY" => std::result::Result::Ok(TargetingAdvertiserCountry::Cy),
            "LU" => std::result::Result::Ok(TargetingAdvertiserCountry::Lu),
            "MT" => std::result::Result::Ok(TargetingAdvertiserCountry::Mt),
            "PL" => std::result::Result::Ok(TargetingAdvertiserCountry::Pl),
            "RO" => std::result::Result::Ok(TargetingAdvertiserCountry::Ro),
            "HU" => std::result::Result::Ok(TargetingAdvertiserCountry::Hu),
            "CZ" => std::result::Result::Ok(TargetingAdvertiserCountry::Cz),
            "GR" => std::result::Result::Ok(TargetingAdvertiserCountry::Gr),
            "SK" => std::result::Result::Ok(TargetingAdvertiserCountry::Sk),
            "BR" => std::result::Result::Ok(TargetingAdvertiserCountry::Br),
            "MX" => std::result::Result::Ok(TargetingAdvertiserCountry::Mx),
            "AR" => std::result::Result::Ok(TargetingAdvertiserCountry::Ar),
            "CL" => std::result::Result::Ok(TargetingAdvertiserCountry::Cl),
            "CO" => std::result::Result::Ok(TargetingAdvertiserCountry::Co),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// Ad group targeting specification defining the ad group target audience. For example, {\"APPTYPE\":[\"iphone\"], \"GENDER\":[\"male\"], \"LOCALE\":[\"en-US\"], \"LOCATION\":[\"501\"], \"AGE_BUCKET\":[\"25-34\"]}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TargetingSpec {
/// Age ranges. If the AGE_BUCKET field is missing, the default behavior in terms of ad delivery is that **All age buckets** will be targeted.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "AGE_BUCKET")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub age_bucket: Option<Nullable<Vec<String>>>,

/// Allowed devices. If the APPTYPE field is missing, the default behavior in terms of ad delivery is that **All devices/apptypes** will be targeted.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "APPTYPE")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub apptype: Option<Nullable<Vec<String>>>,

/// Excluded customer list IDs. Used to drive new customer acquisition goals. For example: [\"2542620905475\"]. Audience lists need to have at least 100 people with Pinterest accounts in them. If the AUDIENCE_EXCLUDE field is missing, the default behavior in terms of ad delivery is that **No users will be excluded**.
    #[serde(rename = "AUDIENCE_EXCLUDE")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audience_exclude: Option<Nullable<Vec<String>>>,

/// Targeted customer list IDs. For example: [\"2542620905473\"]. Audience lists need to have at least 100 people with Pinterest accounts in them Audience lists need to have at least 100 people with Pinterest accounts in them. If the AUDIENCE_INCLUDE field is missing, the default behavior in terms of ad delivery is that **All users will be included**.
    #[serde(rename = "AUDIENCE_INCLUDE'")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audience_include_quote: Option<Nullable<Vec<String>>>,

/// Targeted genders. Values: [\"unknown\",\"male\",\"female\"]. If the GENDER field is missing, the default behavior in terms of ad delivery is that **All genders will be targeted**.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "GENDER")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gender: Option<Nullable<Vec<String>>>,

/// Location region codes, e.g., \"BE-VOV\" (East Flanders, Belgium) For complete list, <a href=\"https://help.pinterest.com/sub/helpcenter/partner/pinterest_location_targeting_codes.xlsx\" target=\"_blank\">click here</a> or postal codes, e.g., \"US-94107\". Use either region codes or postal codes but not both. If the GEO field is missing, the default behavior in terms of ad delivery is that **No geos will be selected**.
    #[serde(rename = "GEO")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub geo: Option<Nullable<Vec<String>>>,

/// Array of interest object IDs. If the INTEREST field is missing, the default behavior in terms of ad delivery is that **All interests will be targeted**.
    #[serde(rename = "INTEREST")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub interest: Option<Vec<String>>,

/// 24 ISO 639-1 two letter language codes. If the LOCALE field is missing, the default behavior in terms of ad delivery is that **All languages will be target, only english non-sublanguage will be targeted**.
    #[serde(rename = "LOCALE")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub locale: Option<Nullable<Vec<String>>>,

/// 22 ISO Alpha 2 two letter country codes or US Nielsen DMA (Designated Market Area) codes (location region codes) (e.g., [\"US\", \"807\"]). For complete list, click here. Location-Country and Location-Metro codes apply. If the LOCATION field is missing, the default behavior in terms of ad delivery is that **Selects default country if not specified (US) and all regions within that country**.
    #[serde(rename = "LOCATION")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<Nullable<Vec<String>>>,

/// Array of object: lookback_window [Integer]: Number of days ago to start lookback timeframe for dynamic retargeting tag_types [Array of integer]: Event types to target for dynamic retargeting exclusion_window [Integer]: Number of days ago to stop lookback timeframe for dynamic retargeting
    #[serde(rename = "SHOPPING_RETARGETING")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shopping_retargeting: Option<Nullable<Vec<models::TargetingSpecShoppingRetargeting>>>,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "TARGETING_STRATEGY")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub targeting_strategy: Option<Nullable<Vec<String>>>,

}


impl TargetingSpec {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TargetingSpec {
        TargetingSpec {
            age_bucket: None,
            apptype: None,
            audience_exclude: None,
            audience_include_quote: None,
            gender: None,
            geo: None,
            interest: None,
            locale: None,
            location: None,
            shopping_retargeting: None,
            targeting_strategy: None,
        }
    }
}

/// Converts the TargetingSpec value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TargetingSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.age_bucket.as_ref().map(|age_bucket| {
                [
                    "AGE_BUCKET".to_string(),
                    age_bucket.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.apptype.as_ref().map(|apptype| {
                [
                    "APPTYPE".to_string(),
                    apptype.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.audience_exclude.as_ref().map(|audience_exclude| {
                [
                    "AUDIENCE_EXCLUDE".to_string(),
                    audience_exclude.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.audience_include_quote.as_ref().map(|audience_include_quote| {
                [
                    "AUDIENCE_INCLUDE'".to_string(),
                    audience_include_quote.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.gender.as_ref().map(|gender| {
                [
                    "GENDER".to_string(),
                    gender.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.geo.as_ref().map(|geo| {
                [
                    "GEO".to_string(),
                    geo.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.interest.as_ref().map(|interest| {
                [
                    "INTEREST".to_string(),
                    interest.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.locale.as_ref().map(|locale| {
                [
                    "LOCALE".to_string(),
                    locale.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.location.as_ref().map(|location| {
                [
                    "LOCATION".to_string(),
                    location.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping SHOPPING_RETARGETING in query parameter serialization


            self.targeting_strategy.as_ref().map(|targeting_strategy| {
                [
                    "TARGETING_STRATEGY".to_string(),
                    targeting_strategy.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TargetingSpec value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TargetingSpec {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub age_bucket: Vec<Vec<String>>,
            pub apptype: Vec<Vec<String>>,
            pub audience_exclude: Vec<Vec<String>>,
            pub audience_include_quote: Vec<Vec<String>>,
            pub gender: Vec<Vec<String>>,
            pub geo: Vec<Vec<String>>,
            pub interest: Vec<Vec<String>>,
            pub locale: Vec<Vec<String>>,
            pub location: Vec<Vec<String>>,
            pub shopping_retargeting: Vec<Vec<models::TargetingSpecShoppingRetargeting>>,
            pub targeting_strategy: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TargetingSpec".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "AGE_BUCKET" => return std::result::Result::Err("Parsing a container in this style is not supported in TargetingSpec".to_string()),
                    "APPTYPE" => return std::result::Result::Err("Parsing a container in this style is not supported in TargetingSpec".to_string()),
                    "AUDIENCE_EXCLUDE" => return std::result::Result::Err("Parsing a container in this style is not supported in TargetingSpec".to_string()),
                    "AUDIENCE_INCLUDE'" => return std::result::Result::Err("Parsing a container in this style is not supported in TargetingSpec".to_string()),
                    "GENDER" => return std::result::Result::Err("Parsing a container in this style is not supported in TargetingSpec".to_string()),
                    "GEO" => return std::result::Result::Err("Parsing a container in this style is not supported in TargetingSpec".to_string()),
                    "INTEREST" => return std::result::Result::Err("Parsing a container in this style is not supported in TargetingSpec".to_string()),
                    "LOCALE" => return std::result::Result::Err("Parsing a container in this style is not supported in TargetingSpec".to_string()),
                    "LOCATION" => return std::result::Result::Err("Parsing a container in this style is not supported in TargetingSpec".to_string()),
                    "SHOPPING_RETARGETING" => return std::result::Result::Err("Parsing a container in this style is not supported in TargetingSpec".to_string()),
                    "TARGETING_STRATEGY" => return std::result::Result::Err("Parsing a container in this style is not supported in TargetingSpec".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TargetingSpec".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TargetingSpec {
            age_bucket: std::result::Result::Err("Nullable types not supported in TargetingSpec".to_string())?,
            apptype: std::result::Result::Err("Nullable types not supported in TargetingSpec".to_string())?,
            audience_exclude: std::result::Result::Err("Nullable types not supported in TargetingSpec".to_string())?,
            audience_include_quote: std::result::Result::Err("Nullable types not supported in TargetingSpec".to_string())?,
            gender: std::result::Result::Err("Nullable types not supported in TargetingSpec".to_string())?,
            geo: std::result::Result::Err("Nullable types not supported in TargetingSpec".to_string())?,
            interest: intermediate_rep.interest.into_iter().next(),
            locale: std::result::Result::Err("Nullable types not supported in TargetingSpec".to_string())?,
            location: std::result::Result::Err("Nullable types not supported in TargetingSpec".to_string())?,
            shopping_retargeting: std::result::Result::Err("Nullable types not supported in TargetingSpec".to_string())?,
            targeting_strategy: std::result::Result::Err("Nullable types not supported in TargetingSpec".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TargetingSpec> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TargetingSpec>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TargetingSpec>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TargetingSpec - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TargetingSpec> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TargetingSpec as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TargetingSpec - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TargetingSpecShoppingRetargeting {
/// Number of days ago to start lookback timeframe for dynamic retargeting
    #[serde(rename = "lookback_window")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lookback_window: Option<i32>,

/// Event types to target for dynamic retargeting
    #[serde(rename = "tag_types")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag_types: Option<Vec<i32>>,

/// Number of days ago to stop lookback timeframe for dynamic retargeting
    #[serde(rename = "exclusion_window")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclusion_window: Option<i32>,

}


impl TargetingSpecShoppingRetargeting {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TargetingSpecShoppingRetargeting {
        TargetingSpecShoppingRetargeting {
            lookback_window: None,
            tag_types: None,
            exclusion_window: None,
        }
    }
}

/// Converts the TargetingSpecShoppingRetargeting value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TargetingSpecShoppingRetargeting {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.lookback_window.as_ref().map(|lookback_window| {
                [
                    "lookback_window".to_string(),
                    lookback_window.to_string(),
                ].join(",")
            }),


            self.tag_types.as_ref().map(|tag_types| {
                [
                    "tag_types".to_string(),
                    tag_types.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.exclusion_window.as_ref().map(|exclusion_window| {
                [
                    "exclusion_window".to_string(),
                    exclusion_window.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TargetingSpecShoppingRetargeting value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TargetingSpecShoppingRetargeting {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub lookback_window: Vec<i32>,
            pub tag_types: Vec<Vec<i32>>,
            pub exclusion_window: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TargetingSpecShoppingRetargeting".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "lookback_window" => intermediate_rep.lookback_window.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tag_types" => return std::result::Result::Err("Parsing a container in this style is not supported in TargetingSpecShoppingRetargeting".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "exclusion_window" => intermediate_rep.exclusion_window.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TargetingSpecShoppingRetargeting".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TargetingSpecShoppingRetargeting {
            lookback_window: intermediate_rep.lookback_window.into_iter().next(),
            tag_types: intermediate_rep.tag_types.into_iter().next(),
            exclusion_window: intermediate_rep.exclusion_window.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TargetingSpecShoppingRetargeting> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TargetingSpecShoppingRetargeting>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TargetingSpecShoppingRetargeting>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TargetingSpecShoppingRetargeting - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TargetingSpecShoppingRetargeting> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TargetingSpecShoppingRetargeting as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TargetingSpecShoppingRetargeting - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TargetingTypeFilter {
/// List of targeting types. Requires `level` to be a value ending in `_TARGETING`.
    #[serde(rename = "targeting_types")]
    #[validate(
            length(min = 1, max = 5),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub targeting_types: Option<Vec<models::AdsAnalyticsTargetingType>>,

}


impl TargetingTypeFilter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TargetingTypeFilter {
        TargetingTypeFilter {
            targeting_types: None,
        }
    }
}

/// Converts the TargetingTypeFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TargetingTypeFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping targeting_types in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TargetingTypeFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TargetingTypeFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub targeting_types: Vec<Vec<models::AdsAnalyticsTargetingType>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TargetingTypeFilter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "targeting_types" => return std::result::Result::Err("Parsing a container in this style is not supported in TargetingTypeFilter".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TargetingTypeFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TargetingTypeFilter {
            targeting_types: intermediate_rep.targeting_types.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TargetingTypeFilter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TargetingTypeFilter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TargetingTypeFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TargetingTypeFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TargetingTypeFilter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TargetingTypeFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TargetingTypeFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Template fields



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TemplateResponse {
/// Template ID
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// ID of the Ad Account that owns the template
    #[serde(rename = "ad_account_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

/// IDs of the Ad Accounts that have access to this template
    #[serde(rename = "ad_account_ids")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_ids: Option<Vec<String>>,

/// ID of the user who created the template
    #[serde(rename = "user_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_id: Option<String>,

/// Template Name
    #[serde(rename = "name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

/// The number of days prior to the day the report will be delivered at which the report will start
    #[serde(rename = "report_start_relative_days_in_past")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub report_start_relative_days_in_past: Option<f64>,

/// The number of days prior to the day the report will be delivered at which the report will end
    #[serde(rename = "report_end_relative_days_in_past")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub report_end_relative_days_in_past: Option<f64>,

    #[serde(rename = "date_range")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_range: Option<models::TemplateResponseDateRange>,

    #[serde(rename = "report_level")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub report_level: Option<models::MetricsReportingLevel>,

    #[serde(rename = "report_format")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub report_format: Option<models::DataOutputFormat>,

/// A list of columns to be included in the report
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "columns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub columns: Option<Vec<String>>,

    #[serde(rename = "granularity")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub granularity: Option<models::Granularity>,

/// The length of the sliding window over which view conversions will be attributed
    #[serde(rename = "view_window_days")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub view_window_days: Option<f64>,

/// The length of the sliding window over which click conversions will be attributed
    #[serde(rename = "click_window_days")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub click_window_days: Option<f64>,

/// The length of the sliding window over which engagement conversions will be attributed
    #[serde(rename = "engagement_window_days")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub engagement_window_days: Option<f64>,

/// Conversion report time type
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "conversion_report_time_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conversion_report_time_type: Option<String>,

/// A JSON representation of any filters to be applied before returning report data. Each filter object should contain all of the following fields:<br> \"field\": The column name<br> \"operator\": The operator. Allowed operators: [\"=\", \"!=\", \"in\", \"not_in\", \"~\", \">\", \"<\", \"contains_substring\"]<br> \"value\": A single value or a list of values
    #[serde(rename = "filters_json")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub filters_json: Option<Nullable<String>>,

/// A boolean value that indicates if the user owns the template
    #[serde(rename = "is_owned_by_user")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_owned_by_user: Option<bool>,

/// A boolean value that indicates if this template has been used to create a scheduled report
    #[serde(rename = "is_scheduled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_scheduled: Option<bool>,

/// The surface used to create this template
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "creation_source")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creation_source: Option<String>,

/// A boolean that indicates if the template has been deleted
    #[serde(rename = "is_deleted")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_deleted: Option<Nullable<bool>>,

/// Time of last update in seconds since Unix epoch
    #[serde(rename = "updated_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_time: Option<f64>,

/// A list of custom column IDs
    #[serde(rename = "custom_column_ids")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_column_ids: Option<Nullable<Vec<models::CustomColumnId>>>,

/// Reporting template type
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

/// The filter on the conversion ingestion source method for conversion metrics
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "ingestion_sources")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ingestion_sources: Option<Nullable<Vec<String>>>,

}


impl TemplateResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TemplateResponse {
        TemplateResponse {
            id: None,
            ad_account_id: None,
            ad_account_ids: None,
            user_id: None,
            name: None,
            report_start_relative_days_in_past: None,
            report_end_relative_days_in_past: None,
            date_range: None,
            report_level: None,
            report_format: None,
            columns: None,
            granularity: None,
            view_window_days: None,
            click_window_days: None,
            engagement_window_days: None,
            conversion_report_time_type: None,
            filters_json: None,
            is_owned_by_user: None,
            is_scheduled: None,
            creation_source: None,
            is_deleted: None,
            updated_time: None,
            custom_column_ids: None,
            r#type: None,
            ingestion_sources: None,
        }
    }
}

/// Converts the TemplateResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TemplateResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),


            self.ad_account_ids.as_ref().map(|ad_account_ids| {
                [
                    "ad_account_ids".to_string(),
                    ad_account_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.user_id.as_ref().map(|user_id| {
                [
                    "user_id".to_string(),
                    user_id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.report_start_relative_days_in_past.as_ref().map(|report_start_relative_days_in_past| {
                [
                    "report_start_relative_days_in_past".to_string(),
                    report_start_relative_days_in_past.to_string(),
                ].join(",")
            }),


            self.report_end_relative_days_in_past.as_ref().map(|report_end_relative_days_in_past| {
                [
                    "report_end_relative_days_in_past".to_string(),
                    report_end_relative_days_in_past.to_string(),
                ].join(",")
            }),

            // Skipping date_range in query parameter serialization

            // Skipping report_level in query parameter serialization

            // Skipping report_format in query parameter serialization


            self.columns.as_ref().map(|columns| {
                [
                    "columns".to_string(),
                    columns.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping granularity in query parameter serialization


            self.view_window_days.as_ref().map(|view_window_days| {
                [
                    "view_window_days".to_string(),
                    view_window_days.to_string(),
                ].join(",")
            }),


            self.click_window_days.as_ref().map(|click_window_days| {
                [
                    "click_window_days".to_string(),
                    click_window_days.to_string(),
                ].join(",")
            }),


            self.engagement_window_days.as_ref().map(|engagement_window_days| {
                [
                    "engagement_window_days".to_string(),
                    engagement_window_days.to_string(),
                ].join(",")
            }),


            self.conversion_report_time_type.as_ref().map(|conversion_report_time_type| {
                [
                    "conversion_report_time_type".to_string(),
                    conversion_report_time_type.to_string(),
                ].join(",")
            }),


            self.filters_json.as_ref().map(|filters_json| {
                [
                    "filters_json".to_string(),
                    filters_json.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_owned_by_user.as_ref().map(|is_owned_by_user| {
                [
                    "is_owned_by_user".to_string(),
                    is_owned_by_user.to_string(),
                ].join(",")
            }),


            self.is_scheduled.as_ref().map(|is_scheduled| {
                [
                    "is_scheduled".to_string(),
                    is_scheduled.to_string(),
                ].join(",")
            }),


            self.creation_source.as_ref().map(|creation_source| {
                [
                    "creation_source".to_string(),
                    creation_source.to_string(),
                ].join(",")
            }),


            self.is_deleted.as_ref().map(|is_deleted| {
                [
                    "is_deleted".to_string(),
                    is_deleted.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.updated_time.as_ref().map(|updated_time| {
                [
                    "updated_time".to_string(),
                    updated_time.to_string(),
                ].join(",")
            }),


            self.custom_column_ids.as_ref().map(|custom_column_ids| {
                [
                    "custom_column_ids".to_string(),
                    custom_column_ids.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.ingestion_sources.as_ref().map(|ingestion_sources| {
                [
                    "ingestion_sources".to_string(),
                    ingestion_sources.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TemplateResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TemplateResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub ad_account_id: Vec<String>,
            pub ad_account_ids: Vec<Vec<String>>,
            pub user_id: Vec<String>,
            pub name: Vec<String>,
            pub report_start_relative_days_in_past: Vec<f64>,
            pub report_end_relative_days_in_past: Vec<f64>,
            pub date_range: Vec<models::TemplateResponseDateRange>,
            pub report_level: Vec<models::MetricsReportingLevel>,
            pub report_format: Vec<models::DataOutputFormat>,
            pub columns: Vec<Vec<String>>,
            pub granularity: Vec<models::Granularity>,
            pub view_window_days: Vec<f64>,
            pub click_window_days: Vec<f64>,
            pub engagement_window_days: Vec<f64>,
            pub conversion_report_time_type: Vec<String>,
            pub filters_json: Vec<String>,
            pub is_owned_by_user: Vec<bool>,
            pub is_scheduled: Vec<bool>,
            pub creation_source: Vec<String>,
            pub is_deleted: Vec<bool>,
            pub updated_time: Vec<f64>,
            pub custom_column_ids: Vec<Vec<models::CustomColumnId>>,
            pub r#type: Vec<String>,
            pub ingestion_sources: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TemplateResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ad_account_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in TemplateResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "user_id" => intermediate_rep.user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in TemplateResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "report_start_relative_days_in_past" => intermediate_rep.report_start_relative_days_in_past.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "report_end_relative_days_in_past" => intermediate_rep.report_end_relative_days_in_past.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "date_range" => intermediate_rep.date_range.push(<models::TemplateResponseDateRange as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "report_level" => intermediate_rep.report_level.push(<models::MetricsReportingLevel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "report_format" => intermediate_rep.report_format.push(<models::DataOutputFormat as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "columns" => return std::result::Result::Err("Parsing a container in this style is not supported in TemplateResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "granularity" => intermediate_rep.granularity.push(<models::Granularity as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "view_window_days" => intermediate_rep.view_window_days.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "click_window_days" => intermediate_rep.click_window_days.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "engagement_window_days" => intermediate_rep.engagement_window_days.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "conversion_report_time_type" => intermediate_rep.conversion_report_time_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "filters_json" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in TemplateResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "is_owned_by_user" => intermediate_rep.is_owned_by_user.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_scheduled" => intermediate_rep.is_scheduled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "creation_source" => intermediate_rep.creation_source.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "is_deleted" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in TemplateResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "updated_time" => intermediate_rep.updated_time.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "custom_column_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in TemplateResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ingestion_sources" => return std::result::Result::Err("Parsing a container in this style is not supported in TemplateResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TemplateResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TemplateResponse {
            id: intermediate_rep.id.into_iter().next(),
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            ad_account_ids: intermediate_rep.ad_account_ids.into_iter().next(),
            user_id: intermediate_rep.user_id.into_iter().next(),
            name: std::result::Result::Err("Nullable types not supported in TemplateResponse".to_string())?,
            report_start_relative_days_in_past: intermediate_rep.report_start_relative_days_in_past.into_iter().next(),
            report_end_relative_days_in_past: intermediate_rep.report_end_relative_days_in_past.into_iter().next(),
            date_range: intermediate_rep.date_range.into_iter().next(),
            report_level: intermediate_rep.report_level.into_iter().next(),
            report_format: intermediate_rep.report_format.into_iter().next(),
            columns: intermediate_rep.columns.into_iter().next(),
            granularity: intermediate_rep.granularity.into_iter().next(),
            view_window_days: intermediate_rep.view_window_days.into_iter().next(),
            click_window_days: intermediate_rep.click_window_days.into_iter().next(),
            engagement_window_days: intermediate_rep.engagement_window_days.into_iter().next(),
            conversion_report_time_type: intermediate_rep.conversion_report_time_type.into_iter().next(),
            filters_json: std::result::Result::Err("Nullable types not supported in TemplateResponse".to_string())?,
            is_owned_by_user: intermediate_rep.is_owned_by_user.into_iter().next(),
            is_scheduled: intermediate_rep.is_scheduled.into_iter().next(),
            creation_source: intermediate_rep.creation_source.into_iter().next(),
            is_deleted: std::result::Result::Err("Nullable types not supported in TemplateResponse".to_string())?,
            updated_time: intermediate_rep.updated_time.into_iter().next(),
            custom_column_ids: std::result::Result::Err("Nullable types not supported in TemplateResponse".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next(),
            ingestion_sources: std::result::Result::Err("Nullable types not supported in TemplateResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TemplateResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TemplateResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TemplateResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TemplateResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TemplateResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TemplateResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TemplateResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TemplateResponseDateRange {
    #[serde(rename = "dynamic_date_range")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dynamic_date_range: Option<Nullable<models::TemplateResponseDateRangeDynamicDateRange>>,

    #[serde(rename = "relative_date_range")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub relative_date_range: Option<Nullable<models::TemplateResponseDateRangeRelativeDateRange>>,

    #[serde(rename = "absolute_date_range")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub absolute_date_range: Option<Nullable<models::TemplateResponseDateRangeAbsoluteDateRange>>,

}


impl TemplateResponseDateRange {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TemplateResponseDateRange {
        TemplateResponseDateRange {
            dynamic_date_range: None,
            relative_date_range: None,
            absolute_date_range: None,
        }
    }
}

/// Converts the TemplateResponseDateRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TemplateResponseDateRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping dynamic_date_range in query parameter serialization

            // Skipping relative_date_range in query parameter serialization

            // Skipping absolute_date_range in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TemplateResponseDateRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TemplateResponseDateRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dynamic_date_range: Vec<models::TemplateResponseDateRangeDynamicDateRange>,
            pub relative_date_range: Vec<models::TemplateResponseDateRangeRelativeDateRange>,
            pub absolute_date_range: Vec<models::TemplateResponseDateRangeAbsoluteDateRange>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TemplateResponseDateRange".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "dynamic_date_range" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in TemplateResponseDateRange".to_string()),
                    "relative_date_range" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in TemplateResponseDateRange".to_string()),
                    "absolute_date_range" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in TemplateResponseDateRange".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TemplateResponseDateRange".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TemplateResponseDateRange {
            dynamic_date_range: std::result::Result::Err("Nullable types not supported in TemplateResponseDateRange".to_string())?,
            relative_date_range: std::result::Result::Err("Nullable types not supported in TemplateResponseDateRange".to_string())?,
            absolute_date_range: std::result::Result::Err("Nullable types not supported in TemplateResponseDateRange".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TemplateResponseDateRange> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TemplateResponseDateRange>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TemplateResponseDateRange>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TemplateResponseDateRange - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TemplateResponseDateRange> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TemplateResponseDateRange as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TemplateResponseDateRange - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The absolute date range of the template



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TemplateResponseDateRangeAbsoluteDateRange {
/// The date range type
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

/// The start date of the date range
    #[serde(rename = "start_date")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_date: Option<f64>,

/// The end date of the date range
    #[serde(rename = "end_date")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_date: Option<f64>,

}


impl TemplateResponseDateRangeAbsoluteDateRange {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TemplateResponseDateRangeAbsoluteDateRange {
        TemplateResponseDateRangeAbsoluteDateRange {
            r#type: None,
            start_date: None,
            end_date: None,
        }
    }
}

/// Converts the TemplateResponseDateRangeAbsoluteDateRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TemplateResponseDateRangeAbsoluteDateRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.start_date.as_ref().map(|start_date| {
                [
                    "start_date".to_string(),
                    start_date.to_string(),
                ].join(",")
            }),


            self.end_date.as_ref().map(|end_date| {
                [
                    "end_date".to_string(),
                    end_date.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TemplateResponseDateRangeAbsoluteDateRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TemplateResponseDateRangeAbsoluteDateRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub start_date: Vec<f64>,
            pub end_date: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TemplateResponseDateRangeAbsoluteDateRange".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "start_date" => intermediate_rep.start_date.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end_date" => intermediate_rep.end_date.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TemplateResponseDateRangeAbsoluteDateRange".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TemplateResponseDateRangeAbsoluteDateRange {
            r#type: intermediate_rep.r#type.into_iter().next(),
            start_date: intermediate_rep.start_date.into_iter().next(),
            end_date: intermediate_rep.end_date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TemplateResponseDateRangeAbsoluteDateRange> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TemplateResponseDateRangeAbsoluteDateRange>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TemplateResponseDateRangeAbsoluteDateRange>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TemplateResponseDateRangeAbsoluteDateRange - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TemplateResponseDateRangeAbsoluteDateRange> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TemplateResponseDateRangeAbsoluteDateRange as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TemplateResponseDateRangeAbsoluteDateRange - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The dynamic date range of the template



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TemplateResponseDateRangeDynamicDateRange {
/// The date range type
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

/// The dynamic range type
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "range")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub range: Option<String>,

}


impl TemplateResponseDateRangeDynamicDateRange {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TemplateResponseDateRangeDynamicDateRange {
        TemplateResponseDateRangeDynamicDateRange {
            r#type: None,
            range: None,
        }
    }
}

/// Converts the TemplateResponseDateRangeDynamicDateRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TemplateResponseDateRangeDynamicDateRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.range.as_ref().map(|range| {
                [
                    "range".to_string(),
                    range.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TemplateResponseDateRangeDynamicDateRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TemplateResponseDateRangeDynamicDateRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub range: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TemplateResponseDateRangeDynamicDateRange".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "range" => intermediate_rep.range.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TemplateResponseDateRangeDynamicDateRange".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TemplateResponseDateRangeDynamicDateRange {
            r#type: intermediate_rep.r#type.into_iter().next(),
            range: intermediate_rep.range.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TemplateResponseDateRangeDynamicDateRange> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TemplateResponseDateRangeDynamicDateRange>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TemplateResponseDateRangeDynamicDateRange>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TemplateResponseDateRangeDynamicDateRange - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TemplateResponseDateRangeDynamicDateRange> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TemplateResponseDateRangeDynamicDateRange as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TemplateResponseDateRangeDynamicDateRange - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The relative date range of the template



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TemplateResponseDateRangeRelativeDateRange {
/// The date range type
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

/// The start date of the date range
    #[serde(rename = "start_days_in_past")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_days_in_past: Option<f64>,

/// The end date of the date range
    #[serde(rename = "end_days_in_past")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_days_in_past: Option<f64>,

}


impl TemplateResponseDateRangeRelativeDateRange {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TemplateResponseDateRangeRelativeDateRange {
        TemplateResponseDateRangeRelativeDateRange {
            r#type: None,
            start_days_in_past: None,
            end_days_in_past: None,
        }
    }
}

/// Converts the TemplateResponseDateRangeRelativeDateRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TemplateResponseDateRangeRelativeDateRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.start_days_in_past.as_ref().map(|start_days_in_past| {
                [
                    "start_days_in_past".to_string(),
                    start_days_in_past.to_string(),
                ].join(",")
            }),


            self.end_days_in_past.as_ref().map(|end_days_in_past| {
                [
                    "end_days_in_past".to_string(),
                    end_days_in_past.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TemplateResponseDateRangeRelativeDateRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TemplateResponseDateRangeRelativeDateRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub start_days_in_past: Vec<f64>,
            pub end_days_in_past: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TemplateResponseDateRangeRelativeDateRange".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "start_days_in_past" => intermediate_rep.start_days_in_past.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end_days_in_past" => intermediate_rep.end_days_in_past.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TemplateResponseDateRangeRelativeDateRange".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TemplateResponseDateRangeRelativeDateRange {
            r#type: intermediate_rep.r#type.into_iter().next(),
            start_days_in_past: intermediate_rep.start_days_in_past.into_iter().next(),
            end_days_in_past: intermediate_rep.end_days_in_past.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TemplateResponseDateRangeRelativeDateRange> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TemplateResponseDateRangeRelativeDateRange>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TemplateResponseDateRangeRelativeDateRange>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TemplateResponseDateRangeRelativeDateRange - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TemplateResponseDateRangeRelativeDateRange> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TemplateResponseDateRangeRelativeDateRange as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TemplateResponseDateRangeRelativeDateRange - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TemplatesList200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::TemplateResponse>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl TemplatesList200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::TemplateResponse>, ) -> TemplatesList200Response {
        TemplatesList200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the TemplatesList200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TemplatesList200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TemplatesList200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TemplatesList200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::TemplateResponse>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TemplatesList200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in TemplatesList200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in TemplatesList200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TemplatesList200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TemplatesList200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in TemplatesList200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in TemplatesList200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TemplatesList200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TemplatesList200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TemplatesList200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TemplatesList200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TemplatesList200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TemplatesList200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TemplatesList200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TermsOfService {
/// The ID of the terms of service
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// The terms of service content
    #[serde(rename = "html")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub html: Option<Nullable<String>>,

/// Whether the ad account has accepted terms of service.
    #[serde(rename = "has_accepted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_accepted: Option<bool>,

/// The ID of the ad account.
    #[serde(rename = "ad_account_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

}


impl TermsOfService {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TermsOfService {
        TermsOfService {
            id: None,
            html: None,
            has_accepted: None,
            ad_account_id: None,
        }
    }
}

/// Converts the TermsOfService value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TermsOfService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.html.as_ref().map(|html| {
                [
                    "html".to_string(),
                    html.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.has_accepted.as_ref().map(|has_accepted| {
                [
                    "has_accepted".to_string(),
                    has_accepted.to_string(),
                ].join(",")
            }),


            self.ad_account_id.as_ref().map(|ad_account_id| {
                [
                    "ad_account_id".to_string(),
                    ad_account_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TermsOfService value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TermsOfService {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub html: Vec<String>,
            pub has_accepted: Vec<bool>,
            pub ad_account_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TermsOfService".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "html" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in TermsOfService".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "has_accepted" => intermediate_rep.has_accepted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TermsOfService".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TermsOfService {
            id: intermediate_rep.id.into_iter().next(),
            html: std::result::Result::Err("Nullable types not supported in TermsOfService".to_string())?,
            has_accepted: intermediate_rep.has_accepted.into_iter().next(),
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TermsOfService> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TermsOfService>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TermsOfService>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TermsOfService - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TermsOfService> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TermsOfService as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TermsOfService - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TopPinsAnalyticsResponse {
    #[serde(rename = "date_availability")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_availability: Option<models::TopPinsAnalyticsResponseDateAvailability>,

    #[serde(rename = "pins")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pins: Option<Vec<models::TopPinsAnalyticsResponsePinsInner>>,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "sort_by")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sort_by: Option<String>,

}


impl TopPinsAnalyticsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TopPinsAnalyticsResponse {
        TopPinsAnalyticsResponse {
            date_availability: None,
            pins: None,
            sort_by: None,
        }
    }
}

/// Converts the TopPinsAnalyticsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TopPinsAnalyticsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping date_availability in query parameter serialization

            // Skipping pins in query parameter serialization


            self.sort_by.as_ref().map(|sort_by| {
                [
                    "sort_by".to_string(),
                    sort_by.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TopPinsAnalyticsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TopPinsAnalyticsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub date_availability: Vec<models::TopPinsAnalyticsResponseDateAvailability>,
            pub pins: Vec<Vec<models::TopPinsAnalyticsResponsePinsInner>>,
            pub sort_by: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TopPinsAnalyticsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "date_availability" => intermediate_rep.date_availability.push(<models::TopPinsAnalyticsResponseDateAvailability as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pins" => return std::result::Result::Err("Parsing a container in this style is not supported in TopPinsAnalyticsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "sort_by" => intermediate_rep.sort_by.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TopPinsAnalyticsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TopPinsAnalyticsResponse {
            date_availability: intermediate_rep.date_availability.into_iter().next(),
            pins: intermediate_rep.pins.into_iter().next(),
            sort_by: intermediate_rep.sort_by.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TopPinsAnalyticsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TopPinsAnalyticsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TopPinsAnalyticsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TopPinsAnalyticsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TopPinsAnalyticsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TopPinsAnalyticsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TopPinsAnalyticsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TopPinsAnalyticsResponseDateAvailability {
    #[serde(rename = "latest_available_timestamp")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub latest_available_timestamp: Option<f64>,

    #[serde(rename = "is_realtime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_realtime: Option<bool>,

}


impl TopPinsAnalyticsResponseDateAvailability {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TopPinsAnalyticsResponseDateAvailability {
        TopPinsAnalyticsResponseDateAvailability {
            latest_available_timestamp: None,
            is_realtime: None,
        }
    }
}

/// Converts the TopPinsAnalyticsResponseDateAvailability value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TopPinsAnalyticsResponseDateAvailability {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.latest_available_timestamp.as_ref().map(|latest_available_timestamp| {
                [
                    "latest_available_timestamp".to_string(),
                    latest_available_timestamp.to_string(),
                ].join(",")
            }),


            self.is_realtime.as_ref().map(|is_realtime| {
                [
                    "is_realtime".to_string(),
                    is_realtime.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TopPinsAnalyticsResponseDateAvailability value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TopPinsAnalyticsResponseDateAvailability {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub latest_available_timestamp: Vec<f64>,
            pub is_realtime: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TopPinsAnalyticsResponseDateAvailability".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "latest_available_timestamp" => intermediate_rep.latest_available_timestamp.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_realtime" => intermediate_rep.is_realtime.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TopPinsAnalyticsResponseDateAvailability".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TopPinsAnalyticsResponseDateAvailability {
            latest_available_timestamp: intermediate_rep.latest_available_timestamp.into_iter().next(),
            is_realtime: intermediate_rep.is_realtime.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TopPinsAnalyticsResponseDateAvailability> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TopPinsAnalyticsResponseDateAvailability>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TopPinsAnalyticsResponseDateAvailability>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TopPinsAnalyticsResponseDateAvailability - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TopPinsAnalyticsResponseDateAvailability> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TopPinsAnalyticsResponseDateAvailability as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TopPinsAnalyticsResponseDateAvailability - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Array with metrics, status, and pin id for the requested metric



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TopPinsAnalyticsResponsePinsInner {
/// The metric name and daily value for each requested metric
    #[serde(rename = "metrics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metrics: Option<std::collections::HashMap<String, f64>>,

    #[serde(rename = "data_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data_status: Option<std::collections::HashMap<String, models::DataStatus>>,

/// The pin id
    #[serde(rename = "pin_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pin_id: Option<String>,

}


impl TopPinsAnalyticsResponsePinsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TopPinsAnalyticsResponsePinsInner {
        TopPinsAnalyticsResponsePinsInner {
            metrics: None,
            data_status: None,
            pin_id: None,
        }
    }
}

/// Converts the TopPinsAnalyticsResponsePinsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TopPinsAnalyticsResponsePinsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping metrics in query parameter serialization

            // Skipping data_status in query parameter serialization
            // Skipping data_status in query parameter serialization


            self.pin_id.as_ref().map(|pin_id| {
                [
                    "pin_id".to_string(),
                    pin_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TopPinsAnalyticsResponsePinsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TopPinsAnalyticsResponsePinsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub metrics: Vec<std::collections::HashMap<String, f64>>,
            pub data_status: Vec<std::collections::HashMap<String, models::DataStatus>>,
            pub pin_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TopPinsAnalyticsResponsePinsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "metrics" => return std::result::Result::Err("Parsing a container in this style is not supported in TopPinsAnalyticsResponsePinsInner".to_string()),
                    "data_status" => return std::result::Result::Err("Parsing a container in this style is not supported in TopPinsAnalyticsResponsePinsInner".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pin_id" => intermediate_rep.pin_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TopPinsAnalyticsResponsePinsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TopPinsAnalyticsResponsePinsInner {
            metrics: intermediate_rep.metrics.into_iter().next(),
            data_status: intermediate_rep.data_status.into_iter().next(),
            pin_id: intermediate_rep.pin_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TopPinsAnalyticsResponsePinsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TopPinsAnalyticsResponsePinsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TopPinsAnalyticsResponsePinsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TopPinsAnalyticsResponsePinsInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TopPinsAnalyticsResponsePinsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TopPinsAnalyticsResponsePinsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TopPinsAnalyticsResponsePinsInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TopVideoPinsAnalyticsResponse {
    #[serde(rename = "date_availability")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date_availability: Option<models::TopPinsAnalyticsResponseDateAvailability>,

    #[serde(rename = "pins")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pins: Option<Vec<models::TopVideoPinsAnalyticsResponsePinsInner>>,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "sort_by")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sort_by: Option<String>,

}


impl TopVideoPinsAnalyticsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TopVideoPinsAnalyticsResponse {
        TopVideoPinsAnalyticsResponse {
            date_availability: None,
            pins: None,
            sort_by: None,
        }
    }
}

/// Converts the TopVideoPinsAnalyticsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TopVideoPinsAnalyticsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping date_availability in query parameter serialization

            // Skipping pins in query parameter serialization


            self.sort_by.as_ref().map(|sort_by| {
                [
                    "sort_by".to_string(),
                    sort_by.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TopVideoPinsAnalyticsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TopVideoPinsAnalyticsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub date_availability: Vec<models::TopPinsAnalyticsResponseDateAvailability>,
            pub pins: Vec<Vec<models::TopVideoPinsAnalyticsResponsePinsInner>>,
            pub sort_by: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TopVideoPinsAnalyticsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "date_availability" => intermediate_rep.date_availability.push(<models::TopPinsAnalyticsResponseDateAvailability as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pins" => return std::result::Result::Err("Parsing a container in this style is not supported in TopVideoPinsAnalyticsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "sort_by" => intermediate_rep.sort_by.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TopVideoPinsAnalyticsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TopVideoPinsAnalyticsResponse {
            date_availability: intermediate_rep.date_availability.into_iter().next(),
            pins: intermediate_rep.pins.into_iter().next(),
            sort_by: intermediate_rep.sort_by.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TopVideoPinsAnalyticsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TopVideoPinsAnalyticsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TopVideoPinsAnalyticsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TopVideoPinsAnalyticsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TopVideoPinsAnalyticsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TopVideoPinsAnalyticsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TopVideoPinsAnalyticsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Array with metrics, status, and pin id for the requested metric



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TopVideoPinsAnalyticsResponsePinsInner {
/// The metric name and daily value for each requested metric
    #[serde(rename = "metrics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metrics: Option<std::collections::HashMap<String, f64>>,

    #[serde(rename = "data_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data_status: Option<std::collections::HashMap<String, models::DataStatus>>,

/// The pin id
    #[serde(rename = "pin_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pin_id: Option<String>,

}


impl TopVideoPinsAnalyticsResponsePinsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TopVideoPinsAnalyticsResponsePinsInner {
        TopVideoPinsAnalyticsResponsePinsInner {
            metrics: None,
            data_status: None,
            pin_id: None,
        }
    }
}

/// Converts the TopVideoPinsAnalyticsResponsePinsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TopVideoPinsAnalyticsResponsePinsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping metrics in query parameter serialization

            // Skipping data_status in query parameter serialization
            // Skipping data_status in query parameter serialization


            self.pin_id.as_ref().map(|pin_id| {
                [
                    "pin_id".to_string(),
                    pin_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TopVideoPinsAnalyticsResponsePinsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TopVideoPinsAnalyticsResponsePinsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub metrics: Vec<std::collections::HashMap<String, f64>>,
            pub data_status: Vec<std::collections::HashMap<String, models::DataStatus>>,
            pub pin_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TopVideoPinsAnalyticsResponsePinsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "metrics" => return std::result::Result::Err("Parsing a container in this style is not supported in TopVideoPinsAnalyticsResponsePinsInner".to_string()),
                    "data_status" => return std::result::Result::Err("Parsing a container in this style is not supported in TopVideoPinsAnalyticsResponsePinsInner".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pin_id" => intermediate_rep.pin_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TopVideoPinsAnalyticsResponsePinsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TopVideoPinsAnalyticsResponsePinsInner {
            metrics: intermediate_rep.metrics.into_iter().next(),
            data_status: intermediate_rep.data_status.into_iter().next(),
            pin_id: intermediate_rep.pin_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TopVideoPinsAnalyticsResponsePinsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TopVideoPinsAnalyticsResponsePinsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TopVideoPinsAnalyticsResponsePinsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TopVideoPinsAnalyticsResponsePinsInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TopVideoPinsAnalyticsResponsePinsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TopVideoPinsAnalyticsResponsePinsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TopVideoPinsAnalyticsResponsePinsInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Third-party tracking URLs. Up to three tracking URLs - with a max length of 2,000 - are supported for each event type. Tracking URLs set at the ad group or ad level can override those set at the campaign level. For more information, see <a href=\"https://help.pinterest.com/en/business/article/third-party-and-dynamic-tracking\" target=\"_blank\">Third-party and dynamic tracking</a>.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TrackingUrls {
    #[serde(rename = "impression")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub impression: Option<Vec<String>>,

    #[serde(rename = "click")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub click: Option<Vec<String>>,

    #[serde(rename = "engagement")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub engagement: Option<Vec<String>>,

    #[serde(rename = "buyable_button")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub buyable_button: Option<Vec<String>>,

    #[serde(rename = "audience_verification")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audience_verification: Option<Vec<String>>,

}


impl TrackingUrls {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TrackingUrls {
        TrackingUrls {
            impression: None,
            click: None,
            engagement: None,
            buyable_button: None,
            audience_verification: None,
        }
    }
}

/// Converts the TrackingUrls value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TrackingUrls {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.impression.as_ref().map(|impression| {
                [
                    "impression".to_string(),
                    impression.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.click.as_ref().map(|click| {
                [
                    "click".to_string(),
                    click.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.engagement.as_ref().map(|engagement| {
                [
                    "engagement".to_string(),
                    engagement.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.buyable_button.as_ref().map(|buyable_button| {
                [
                    "buyable_button".to_string(),
                    buyable_button.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.audience_verification.as_ref().map(|audience_verification| {
                [
                    "audience_verification".to_string(),
                    audience_verification.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TrackingUrls value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TrackingUrls {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub impression: Vec<Vec<String>>,
            pub click: Vec<Vec<String>>,
            pub engagement: Vec<Vec<String>>,
            pub buyable_button: Vec<Vec<String>>,
            pub audience_verification: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TrackingUrls".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "impression" => return std::result::Result::Err("Parsing a container in this style is not supported in TrackingUrls".to_string()),
                    "click" => return std::result::Result::Err("Parsing a container in this style is not supported in TrackingUrls".to_string()),
                    "engagement" => return std::result::Result::Err("Parsing a container in this style is not supported in TrackingUrls".to_string()),
                    "buyable_button" => return std::result::Result::Err("Parsing a container in this style is not supported in TrackingUrls".to_string()),
                    "audience_verification" => return std::result::Result::Err("Parsing a container in this style is not supported in TrackingUrls".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TrackingUrls".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TrackingUrls {
            impression: intermediate_rep.impression.into_iter().next(),
            click: intermediate_rep.click.into_iter().next(),
            engagement: intermediate_rep.engagement.into_iter().next(),
            buyable_button: intermediate_rep.buyable_button.into_iter().next(),
            audience_verification: intermediate_rep.audience_verification.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TrackingUrls> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TrackingUrls>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TrackingUrls>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TrackingUrls - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TrackingUrls> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TrackingUrls as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TrackingUrls - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum TrendType {
    #[serde(rename = "growing")]
    Growing,
    #[serde(rename = "monthly")]
    Monthly,
    #[serde(rename = "yearly")]
    Yearly,
    #[serde(rename = "seasonal")]
    Seasonal,
}

impl std::fmt::Display for TrendType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TrendType::Growing => write!(f, "growing"),
            TrendType::Monthly => write!(f, "monthly"),
            TrendType::Yearly => write!(f, "yearly"),
            TrendType::Seasonal => write!(f, "seasonal"),
        }
    }
}

impl std::str::FromStr for TrendType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "growing" => std::result::Result::Ok(TrendType::Growing),
            "monthly" => std::result::Result::Ok(TrendType::Monthly),
            "yearly" => std::result::Result::Ok(TrendType::Yearly),
            "seasonal" => std::result::Result::Ok(TrendType::Seasonal),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TrendingKeywordsResponse {
/// The top trending keywords for the specified trend type in the requested region.<br /> Results are ordered, with the first element in the array representing the #1 top trend.
    #[serde(rename = "trends")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub trends: Option<Vec<models::TrendingKeywordsResponseTrendsInner>>,

}


impl TrendingKeywordsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TrendingKeywordsResponse {
        TrendingKeywordsResponse {
            trends: None,
        }
    }
}

/// Converts the TrendingKeywordsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TrendingKeywordsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping trends in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TrendingKeywordsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TrendingKeywordsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub trends: Vec<Vec<models::TrendingKeywordsResponseTrendsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TrendingKeywordsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "trends" => return std::result::Result::Err("Parsing a container in this style is not supported in TrendingKeywordsResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TrendingKeywordsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TrendingKeywordsResponse {
            trends: intermediate_rep.trends.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TrendingKeywordsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TrendingKeywordsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TrendingKeywordsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TrendingKeywordsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TrendingKeywordsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TrendingKeywordsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TrendingKeywordsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TrendingKeywordsResponseTrendsInner {
/// The keyword that is trending.
    #[serde(rename = "keyword")]
    #[validate(
            length(min = 1),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub keyword: Option<String>,

/// The week-over-week percent change in search volume for this keyword.<br /> For example, a value of \"50\" would represent a 50% increase in searches in the last seven days compared to the week prior.<br /> **Note**: growth rates are rounded, with a maximum of +/- 10000% change.  A value of 10001 indicates that this keyword experienced > 10000% week-over-week growth.
    #[serde(rename = "pct_growth_wow")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pct_growth_wow: Option<i32>,

/// The month-over-month percent change in search volume for this keyword.<br /> For example, a value of \"400\" would represent a 400% increase in searches in the last 30 days compared to the month prior.<br /> **Note**: growth rates are rounded, with a maximum of +/- 10000% change.  A value of 10001 indicates that this keyword experienced > 10000% month-over-month growth.
    #[serde(rename = "pct_growth_mom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pct_growth_mom: Option<i32>,

/// The year-over-year percent change in search volume for this keyword.<br /> For example, a value of \"-5\" would represent a 5% decrease in searches in the last 365 days compared to the month prior.<br /> **Note**: growth rates are rounded, with a maximum of +/- 10000% change.  A value of 10001 indicates that this keyword experienced > 10000% year-over-year growth.
    #[serde(rename = "pct_growth_yoy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pct_growth_yoy: Option<i32>,

    #[serde(rename = "time_series")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub time_series: Option<models::TrendingKeywordsResponseTrendsInnerTimeSeries>,

}


impl TrendingKeywordsResponseTrendsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TrendingKeywordsResponseTrendsInner {
        TrendingKeywordsResponseTrendsInner {
            keyword: None,
            pct_growth_wow: None,
            pct_growth_mom: None,
            pct_growth_yoy: None,
            time_series: None,
        }
    }
}

/// Converts the TrendingKeywordsResponseTrendsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TrendingKeywordsResponseTrendsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.keyword.as_ref().map(|keyword| {
                [
                    "keyword".to_string(),
                    keyword.to_string(),
                ].join(",")
            }),


            self.pct_growth_wow.as_ref().map(|pct_growth_wow| {
                [
                    "pct_growth_wow".to_string(),
                    pct_growth_wow.to_string(),
                ].join(",")
            }),


            self.pct_growth_mom.as_ref().map(|pct_growth_mom| {
                [
                    "pct_growth_mom".to_string(),
                    pct_growth_mom.to_string(),
                ].join(",")
            }),


            self.pct_growth_yoy.as_ref().map(|pct_growth_yoy| {
                [
                    "pct_growth_yoy".to_string(),
                    pct_growth_yoy.to_string(),
                ].join(",")
            }),

            // Skipping time_series in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TrendingKeywordsResponseTrendsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TrendingKeywordsResponseTrendsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub keyword: Vec<String>,
            pub pct_growth_wow: Vec<i32>,
            pub pct_growth_mom: Vec<i32>,
            pub pct_growth_yoy: Vec<i32>,
            pub time_series: Vec<models::TrendingKeywordsResponseTrendsInnerTimeSeries>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TrendingKeywordsResponseTrendsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "keyword" => intermediate_rep.keyword.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pct_growth_wow" => intermediate_rep.pct_growth_wow.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pct_growth_mom" => intermediate_rep.pct_growth_mom.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pct_growth_yoy" => intermediate_rep.pct_growth_yoy.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "time_series" => intermediate_rep.time_series.push(<models::TrendingKeywordsResponseTrendsInnerTimeSeries as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TrendingKeywordsResponseTrendsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TrendingKeywordsResponseTrendsInner {
            keyword: intermediate_rep.keyword.into_iter().next(),
            pct_growth_wow: intermediate_rep.pct_growth_wow.into_iter().next(),
            pct_growth_mom: intermediate_rep.pct_growth_mom.into_iter().next(),
            pct_growth_yoy: intermediate_rep.pct_growth_yoy.into_iter().next(),
            time_series: intermediate_rep.time_series.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TrendingKeywordsResponseTrendsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TrendingKeywordsResponseTrendsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TrendingKeywordsResponseTrendsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TrendingKeywordsResponseTrendsInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TrendingKeywordsResponseTrendsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TrendingKeywordsResponseTrendsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TrendingKeywordsResponseTrendsInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A sequence of weekly observations of the relative search volume for this keyword over the past year.<br /> These values are normalized to a [0-100] range, and can be used to visualize the history of user interest in this keyword. By default, normalization is applied independently to the time series of each keyword, but the `normalize_against_group` query parameter can be used in cases where you wish to compare relative volume between keywords.<br /> **Note**: The date of each observation is in ISO-8601 format and represents the *end* of the week.  For example, a value of `2023-10-31` would include searches that happened between `2023-10-25` and `2023-10-31`.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TrendingKeywordsResponseTrendsInnerTimeSeries {
    #[serde(rename = "date")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::naive::NaiveDate>,

}


impl TrendingKeywordsResponseTrendsInnerTimeSeries {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TrendingKeywordsResponseTrendsInnerTimeSeries {
        TrendingKeywordsResponseTrendsInnerTimeSeries {
            date: None,
        }
    }
}

/// Converts the TrendingKeywordsResponseTrendsInnerTimeSeries value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TrendingKeywordsResponseTrendsInnerTimeSeries {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping date in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TrendingKeywordsResponseTrendsInnerTimeSeries value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TrendingKeywordsResponseTrendsInnerTimeSeries {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub date: Vec<chrono::naive::NaiveDate>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TrendingKeywordsResponseTrendsInnerTimeSeries".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "date" => intermediate_rep.date.push(<chrono::naive::NaiveDate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TrendingKeywordsResponseTrendsInnerTimeSeries".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TrendingKeywordsResponseTrendsInnerTimeSeries {
            date: intermediate_rep.date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TrendingKeywordsResponseTrendsInnerTimeSeries> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TrendingKeywordsResponseTrendsInnerTimeSeries>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TrendingKeywordsResponseTrendsInnerTimeSeries>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TrendingKeywordsResponseTrendsInnerTimeSeries - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TrendingKeywordsResponseTrendsInnerTimeSeries> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TrendingKeywordsResponseTrendsInnerTimeSeries as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TrendingKeywordsResponseTrendsInnerTimeSeries - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum TrendsSupportedRegion {
    #[serde(rename = "US")]
    Us,
    #[serde(rename = "CA")]
    Ca,
    #[serde(rename = "DE")]
    De,
    #[serde(rename = "FR")]
    Fr,
    #[serde(rename = "ES")]
    Es,
    #[serde(rename = "IT")]
    It,
    #[serde(rename = "DE+AT+CH")]
    DePlusAtPlusCh,
    #[serde(rename = "GB+IE")]
    GbPlusIe,
    #[serde(rename = "IT+ES+PT+GR+MT")]
    ItPlusEsPlusPtPlusGrPlusMt,
    #[serde(rename = "PL+RO+HU+SK+CZ")]
    PlPlusRoPlusHuPlusSkPlusCz,
    #[serde(rename = "SE+DK+FI+NO")]
    SePlusDkPlusFiPlusNo,
    #[serde(rename = "NL+BE+LU")]
    NlPlusBePlusLu,
    #[serde(rename = "AR")]
    Ar,
    #[serde(rename = "BR")]
    Br,
    #[serde(rename = "CO")]
    Co,
    #[serde(rename = "MX")]
    Mx,
    #[serde(rename = "MX+AR+CO+CL")]
    MxPlusArPlusCoPlusCl,
    #[serde(rename = "AU+NZ")]
    AuPlusNz,
}

impl std::fmt::Display for TrendsSupportedRegion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TrendsSupportedRegion::Us => write!(f, "US"),
            TrendsSupportedRegion::Ca => write!(f, "CA"),
            TrendsSupportedRegion::De => write!(f, "DE"),
            TrendsSupportedRegion::Fr => write!(f, "FR"),
            TrendsSupportedRegion::Es => write!(f, "ES"),
            TrendsSupportedRegion::It => write!(f, "IT"),
            TrendsSupportedRegion::DePlusAtPlusCh => write!(f, "DE+AT+CH"),
            TrendsSupportedRegion::GbPlusIe => write!(f, "GB+IE"),
            TrendsSupportedRegion::ItPlusEsPlusPtPlusGrPlusMt => write!(f, "IT+ES+PT+GR+MT"),
            TrendsSupportedRegion::PlPlusRoPlusHuPlusSkPlusCz => write!(f, "PL+RO+HU+SK+CZ"),
            TrendsSupportedRegion::SePlusDkPlusFiPlusNo => write!(f, "SE+DK+FI+NO"),
            TrendsSupportedRegion::NlPlusBePlusLu => write!(f, "NL+BE+LU"),
            TrendsSupportedRegion::Ar => write!(f, "AR"),
            TrendsSupportedRegion::Br => write!(f, "BR"),
            TrendsSupportedRegion::Co => write!(f, "CO"),
            TrendsSupportedRegion::Mx => write!(f, "MX"),
            TrendsSupportedRegion::MxPlusArPlusCoPlusCl => write!(f, "MX+AR+CO+CL"),
            TrendsSupportedRegion::AuPlusNz => write!(f, "AU+NZ"),
        }
    }
}

impl std::str::FromStr for TrendsSupportedRegion {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "US" => std::result::Result::Ok(TrendsSupportedRegion::Us),
            "CA" => std::result::Result::Ok(TrendsSupportedRegion::Ca),
            "DE" => std::result::Result::Ok(TrendsSupportedRegion::De),
            "FR" => std::result::Result::Ok(TrendsSupportedRegion::Fr),
            "ES" => std::result::Result::Ok(TrendsSupportedRegion::Es),
            "IT" => std::result::Result::Ok(TrendsSupportedRegion::It),
            "DE+AT+CH" => std::result::Result::Ok(TrendsSupportedRegion::DePlusAtPlusCh),
            "GB+IE" => std::result::Result::Ok(TrendsSupportedRegion::GbPlusIe),
            "IT+ES+PT+GR+MT" => std::result::Result::Ok(TrendsSupportedRegion::ItPlusEsPlusPtPlusGrPlusMt),
            "PL+RO+HU+SK+CZ" => std::result::Result::Ok(TrendsSupportedRegion::PlPlusRoPlusHuPlusSkPlusCz),
            "SE+DK+FI+NO" => std::result::Result::Ok(TrendsSupportedRegion::SePlusDkPlusFiPlusNo),
            "NL+BE+LU" => std::result::Result::Ok(TrendsSupportedRegion::NlPlusBePlusLu),
            "AR" => std::result::Result::Ok(TrendsSupportedRegion::Ar),
            "BR" => std::result::Result::Ok(TrendsSupportedRegion::Br),
            "CO" => std::result::Result::Ok(TrendsSupportedRegion::Co),
            "MX" => std::result::Result::Ok(TrendsSupportedRegion::Mx),
            "MX+AR+CO+CL" => std::result::Result::Ok(TrendsSupportedRegion::MxPlusArPlusCoPlusCl),
            "AU+NZ" => std::result::Result::Ok(TrendsSupportedRegion::AuPlusNz),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdatableItemAttributes {
/// Allows advertisers to specify a separate URL that can be used to track traffic coming from Pinterest shopping ads. Must send full URL including tracking—do not send tracking parameters only. At this time we do not support impression tracking. Must begin with http:// or https://.
    #[serde(rename = "ad_link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_link: Option<Nullable<String>>,

/// Set this attribute to TRUE if you're submitting items that are considered “adult”. These will not be shown on Pinterest.
    #[serde(rename = "adult")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adult: Option<Nullable<bool>>,

/// The age group to apply a demographic range to the product. Must be one of the following values (upper or lowercased): ‘newborn’, ‘infant’, ‘toddler’, ‘kids’, or ‘adult’.
    #[serde(rename = "age_group")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub age_group: Option<Nullable<String>>,

/// The availability of the product. Must be one of the following values (upper or lowercased): ‘in stock’, ‘out of stock’, ‘preorder’.
    #[serde(rename = "availability")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub availability: Option<String>,

/// Average reviews for the item. Can be a number from 1-5.
    #[serde(rename = "average_review_rating")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub average_review_rating: Option<Nullable<f64>>,

/// The brand of the product.
    #[serde(rename = "brand")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub brand: Option<Nullable<String>>,

/// This attribute is not supported anymore.
    #[serde(rename = "checkout_enabled")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub checkout_enabled: Option<Nullable<bool>>,

/// The primary color of the product.
    #[serde(rename = "color")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub color: Option<Nullable<String>>,

/// The condition of the product. Must be one of the following values (upper or lowercased): ‘new’, ‘used’, or ‘refurbished’.
    #[serde(rename = "condition")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub condition: Option<Nullable<String>>,

/// <p><= 1000 characters</p> <p>Custom grouping of products.</p>
    #[serde(rename = "custom_label_0")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_0: Option<Nullable<String>>,

/// <p><= 1000 characters</p> <p>Custom grouping of products.</p>
    #[serde(rename = "custom_label_1")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_1: Option<Nullable<String>>,

/// <p><= 1000 characters</p> <p>Custom grouping of products.</p>
    #[serde(rename = "custom_label_2")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_2: Option<Nullable<String>>,

/// <p><= 1000 characters</p> <p>Custom grouping of products.</p>
    #[serde(rename = "custom_label_3")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_3: Option<Nullable<String>>,

/// <p><= 1000 characters</p> <p>Custom grouping of products.</p>
    #[serde(rename = "custom_label_4")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_4: Option<Nullable<String>>,

/// <p><= 10000 characters</p> <p>The description of the product.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

/// The item is free to ship.
    #[serde(rename = "free_shipping_label")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub free_shipping_label: Option<Nullable<bool>>,

/// The minimum order purchase necessary for the customer to get free shipping. Only relevant if free shipping is offered.
    #[serde(rename = "free_shipping_limit")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub free_shipping_limit: Option<Nullable<String>>,

/// The gender associated with the product. Must be one of the following values (upper or lowercased): ‘male’, ‘female’, or ‘unisex’.
    #[serde(rename = "gender")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gender: Option<Nullable<String>>,

/// The categorization of the product based on the standardized Google Product Taxonomy. This is a set taxonomy. Both the text values and numeric codes are accepted.
    #[serde(rename = "google_product_category")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub google_product_category: Option<Nullable<String>>,

/// The unique universal product identifier.
    #[serde(rename = "gtin")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gtin: Option<Nullable<i32>>,

/// <p><= 127 characters</p> <p>The user-created unique ID that represents the product. Only Unicode characters are accepted.</p>
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// <p><= 127 characters</p> <p>The parent ID of the product.</p>
    #[serde(rename = "item_group_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_group_id: Option<Nullable<String>>,

/// The millisecond timestamp when the item was lastly modified by the merchant.
    #[serde(rename = "last_updated_time")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_updated_time: Option<Nullable<i64>>,

/// <p><= 511 characters</p> <p>The landing page for the product.</p>
    #[serde(rename = "link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link: Option<String>,

/// The material used to make the product.
    #[serde(rename = "material")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub material: Option<Nullable<String>>,

/// The minimum advertised price of the product. It supports the following formats, \"19.99 USD\", \"19.99USD\" and \"19.99\". If the currency is not included, we default to US dollars.
    #[serde(rename = "min_ad_price")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_ad_price: Option<Nullable<String>>,

/// The mobile-optimized version of your landing page. Must begin with http:// or https://.
    #[serde(rename = "mobile_link")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mobile_link: Option<Nullable<String>>,

/// Manufacturer Part Number are alpha-numeric codes created by the manufacturer of a product to uniquely identify it among all products from the same manufacturer.
    #[serde(rename = "mpn")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mpn: Option<Nullable<String>>,

/// The number of ratings for the item.
    #[serde(rename = "number_of_ratings")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub number_of_ratings: Option<Nullable<i32>>,

/// The number of reviews available for the item.
    #[serde(rename = "number_of_reviews")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub number_of_reviews: Option<Nullable<i32>>,

/// The description of the pattern used for the product.
    #[serde(rename = "pattern")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pattern: Option<Nullable<String>>,

/// The price of the product. It supports the following formats, \"24.99 USD\", \"24.99USD\" and \"24.99\". If the currency is not included, we default to US dollars.
    #[serde(rename = "price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<String>,

/// <p><= 1000 characters</p> <p>The categorization of your product based on your custom product taxonomy. Subcategories must be sent separated by “ > “. The > must be wrapped by spaces. We do not recognize any other delimiters such as comma or pipe.</p>
    #[serde(rename = "product_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_type: Option<Nullable<String>>,

/// The discounted price of the product. The sale_price must be lower than the price. It supports the following formats, \"14.99 USD\", \"14.99USD\" and \"14.99\". If the currency is not included, we default to US dollars.
    #[serde(rename = "sale_price")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sale_price: Option<Nullable<String>>,

/// Shipping consists of one group of up to four elements, country, region, service (all optional) and price (required). All colons, even for blank values, are required.
    #[serde(rename = "shipping")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping: Option<Nullable<String>>,

/// The height of the package needed to ship the product. Ensure there is a space between the numeric string and the metric.
    #[serde(rename = "shipping_height")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_height: Option<Nullable<String>>,

/// The weight of the product. Ensure there is a space between the numeric string and the metric.
    #[serde(rename = "shipping_weight")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_weight: Option<Nullable<String>>,

/// The width of the package needed to ship the product. Ensure there is a space between the numeric string and the metric.
    #[serde(rename = "shipping_width")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_width: Option<Nullable<String>>,

/// The size of the product.
    #[serde(rename = "size")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<Nullable<String>>,

/// Indicates the country’s sizing system in which you are submitting your product. Must be one of the following values (upper or lowercased): ‘US’, ‘UK’, ‘EU’, ‘DE’, ‘FR’, ‘JP’, ‘CN’, ‘IT’, ‘BR’, ‘MEX’, or ‘AU’.
    #[serde(rename = "size_system")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_system: Option<Nullable<String>>,

/// Additional description for the size. Must be one of the following values (upper or lowercased): ‘regular’, ‘petite’, ‘plus’, ‘big_and_tall’, or ‘maternity’.
    #[serde(rename = "size_type")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_type: Option<Nullable<String>>,

/// Tax consists of one group of up to four elements, country, region, rate (all required) and tax_ship (optional). All colons, even for blank values, are required.
    #[serde(rename = "tax")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tax: Option<Nullable<String>>,

/// <p><= 500 characters</p> <p>The name of the product.</p>
    #[serde(rename = "title")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,

/// Options for this variant. People will see these options next to your Pin and can select the one they want. List them in the order you want them displayed.
    #[serde(rename = "variant_names")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub variant_names: Option<Nullable<Vec<String>>>,

/// Option values for this variant. People will see these options next to your Pin and can select the one they want. List them in the order you want them displayed. The order of the variant values must be consistent with the order of the variant names.
    #[serde(rename = "variant_values")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub variant_values: Option<Nullable<Vec<String>>>,

}


impl UpdatableItemAttributes {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> UpdatableItemAttributes {
        UpdatableItemAttributes {
            ad_link: None,
            adult: None,
            age_group: None,
            availability: None,
            average_review_rating: None,
            brand: None,
            checkout_enabled: None,
            color: None,
            condition: None,
            custom_label_0: None,
            custom_label_1: None,
            custom_label_2: None,
            custom_label_3: None,
            custom_label_4: None,
            description: None,
            free_shipping_label: None,
            free_shipping_limit: None,
            gender: None,
            google_product_category: None,
            gtin: None,
            id: None,
            item_group_id: None,
            last_updated_time: None,
            link: None,
            material: None,
            min_ad_price: None,
            mobile_link: None,
            mpn: None,
            number_of_ratings: None,
            number_of_reviews: None,
            pattern: None,
            price: None,
            product_type: None,
            sale_price: None,
            shipping: None,
            shipping_height: None,
            shipping_weight: None,
            shipping_width: None,
            size: None,
            size_system: None,
            size_type: None,
            tax: None,
            title: None,
            variant_names: None,
            variant_values: None,
        }
    }
}

/// Converts the UpdatableItemAttributes value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UpdatableItemAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ad_link.as_ref().map(|ad_link| {
                [
                    "ad_link".to_string(),
                    ad_link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.adult.as_ref().map(|adult| {
                [
                    "adult".to_string(),
                    adult.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.age_group.as_ref().map(|age_group| {
                [
                    "age_group".to_string(),
                    age_group.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.availability.as_ref().map(|availability| {
                [
                    "availability".to_string(),
                    availability.to_string(),
                ].join(",")
            }),


            self.average_review_rating.as_ref().map(|average_review_rating| {
                [
                    "average_review_rating".to_string(),
                    average_review_rating.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.brand.as_ref().map(|brand| {
                [
                    "brand".to_string(),
                    brand.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.checkout_enabled.as_ref().map(|checkout_enabled| {
                [
                    "checkout_enabled".to_string(),
                    checkout_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.color.as_ref().map(|color| {
                [
                    "color".to_string(),
                    color.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.condition.as_ref().map(|condition| {
                [
                    "condition".to_string(),
                    condition.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_0.as_ref().map(|custom_label_0| {
                [
                    "custom_label_0".to_string(),
                    custom_label_0.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_1.as_ref().map(|custom_label_1| {
                [
                    "custom_label_1".to_string(),
                    custom_label_1.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_2.as_ref().map(|custom_label_2| {
                [
                    "custom_label_2".to_string(),
                    custom_label_2.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_3.as_ref().map(|custom_label_3| {
                [
                    "custom_label_3".to_string(),
                    custom_label_3.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.custom_label_4.as_ref().map(|custom_label_4| {
                [
                    "custom_label_4".to_string(),
                    custom_label_4.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.free_shipping_label.as_ref().map(|free_shipping_label| {
                [
                    "free_shipping_label".to_string(),
                    free_shipping_label.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.free_shipping_limit.as_ref().map(|free_shipping_limit| {
                [
                    "free_shipping_limit".to_string(),
                    free_shipping_limit.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.gender.as_ref().map(|gender| {
                [
                    "gender".to_string(),
                    gender.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.google_product_category.as_ref().map(|google_product_category| {
                [
                    "google_product_category".to_string(),
                    google_product_category.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.gtin.as_ref().map(|gtin| {
                [
                    "gtin".to_string(),
                    gtin.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.item_group_id.as_ref().map(|item_group_id| {
                [
                    "item_group_id".to_string(),
                    item_group_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.last_updated_time.as_ref().map(|last_updated_time| {
                [
                    "last_updated_time".to_string(),
                    last_updated_time.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.link.as_ref().map(|link| {
                [
                    "link".to_string(),
                    link.to_string(),
                ].join(",")
            }),


            self.material.as_ref().map(|material| {
                [
                    "material".to_string(),
                    material.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.min_ad_price.as_ref().map(|min_ad_price| {
                [
                    "min_ad_price".to_string(),
                    min_ad_price.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.mobile_link.as_ref().map(|mobile_link| {
                [
                    "mobile_link".to_string(),
                    mobile_link.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.mpn.as_ref().map(|mpn| {
                [
                    "mpn".to_string(),
                    mpn.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.number_of_ratings.as_ref().map(|number_of_ratings| {
                [
                    "number_of_ratings".to_string(),
                    number_of_ratings.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.number_of_reviews.as_ref().map(|number_of_reviews| {
                [
                    "number_of_reviews".to_string(),
                    number_of_reviews.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.pattern.as_ref().map(|pattern| {
                [
                    "pattern".to_string(),
                    pattern.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.price.as_ref().map(|price| {
                [
                    "price".to_string(),
                    price.to_string(),
                ].join(",")
            }),


            self.product_type.as_ref().map(|product_type| {
                [
                    "product_type".to_string(),
                    product_type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.sale_price.as_ref().map(|sale_price| {
                [
                    "sale_price".to_string(),
                    sale_price.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.shipping.as_ref().map(|shipping| {
                [
                    "shipping".to_string(),
                    shipping.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.shipping_height.as_ref().map(|shipping_height| {
                [
                    "shipping_height".to_string(),
                    shipping_height.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.shipping_weight.as_ref().map(|shipping_weight| {
                [
                    "shipping_weight".to_string(),
                    shipping_weight.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.shipping_width.as_ref().map(|shipping_width| {
                [
                    "shipping_width".to_string(),
                    shipping_width.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "size".to_string(),
                    size.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.size_system.as_ref().map(|size_system| {
                [
                    "size_system".to_string(),
                    size_system.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.size_type.as_ref().map(|size_type| {
                [
                    "size_type".to_string(),
                    size_type.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.tax.as_ref().map(|tax| {
                [
                    "tax".to_string(),
                    tax.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.title.as_ref().map(|title| {
                [
                    "title".to_string(),
                    title.to_string(),
                ].join(",")
            }),


            self.variant_names.as_ref().map(|variant_names| {
                [
                    "variant_names".to_string(),
                    variant_names.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),


            self.variant_values.as_ref().map(|variant_values| {
                [
                    "variant_values".to_string(),
                    variant_values.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdatableItemAttributes value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdatableItemAttributes {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ad_link: Vec<String>,
            pub adult: Vec<bool>,
            pub age_group: Vec<String>,
            pub availability: Vec<String>,
            pub average_review_rating: Vec<f64>,
            pub brand: Vec<String>,
            pub checkout_enabled: Vec<bool>,
            pub color: Vec<String>,
            pub condition: Vec<String>,
            pub custom_label_0: Vec<String>,
            pub custom_label_1: Vec<String>,
            pub custom_label_2: Vec<String>,
            pub custom_label_3: Vec<String>,
            pub custom_label_4: Vec<String>,
            pub description: Vec<String>,
            pub free_shipping_label: Vec<bool>,
            pub free_shipping_limit: Vec<String>,
            pub gender: Vec<String>,
            pub google_product_category: Vec<String>,
            pub gtin: Vec<i32>,
            pub id: Vec<String>,
            pub item_group_id: Vec<String>,
            pub last_updated_time: Vec<i64>,
            pub link: Vec<String>,
            pub material: Vec<String>,
            pub min_ad_price: Vec<String>,
            pub mobile_link: Vec<String>,
            pub mpn: Vec<String>,
            pub number_of_ratings: Vec<i32>,
            pub number_of_reviews: Vec<i32>,
            pub pattern: Vec<String>,
            pub price: Vec<String>,
            pub product_type: Vec<String>,
            pub sale_price: Vec<String>,
            pub shipping: Vec<String>,
            pub shipping_height: Vec<String>,
            pub shipping_weight: Vec<String>,
            pub shipping_width: Vec<String>,
            pub size: Vec<String>,
            pub size_system: Vec<String>,
            pub size_type: Vec<String>,
            pub tax: Vec<String>,
            pub title: Vec<String>,
            pub variant_names: Vec<Vec<String>>,
            pub variant_values: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdatableItemAttributes".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ad_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "adult" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "age_group" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "availability" => intermediate_rep.availability.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "average_review_rating" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "brand" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "checkout_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "color" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "condition" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "custom_label_0" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "custom_label_1" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "custom_label_2" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "custom_label_3" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "custom_label_4" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "free_shipping_label" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "free_shipping_limit" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "gender" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "google_product_category" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "gtin" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "item_group_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "last_updated_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "link" => intermediate_rep.link.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "material" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "min_ad_price" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "mobile_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "mpn" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "number_of_ratings" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "number_of_reviews" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "pattern" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "price" => intermediate_rep.price.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "product_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "sale_price" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "shipping" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "shipping_height" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "shipping_weight" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "shipping_width" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "size" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "size_system" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "size_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    "tax" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdatableItemAttributes".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "variant_names" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdatableItemAttributes".to_string()),
                    "variant_values" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdatableItemAttributes".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdatableItemAttributes".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdatableItemAttributes {
            ad_link: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            adult: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            age_group: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            availability: intermediate_rep.availability.into_iter().next(),
            average_review_rating: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            brand: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            checkout_enabled: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            color: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            condition: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            custom_label_0: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            custom_label_1: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            custom_label_2: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            custom_label_3: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            custom_label_4: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            description: intermediate_rep.description.into_iter().next(),
            free_shipping_label: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            free_shipping_limit: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            gender: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            google_product_category: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            gtin: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            id: intermediate_rep.id.into_iter().next(),
            item_group_id: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            last_updated_time: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            link: intermediate_rep.link.into_iter().next(),
            material: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            min_ad_price: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            mobile_link: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            mpn: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            number_of_ratings: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            number_of_reviews: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            pattern: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            price: intermediate_rep.price.into_iter().next(),
            product_type: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            sale_price: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            shipping: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            shipping_height: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            shipping_weight: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            shipping_width: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            size: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            size_system: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            size_type: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            tax: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            title: intermediate_rep.title.into_iter().next(),
            variant_names: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
            variant_values: std::result::Result::Err("Nullable types not supported in UpdatableItemAttributes".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdatableItemAttributes> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdatableItemAttributes>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdatableItemAttributes>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdatableItemAttributes - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UpdatableItemAttributes> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdatableItemAttributes as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdatableItemAttributes - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The field types supported by the update mask
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum UpdateMaskFieldType {
    #[serde(rename = "ad_link")]
    AdLink,
    #[serde(rename = "adult")]
    Adult,
    #[serde(rename = "age_group")]
    AgeGroup,
    #[serde(rename = "availability")]
    Availability,
    #[serde(rename = "average_review_rating")]
    AverageReviewRating,
    #[serde(rename = "brand")]
    Brand,
    #[serde(rename = "checkout_enabled")]
    CheckoutEnabled,
    #[serde(rename = "color")]
    Color,
    #[serde(rename = "condition")]
    Condition,
    #[serde(rename = "custom_label_0")]
    CustomLabel0,
    #[serde(rename = "custom_label_1")]
    CustomLabel1,
    #[serde(rename = "custom_label_2")]
    CustomLabel2,
    #[serde(rename = "custom_label_3")]
    CustomLabel3,
    #[serde(rename = "custom_label_4")]
    CustomLabel4,
    #[serde(rename = "description")]
    Description,
    #[serde(rename = "free_shipping_label")]
    FreeShippingLabel,
    #[serde(rename = "free_shipping_limit")]
    FreeShippingLimit,
    #[serde(rename = "gender")]
    Gender,
    #[serde(rename = "google_product_category")]
    GoogleProductCategory,
    #[serde(rename = "gtin")]
    Gtin,
    #[serde(rename = "item_group_id")]
    ItemGroupId,
    #[serde(rename = "last_updated_time")]
    LastUpdatedTime,
    #[serde(rename = "link")]
    Link,
    #[serde(rename = "material")]
    Material,
    #[serde(rename = "min_ad_price")]
    MinAdPrice,
    #[serde(rename = "mpn")]
    Mpn,
    #[serde(rename = "number_of_ratings")]
    NumberOfRatings,
    #[serde(rename = "number_of_reviews")]
    NumberOfReviews,
    #[serde(rename = "pattern")]
    Pattern,
    #[serde(rename = "price")]
    Price,
    #[serde(rename = "product_type")]
    ProductType,
    #[serde(rename = "sale_price")]
    SalePrice,
    #[serde(rename = "shipping")]
    Shipping,
    #[serde(rename = "shipping_height")]
    ShippingHeight,
    #[serde(rename = "shipping_weight")]
    ShippingWeight,
    #[serde(rename = "shipping_width")]
    ShippingWidth,
    #[serde(rename = "size")]
    Size,
    #[serde(rename = "size_system")]
    SizeSystem,
    #[serde(rename = "size_type")]
    SizeType,
    #[serde(rename = "tax")]
    Tax,
    #[serde(rename = "title")]
    Title,
    #[serde(rename = "variant_names")]
    VariantNames,
    #[serde(rename = "variant_values")]
    VariantValues,
}

impl std::fmt::Display for UpdateMaskFieldType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            UpdateMaskFieldType::AdLink => write!(f, "ad_link"),
            UpdateMaskFieldType::Adult => write!(f, "adult"),
            UpdateMaskFieldType::AgeGroup => write!(f, "age_group"),
            UpdateMaskFieldType::Availability => write!(f, "availability"),
            UpdateMaskFieldType::AverageReviewRating => write!(f, "average_review_rating"),
            UpdateMaskFieldType::Brand => write!(f, "brand"),
            UpdateMaskFieldType::CheckoutEnabled => write!(f, "checkout_enabled"),
            UpdateMaskFieldType::Color => write!(f, "color"),
            UpdateMaskFieldType::Condition => write!(f, "condition"),
            UpdateMaskFieldType::CustomLabel0 => write!(f, "custom_label_0"),
            UpdateMaskFieldType::CustomLabel1 => write!(f, "custom_label_1"),
            UpdateMaskFieldType::CustomLabel2 => write!(f, "custom_label_2"),
            UpdateMaskFieldType::CustomLabel3 => write!(f, "custom_label_3"),
            UpdateMaskFieldType::CustomLabel4 => write!(f, "custom_label_4"),
            UpdateMaskFieldType::Description => write!(f, "description"),
            UpdateMaskFieldType::FreeShippingLabel => write!(f, "free_shipping_label"),
            UpdateMaskFieldType::FreeShippingLimit => write!(f, "free_shipping_limit"),
            UpdateMaskFieldType::Gender => write!(f, "gender"),
            UpdateMaskFieldType::GoogleProductCategory => write!(f, "google_product_category"),
            UpdateMaskFieldType::Gtin => write!(f, "gtin"),
            UpdateMaskFieldType::ItemGroupId => write!(f, "item_group_id"),
            UpdateMaskFieldType::LastUpdatedTime => write!(f, "last_updated_time"),
            UpdateMaskFieldType::Link => write!(f, "link"),
            UpdateMaskFieldType::Material => write!(f, "material"),
            UpdateMaskFieldType::MinAdPrice => write!(f, "min_ad_price"),
            UpdateMaskFieldType::Mpn => write!(f, "mpn"),
            UpdateMaskFieldType::NumberOfRatings => write!(f, "number_of_ratings"),
            UpdateMaskFieldType::NumberOfReviews => write!(f, "number_of_reviews"),
            UpdateMaskFieldType::Pattern => write!(f, "pattern"),
            UpdateMaskFieldType::Price => write!(f, "price"),
            UpdateMaskFieldType::ProductType => write!(f, "product_type"),
            UpdateMaskFieldType::SalePrice => write!(f, "sale_price"),
            UpdateMaskFieldType::Shipping => write!(f, "shipping"),
            UpdateMaskFieldType::ShippingHeight => write!(f, "shipping_height"),
            UpdateMaskFieldType::ShippingWeight => write!(f, "shipping_weight"),
            UpdateMaskFieldType::ShippingWidth => write!(f, "shipping_width"),
            UpdateMaskFieldType::Size => write!(f, "size"),
            UpdateMaskFieldType::SizeSystem => write!(f, "size_system"),
            UpdateMaskFieldType::SizeType => write!(f, "size_type"),
            UpdateMaskFieldType::Tax => write!(f, "tax"),
            UpdateMaskFieldType::Title => write!(f, "title"),
            UpdateMaskFieldType::VariantNames => write!(f, "variant_names"),
            UpdateMaskFieldType::VariantValues => write!(f, "variant_values"),
        }
    }
}

impl std::str::FromStr for UpdateMaskFieldType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ad_link" => std::result::Result::Ok(UpdateMaskFieldType::AdLink),
            "adult" => std::result::Result::Ok(UpdateMaskFieldType::Adult),
            "age_group" => std::result::Result::Ok(UpdateMaskFieldType::AgeGroup),
            "availability" => std::result::Result::Ok(UpdateMaskFieldType::Availability),
            "average_review_rating" => std::result::Result::Ok(UpdateMaskFieldType::AverageReviewRating),
            "brand" => std::result::Result::Ok(UpdateMaskFieldType::Brand),
            "checkout_enabled" => std::result::Result::Ok(UpdateMaskFieldType::CheckoutEnabled),
            "color" => std::result::Result::Ok(UpdateMaskFieldType::Color),
            "condition" => std::result::Result::Ok(UpdateMaskFieldType::Condition),
            "custom_label_0" => std::result::Result::Ok(UpdateMaskFieldType::CustomLabel0),
            "custom_label_1" => std::result::Result::Ok(UpdateMaskFieldType::CustomLabel1),
            "custom_label_2" => std::result::Result::Ok(UpdateMaskFieldType::CustomLabel2),
            "custom_label_3" => std::result::Result::Ok(UpdateMaskFieldType::CustomLabel3),
            "custom_label_4" => std::result::Result::Ok(UpdateMaskFieldType::CustomLabel4),
            "description" => std::result::Result::Ok(UpdateMaskFieldType::Description),
            "free_shipping_label" => std::result::Result::Ok(UpdateMaskFieldType::FreeShippingLabel),
            "free_shipping_limit" => std::result::Result::Ok(UpdateMaskFieldType::FreeShippingLimit),
            "gender" => std::result::Result::Ok(UpdateMaskFieldType::Gender),
            "google_product_category" => std::result::Result::Ok(UpdateMaskFieldType::GoogleProductCategory),
            "gtin" => std::result::Result::Ok(UpdateMaskFieldType::Gtin),
            "item_group_id" => std::result::Result::Ok(UpdateMaskFieldType::ItemGroupId),
            "last_updated_time" => std::result::Result::Ok(UpdateMaskFieldType::LastUpdatedTime),
            "link" => std::result::Result::Ok(UpdateMaskFieldType::Link),
            "material" => std::result::Result::Ok(UpdateMaskFieldType::Material),
            "min_ad_price" => std::result::Result::Ok(UpdateMaskFieldType::MinAdPrice),
            "mpn" => std::result::Result::Ok(UpdateMaskFieldType::Mpn),
            "number_of_ratings" => std::result::Result::Ok(UpdateMaskFieldType::NumberOfRatings),
            "number_of_reviews" => std::result::Result::Ok(UpdateMaskFieldType::NumberOfReviews),
            "pattern" => std::result::Result::Ok(UpdateMaskFieldType::Pattern),
            "price" => std::result::Result::Ok(UpdateMaskFieldType::Price),
            "product_type" => std::result::Result::Ok(UpdateMaskFieldType::ProductType),
            "sale_price" => std::result::Result::Ok(UpdateMaskFieldType::SalePrice),
            "shipping" => std::result::Result::Ok(UpdateMaskFieldType::Shipping),
            "shipping_height" => std::result::Result::Ok(UpdateMaskFieldType::ShippingHeight),
            "shipping_weight" => std::result::Result::Ok(UpdateMaskFieldType::ShippingWeight),
            "shipping_width" => std::result::Result::Ok(UpdateMaskFieldType::ShippingWidth),
            "size" => std::result::Result::Ok(UpdateMaskFieldType::Size),
            "size_system" => std::result::Result::Ok(UpdateMaskFieldType::SizeSystem),
            "size_type" => std::result::Result::Ok(UpdateMaskFieldType::SizeType),
            "tax" => std::result::Result::Ok(UpdateMaskFieldType::Tax),
            "title" => std::result::Result::Ok(UpdateMaskFieldType::Title),
            "variant_names" => std::result::Result::Ok(UpdateMaskFieldType::VariantNames),
            "variant_values" => std::result::Result::Ok(UpdateMaskFieldType::VariantValues),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserAccountFollowedInterests200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::Interest>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl UserAccountFollowedInterests200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::Interest>, ) -> UserAccountFollowedInterests200Response {
        UserAccountFollowedInterests200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the UserAccountFollowedInterests200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UserAccountFollowedInterests200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserAccountFollowedInterests200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserAccountFollowedInterests200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::Interest>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserAccountFollowedInterests200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in UserAccountFollowedInterests200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UserAccountFollowedInterests200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserAccountFollowedInterests200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserAccountFollowedInterests200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in UserAccountFollowedInterests200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in UserAccountFollowedInterests200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserAccountFollowedInterests200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UserAccountFollowedInterests200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserAccountFollowedInterests200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UserAccountFollowedInterests200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UserAccountFollowedInterests200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserAccountFollowedInterests200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UserAccountFollowedInterests200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Specifies the type of followees to be kept when filtering them.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum UserFollowingFeedType {
    #[serde(rename = "ALL")]
    All,
    #[serde(rename = "RANKED")]
    Ranked,
    #[serde(rename = "CREATOR_ONLY")]
    CreatorOnly,
    #[serde(rename = "RANKED_CREATOR_ONLY")]
    RankedCreatorOnly,
}

impl std::fmt::Display for UserFollowingFeedType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            UserFollowingFeedType::All => write!(f, "ALL"),
            UserFollowingFeedType::Ranked => write!(f, "RANKED"),
            UserFollowingFeedType::CreatorOnly => write!(f, "CREATOR_ONLY"),
            UserFollowingFeedType::RankedCreatorOnly => write!(f, "RANKED_CREATOR_ONLY"),
        }
    }
}

impl std::str::FromStr for UserFollowingFeedType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ALL" => std::result::Result::Ok(UserFollowingFeedType::All),
            "RANKED" => std::result::Result::Ok(UserFollowingFeedType::Ranked),
            "CREATOR_ONLY" => std::result::Result::Ok(UserFollowingFeedType::CreatorOnly),
            "RANKED_CREATOR_ONLY" => std::result::Result::Ok(UserFollowingFeedType::RankedCreatorOnly),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserFollowingGet200Response {
/// Users
    #[serde(rename = "items")]
    pub items: Vec<models::UserSummary>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl UserFollowingGet200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::UserSummary>, ) -> UserFollowingGet200Response {
        UserFollowingGet200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the UserFollowingGet200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UserFollowingGet200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserFollowingGet200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserFollowingGet200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::UserSummary>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserFollowingGet200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in UserFollowingGet200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UserFollowingGet200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserFollowingGet200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserFollowingGet200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in UserFollowingGet200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in UserFollowingGet200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserFollowingGet200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UserFollowingGet200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserFollowingGet200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UserFollowingGet200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UserFollowingGet200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserFollowingGet200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UserFollowingGet200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// User list operation type (add or remove)
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum UserListOperationType {
    #[serde(rename = "ADD")]
    Add,
    #[serde(rename = "REMOVE")]
    Remove,
}

impl std::fmt::Display for UserListOperationType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            UserListOperationType::Add => write!(f, "ADD"),
            UserListOperationType::Remove => write!(f, "REMOVE"),
        }
    }
}

impl std::str::FromStr for UserListOperationType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ADD" => std::result::Result::Ok(UserListOperationType::Add),
            "REMOVE" => std::result::Result::Ok(UserListOperationType::Remove),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// User list type
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum UserListType {
    #[serde(rename = "EMAIL")]
    Email,
    #[serde(rename = "IDFA")]
    Idfa,
    #[serde(rename = "MAID")]
    Maid,
    #[serde(rename = "LR_ID")]
    LrId,
    #[serde(rename = "DLX_ID")]
    DlxId,
    #[serde(rename = "HASHED_PINNER_ID")]
    HashedPinnerId,
}

impl std::fmt::Display for UserListType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            UserListType::Email => write!(f, "EMAIL"),
            UserListType::Idfa => write!(f, "IDFA"),
            UserListType::Maid => write!(f, "MAID"),
            UserListType::LrId => write!(f, "LR_ID"),
            UserListType::DlxId => write!(f, "DLX_ID"),
            UserListType::HashedPinnerId => write!(f, "HASHED_PINNER_ID"),
        }
    }
}

impl std::str::FromStr for UserListType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "EMAIL" => std::result::Result::Ok(UserListType::Email),
            "IDFA" => std::result::Result::Ok(UserListType::Idfa),
            "MAID" => std::result::Result::Ok(UserListType::Maid),
            "LR_ID" => std::result::Result::Ok(UserListType::LrId),
            "DLX_ID" => std::result::Result::Ok(UserListType::DlxId),
            "HASHED_PINNER_ID" => std::result::Result::Ok(UserListType::HashedPinnerId),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserSummary {
/// Username
    #[serde(rename = "username")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,

/// Always \"user\"
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

}


impl UserSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> UserSummary {
        UserSummary {
            username: None,
            r#type: None,
        }
    }
}

/// Converts the UserSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UserSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.username.as_ref().map(|username| {
                [
                    "username".to_string(),
                    username.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub username: Vec<String>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserSummary {
            username: intermediate_rep.username.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UserSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UserSummary - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UserSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UserSummary - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserWebsiteSummary {
/// Website with path or domain only
    #[serde(rename = "website")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub website: Option<String>,

/// Status of the verification process
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

/// UTC timestamp when the verification happened - sometimes missing
    #[serde(rename = "verified_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub verified_at: Option<String>,

}


impl UserWebsiteSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> UserWebsiteSummary {
        UserWebsiteSummary {
            website: None,
            status: None,
            verified_at: None,
        }
    }
}

/// Converts the UserWebsiteSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UserWebsiteSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.website.as_ref().map(|website| {
                [
                    "website".to_string(),
                    website.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),


            self.verified_at.as_ref().map(|verified_at| {
                [
                    "verified_at".to_string(),
                    verified_at.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserWebsiteSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserWebsiteSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub website: Vec<String>,
            pub status: Vec<String>,
            pub verified_at: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserWebsiteSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "website" => intermediate_rep.website.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "verified_at" => intermediate_rep.verified_at.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserWebsiteSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserWebsiteSummary {
            website: intermediate_rep.website.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            verified_at: intermediate_rep.verified_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserWebsiteSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UserWebsiteSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserWebsiteSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UserWebsiteSummary - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UserWebsiteSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserWebsiteSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UserWebsiteSummary - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserWebsiteVerificationCode {
/// Code to check against the user claiming the website
    #[serde(rename = "verification_code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub verification_code: Option<String>,

/// DNS TXT record to check against for the website to be claimed
    #[serde(rename = "dns_txt_record")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_txt_record: Option<String>,

/// Metatag the verification process searchs for the website to be claimed
    #[serde(rename = "metatag")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metatag: Option<String>,

/// File expected to find on the website being claimed
    #[serde(rename = "filename")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub filename: Option<String>,

/// A full html file to upload to the website in order for it to be claimed
    #[serde(rename = "file_content")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_content: Option<String>,

}


impl UserWebsiteVerificationCode {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> UserWebsiteVerificationCode {
        UserWebsiteVerificationCode {
            verification_code: None,
            dns_txt_record: None,
            metatag: None,
            filename: None,
            file_content: None,
        }
    }
}

/// Converts the UserWebsiteVerificationCode value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UserWebsiteVerificationCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.verification_code.as_ref().map(|verification_code| {
                [
                    "verification_code".to_string(),
                    verification_code.to_string(),
                ].join(",")
            }),


            self.dns_txt_record.as_ref().map(|dns_txt_record| {
                [
                    "dns_txt_record".to_string(),
                    dns_txt_record.to_string(),
                ].join(",")
            }),


            self.metatag.as_ref().map(|metatag| {
                [
                    "metatag".to_string(),
                    metatag.to_string(),
                ].join(",")
            }),


            self.filename.as_ref().map(|filename| {
                [
                    "filename".to_string(),
                    filename.to_string(),
                ].join(",")
            }),


            self.file_content.as_ref().map(|file_content| {
                [
                    "file_content".to_string(),
                    file_content.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserWebsiteVerificationCode value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserWebsiteVerificationCode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub verification_code: Vec<String>,
            pub dns_txt_record: Vec<String>,
            pub metatag: Vec<String>,
            pub filename: Vec<String>,
            pub file_content: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserWebsiteVerificationCode".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "verification_code" => intermediate_rep.verification_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dns_txt_record" => intermediate_rep.dns_txt_record.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "metatag" => intermediate_rep.metatag.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "filename" => intermediate_rep.filename.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_content" => intermediate_rep.file_content.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserWebsiteVerificationCode".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserWebsiteVerificationCode {
            verification_code: intermediate_rep.verification_code.into_iter().next(),
            dns_txt_record: intermediate_rep.dns_txt_record.into_iter().next(),
            metatag: intermediate_rep.metatag.into_iter().next(),
            filename: intermediate_rep.filename.into_iter().next(),
            file_content: intermediate_rep.file_content.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserWebsiteVerificationCode> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UserWebsiteVerificationCode>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserWebsiteVerificationCode>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UserWebsiteVerificationCode - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UserWebsiteVerificationCode> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserWebsiteVerificationCode as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UserWebsiteVerificationCode - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// User website verification request



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserWebsiteVerifyRequest {
    #[serde(rename = "website")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub website: Option<String>,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "verification_method")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub verification_method: Option<String>,

}


impl UserWebsiteVerifyRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> UserWebsiteVerifyRequest {
        UserWebsiteVerifyRequest {
            website: None,
            verification_method: Some("METATAG".to_string()),
        }
    }
}

/// Converts the UserWebsiteVerifyRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UserWebsiteVerifyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.website.as_ref().map(|website| {
                [
                    "website".to_string(),
                    website.to_string(),
                ].join(",")
            }),


            self.verification_method.as_ref().map(|verification_method| {
                [
                    "verification_method".to_string(),
                    verification_method.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserWebsiteVerifyRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserWebsiteVerifyRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub website: Vec<String>,
            pub verification_method: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserWebsiteVerifyRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "website" => intermediate_rep.website.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "verification_method" => intermediate_rep.verification_method.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserWebsiteVerifyRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserWebsiteVerifyRequest {
            website: intermediate_rep.website.into_iter().next(),
            verification_method: intermediate_rep.verification_method.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserWebsiteVerifyRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UserWebsiteVerifyRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserWebsiteVerifyRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UserWebsiteVerifyRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UserWebsiteVerifyRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserWebsiteVerifyRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UserWebsiteVerifyRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserWebsitesGet200Response {
    #[serde(rename = "items")]
    pub items: Vec<models::UserWebsiteSummary>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<Nullable<String>>,

}


impl UserWebsitesGet200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(items: Vec<models::UserWebsiteSummary>, ) -> UserWebsitesGet200Response {
        UserWebsitesGet200Response {
            items,
            bookmark: None,
        }
    }
}

/// Converts the UserWebsitesGet200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UserWebsitesGet200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping items in query parameter serialization


            self.bookmark.as_ref().map(|bookmark| {
                [
                    "bookmark".to_string(),
                    bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserWebsitesGet200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserWebsitesGet200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub items: Vec<Vec<models::UserWebsiteSummary>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserWebsitesGet200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in UserWebsitesGet200Response".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UserWebsitesGet200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserWebsitesGet200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserWebsitesGet200Response {
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in UserWebsitesGet200Response".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in UserWebsitesGet200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserWebsitesGet200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UserWebsitesGet200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserWebsitesGet200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UserWebsitesGet200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UserWebsitesGet200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserWebsitesGet200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UserWebsitesGet200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VideoMetadata {
    #[serde(rename = "item_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_type: Option<String>,

    #[serde(rename = "cover_image_url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cover_image_url: Option<String>,

/// Video url (720p). </p><strong>Note:</strong> This field is limited and not available to all apps.
    #[serde(rename = "video_url")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub video_url: Option<Nullable<String>>,

/// Duration (in milliseconds)
    #[serde(rename = "duration")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub duration: Option<f64>,

/// Height (in pixels)
    #[serde(rename = "height")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub height: Option<i32>,

/// Width (in pixels)
    #[serde(rename = "width")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub width: Option<i32>,

}


impl VideoMetadata {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> VideoMetadata {
        VideoMetadata {
            item_type: None,
            cover_image_url: None,
            video_url: None,
            duration: None,
            height: None,
            width: None,
        }
    }
}

/// Converts the VideoMetadata value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VideoMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.item_type.as_ref().map(|item_type| {
                [
                    "item_type".to_string(),
                    item_type.to_string(),
                ].join(",")
            }),


            self.cover_image_url.as_ref().map(|cover_image_url| {
                [
                    "cover_image_url".to_string(),
                    cover_image_url.to_string(),
                ].join(",")
            }),


            self.video_url.as_ref().map(|video_url| {
                [
                    "video_url".to_string(),
                    video_url.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.duration.as_ref().map(|duration| {
                [
                    "duration".to_string(),
                    duration.to_string(),
                ].join(",")
            }),


            self.height.as_ref().map(|height| {
                [
                    "height".to_string(),
                    height.to_string(),
                ].join(",")
            }),


            self.width.as_ref().map(|width| {
                [
                    "width".to_string(),
                    width.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VideoMetadata value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VideoMetadata {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item_type: Vec<String>,
            pub cover_image_url: Vec<String>,
            pub video_url: Vec<String>,
            pub duration: Vec<f64>,
            pub height: Vec<i32>,
            pub width: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VideoMetadata".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "item_type" => intermediate_rep.item_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cover_image_url" => intermediate_rep.cover_image_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "video_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in VideoMetadata".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "duration" => intermediate_rep.duration.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "height" => intermediate_rep.height.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "width" => intermediate_rep.width.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VideoMetadata".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VideoMetadata {
            item_type: intermediate_rep.item_type.into_iter().next(),
            cover_image_url: intermediate_rep.cover_image_url.into_iter().next(),
            video_url: std::result::Result::Err("Nullable types not supported in VideoMetadata".to_string())?,
            duration: intermediate_rep.duration.into_iter().next(),
            height: intermediate_rep.height.into_iter().next(),
            width: intermediate_rep.width.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VideoMetadata> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VideoMetadata>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VideoMetadata>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VideoMetadata - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VideoMetadata> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VideoMetadata as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VideoMetadata - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}



