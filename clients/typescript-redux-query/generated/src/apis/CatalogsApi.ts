// tslint:disable
/**
 * Pinterest REST API
 * Pinterest\'s REST API
 *
 * The version of the OpenAPI document: 5.3.0
 * Contact: pinterest-api@pinterest.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    CatalogsFeed,
    CatalogsFeedFromJSON,
    CatalogsFeedToJSON,
    CatalogsFeedsCreateRequest,
    CatalogsFeedsCreateRequestFromJSON,
    CatalogsFeedsCreateRequestToJSON,
    CatalogsFeedsUpdateRequest,
    CatalogsFeedsUpdateRequestFromJSON,
    CatalogsFeedsUpdateRequestToJSON,
    CatalogsItems,
    CatalogsItemsFromJSON,
    CatalogsItemsToJSON,
    CatalogsItemsBatch,
    CatalogsItemsBatchFromJSON,
    CatalogsItemsBatchToJSON,
    CatalogsItemsBatchRequest,
    CatalogsItemsBatchRequestFromJSON,
    CatalogsItemsBatchRequestToJSON,
    CatalogsProductGroup,
    CatalogsProductGroupFromJSON,
    CatalogsProductGroupToJSON,
    CatalogsProductGroupCreateRequest,
    CatalogsProductGroupCreateRequestFromJSON,
    CatalogsProductGroupCreateRequestToJSON,
    CatalogsProductGroupUpdateRequest,
    CatalogsProductGroupUpdateRequestFromJSON,
    CatalogsProductGroupUpdateRequestToJSON,
    Paginated,
    PaginatedFromJSON,
    PaginatedToJSON,
} from '../models';

export interface CatalogsProductGroupsCreateRequest {
    catalogsProductGroupCreateRequest: CatalogsProductGroupCreateRequest;
}

export interface CatalogsProductGroupsDeleteRequest {
    productGroupId: string;
}

export interface CatalogsProductGroupsListRequest {
    feedId: string;
    bookmark?: string;
    pageSize?: number;
}

export interface CatalogsProductGroupsUpdateRequest {
    productGroupId: string;
    catalogsProductGroupUpdateRequest: CatalogsProductGroupUpdateRequest;
}

export interface FeedProcessingResultsListRequest {
    feedId: string;
    bookmark?: string;
    pageSize?: number;
}

export interface FeedsCreateRequest {
    catalogsFeedsCreateRequest: CatalogsFeedsCreateRequest;
}

export interface FeedsDeleteRequest {
    feedId: string;
}

export interface FeedsGetRequest {
    feedId: string;
}

export interface FeedsListRequest {
    bookmark?: string;
    pageSize?: number;
}

export interface FeedsUpdateRequest {
    feedId: string;
    catalogsFeedsUpdateRequest: CatalogsFeedsUpdateRequest;
}

export interface ItemsBatchGetRequest {
    batchId: string;
}

export interface ItemsBatchPostRequest {
    catalogsItemsBatchRequest: CatalogsItemsBatchRequest;
}

export interface ItemsGetRequest {
    country: string;
    itemIds: Array<string>;
    language: string;
}


/**
 * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Create product group to use in Catalogs.
 * Create product group
 */
function catalogsProductGroupsCreateRaw<T>(requestParameters: CatalogsProductGroupsCreateRequest, requestConfig: runtime.TypedQueryConfig<T, object> = {}): QueryConfig<T> {
    if (requestParameters.catalogsProductGroupCreateRequest === null || requestParameters.catalogsProductGroupCreateRequest === undefined) {
        throw new runtime.RequiredError('catalogsProductGroupCreateRequest','Required parameter requestParameters.catalogsProductGroupCreateRequest was null or undefined when calling catalogsProductGroupsCreate.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["catalogs:write"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/catalogs/product_groups`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CatalogsProductGroupCreateRequestToJSON(requestParameters.catalogsProductGroupCreateRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Create product group to use in Catalogs.
* Create product group
*/
export function catalogsProductGroupsCreate<T>(requestParameters: CatalogsProductGroupsCreateRequest, requestConfig?: runtime.TypedQueryConfig<T, object>): QueryConfig<T> {
    return catalogsProductGroupsCreateRaw(requestParameters, requestConfig);
}

/**
 * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Delete a product group from being in use in Catalogs.
 * Delete product group
 */
function catalogsProductGroupsDeleteRaw<T>(requestParameters: CatalogsProductGroupsDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.productGroupId === null || requestParameters.productGroupId === undefined) {
        throw new runtime.RequiredError('productGroupId','Required parameter requestParameters.productGroupId was null or undefined when calling catalogsProductGroupsDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["catalogs:write"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/catalogs/product_groups/{product_group_id}`.replace(`{${"product_group_id"}}`, encodeURIComponent(String(requestParameters.productGroupId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Delete a product group from being in use in Catalogs.
* Delete product group
*/
export function catalogsProductGroupsDelete<T>(requestParameters: CatalogsProductGroupsDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return catalogsProductGroupsDeleteRaw(requestParameters, requestConfig);
}

/**
 * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Get a list of product groups for a given Catalogs Feed Id.
 * Get product groups list
 */
function catalogsProductGroupsListRaw<T>(requestParameters: CatalogsProductGroupsListRequest, requestConfig: runtime.TypedQueryConfig<T, Paginated & object> = {}): QueryConfig<T> {
    if (requestParameters.feedId === null || requestParameters.feedId === undefined) {
        throw new runtime.RequiredError('feedId','Required parameter requestParameters.feedId was null or undefined when calling catalogsProductGroupsList.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.feedId !== undefined) {
        queryParameters['feed_id'] = requestParameters.feedId;
    }


    if (requestParameters.bookmark !== undefined) {
        queryParameters['bookmark'] = requestParameters.bookmark;
    }


    if (requestParameters.pageSize !== undefined) {
        queryParameters['page_size'] = requestParameters.pageSize;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["catalogs:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/catalogs/product_groups`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(Paginated &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Get a list of product groups for a given Catalogs Feed Id.
* Get product groups list
*/
export function catalogsProductGroupsList<T>(requestParameters: CatalogsProductGroupsListRequest, requestConfig?: runtime.TypedQueryConfig<T, Paginated & object>): QueryConfig<T> {
    return catalogsProductGroupsListRaw(requestParameters, requestConfig);
}

/**
 * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Update product group to use in Catalogs.
 * Update product group
 */
function catalogsProductGroupsUpdateRaw<T>(requestParameters: CatalogsProductGroupsUpdateRequest, requestConfig: runtime.TypedQueryConfig<T, CatalogsProductGroup> = {}): QueryConfig<T> {
    if (requestParameters.productGroupId === null || requestParameters.productGroupId === undefined) {
        throw new runtime.RequiredError('productGroupId','Required parameter requestParameters.productGroupId was null or undefined when calling catalogsProductGroupsUpdate.');
    }

    if (requestParameters.catalogsProductGroupUpdateRequest === null || requestParameters.catalogsProductGroupUpdateRequest === undefined) {
        throw new runtime.RequiredError('catalogsProductGroupUpdateRequest','Required parameter requestParameters.catalogsProductGroupUpdateRequest was null or undefined when calling catalogsProductGroupsUpdate.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["catalogs:write"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/catalogs/product_groups/{product_group_id}`.replace(`{${"product_group_id"}}`, encodeURIComponent(String(requestParameters.productGroupId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PATCH',
            headers: headerParameters,
        },
        body: queryParameters || CatalogsProductGroupUpdateRequestToJSON(requestParameters.catalogsProductGroupUpdateRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CatalogsProductGroupFromJSON(body), text);
    }

    return config;
}

/**
* <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Update product group to use in Catalogs.
* Update product group
*/
export function catalogsProductGroupsUpdate<T>(requestParameters: CatalogsProductGroupsUpdateRequest, requestConfig?: runtime.TypedQueryConfig<T, CatalogsProductGroup>): QueryConfig<T> {
    return catalogsProductGroupsUpdateRaw(requestParameters, requestConfig);
}

/**
 * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Fetch a feed processing results owned by the owner user account.
 * List processing results for a given feed
 */
function feedProcessingResultsListRaw<T>(requestParameters: FeedProcessingResultsListRequest, requestConfig: runtime.TypedQueryConfig<T, Paginated & object> = {}): QueryConfig<T> {
    if (requestParameters.feedId === null || requestParameters.feedId === undefined) {
        throw new runtime.RequiredError('feedId','Required parameter requestParameters.feedId was null or undefined when calling feedProcessingResultsList.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.bookmark !== undefined) {
        queryParameters['bookmark'] = requestParameters.bookmark;
    }


    if (requestParameters.pageSize !== undefined) {
        queryParameters['page_size'] = requestParameters.pageSize;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["catalogs:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/catalogs/feeds/{feed_id}/processing_results`.replace(`{${"feed_id"}}`, encodeURIComponent(String(requestParameters.feedId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(Paginated &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Fetch a feed processing results owned by the owner user account.
* List processing results for a given feed
*/
export function feedProcessingResultsList<T>(requestParameters: FeedProcessingResultsListRequest, requestConfig?: runtime.TypedQueryConfig<T, Paginated & object>): QueryConfig<T> {
    return feedProcessingResultsListRaw(requestParameters, requestConfig);
}

/**
 * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Create a new feed owned by the \"operating user_account\".
 * Create feed
 */
function feedsCreateRaw<T>(requestParameters: FeedsCreateRequest, requestConfig: runtime.TypedQueryConfig<T, CatalogsFeed> = {}): QueryConfig<T> {
    if (requestParameters.catalogsFeedsCreateRequest === null || requestParameters.catalogsFeedsCreateRequest === undefined) {
        throw new runtime.RequiredError('catalogsFeedsCreateRequest','Required parameter requestParameters.catalogsFeedsCreateRequest was null or undefined when calling feedsCreate.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["catalogs:read", "catalogs:write"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/catalogs/feeds`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CatalogsFeedsCreateRequestToJSON(requestParameters.catalogsFeedsCreateRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CatalogsFeedFromJSON(body), text);
    }

    return config;
}

/**
* <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Create a new feed owned by the \"operating user_account\".
* Create feed
*/
export function feedsCreate<T>(requestParameters: FeedsCreateRequest, requestConfig?: runtime.TypedQueryConfig<T, CatalogsFeed>): QueryConfig<T> {
    return feedsCreateRaw(requestParameters, requestConfig);
}

/**
 * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Delete a feed owned by the \"operating user_account\".
 * Delete feed
 */
function feedsDeleteRaw<T>(requestParameters: FeedsDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.feedId === null || requestParameters.feedId === undefined) {
        throw new runtime.RequiredError('feedId','Required parameter requestParameters.feedId was null or undefined when calling feedsDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["catalogs:read", "catalogs:write"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/catalogs/feeds/{feed_id}`.replace(`{${"feed_id"}}`, encodeURIComponent(String(requestParameters.feedId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Delete a feed owned by the \"operating user_account\".
* Delete feed
*/
export function feedsDelete<T>(requestParameters: FeedsDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return feedsDeleteRaw(requestParameters, requestConfig);
}

/**
 * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Get a single feed owned by the \"operating user_account\".
 * Get feed
 */
function feedsGetRaw<T>(requestParameters: FeedsGetRequest, requestConfig: runtime.TypedQueryConfig<T, CatalogsFeed> = {}): QueryConfig<T> {
    if (requestParameters.feedId === null || requestParameters.feedId === undefined) {
        throw new runtime.RequiredError('feedId','Required parameter requestParameters.feedId was null or undefined when calling feedsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["catalogs:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/catalogs/feeds/{feed_id}`.replace(`{${"feed_id"}}`, encodeURIComponent(String(requestParameters.feedId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CatalogsFeedFromJSON(body), text);
    }

    return config;
}

/**
* <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Get a single feed owned by the \"operating user_account\".
* Get feed
*/
export function feedsGet<T>(requestParameters: FeedsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, CatalogsFeed>): QueryConfig<T> {
    return feedsGetRaw(requestParameters, requestConfig);
}

/**
 * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Fetch feeds owned by the \"operating user_account\".
 * List feeds
 */
function feedsListRaw<T>(requestParameters: FeedsListRequest, requestConfig: runtime.TypedQueryConfig<T, Paginated & object> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.bookmark !== undefined) {
        queryParameters['bookmark'] = requestParameters.bookmark;
    }


    if (requestParameters.pageSize !== undefined) {
        queryParameters['page_size'] = requestParameters.pageSize;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["catalogs:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/catalogs/feeds`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(Paginated &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Fetch feeds owned by the \"operating user_account\".
* List feeds
*/
export function feedsList<T>(requestParameters: FeedsListRequest, requestConfig?: runtime.TypedQueryConfig<T, Paginated & object>): QueryConfig<T> {
    return feedsListRaw(requestParameters, requestConfig);
}

/**
 * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Update a feed owned by the \"operating user_account\".
 * Update feed
 */
function feedsUpdateRaw<T>(requestParameters: FeedsUpdateRequest, requestConfig: runtime.TypedQueryConfig<T, CatalogsFeed> = {}): QueryConfig<T> {
    if (requestParameters.feedId === null || requestParameters.feedId === undefined) {
        throw new runtime.RequiredError('feedId','Required parameter requestParameters.feedId was null or undefined when calling feedsUpdate.');
    }

    if (requestParameters.catalogsFeedsUpdateRequest === null || requestParameters.catalogsFeedsUpdateRequest === undefined) {
        throw new runtime.RequiredError('catalogsFeedsUpdateRequest','Required parameter requestParameters.catalogsFeedsUpdateRequest was null or undefined when calling feedsUpdate.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["catalogs:read", "catalogs:write"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/catalogs/feeds/{feed_id}`.replace(`{${"feed_id"}}`, encodeURIComponent(String(requestParameters.feedId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PATCH',
            headers: headerParameters,
        },
        body: queryParameters || CatalogsFeedsUpdateRequestToJSON(requestParameters.catalogsFeedsUpdateRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CatalogsFeedFromJSON(body), text);
    }

    return config;
}

/**
* <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Update a feed owned by the \"operating user_account\".
* Update feed
*/
export function feedsUpdate<T>(requestParameters: FeedsUpdateRequest, requestConfig?: runtime.TypedQueryConfig<T, CatalogsFeed>): QueryConfig<T> {
    return feedsUpdateRaw(requestParameters, requestConfig);
}

/**
 * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Get a single catalogs items batch created by the \"operating user_account\".
 * Get catalogs items batch
 */
function itemsBatchGetRaw<T>(requestParameters: ItemsBatchGetRequest, requestConfig: runtime.TypedQueryConfig<T, CatalogsItemsBatch> = {}): QueryConfig<T> {
    if (requestParameters.batchId === null || requestParameters.batchId === undefined) {
        throw new runtime.RequiredError('batchId','Required parameter requestParameters.batchId was null or undefined when calling itemsBatchGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["catalogs:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/catalogs/items/batch/{batch_id}`.replace(`{${"batch_id"}}`, encodeURIComponent(String(requestParameters.batchId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CatalogsItemsBatchFromJSON(body), text);
    }

    return config;
}

/**
* <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  Get a single catalogs items batch created by the \"operating user_account\".
* Get catalogs items batch
*/
export function itemsBatchGet<T>(requestParameters: ItemsBatchGetRequest, requestConfig?: runtime.TypedQueryConfig<T, CatalogsItemsBatch>): QueryConfig<T> {
    return itemsBatchGetRaw(requestParameters, requestConfig);
}

/**
 * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  This endpoint supports multiple operations on a set of one or more catalog items.
 * Perform an operation on an item batch
 */
function itemsBatchPostRaw<T>(requestParameters: ItemsBatchPostRequest, requestConfig: runtime.TypedQueryConfig<T, CatalogsItemsBatch> = {}): QueryConfig<T> {
    if (requestParameters.catalogsItemsBatchRequest === null || requestParameters.catalogsItemsBatchRequest === undefined) {
        throw new runtime.RequiredError('catalogsItemsBatchRequest','Required parameter requestParameters.catalogsItemsBatchRequest was null or undefined when calling itemsBatchPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["catalogs:read", "catalogs:write"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/catalogs/items/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CatalogsItemsBatchRequestToJSON(requestParameters.catalogsItemsBatchRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CatalogsItemsBatchFromJSON(body), text);
    }

    return config;
}

/**
* <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/api/v5/#tag/Understanding-catalog-management\'>Learn more</a>.</strong>  This endpoint supports multiple operations on a set of one or more catalog items.
* Perform an operation on an item batch
*/
export function itemsBatchPost<T>(requestParameters: ItemsBatchPostRequest, requestConfig?: runtime.TypedQueryConfig<T, CatalogsItemsBatch>): QueryConfig<T> {
    return itemsBatchPostRaw(requestParameters, requestConfig);
}

/**
 * Get the items of the catalog created by the \"operating user_account\"
 * Get catalogs items
 */
function itemsGetRaw<T>(requestParameters: ItemsGetRequest, requestConfig: runtime.TypedQueryConfig<T, CatalogsItems> = {}): QueryConfig<T> {
    if (requestParameters.country === null || requestParameters.country === undefined) {
        throw new runtime.RequiredError('country','Required parameter requestParameters.country was null or undefined when calling itemsGet.');
    }

    if (requestParameters.itemIds === null || requestParameters.itemIds === undefined) {
        throw new runtime.RequiredError('itemIds','Required parameter requestParameters.itemIds was null or undefined when calling itemsGet.');
    }

    if (requestParameters.language === null || requestParameters.language === undefined) {
        throw new runtime.RequiredError('language','Required parameter requestParameters.language was null or undefined when calling itemsGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.country !== undefined) {
        queryParameters['country'] = requestParameters.country;
    }


    if (requestParameters.itemIds) {
        queryParameters['item_ids'] = requestParameters.itemIds;
    }


    if (requestParameters.language !== undefined) {
        queryParameters['language'] = requestParameters.language;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["catalogs:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/catalogs/items`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CatalogsItemsFromJSON(body), text);
    }

    return config;
}

/**
* Get the items of the catalog created by the \"operating user_account\"
* Get catalogs items
*/
export function itemsGet<T>(requestParameters: ItemsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, CatalogsItems>): QueryConfig<T> {
    return itemsGetRaw(requestParameters, requestConfig);
}

