/*
 * Pinterest REST API
 * Pinterest's REST API
 *
 * The version of the OpenAPI document: 5.12.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.github.oapicf.pinterestsdk.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.github.oapicf.pinterestsdk.JSON;

/**
 * Object containing customer information data. Note, It is required at least one of 1) em, 2) hashed_maids or 3) pair client_ip_address + client_user_agent.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-03-14T23:01:05.225954683Z[Etc/UTC]", comments = "Generator version: 7.4.0")
public class ConversionEventsUserData {
  public static final String SERIALIZED_NAME_PH = "ph";
  @SerializedName(SERIALIZED_NAME_PH)
  private List<String> ph;

  public static final String SERIALIZED_NAME_GE = "ge";
  @SerializedName(SERIALIZED_NAME_GE)
  private List<String> ge;

  public static final String SERIALIZED_NAME_DB = "db";
  @SerializedName(SERIALIZED_NAME_DB)
  private List<String> db;

  public static final String SERIALIZED_NAME_LN = "ln";
  @SerializedName(SERIALIZED_NAME_LN)
  private List<String> ln;

  public static final String SERIALIZED_NAME_FN = "fn";
  @SerializedName(SERIALIZED_NAME_FN)
  private List<String> fn;

  public static final String SERIALIZED_NAME_CT = "ct";
  @SerializedName(SERIALIZED_NAME_CT)
  private List<String> ct;

  public static final String SERIALIZED_NAME_ST = "st";
  @SerializedName(SERIALIZED_NAME_ST)
  private List<String> st;

  public static final String SERIALIZED_NAME_ZP = "zp";
  @SerializedName(SERIALIZED_NAME_ZP)
  private List<String> zp;

  public static final String SERIALIZED_NAME_COUNTRY = "country";
  @SerializedName(SERIALIZED_NAME_COUNTRY)
  private List<String> country;

  public static final String SERIALIZED_NAME_EXTERNAL_ID = "external_id";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_ID)
  private List<String> externalId;

  public static final String SERIALIZED_NAME_CLICK_ID = "click_id";
  @SerializedName(SERIALIZED_NAME_CLICK_ID)
  private String clickId;

  public static final String SERIALIZED_NAME_PARTNER_ID = "partner_id";
  @SerializedName(SERIALIZED_NAME_PARTNER_ID)
  private String partnerId;

  public ConversionEventsUserData() {
  }

  public ConversionEventsUserData ph(List<String> ph) {
    this.ph = ph;
    return this;
  }

  public ConversionEventsUserData addPhItem(String phItem) {
    if (this.ph == null) {
      this.ph = new ArrayList<>();
    }
    this.ph.add(phItem);
    return this;
  }

   /**
   * Sha256 hashes of user&#39;s phone numbers, only digits with country code, area code, and number. Remove any symbols, letters, spaces and leading zeros. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA.
   * @return ph
  **/
  @javax.annotation.Nullable
  public List<String> getPh() {
    return ph;
  }

  public void setPh(List<String> ph) {
    this.ph = ph;
  }


  public ConversionEventsUserData ge(List<String> ge) {
    this.ge = ge;
    return this;
  }

  public ConversionEventsUserData addGeItem(String geItem) {
    if (this.ge == null) {
      this.ge = new ArrayList<>();
    }
    this.ge.add(geItem);
    return this;
  }

   /**
   * Sha256 hashes of user&#39;s gender, in lowercase. Either \&quot;f\&quot; or \&quot;m\&quot; or \&quot;n\&quot; for non-binary gender.
   * @return ge
  **/
  @javax.annotation.Nullable
  public List<String> getGe() {
    return ge;
  }

  public void setGe(List<String> ge) {
    this.ge = ge;
  }


  public ConversionEventsUserData db(List<String> db) {
    this.db = db;
    return this;
  }

  public ConversionEventsUserData addDbItem(String dbItem) {
    if (this.db == null) {
      this.db = new ArrayList<>();
    }
    this.db.add(dbItem);
    return this;
  }

   /**
   * Sha256 hashes of user&#39;s date of birthday, given as year, month, and day.
   * @return db
  **/
  @javax.annotation.Nullable
  public List<String> getDb() {
    return db;
  }

  public void setDb(List<String> db) {
    this.db = db;
  }


  public ConversionEventsUserData ln(List<String> ln) {
    this.ln = ln;
    return this;
  }

  public ConversionEventsUserData addLnItem(String lnItem) {
    if (this.ln == null) {
      this.ln = new ArrayList<>();
    }
    this.ln.add(lnItem);
    return this;
  }

   /**
   * Sha256 hashes of user&#39;s last name, in lowercase. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA.
   * @return ln
  **/
  @javax.annotation.Nullable
  public List<String> getLn() {
    return ln;
  }

  public void setLn(List<String> ln) {
    this.ln = ln;
  }


  public ConversionEventsUserData fn(List<String> fn) {
    this.fn = fn;
    return this;
  }

  public ConversionEventsUserData addFnItem(String fnItem) {
    if (this.fn == null) {
      this.fn = new ArrayList<>();
    }
    this.fn.add(fnItem);
    return this;
  }

   /**
   * Sha256 hashes of user&#39;s first name, in lowercase. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA.
   * @return fn
  **/
  @javax.annotation.Nullable
  public List<String> getFn() {
    return fn;
  }

  public void setFn(List<String> fn) {
    this.fn = fn;
  }


  public ConversionEventsUserData ct(List<String> ct) {
    this.ct = ct;
    return this;
  }

  public ConversionEventsUserData addCtItem(String ctItem) {
    if (this.ct == null) {
      this.ct = new ArrayList<>();
    }
    this.ct.add(ctItem);
    return this;
  }

   /**
   * Sha256 hashes of user&#39;s city, in lowercase, and without spaces or punctuation. User residency city (mostly billing).
   * @return ct
  **/
  @javax.annotation.Nullable
  public List<String> getCt() {
    return ct;
  }

  public void setCt(List<String> ct) {
    this.ct = ct;
  }


  public ConversionEventsUserData st(List<String> st) {
    this.st = st;
    return this;
  }

  public ConversionEventsUserData addStItem(String stItem) {
    if (this.st == null) {
      this.st = new ArrayList<>();
    }
    this.st.add(stItem);
    return this;
  }

   /**
   * Sha256 hashes of user&#39;s state, given as a two-letter code in lowercase. User residency state (mostly billing).
   * @return st
  **/
  @javax.annotation.Nullable
  public List<String> getSt() {
    return st;
  }

  public void setSt(List<String> st) {
    this.st = st;
  }


  public ConversionEventsUserData zp(List<String> zp) {
    this.zp = zp;
    return this;
  }

  public ConversionEventsUserData addZpItem(String zpItem) {
    if (this.zp == null) {
      this.zp = new ArrayList<>();
    }
    this.zp.add(zpItem);
    return this;
  }

   /**
   * Sha256 hashes of user&#39;s zipcode, only digits. User residency zipcode (mostly billing).
   * @return zp
  **/
  @javax.annotation.Nullable
  public List<String> getZp() {
    return zp;
  }

  public void setZp(List<String> zp) {
    this.zp = zp;
  }


  public ConversionEventsUserData country(List<String> country) {
    this.country = country;
    return this;
  }

  public ConversionEventsUserData addCountryItem(String countryItem) {
    if (this.country == null) {
      this.country = new ArrayList<>();
    }
    this.country.add(countryItem);
    return this;
  }

   /**
   * Sha256 hashes of two-character ISO-3166 country code indicating the user&#39;s country, in lowercase.
   * @return country
  **/
  @javax.annotation.Nullable
  public List<String> getCountry() {
    return country;
  }

  public void setCountry(List<String> country) {
    this.country = country;
  }


  public ConversionEventsUserData externalId(List<String> externalId) {
    this.externalId = externalId;
    return this;
  }

  public ConversionEventsUserData addExternalIdItem(String externalIdItem) {
    if (this.externalId == null) {
      this.externalId = new ArrayList<>();
    }
    this.externalId.add(externalIdItem);
    return this;
  }

   /**
   * Sha256 hashes of the unique id from the advertiser that identifies a user in their space, e.g. user id, loyalty id, etc. We highly recommend this on all events. It may improve reporting performance such as ROAS/CPA.
   * @return externalId
  **/
  @javax.annotation.Nullable
  public List<String> getExternalId() {
    return externalId;
  }

  public void setExternalId(List<String> externalId) {
    this.externalId = externalId;
  }


  public ConversionEventsUserData clickId(String clickId) {
    this.clickId = clickId;
    return this;
  }

   /**
   * The unique identifier stored in _epik cookie on your domain or &amp;epik&#x3D; query parameter in the URL. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA.
   * @return clickId
  **/
  @javax.annotation.Nullable
  public String getClickId() {
    return clickId;
  }

  public void setClickId(String clickId) {
    this.clickId = clickId;
  }


  public ConversionEventsUserData partnerId(String partnerId) {
    this.partnerId = partnerId;
    return this;
  }

   /**
   * A unique identifier of visitors&#39; information defined by third party partners. e.g RampID
   * @return partnerId
  **/
  @javax.annotation.Nullable
  public String getPartnerId() {
    return partnerId;
  }

  public void setPartnerId(String partnerId) {
    this.partnerId = partnerId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ConversionEventsUserData conversionEventsUserData = (ConversionEventsUserData) o;
    return Objects.equals(this.ph, conversionEventsUserData.ph) &&
        Objects.equals(this.ge, conversionEventsUserData.ge) &&
        Objects.equals(this.db, conversionEventsUserData.db) &&
        Objects.equals(this.ln, conversionEventsUserData.ln) &&
        Objects.equals(this.fn, conversionEventsUserData.fn) &&
        Objects.equals(this.ct, conversionEventsUserData.ct) &&
        Objects.equals(this.st, conversionEventsUserData.st) &&
        Objects.equals(this.zp, conversionEventsUserData.zp) &&
        Objects.equals(this.country, conversionEventsUserData.country) &&
        Objects.equals(this.externalId, conversionEventsUserData.externalId) &&
        Objects.equals(this.clickId, conversionEventsUserData.clickId) &&
        Objects.equals(this.partnerId, conversionEventsUserData.partnerId);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(ph, ge, db, ln, fn, ct, st, zp, country, externalId, clickId, partnerId);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ConversionEventsUserData {\n");
    sb.append("    ph: ").append(toIndentedString(ph)).append("\n");
    sb.append("    ge: ").append(toIndentedString(ge)).append("\n");
    sb.append("    db: ").append(toIndentedString(db)).append("\n");
    sb.append("    ln: ").append(toIndentedString(ln)).append("\n");
    sb.append("    fn: ").append(toIndentedString(fn)).append("\n");
    sb.append("    ct: ").append(toIndentedString(ct)).append("\n");
    sb.append("    st: ").append(toIndentedString(st)).append("\n");
    sb.append("    zp: ").append(toIndentedString(zp)).append("\n");
    sb.append("    country: ").append(toIndentedString(country)).append("\n");
    sb.append("    externalId: ").append(toIndentedString(externalId)).append("\n");
    sb.append("    clickId: ").append(toIndentedString(clickId)).append("\n");
    sb.append("    partnerId: ").append(toIndentedString(partnerId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to ConversionEventsUserData
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ConversionEventsUserData.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ConversionEventsUserData is not found in the empty JSON string", ConversionEventsUserData.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ConversionEventsUserData.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ConversionEventsUserData` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("ph") != null && !jsonObj.get("ph").isJsonNull() && !jsonObj.get("ph").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `ph` to be an array in the JSON string but got `%s`", jsonObj.get("ph").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("ge") != null && !jsonObj.get("ge").isJsonNull() && !jsonObj.get("ge").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `ge` to be an array in the JSON string but got `%s`", jsonObj.get("ge").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("db") != null && !jsonObj.get("db").isJsonNull() && !jsonObj.get("db").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `db` to be an array in the JSON string but got `%s`", jsonObj.get("db").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("ln") != null && !jsonObj.get("ln").isJsonNull() && !jsonObj.get("ln").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `ln` to be an array in the JSON string but got `%s`", jsonObj.get("ln").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("fn") != null && !jsonObj.get("fn").isJsonNull() && !jsonObj.get("fn").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `fn` to be an array in the JSON string but got `%s`", jsonObj.get("fn").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("ct") != null && !jsonObj.get("ct").isJsonNull() && !jsonObj.get("ct").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `ct` to be an array in the JSON string but got `%s`", jsonObj.get("ct").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("st") != null && !jsonObj.get("st").isJsonNull() && !jsonObj.get("st").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `st` to be an array in the JSON string but got `%s`", jsonObj.get("st").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("zp") != null && !jsonObj.get("zp").isJsonNull() && !jsonObj.get("zp").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `zp` to be an array in the JSON string but got `%s`", jsonObj.get("zp").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("country") != null && !jsonObj.get("country").isJsonNull() && !jsonObj.get("country").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `country` to be an array in the JSON string but got `%s`", jsonObj.get("country").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("external_id") != null && !jsonObj.get("external_id").isJsonNull() && !jsonObj.get("external_id").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `external_id` to be an array in the JSON string but got `%s`", jsonObj.get("external_id").toString()));
      }
      if ((jsonObj.get("click_id") != null && !jsonObj.get("click_id").isJsonNull()) && !jsonObj.get("click_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `click_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("click_id").toString()));
      }
      if ((jsonObj.get("partner_id") != null && !jsonObj.get("partner_id").isJsonNull()) && !jsonObj.get("partner_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `partner_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("partner_id").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ConversionEventsUserData.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ConversionEventsUserData' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ConversionEventsUserData> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ConversionEventsUserData.class));

       return (TypeAdapter<T>) new TypeAdapter<ConversionEventsUserData>() {
           @Override
           public void write(JsonWriter out, ConversionEventsUserData value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ConversionEventsUserData read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ConversionEventsUserData given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ConversionEventsUserData
  * @throws IOException if the JSON string is invalid with respect to ConversionEventsUserData
  */
  public static ConversionEventsUserData fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ConversionEventsUserData.class);
  }

 /**
  * Convert an instance of ConversionEventsUserData to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

