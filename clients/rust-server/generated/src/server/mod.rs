use futures::{future, future::BoxFuture, Stream, stream, future::FutureExt, stream::TryStreamExt};
use hyper::{Request, Response, StatusCode, Body, HeaderMap};
use hyper::header::{HeaderName, HeaderValue, CONTENT_TYPE};
use log::warn;
#[allow(unused_imports)]
use std::convert::{TryFrom, TryInto};
use std::error::Error;
use std::future::Future;
use std::marker::PhantomData;
use std::task::{Context, Poll};
use swagger::{ApiError, BodyExt, Has, RequestParser, XSpanIdString};
pub use swagger::auth::Authorization;
use swagger::auth::Scopes;
use url::form_urlencoded;

#[allow(unused_imports)]
use crate::models;
use crate::header;

pub use crate::context;

type ServiceFuture = BoxFuture<'static, Result<Response<Body>, crate::ServiceError>>;

use crate::{Api,
     AdAccountSlashAnalyticsResponse,
     AdAccountTargetingAnalyticsSlashGetResponse,
     AdAccountsSlashCreateResponse,
     AdAccountsSlashGetResponse,
     AdAccountsSlashListResponse,
     AnalyticsSlashCreateMmmReportResponse,
     AnalyticsSlashCreateReportResponse,
     AnalyticsSlashCreateTemplateReportResponse,
     AnalyticsSlashGetMmmReportResponse,
     AnalyticsSlashGetReportResponse,
     SandboxSlashDeleteResponse,
     TemplatesSlashListResponse,
     AdGroupsBidFloorSlashGetResponse,
     AdGroupsSlashAnalyticsResponse,
     AdGroupsSlashAudienceSizingResponse,
     AdGroupsSlashCreateResponse,
     AdGroupsSlashGetResponse,
     AdGroupsSlashListResponse,
     AdGroupsSlashUpdateResponse,
     AdGroupsTargetingAnalyticsSlashGetResponse,
     AdPreviewsSlashCreateResponse,
     AdTargetingAnalyticsSlashGetResponse,
     AdsSlashAnalyticsResponse,
     AdsSlashCreateResponse,
     AdsSlashGetResponse,
     AdsSlashListResponse,
     AdsSlashUpdateResponse,
     AudienceInsightsScopeAndTypeSlashGetResponse,
     AudienceInsightsSlashGetResponse,
     AudiencesSlashCreateResponse,
     AudiencesSlashCreateCustomResponse,
     AudiencesSlashGetResponse,
     AudiencesSlashListResponse,
     AudiencesSlashUpdateResponse,
     AdsCreditSlashRedeemResponse,
     AdsCreditsDiscountsSlashGetResponse,
     BillingProfilesSlashGetResponse,
     SsioAccountsSlashGetResponse,
     SsioInsertionOrderSlashCreateResponse,
     SsioInsertionOrderSlashEditResponse,
     SsioInsertionOrdersStatusSlashGetByAdAccountResponse,
     SsioInsertionOrdersStatusSlashGetByPinOrderIdResponse,
     SsioOrderLinesSlashGetByAdAccountResponse,
     BoardSectionsSlashCreateResponse,
     BoardSectionsSlashDeleteResponse,
     BoardSectionsSlashListResponse,
     BoardSectionsSlashListPinsResponse,
     BoardSectionsSlashUpdateResponse,
     BoardsSlashCreateResponse,
     BoardsSlashDeleteResponse,
     BoardsSlashGetResponse,
     BoardsSlashListResponse,
     BoardsSlashListPinsResponse,
     BoardsSlashUpdateResponse,
     BulkDownloadSlashCreateResponse,
     BulkRequestSlashGetResponse,
     BulkUpsertSlashCreateResponse,
     CampaignTargetingAnalyticsSlashGetResponse,
     CampaignsSlashAnalyticsResponse,
     CampaignsSlashCreateResponse,
     CampaignsSlashGetResponse,
     CampaignsSlashListResponse,
     CampaignsSlashUpdateResponse,
     CatalogsProductGroupPinsSlashListResponse,
     CatalogsProductGroupsSlashCreateResponse,
     CatalogsProductGroupsSlashDeleteResponse,
     CatalogsProductGroupsSlashGetResponse,
     CatalogsProductGroupsSlashListResponse,
     CatalogsProductGroupsSlashProductCountsGetResponse,
     CatalogsProductGroupsSlashUpdateResponse,
     CatalogsSlashListResponse,
     FeedProcessingResultsSlashListResponse,
     FeedsSlashCreateResponse,
     FeedsSlashDeleteResponse,
     FeedsSlashGetResponse,
     FeedsSlashListResponse,
     FeedsSlashUpdateResponse,
     ItemsBatchSlashGetResponse,
     ItemsBatchSlashPostResponse,
     ItemsIssuesSlashListResponse,
     ItemsSlashGetResponse,
     ProductsByProductGroupFilterSlashListResponse,
     EventsSlashCreateResponse,
     ConversionTagsSlashCreateResponse,
     ConversionTagsSlashGetResponse,
     ConversionTagsSlashListResponse,
     OcpmEligibleConversionTagsSlashGetResponse,
     PageVisitConversionTagsSlashGetResponse,
     CustomerListsSlashCreateResponse,
     CustomerListsSlashGetResponse,
     CustomerListsSlashListResponse,
     CustomerListsSlashUpdateResponse,
     IntegrationsCommerceSlashDelResponse,
     IntegrationsCommerceSlashGetResponse,
     IntegrationsCommerceSlashPatchResponse,
     IntegrationsCommerceSlashPostResponse,
     IntegrationsLogsSlashPostResponse,
     IntegrationsSlashGetByIdResponse,
     IntegrationsSlashGetListResponse,
     CountryKeywordsMetricsSlashGetResponse,
     KeywordsSlashCreateResponse,
     KeywordsSlashGetResponse,
     KeywordsSlashUpdateResponse,
     TrendingKeywordsSlashListResponse,
     AdAccountsSubscriptionsSlashDelByIdResponse,
     AdAccountsSubscriptionsSlashGetByIdResponse,
     AdAccountsSubscriptionsSlashGetListResponse,
     AdAccountsSubscriptionsSlashPostResponse,
     LeadFormSlashGetResponse,
     LeadFormTestSlashCreateResponse,
     LeadFormsSlashListResponse,
     MediaSlashCreateResponse,
     MediaSlashGetResponse,
     MediaSlashListResponse,
     OauthSlashTokenResponse,
     OrderLinesSlashGetResponse,
     OrderLinesSlashListResponse,
     PinsSlashAnalyticsResponse,
     PinsSlashCreateResponse,
     PinsSlashDeleteResponse,
     PinsSlashGetResponse,
     PinsSlashListResponse,
     PinsSlashSaveResponse,
     PinsSlashUpdateResponse,
     ProductGroupPromotionsSlashCreateResponse,
     ProductGroupPromotionsSlashGetResponse,
     ProductGroupPromotionsSlashListResponse,
     ProductGroupPromotionsSlashUpdateResponse,
     ProductGroupsSlashAnalyticsResponse,
     AdAccountsCatalogsProductGroupsSlashListResponse,
     AdAccountCountriesSlashGetResponse,
     DeliveryMetricsSlashGetResponse,
     InterestTargetingOptionsSlashGetResponse,
     LeadFormQuestionsSlashGetResponse,
     MetricsReadyStateSlashGetResponse,
     TargetingOptionsSlashGetResponse,
     SearchPartnerPinsResponse,
     SearchUserBoardsSlashGetResponse,
     SearchUserPinsSlashListResponse,
     TermsRelatedSlashListResponse,
     TermsSuggestedSlashListResponse,
     TermsOfServiceSlashGetResponse,
     BoardsUserFollowsSlashListResponse,
     FollowUserSlashUpdateResponse,
     FollowersSlashListResponse,
     LinkedBusinessAccountsSlashGetResponse,
     UnverifyWebsiteSlashDeleteResponse,
     UserAccountSlashAnalyticsResponse,
     UserAccountSlashAnalyticsSlashTopPinsResponse,
     UserAccountSlashAnalyticsSlashTopVideoPinsResponse,
     UserAccountSlashFollowedInterestsResponse,
     UserAccountSlashGetResponse,
     UserFollowingSlashGetResponse,
     UserWebsitesSlashGetResponse,
     VerifyWebsiteSlashUpdateResponse,
     WebsiteVerificationSlashGetResponse
};

mod paths {
    use lazy_static::lazy_static;

    lazy_static! {
        pub static ref GLOBAL_REGEX_SET: regex::RegexSet = regex::RegexSet::new(vec![
            r"^/v5/ad_accounts$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ad_groups$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ad_groups/analytics$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ad_groups/audience_sizing$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ad_groups/targeting_analytics$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ad_groups/(?P<ad_group_id>[^/?#]*)$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ad_previews$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ads$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ads/analytics$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ads/targeting_analytics$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ads/(?P<ad_id>[^/?#]*)$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ads_credit/discounts$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ads_credit/redeem$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/analytics$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/audience_insights$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/audiences$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/audiences/custom$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/audiences/(?P<audience_id>[^/?#]*)$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/bid_floor$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/billing_profiles$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/bulk/download$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/bulk/upsert$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/bulk/(?P<bulk_request_id>[^/?#]*)$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/campaigns$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/campaigns/analytics$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/campaigns/targeting_analytics$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/campaigns/(?P<campaign_id>[^/?#]*)$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/conversion_tags$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/conversion_tags/ocpm_eligible$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/conversion_tags/page_visit$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/conversion_tags/(?P<conversion_tag_id>[^/?#]*)$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/customer_lists$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/customer_lists/(?P<customer_list_id>[^/?#]*)$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/events$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/insights/audiences$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/keywords$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/keywords/metrics$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/lead_forms$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/lead_forms/(?P<lead_form_id>[^/?#]*)$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/lead_forms/(?P<lead_form_id>[^/?#]*)/test$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/leads/subscriptions$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/leads/subscriptions/(?P<subscription_id>[^/?#]*)$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/mmm_reports$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/order_lines$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/order_lines/(?P<order_line_id>[^/?#]*)$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/product_group_promotions$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/product_group_promotions/(?P<product_group_promotion_id>[^/?#]*)$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/product_groups/analytics$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/product_groups/catalogs$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/reports$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/sandbox$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ssio/accounts$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ssio/insertion_orders$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ssio/insertion_orders/status$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ssio/insertion_orders/(?P<pin_order_id>[^/?#]*)/status$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ssio/order_lines$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/targeting_analytics$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/templates$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/templates/(?P<template_id>[^/?#]*)/reports$",
            r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/terms_of_service$",
            r"^/v5/boards$",
            r"^/v5/boards/(?P<board_id>[^/?#]*)$",
            r"^/v5/boards/(?P<board_id>[^/?#]*)/pins$",
            r"^/v5/boards/(?P<board_id>[^/?#]*)/sections$",
            r"^/v5/boards/(?P<board_id>[^/?#]*)/sections/(?P<section_id>[^/?#]*)$",
            r"^/v5/boards/(?P<board_id>[^/?#]*)/sections/(?P<section_id>[^/?#]*)/pins$",
            r"^/v5/catalogs$",
            r"^/v5/catalogs/feeds$",
            r"^/v5/catalogs/feeds/(?P<feed_id>[^/?#]*)$",
            r"^/v5/catalogs/feeds/(?P<feed_id>[^/?#]*)/processing_results$",
            r"^/v5/catalogs/items$",
            r"^/v5/catalogs/items/batch$",
            r"^/v5/catalogs/items/batch/(?P<batch_id>[^/?#]*)$",
            r"^/v5/catalogs/processing_results/(?P<processing_result_id>[^/?#]*)/item_issues$",
            r"^/v5/catalogs/product_groups$",
            r"^/v5/catalogs/product_groups/(?P<product_group_id>[^/?#]*)$",
            r"^/v5/catalogs/product_groups/(?P<product_group_id>[^/?#]*)/product_counts$",
            r"^/v5/catalogs/product_groups/(?P<product_group_id>[^/?#]*)/products$",
            r"^/v5/catalogs/products/get_by_product_group_filters$",
            r"^/v5/integrations$",
            r"^/v5/integrations/commerce$",
            r"^/v5/integrations/commerce/(?P<external_business_id>[^/?#]*)$",
            r"^/v5/integrations/logs$",
            r"^/v5/integrations/(?P<id>[^/?#]*)$",
            r"^/v5/media$",
            r"^/v5/media/(?P<media_id>[^/?#]*)$",
            r"^/v5/oauth/token$",
            r"^/v5/pins$",
            r"^/v5/pins/(?P<pin_id>[^/?#]*)$",
            r"^/v5/pins/(?P<pin_id>[^/?#]*)/analytics$",
            r"^/v5/pins/(?P<pin_id>[^/?#]*)/save$",
            r"^/v5/resources/ad_account_countries$",
            r"^/v5/resources/delivery_metrics$",
            r"^/v5/resources/lead_form_questions$",
            r"^/v5/resources/metrics_ready_state$",
            r"^/v5/resources/targeting/interests/(?P<interest_id>[^/?#]*)$",
            r"^/v5/resources/targeting/(?P<targeting_type>[^/?#]*)$",
            r"^/v5/search/boards$",
            r"^/v5/search/partner/pins$",
            r"^/v5/search/pins$",
            r"^/v5/terms/related$",
            r"^/v5/terms/suggested$",
            r"^/v5/trends/keywords/(?P<region>[^/?#]*)/top/(?P<trend_type>[^/?#]*)$",
            r"^/v5/user_account$",
            r"^/v5/user_account/analytics$",
            r"^/v5/user_account/analytics/top_pins$",
            r"^/v5/user_account/analytics/top_video_pins$",
            r"^/v5/user_account/businesses$",
            r"^/v5/user_account/followers$",
            r"^/v5/user_account/following$",
            r"^/v5/user_account/following/boards$",
            r"^/v5/user_account/following/(?P<username>[^/?#]*)$",
            r"^/v5/user_account/websites$",
            r"^/v5/user_account/websites/verification$",
            r"^/v5/users/(?P<username>[^/?#]*)/interests/follow$"
        ])
        .expect("Unable to create global regex set");
    }
    pub(crate) static ID_AD_ACCOUNTS: usize = 0;
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID: usize = 1;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS: usize = 2;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ad_groups$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_ANALYTICS: usize = 3;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_ANALYTICS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ad_groups/analytics$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_ANALYTICS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AUDIENCE_SIZING: usize = 4;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AUDIENCE_SIZING: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ad_groups/audience_sizing$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AUDIENCE_SIZING");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_TARGETING_ANALYTICS: usize = 5;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_TARGETING_ANALYTICS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ad_groups/targeting_analytics$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_TARGETING_ANALYTICS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AD_GROUP_ID: usize = 6;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AD_GROUP_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ad_groups/(?P<ad_group_id>[^/?#]*)$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AD_GROUP_ID");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_PREVIEWS: usize = 7;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_PREVIEWS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ad_previews$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_AD_PREVIEWS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS: usize = 8;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ads$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_ADS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_ANALYTICS: usize = 9;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_ANALYTICS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ads/analytics$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_ANALYTICS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_TARGETING_ANALYTICS: usize = 10;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_TARGETING_ANALYTICS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ads/targeting_analytics$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_TARGETING_ANALYTICS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_AD_ID: usize = 11;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_AD_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ads/(?P<ad_id>[^/?#]*)$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_AD_ID");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_DISCOUNTS: usize = 12;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_DISCOUNTS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ads_credit/discounts$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_DISCOUNTS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_REDEEM: usize = 13;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_REDEEM: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ads_credit/redeem$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_REDEEM");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ANALYTICS: usize = 14;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ANALYTICS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/analytics$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_ANALYTICS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCE_INSIGHTS: usize = 15;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCE_INSIGHTS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/audience_insights$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCE_INSIGHTS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES: usize = 16;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/audiences$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_CUSTOM: usize = 17;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_CUSTOM: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/audiences/custom$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_CUSTOM");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_AUDIENCE_ID: usize = 18;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_AUDIENCE_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/audiences/(?P<audience_id>[^/?#]*)$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_AUDIENCE_ID");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BID_FLOOR: usize = 19;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_BID_FLOOR: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/bid_floor$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_BID_FLOOR");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BILLING_PROFILES: usize = 20;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_BILLING_PROFILES: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/billing_profiles$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_BILLING_PROFILES");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_DOWNLOAD: usize = 21;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_DOWNLOAD: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/bulk/download$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_DOWNLOAD");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_UPSERT: usize = 22;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_UPSERT: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/bulk/upsert$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_UPSERT");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_BULK_REQUEST_ID: usize = 23;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_BULK_REQUEST_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/bulk/(?P<bulk_request_id>[^/?#]*)$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_BULK_REQUEST_ID");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS: usize = 24;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/campaigns$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_ANALYTICS: usize = 25;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_ANALYTICS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/campaigns/analytics$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_ANALYTICS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_TARGETING_ANALYTICS: usize = 26;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_TARGETING_ANALYTICS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/campaigns/targeting_analytics$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_TARGETING_ANALYTICS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_CAMPAIGN_ID: usize = 27;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_CAMPAIGN_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/campaigns/(?P<campaign_id>[^/?#]*)$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_CAMPAIGN_ID");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS: usize = 28;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/conversion_tags$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_OCPM_ELIGIBLE: usize = 29;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_OCPM_ELIGIBLE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/conversion_tags/ocpm_eligible$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_OCPM_ELIGIBLE");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_PAGE_VISIT: usize = 30;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_PAGE_VISIT: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/conversion_tags/page_visit$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_PAGE_VISIT");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_CONVERSION_TAG_ID: usize = 31;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_CONVERSION_TAG_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/conversion_tags/(?P<conversion_tag_id>[^/?#]*)$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_CONVERSION_TAG_ID");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS: usize = 32;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/customer_lists$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS_CUSTOMER_LIST_ID: usize = 33;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS_CUSTOMER_LIST_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/customer_lists/(?P<customer_list_id>[^/?#]*)$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS_CUSTOMER_LIST_ID");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_EVENTS: usize = 34;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_EVENTS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/events$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_EVENTS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_INSIGHTS_AUDIENCES: usize = 35;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_INSIGHTS_AUDIENCES: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/insights/audiences$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_INSIGHTS_AUDIENCES");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS: usize = 36;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/keywords$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS_METRICS: usize = 37;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS_METRICS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/keywords/metrics$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS_METRICS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS: usize = 38;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/lead_forms$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID: usize = 39;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/lead_forms/(?P<lead_form_id>[^/?#]*)$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID_TEST: usize = 40;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID_TEST: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/lead_forms/(?P<lead_form_id>[^/?#]*)/test$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID_TEST");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS: usize = 41;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/leads/subscriptions$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS_SUBSCRIPTION_ID: usize = 42;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS_SUBSCRIPTION_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/leads/subscriptions/(?P<subscription_id>[^/?#]*)$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS_SUBSCRIPTION_ID");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_MMM_REPORTS: usize = 43;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_MMM_REPORTS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/mmm_reports$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_MMM_REPORTS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES: usize = 44;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/order_lines$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES_ORDER_LINE_ID: usize = 45;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES_ORDER_LINE_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/order_lines/(?P<order_line_id>[^/?#]*)$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES_ORDER_LINE_ID");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS: usize = 46;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/product_group_promotions$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS_PRODUCT_GROUP_PROMOTION_ID: usize = 47;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS_PRODUCT_GROUP_PROMOTION_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/product_group_promotions/(?P<product_group_promotion_id>[^/?#]*)$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS_PRODUCT_GROUP_PROMOTION_ID");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_ANALYTICS: usize = 48;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_ANALYTICS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/product_groups/analytics$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_ANALYTICS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_CATALOGS: usize = 49;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_CATALOGS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/product_groups/catalogs$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_CATALOGS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_REPORTS: usize = 50;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_REPORTS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/reports$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_REPORTS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SANDBOX: usize = 51;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SANDBOX: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/sandbox$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_SANDBOX");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ACCOUNTS: usize = 52;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ACCOUNTS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ssio/accounts$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ACCOUNTS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS: usize = 53;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ssio/insertion_orders$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_STATUS: usize = 54;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_STATUS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ssio/insertion_orders/status$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_STATUS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_PIN_ORDER_ID_STATUS: usize = 55;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_PIN_ORDER_ID_STATUS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ssio/insertion_orders/(?P<pin_order_id>[^/?#]*)/status$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_PIN_ORDER_ID_STATUS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ORDER_LINES: usize = 56;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ORDER_LINES: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/ssio/order_lines$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ORDER_LINES");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_TARGETING_ANALYTICS: usize = 57;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_TARGETING_ANALYTICS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/targeting_analytics$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_TARGETING_ANALYTICS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES: usize = 58;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/templates$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES_TEMPLATE_ID_REPORTS: usize = 59;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES_TEMPLATE_ID_REPORTS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/templates/(?P<template_id>[^/?#]*)/reports$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES_TEMPLATE_ID_REPORTS");
    }
    pub(crate) static ID_AD_ACCOUNTS_AD_ACCOUNT_ID_TERMS_OF_SERVICE: usize = 60;
    lazy_static! {
        pub static ref REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_TERMS_OF_SERVICE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/ad_accounts/(?P<ad_account_id>[^/?#]*)/terms_of_service$")
                .expect("Unable to create regex for AD_ACCOUNTS_AD_ACCOUNT_ID_TERMS_OF_SERVICE");
    }
    pub(crate) static ID_BOARDS: usize = 61;
    pub(crate) static ID_BOARDS_BOARD_ID: usize = 62;
    lazy_static! {
        pub static ref REGEX_BOARDS_BOARD_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/boards/(?P<board_id>[^/?#]*)$")
                .expect("Unable to create regex for BOARDS_BOARD_ID");
    }
    pub(crate) static ID_BOARDS_BOARD_ID_PINS: usize = 63;
    lazy_static! {
        pub static ref REGEX_BOARDS_BOARD_ID_PINS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/boards/(?P<board_id>[^/?#]*)/pins$")
                .expect("Unable to create regex for BOARDS_BOARD_ID_PINS");
    }
    pub(crate) static ID_BOARDS_BOARD_ID_SECTIONS: usize = 64;
    lazy_static! {
        pub static ref REGEX_BOARDS_BOARD_ID_SECTIONS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/boards/(?P<board_id>[^/?#]*)/sections$")
                .expect("Unable to create regex for BOARDS_BOARD_ID_SECTIONS");
    }
    pub(crate) static ID_BOARDS_BOARD_ID_SECTIONS_SECTION_ID: usize = 65;
    lazy_static! {
        pub static ref REGEX_BOARDS_BOARD_ID_SECTIONS_SECTION_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/boards/(?P<board_id>[^/?#]*)/sections/(?P<section_id>[^/?#]*)$")
                .expect("Unable to create regex for BOARDS_BOARD_ID_SECTIONS_SECTION_ID");
    }
    pub(crate) static ID_BOARDS_BOARD_ID_SECTIONS_SECTION_ID_PINS: usize = 66;
    lazy_static! {
        pub static ref REGEX_BOARDS_BOARD_ID_SECTIONS_SECTION_ID_PINS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/boards/(?P<board_id>[^/?#]*)/sections/(?P<section_id>[^/?#]*)/pins$")
                .expect("Unable to create regex for BOARDS_BOARD_ID_SECTIONS_SECTION_ID_PINS");
    }
    pub(crate) static ID_CATALOGS: usize = 67;
    pub(crate) static ID_CATALOGS_FEEDS: usize = 68;
    pub(crate) static ID_CATALOGS_FEEDS_FEED_ID: usize = 69;
    lazy_static! {
        pub static ref REGEX_CATALOGS_FEEDS_FEED_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/catalogs/feeds/(?P<feed_id>[^/?#]*)$")
                .expect("Unable to create regex for CATALOGS_FEEDS_FEED_ID");
    }
    pub(crate) static ID_CATALOGS_FEEDS_FEED_ID_PROCESSING_RESULTS: usize = 70;
    lazy_static! {
        pub static ref REGEX_CATALOGS_FEEDS_FEED_ID_PROCESSING_RESULTS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/catalogs/feeds/(?P<feed_id>[^/?#]*)/processing_results$")
                .expect("Unable to create regex for CATALOGS_FEEDS_FEED_ID_PROCESSING_RESULTS");
    }
    pub(crate) static ID_CATALOGS_ITEMS: usize = 71;
    pub(crate) static ID_CATALOGS_ITEMS_BATCH: usize = 72;
    pub(crate) static ID_CATALOGS_ITEMS_BATCH_BATCH_ID: usize = 73;
    lazy_static! {
        pub static ref REGEX_CATALOGS_ITEMS_BATCH_BATCH_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/catalogs/items/batch/(?P<batch_id>[^/?#]*)$")
                .expect("Unable to create regex for CATALOGS_ITEMS_BATCH_BATCH_ID");
    }
    pub(crate) static ID_CATALOGS_PROCESSING_RESULTS_PROCESSING_RESULT_ID_ITEM_ISSUES: usize = 74;
    lazy_static! {
        pub static ref REGEX_CATALOGS_PROCESSING_RESULTS_PROCESSING_RESULT_ID_ITEM_ISSUES: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/catalogs/processing_results/(?P<processing_result_id>[^/?#]*)/item_issues$")
                .expect("Unable to create regex for CATALOGS_PROCESSING_RESULTS_PROCESSING_RESULT_ID_ITEM_ISSUES");
    }
    pub(crate) static ID_CATALOGS_PRODUCT_GROUPS: usize = 75;
    pub(crate) static ID_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID: usize = 76;
    lazy_static! {
        pub static ref REGEX_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/catalogs/product_groups/(?P<product_group_id>[^/?#]*)$")
                .expect("Unable to create regex for CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID");
    }
    pub(crate) static ID_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCT_COUNTS: usize = 77;
    lazy_static! {
        pub static ref REGEX_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCT_COUNTS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/catalogs/product_groups/(?P<product_group_id>[^/?#]*)/product_counts$")
                .expect("Unable to create regex for CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCT_COUNTS");
    }
    pub(crate) static ID_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCTS: usize = 78;
    lazy_static! {
        pub static ref REGEX_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCTS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/catalogs/product_groups/(?P<product_group_id>[^/?#]*)/products$")
                .expect("Unable to create regex for CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCTS");
    }
    pub(crate) static ID_CATALOGS_PRODUCTS_GET_BY_PRODUCT_GROUP_FILTERS: usize = 79;
    pub(crate) static ID_INTEGRATIONS: usize = 80;
    pub(crate) static ID_INTEGRATIONS_COMMERCE: usize = 81;
    pub(crate) static ID_INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID: usize = 82;
    lazy_static! {
        pub static ref REGEX_INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/integrations/commerce/(?P<external_business_id>[^/?#]*)$")
                .expect("Unable to create regex for INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID");
    }
    pub(crate) static ID_INTEGRATIONS_LOGS: usize = 83;
    pub(crate) static ID_INTEGRATIONS_ID: usize = 84;
    lazy_static! {
        pub static ref REGEX_INTEGRATIONS_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/integrations/(?P<id>[^/?#]*)$")
                .expect("Unable to create regex for INTEGRATIONS_ID");
    }
    pub(crate) static ID_MEDIA: usize = 85;
    pub(crate) static ID_MEDIA_MEDIA_ID: usize = 86;
    lazy_static! {
        pub static ref REGEX_MEDIA_MEDIA_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/media/(?P<media_id>[^/?#]*)$")
                .expect("Unable to create regex for MEDIA_MEDIA_ID");
    }
    pub(crate) static ID_OAUTH_TOKEN: usize = 87;
    pub(crate) static ID_PINS: usize = 88;
    pub(crate) static ID_PINS_PIN_ID: usize = 89;
    lazy_static! {
        pub static ref REGEX_PINS_PIN_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/pins/(?P<pin_id>[^/?#]*)$")
                .expect("Unable to create regex for PINS_PIN_ID");
    }
    pub(crate) static ID_PINS_PIN_ID_ANALYTICS: usize = 90;
    lazy_static! {
        pub static ref REGEX_PINS_PIN_ID_ANALYTICS: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/pins/(?P<pin_id>[^/?#]*)/analytics$")
                .expect("Unable to create regex for PINS_PIN_ID_ANALYTICS");
    }
    pub(crate) static ID_PINS_PIN_ID_SAVE: usize = 91;
    lazy_static! {
        pub static ref REGEX_PINS_PIN_ID_SAVE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/pins/(?P<pin_id>[^/?#]*)/save$")
                .expect("Unable to create regex for PINS_PIN_ID_SAVE");
    }
    pub(crate) static ID_RESOURCES_AD_ACCOUNT_COUNTRIES: usize = 92;
    pub(crate) static ID_RESOURCES_DELIVERY_METRICS: usize = 93;
    pub(crate) static ID_RESOURCES_LEAD_FORM_QUESTIONS: usize = 94;
    pub(crate) static ID_RESOURCES_METRICS_READY_STATE: usize = 95;
    pub(crate) static ID_RESOURCES_TARGETING_INTERESTS_INTEREST_ID: usize = 96;
    lazy_static! {
        pub static ref REGEX_RESOURCES_TARGETING_INTERESTS_INTEREST_ID: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/resources/targeting/interests/(?P<interest_id>[^/?#]*)$")
                .expect("Unable to create regex for RESOURCES_TARGETING_INTERESTS_INTEREST_ID");
    }
    pub(crate) static ID_RESOURCES_TARGETING_TARGETING_TYPE: usize = 97;
    lazy_static! {
        pub static ref REGEX_RESOURCES_TARGETING_TARGETING_TYPE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/resources/targeting/(?P<targeting_type>[^/?#]*)$")
                .expect("Unable to create regex for RESOURCES_TARGETING_TARGETING_TYPE");
    }
    pub(crate) static ID_SEARCH_BOARDS: usize = 98;
    pub(crate) static ID_SEARCH_PARTNER_PINS: usize = 99;
    pub(crate) static ID_SEARCH_PINS: usize = 100;
    pub(crate) static ID_TERMS_RELATED: usize = 101;
    pub(crate) static ID_TERMS_SUGGESTED: usize = 102;
    pub(crate) static ID_TRENDS_KEYWORDS_REGION_TOP_TREND_TYPE: usize = 103;
    lazy_static! {
        pub static ref REGEX_TRENDS_KEYWORDS_REGION_TOP_TREND_TYPE: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/trends/keywords/(?P<region>[^/?#]*)/top/(?P<trend_type>[^/?#]*)$")
                .expect("Unable to create regex for TRENDS_KEYWORDS_REGION_TOP_TREND_TYPE");
    }
    pub(crate) static ID_USER_ACCOUNT: usize = 104;
    pub(crate) static ID_USER_ACCOUNT_ANALYTICS: usize = 105;
    pub(crate) static ID_USER_ACCOUNT_ANALYTICS_TOP_PINS: usize = 106;
    pub(crate) static ID_USER_ACCOUNT_ANALYTICS_TOP_VIDEO_PINS: usize = 107;
    pub(crate) static ID_USER_ACCOUNT_BUSINESSES: usize = 108;
    pub(crate) static ID_USER_ACCOUNT_FOLLOWERS: usize = 109;
    pub(crate) static ID_USER_ACCOUNT_FOLLOWING: usize = 110;
    pub(crate) static ID_USER_ACCOUNT_FOLLOWING_BOARDS: usize = 111;
    pub(crate) static ID_USER_ACCOUNT_FOLLOWING_USERNAME: usize = 112;
    lazy_static! {
        pub static ref REGEX_USER_ACCOUNT_FOLLOWING_USERNAME: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/user_account/following/(?P<username>[^/?#]*)$")
                .expect("Unable to create regex for USER_ACCOUNT_FOLLOWING_USERNAME");
    }
    pub(crate) static ID_USER_ACCOUNT_WEBSITES: usize = 113;
    pub(crate) static ID_USER_ACCOUNT_WEBSITES_VERIFICATION: usize = 114;
    pub(crate) static ID_USERS_USERNAME_INTERESTS_FOLLOW: usize = 115;
    lazy_static! {
        pub static ref REGEX_USERS_USERNAME_INTERESTS_FOLLOW: regex::Regex =
            #[allow(clippy::invalid_regex)]
            regex::Regex::new(r"^/v5/users/(?P<username>[^/?#]*)/interests/follow$")
                .expect("Unable to create regex for USERS_USERNAME_INTERESTS_FOLLOW");
    }
}

pub struct MakeService<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> + Has<Option<Authorization>> + Send + Sync + 'static
{
    api_impl: T,
    marker: PhantomData<C>,
}

impl<T, C> MakeService<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> + Has<Option<Authorization>> + Send + Sync + 'static
{
    pub fn new(api_impl: T) -> Self {
        MakeService {
            api_impl,
            marker: PhantomData
        }
    }
}

impl<T, C, Target> hyper::service::Service<Target> for MakeService<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> + Has<Option<Authorization>> + Send + Sync + 'static
{
    type Response = Service<T, C>;
    type Error = crate::ServiceError;
    type Future = future::Ready<Result<Self::Response, Self::Error>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        Poll::Ready(Ok(()))
    }

    fn call(&mut self, target: Target) -> Self::Future {
        futures::future::ok(Service::new(
            self.api_impl.clone(),
        ))
    }
}

fn method_not_allowed() -> Result<Response<Body>, crate::ServiceError> {
    Ok(
        Response::builder().status(StatusCode::METHOD_NOT_ALLOWED)
            .body(Body::empty())
            .expect("Unable to create Method Not Allowed response")
    )
}

pub struct Service<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> + Has<Option<Authorization>> + Send + Sync + 'static
{
    api_impl: T,
    marker: PhantomData<C>,
}

impl<T, C> Service<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> + Has<Option<Authorization>> + Send + Sync + 'static
{
    pub fn new(api_impl: T) -> Self {
        Service {
            api_impl,
            marker: PhantomData
        }
    }
}

impl<T, C> Clone for Service<T, C> where
    T: Api<C> + Clone + Send + 'static,
    C: Has<XSpanIdString> + Has<Option<Authorization>> + Send + Sync + 'static
{
    fn clone(&self) -> Self {
        Service {
            api_impl: self.api_impl.clone(),
            marker: self.marker,
        }
    }
}

impl<T, C> hyper::service::Service<(Request<Body>, C)> for Service<T, C> where
    T: Api<C> + Clone + Send + Sync + 'static,
    C: Has<XSpanIdString> + Has<Option<Authorization>> + Send + Sync + 'static
{
    type Response = Response<Body>;
    type Error = crate::ServiceError;
    type Future = ServiceFuture;

    fn poll_ready(&mut self, cx: &mut Context) -> Poll<Result<(), Self::Error>> {
        self.api_impl.poll_ready(cx)
    }

    fn call(&mut self, req: (Request<Body>, C)) -> Self::Future { async fn run<T, C>(mut api_impl: T, req: (Request<Body>, C)) -> Result<Response<Body>, crate::ServiceError> where
        T: Api<C> + Clone + Send + 'static,
        C: Has<XSpanIdString> + Has<Option<Authorization>> + Send + Sync + 'static
    {
        let (request, context) = req;
        let (parts, body) = request.into_parts();
        let (method, uri, headers) = (parts.method, parts.uri, parts.headers);
        let path = paths::GLOBAL_REGEX_SET.matches(uri.path());

        match method {

            // AdAccountSlashAnalytics - GET /ad_accounts/{ad_account_id}/analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ANALYTICS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ANALYTICS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_ANALYTICS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ANALYTICS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_start_date = query_params.iter().filter(|e| e.0 == "start_date").map(|e| e.1.clone())
                    .next();
                let param_start_date = match param_start_date {
                    Some(param_start_date) => {
                        let param_start_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_start_date);
                        match param_start_date {
                            Ok(param_start_date) => Some(param_start_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter start_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter start_date")),
                        }
                    },
                    None => None,
                };
                let param_start_date = match param_start_date {
                    Some(param_start_date) => param_start_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter start_date"))
                        .expect("Unable to create Bad Request response for missing query parameter start_date")),
                };
                let param_end_date = query_params.iter().filter(|e| e.0 == "end_date").map(|e| e.1.clone())
                    .next();
                let param_end_date = match param_end_date {
                    Some(param_end_date) => {
                        let param_end_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_end_date);
                        match param_end_date {
                            Ok(param_end_date) => Some(param_end_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter end_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter end_date")),
                        }
                    },
                    None => None,
                };
                let param_end_date = match param_end_date {
                    Some(param_end_date) => param_end_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter end_date"))
                        .expect("Unable to create Bad Request response for missing query parameter end_date")),
                };
                let param_columns = query_params.iter().filter(|e| e.0 == "columns").map(|e| e.1.clone())
                    .filter_map(|param_columns| param_columns.parse().ok())
                    .collect::<Vec<_>>();
                let param_granularity = query_params.iter().filter(|e| e.0 == "granularity").map(|e| e.1.clone())
                    .next();
                let param_granularity = match param_granularity {
                    Some(param_granularity) => {
                        let param_granularity =
                            <models::Granularity as std::str::FromStr>::from_str
                                (&param_granularity);
                        match param_granularity {
                            Ok(param_granularity) => Some(param_granularity),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter granularity - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter granularity")),
                        }
                    },
                    None => None,
                };
                let param_granularity = match param_granularity {
                    Some(param_granularity) => param_granularity,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter granularity"))
                        .expect("Unable to create Bad Request response for missing query parameter granularity")),
                };
                let param_click_window_days = query_params.iter().filter(|e| e.0 == "click_window_days").map(|e| e.1.clone())
                    .next();
                let param_click_window_days = match param_click_window_days {
                    Some(param_click_window_days) => {
                        let param_click_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_click_window_days);
                        match param_click_window_days {
                            Ok(param_click_window_days) => Some(param_click_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter click_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter click_window_days")),
                        }
                    },
                    None => None,
                };
                let param_engagement_window_days = query_params.iter().filter(|e| e.0 == "engagement_window_days").map(|e| e.1.clone())
                    .next();
                let param_engagement_window_days = match param_engagement_window_days {
                    Some(param_engagement_window_days) => {
                        let param_engagement_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_engagement_window_days);
                        match param_engagement_window_days {
                            Ok(param_engagement_window_days) => Some(param_engagement_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter engagement_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter engagement_window_days")),
                        }
                    },
                    None => None,
                };
                let param_view_window_days = query_params.iter().filter(|e| e.0 == "view_window_days").map(|e| e.1.clone())
                    .next();
                let param_view_window_days = match param_view_window_days {
                    Some(param_view_window_days) => {
                        let param_view_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_view_window_days);
                        match param_view_window_days {
                            Ok(param_view_window_days) => Some(param_view_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter view_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter view_window_days")),
                        }
                    },
                    None => None,
                };
                let param_conversion_report_time = query_params.iter().filter(|e| e.0 == "conversion_report_time").map(|e| e.1.clone())
                    .next();
                let param_conversion_report_time = match param_conversion_report_time {
                    Some(param_conversion_report_time) => {
                        let param_conversion_report_time =
                            <String as std::str::FromStr>::from_str
                                (&param_conversion_report_time);
                        match param_conversion_report_time {
                            Ok(param_conversion_report_time) => Some(param_conversion_report_time),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter conversion_report_time - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter conversion_report_time")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.ad_account_slash_analytics(
                                            param_ad_account_id,
                                            param_start_date,
                                            param_end_date,
                                            param_columns.as_ref(),
                                            param_granularity,
                                            param_click_window_days,
                                            param_engagement_window_days,
                                            param_view_window_days,
                                            param_conversion_report_time,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdAccountSlashAnalyticsResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNT_SLASH_ANALYTICS_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountSlashAnalyticsResponse::InvalidAdAccountAnalyticsParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNT_SLASH_ANALYTICS_INVALID_AD_ACCOUNT_ANALYTICS_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountSlashAnalyticsResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNT_SLASH_ANALYTICS_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdAccountTargetingAnalyticsSlashGet - GET /ad_accounts/{ad_account_id}/targeting_analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_TARGETING_ANALYTICS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_TARGETING_ANALYTICS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_TARGETING_ANALYTICS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_TARGETING_ANALYTICS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_start_date = query_params.iter().filter(|e| e.0 == "start_date").map(|e| e.1.clone())
                    .next();
                let param_start_date = match param_start_date {
                    Some(param_start_date) => {
                        let param_start_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_start_date);
                        match param_start_date {
                            Ok(param_start_date) => Some(param_start_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter start_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter start_date")),
                        }
                    },
                    None => None,
                };
                let param_start_date = match param_start_date {
                    Some(param_start_date) => param_start_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter start_date"))
                        .expect("Unable to create Bad Request response for missing query parameter start_date")),
                };
                let param_end_date = query_params.iter().filter(|e| e.0 == "end_date").map(|e| e.1.clone())
                    .next();
                let param_end_date = match param_end_date {
                    Some(param_end_date) => {
                        let param_end_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_end_date);
                        match param_end_date {
                            Ok(param_end_date) => Some(param_end_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter end_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter end_date")),
                        }
                    },
                    None => None,
                };
                let param_end_date = match param_end_date {
                    Some(param_end_date) => param_end_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter end_date"))
                        .expect("Unable to create Bad Request response for missing query parameter end_date")),
                };
                let param_targeting_types = query_params.iter().filter(|e| e.0 == "targeting_types").map(|e| e.1.clone())
                    .filter_map(|param_targeting_types| param_targeting_types.parse().ok())
                    .collect::<Vec<_>>();
                let param_columns = query_params.iter().filter(|e| e.0 == "columns").map(|e| e.1.clone())
                    .filter_map(|param_columns| param_columns.parse().ok())
                    .collect::<Vec<_>>();
                let param_granularity = query_params.iter().filter(|e| e.0 == "granularity").map(|e| e.1.clone())
                    .next();
                let param_granularity = match param_granularity {
                    Some(param_granularity) => {
                        let param_granularity =
                            <models::Granularity as std::str::FromStr>::from_str
                                (&param_granularity);
                        match param_granularity {
                            Ok(param_granularity) => Some(param_granularity),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter granularity - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter granularity")),
                        }
                    },
                    None => None,
                };
                let param_granularity = match param_granularity {
                    Some(param_granularity) => param_granularity,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter granularity"))
                        .expect("Unable to create Bad Request response for missing query parameter granularity")),
                };
                let param_click_window_days = query_params.iter().filter(|e| e.0 == "click_window_days").map(|e| e.1.clone())
                    .next();
                let param_click_window_days = match param_click_window_days {
                    Some(param_click_window_days) => {
                        let param_click_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_click_window_days);
                        match param_click_window_days {
                            Ok(param_click_window_days) => Some(param_click_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter click_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter click_window_days")),
                        }
                    },
                    None => None,
                };
                let param_engagement_window_days = query_params.iter().filter(|e| e.0 == "engagement_window_days").map(|e| e.1.clone())
                    .next();
                let param_engagement_window_days = match param_engagement_window_days {
                    Some(param_engagement_window_days) => {
                        let param_engagement_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_engagement_window_days);
                        match param_engagement_window_days {
                            Ok(param_engagement_window_days) => Some(param_engagement_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter engagement_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter engagement_window_days")),
                        }
                    },
                    None => None,
                };
                let param_view_window_days = query_params.iter().filter(|e| e.0 == "view_window_days").map(|e| e.1.clone())
                    .next();
                let param_view_window_days = match param_view_window_days {
                    Some(param_view_window_days) => {
                        let param_view_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_view_window_days);
                        match param_view_window_days {
                            Ok(param_view_window_days) => Some(param_view_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter view_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter view_window_days")),
                        }
                    },
                    None => None,
                };
                let param_conversion_report_time = query_params.iter().filter(|e| e.0 == "conversion_report_time").map(|e| e.1.clone())
                    .next();
                let param_conversion_report_time = match param_conversion_report_time {
                    Some(param_conversion_report_time) => {
                        let param_conversion_report_time =
                            <String as std::str::FromStr>::from_str
                                (&param_conversion_report_time);
                        match param_conversion_report_time {
                            Ok(param_conversion_report_time) => Some(param_conversion_report_time),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter conversion_report_time - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter conversion_report_time")),
                        }
                    },
                    None => None,
                };
                let param_attribution_types = query_params.iter().filter(|e| e.0 == "attribution_types").map(|e| e.1.clone())
                    .next();
                let param_attribution_types = match param_attribution_types {
                    Some(param_attribution_types) => {
                        let param_attribution_types =
                            <models::ConversionReportAttributionType as std::str::FromStr>::from_str
                                (&param_attribution_types);
                        match param_attribution_types {
                            Ok(param_attribution_types) => Some(param_attribution_types),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter attribution_types - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter attribution_types")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.ad_account_targeting_analytics_slash_get(
                                            param_ad_account_id,
                                            param_start_date,
                                            param_end_date,
                                            param_targeting_types.as_ref(),
                                            param_columns.as_ref(),
                                            param_granularity,
                                            param_click_window_days,
                                            param_engagement_window_days,
                                            param_view_window_days,
                                            param_conversion_report_time,
                                            param_attribution_types,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdAccountTargetingAnalyticsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNT_TARGETING_ANALYTICS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountTargetingAnalyticsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNT_TARGETING_ANALYTICS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdAccountsSlashCreate - POST /ad_accounts
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_ad_account_create_request: Option<models::AdAccountCreateRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_ad_account_create_request) => param_ad_account_create_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter AdAccountCreateRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter AdAccountCreateRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_ad_account_create_request = match param_ad_account_create_request {
                                    Some(param_ad_account_create_request) => param_ad_account_create_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter AdAccountCreateRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter AdAccountCreateRequest")),
                                };

                                let result = api_impl.ad_accounts_slash_create(
                                            param_ad_account_create_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdAccountsSlashCreateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SLASH_CREATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter AdAccountCreateRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter AdAccountCreateRequest")),
                        }
            },

            // AdAccountsSlashGet - GET /ad_accounts/{ad_account_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.ad_accounts_slash_get(
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdAccountsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdAccountsSlashList - GET /ad_accounts
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_include_shared_accounts = query_params.iter().filter(|e| e.0 == "include_shared_accounts").map(|e| e.1.clone())
                    .next();
                let param_include_shared_accounts = match param_include_shared_accounts {
                    Some(param_include_shared_accounts) => {
                        let param_include_shared_accounts =
                            <bool as std::str::FromStr>::from_str
                                (&param_include_shared_accounts);
                        match param_include_shared_accounts {
                            Ok(param_include_shared_accounts) => Some(param_include_shared_accounts),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter include_shared_accounts - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter include_shared_accounts")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.ad_accounts_slash_list(
                                            param_bookmark,
                                            param_page_size,
                                            param_include_shared_accounts,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdAccountsSlashListResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SLASH_LIST_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AnalyticsSlashCreateMmmReport - POST /ad_accounts/{ad_account_id}/mmm_reports
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_MMM_REPORTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_MMM_REPORTS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_MMM_REPORTS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_MMM_REPORTS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_create_mmm_report_request: Option<models::CreateMmmReportRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_create_mmm_report_request) => param_create_mmm_report_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter CreateMmmReportRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter CreateMmmReportRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_create_mmm_report_request = match param_create_mmm_report_request {
                                    Some(param_create_mmm_report_request) => param_create_mmm_report_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter CreateMmmReportRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter CreateMmmReportRequest")),
                                };

                                let result = api_impl.analytics_slash_create_mmm_report(
                                            param_ad_account_id,
                                            param_create_mmm_report_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AnalyticsSlashCreateMmmReportResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ANALYTICS_SLASH_CREATE_MMM_REPORT_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AnalyticsSlashCreateMmmReportResponse::InvalidAdAccountAdsAnalyticsMmmParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ANALYTICS_SLASH_CREATE_MMM_REPORT_INVALID_AD_ACCOUNT_ADS_ANALYTICS_MMM_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AnalyticsSlashCreateMmmReportResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ANALYTICS_SLASH_CREATE_MMM_REPORT_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter CreateMmmReportRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter CreateMmmReportRequest")),
                        }
            },

            // AnalyticsSlashCreateReport - POST /ad_accounts/{ad_account_id}/reports
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_REPORTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_REPORTS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_REPORTS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_REPORTS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_ads_analytics_create_async_request: Option<models::AdsAnalyticsCreateAsyncRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_ads_analytics_create_async_request) => param_ads_analytics_create_async_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter AdsAnalyticsCreateAsyncRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter AdsAnalyticsCreateAsyncRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_ads_analytics_create_async_request = match param_ads_analytics_create_async_request {
                                    Some(param_ads_analytics_create_async_request) => param_ads_analytics_create_async_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter AdsAnalyticsCreateAsyncRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter AdsAnalyticsCreateAsyncRequest")),
                                };

                                let result = api_impl.analytics_slash_create_report(
                                            param_ad_account_id,
                                            param_ads_analytics_create_async_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AnalyticsSlashCreateReportResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ANALYTICS_SLASH_CREATE_REPORT_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AnalyticsSlashCreateReportResponse::InvalidAdAccountAdsAnalyticsParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ANALYTICS_SLASH_CREATE_REPORT_INVALID_AD_ACCOUNT_ADS_ANALYTICS_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AnalyticsSlashCreateReportResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ANALYTICS_SLASH_CREATE_REPORT_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter AdsAnalyticsCreateAsyncRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter AdsAnalyticsCreateAsyncRequest")),
                        }
            },

            // AnalyticsSlashCreateTemplateReport - POST /ad_accounts/{ad_account_id}/templates/{template_id}/reports
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES_TEMPLATE_ID_REPORTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES_TEMPLATE_ID_REPORTS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES_TEMPLATE_ID_REPORTS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES_TEMPLATE_ID_REPORTS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_template_id = match percent_encoding::percent_decode(path_params["template_id"].as_bytes()).decode_utf8() {
                    Ok(param_template_id) => match param_template_id.parse::<String>() {
                        Ok(param_template_id) => param_template_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter template_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["template_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_start_date = query_params.iter().filter(|e| e.0 == "start_date").map(|e| e.1.clone())
                    .next();
                let param_start_date = match param_start_date {
                    Some(param_start_date) => {
                        let param_start_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_start_date);
                        match param_start_date {
                            Ok(param_start_date) => Some(param_start_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter start_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter start_date")),
                        }
                    },
                    None => None,
                };
                let param_end_date = query_params.iter().filter(|e| e.0 == "end_date").map(|e| e.1.clone())
                    .next();
                let param_end_date = match param_end_date {
                    Some(param_end_date) => {
                        let param_end_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_end_date);
                        match param_end_date {
                            Ok(param_end_date) => Some(param_end_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter end_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter end_date")),
                        }
                    },
                    None => None,
                };
                let param_granularity = query_params.iter().filter(|e| e.0 == "granularity").map(|e| e.1.clone())
                    .next();
                let param_granularity = match param_granularity {
                    Some(param_granularity) => {
                        let param_granularity =
                            <models::Granularity as std::str::FromStr>::from_str
                                (&param_granularity);
                        match param_granularity {
                            Ok(param_granularity) => Some(param_granularity),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter granularity - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter granularity")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.analytics_slash_create_template_report(
                                            param_ad_account_id,
                                            param_template_id,
                                            param_start_date,
                                            param_end_date,
                                            param_granularity,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AnalyticsSlashCreateTemplateReportResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ANALYTICS_SLASH_CREATE_TEMPLATE_REPORT_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AnalyticsSlashCreateTemplateReportResponse::InvalidAdAccountAdsAnalyticsTemplateParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ANALYTICS_SLASH_CREATE_TEMPLATE_REPORT_INVALID_AD_ACCOUNT_ADS_ANALYTICS_TEMPLATE_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AnalyticsSlashCreateTemplateReportResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ANALYTICS_SLASH_CREATE_TEMPLATE_REPORT_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AnalyticsSlashGetMmmReport - GET /ad_accounts/{ad_account_id}/mmm_reports
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_MMM_REPORTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_MMM_REPORTS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_MMM_REPORTS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_MMM_REPORTS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_token = query_params.iter().filter(|e| e.0 == "token").map(|e| e.1.clone())
                    .next();
                let param_token = match param_token {
                    Some(param_token) => {
                        let param_token =
                            <String as std::str::FromStr>::from_str
                                (&param_token);
                        match param_token {
                            Ok(param_token) => Some(param_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter token")),
                        }
                    },
                    None => None,
                };
                let param_token = match param_token {
                    Some(param_token) => param_token,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter token"))
                        .expect("Unable to create Bad Request response for missing query parameter token")),
                };

                                let result = api_impl.analytics_slash_get_mmm_report(
                                            param_ad_account_id,
                                            param_token,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AnalyticsSlashGetMmmReportResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ANALYTICS_SLASH_GET_MMM_REPORT_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AnalyticsSlashGetMmmReportResponse::InvalidAdAccountAdsAnalyticsParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ANALYTICS_SLASH_GET_MMM_REPORT_INVALID_AD_ACCOUNT_ADS_ANALYTICS_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AnalyticsSlashGetMmmReportResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ANALYTICS_SLASH_GET_MMM_REPORT_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AnalyticsSlashGetReport - GET /ad_accounts/{ad_account_id}/reports
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_REPORTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_REPORTS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_REPORTS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_REPORTS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_token = query_params.iter().filter(|e| e.0 == "token").map(|e| e.1.clone())
                    .next();
                let param_token = match param_token {
                    Some(param_token) => {
                        let param_token =
                            <String as std::str::FromStr>::from_str
                                (&param_token);
                        match param_token {
                            Ok(param_token) => Some(param_token),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter token - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter token")),
                        }
                    },
                    None => None,
                };
                let param_token = match param_token {
                    Some(param_token) => param_token,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter token"))
                        .expect("Unable to create Bad Request response for missing query parameter token")),
                };

                                let result = api_impl.analytics_slash_get_report(
                                            param_ad_account_id,
                                            param_token,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AnalyticsSlashGetReportResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ANALYTICS_SLASH_GET_REPORT_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AnalyticsSlashGetReportResponse::InvalidAdAccountAdsAnalyticsParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ANALYTICS_SLASH_GET_REPORT_INVALID_AD_ACCOUNT_ADS_ANALYTICS_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AnalyticsSlashGetReportResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ANALYTICS_SLASH_GET_REPORT_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // SandboxSlashDelete - DELETE /ad_accounts/{ad_account_id}/sandbox
            hyper::Method::DELETE if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SANDBOX) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SANDBOX
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_SANDBOX in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SANDBOX.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.sandbox_slash_delete(
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                SandboxSlashDeleteResponse::OK
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SANDBOX_SLASH_DELETE_OK"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SandboxSlashDeleteResponse::InvalidAdAccountId
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SANDBOX_SLASH_DELETE_INVALID_AD_ACCOUNT_ID"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SandboxSlashDeleteResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SANDBOX_SLASH_DELETE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // TemplatesSlashList - GET /ad_accounts/{ad_account_id}/templates
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_order = query_params.iter().filter(|e| e.0 == "order").map(|e| e.1.clone())
                    .next();
                let param_order = match param_order {
                    Some(param_order) => {
                        let param_order =
                            <String as std::str::FromStr>::from_str
                                (&param_order);
                        match param_order {
                            Ok(param_order) => Some(param_order),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter order - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter order")),
                        }
                    },
                    None => None,
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.templates_slash_list(
                                            param_ad_account_id,
                                            param_page_size,
                                            param_order,
                                            param_bookmark,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                TemplatesSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for TEMPLATES_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                TemplatesSlashListResponse::InvalidAdAccountTemplateParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for TEMPLATES_SLASH_LIST_INVALID_AD_ACCOUNT_TEMPLATE_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                TemplatesSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for TEMPLATES_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdGroupsBidFloorSlashGet - POST /ad_accounts/{ad_account_id}/bid_floor
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BID_FLOOR) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_BID_FLOOR
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_BID_FLOOR in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_BID_FLOOR.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_bid_floor_request: Option<models::BidFloorRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_bid_floor_request) => param_bid_floor_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter BidFloorRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter BidFloorRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_bid_floor_request = match param_bid_floor_request {
                                    Some(param_bid_floor_request) => param_bid_floor_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter BidFloorRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter BidFloorRequest")),
                                };

                                let result = api_impl.ad_groups_bid_floor_slash_get(
                                            param_ad_account_id,
                                            param_bid_floor_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdGroupsBidFloorSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_BID_FLOOR_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdGroupsBidFloorSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_BID_FLOOR_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter BidFloorRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter BidFloorRequest")),
                        }
            },

            // AdGroupsSlashAnalytics - GET /ad_accounts/{ad_account_id}/ad_groups/analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_ANALYTICS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_ANALYTICS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_ANALYTICS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_ANALYTICS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_start_date = query_params.iter().filter(|e| e.0 == "start_date").map(|e| e.1.clone())
                    .next();
                let param_start_date = match param_start_date {
                    Some(param_start_date) => {
                        let param_start_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_start_date);
                        match param_start_date {
                            Ok(param_start_date) => Some(param_start_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter start_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter start_date")),
                        }
                    },
                    None => None,
                };
                let param_start_date = match param_start_date {
                    Some(param_start_date) => param_start_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter start_date"))
                        .expect("Unable to create Bad Request response for missing query parameter start_date")),
                };
                let param_end_date = query_params.iter().filter(|e| e.0 == "end_date").map(|e| e.1.clone())
                    .next();
                let param_end_date = match param_end_date {
                    Some(param_end_date) => {
                        let param_end_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_end_date);
                        match param_end_date {
                            Ok(param_end_date) => Some(param_end_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter end_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter end_date")),
                        }
                    },
                    None => None,
                };
                let param_end_date = match param_end_date {
                    Some(param_end_date) => param_end_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter end_date"))
                        .expect("Unable to create Bad Request response for missing query parameter end_date")),
                };
                let param_ad_group_ids = query_params.iter().filter(|e| e.0 == "ad_group_ids").map(|e| e.1.clone())
                    .filter_map(|param_ad_group_ids| param_ad_group_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_columns = query_params.iter().filter(|e| e.0 == "columns").map(|e| e.1.clone())
                    .filter_map(|param_columns| param_columns.parse().ok())
                    .collect::<Vec<_>>();
                let param_granularity = query_params.iter().filter(|e| e.0 == "granularity").map(|e| e.1.clone())
                    .next();
                let param_granularity = match param_granularity {
                    Some(param_granularity) => {
                        let param_granularity =
                            <models::Granularity as std::str::FromStr>::from_str
                                (&param_granularity);
                        match param_granularity {
                            Ok(param_granularity) => Some(param_granularity),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter granularity - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter granularity")),
                        }
                    },
                    None => None,
                };
                let param_granularity = match param_granularity {
                    Some(param_granularity) => param_granularity,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter granularity"))
                        .expect("Unable to create Bad Request response for missing query parameter granularity")),
                };
                let param_click_window_days = query_params.iter().filter(|e| e.0 == "click_window_days").map(|e| e.1.clone())
                    .next();
                let param_click_window_days = match param_click_window_days {
                    Some(param_click_window_days) => {
                        let param_click_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_click_window_days);
                        match param_click_window_days {
                            Ok(param_click_window_days) => Some(param_click_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter click_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter click_window_days")),
                        }
                    },
                    None => None,
                };
                let param_engagement_window_days = query_params.iter().filter(|e| e.0 == "engagement_window_days").map(|e| e.1.clone())
                    .next();
                let param_engagement_window_days = match param_engagement_window_days {
                    Some(param_engagement_window_days) => {
                        let param_engagement_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_engagement_window_days);
                        match param_engagement_window_days {
                            Ok(param_engagement_window_days) => Some(param_engagement_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter engagement_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter engagement_window_days")),
                        }
                    },
                    None => None,
                };
                let param_view_window_days = query_params.iter().filter(|e| e.0 == "view_window_days").map(|e| e.1.clone())
                    .next();
                let param_view_window_days = match param_view_window_days {
                    Some(param_view_window_days) => {
                        let param_view_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_view_window_days);
                        match param_view_window_days {
                            Ok(param_view_window_days) => Some(param_view_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter view_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter view_window_days")),
                        }
                    },
                    None => None,
                };
                let param_conversion_report_time = query_params.iter().filter(|e| e.0 == "conversion_report_time").map(|e| e.1.clone())
                    .next();
                let param_conversion_report_time = match param_conversion_report_time {
                    Some(param_conversion_report_time) => {
                        let param_conversion_report_time =
                            <String as std::str::FromStr>::from_str
                                (&param_conversion_report_time);
                        match param_conversion_report_time {
                            Ok(param_conversion_report_time) => Some(param_conversion_report_time),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter conversion_report_time - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter conversion_report_time")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.ad_groups_slash_analytics(
                                            param_ad_account_id,
                                            param_start_date,
                                            param_end_date,
                                            param_ad_group_ids.as_ref(),
                                            param_columns.as_ref(),
                                            param_granularity,
                                            param_click_window_days,
                                            param_engagement_window_days,
                                            param_view_window_days,
                                            param_conversion_report_time,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdGroupsSlashAnalyticsResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_SLASH_ANALYTICS_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdGroupsSlashAnalyticsResponse::InvalidAdAccountGroupAnalyticsParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_SLASH_ANALYTICS_INVALID_AD_ACCOUNT_GROUP_ANALYTICS_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdGroupsSlashAnalyticsResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_SLASH_ANALYTICS_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdGroupsSlashAudienceSizing - GET /ad_accounts/{ad_account_id}/ad_groups/audience_sizing
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AUDIENCE_SIZING) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AUDIENCE_SIZING
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AUDIENCE_SIZING in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AUDIENCE_SIZING.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_ad_group_audience_sizing_request: Option<models::AdGroupAudienceSizingRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_ad_group_audience_sizing_request) => param_ad_group_audience_sizing_request,
                                        Err(_) => None,
                                    }
                                } else {
                                    None
                                };

                                let result = api_impl.ad_groups_slash_audience_sizing(
                                            param_ad_account_id,
                                            param_ad_group_audience_sizing_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdGroupsSlashAudienceSizingResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_SLASH_AUDIENCE_SIZING_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdGroupsSlashAudienceSizingResponse::InvalidAdGroupAudienceSizingParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_SLASH_AUDIENCE_SIZING_INVALID_AD_GROUP_AUDIENCE_SIZING_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdGroupsSlashAudienceSizingResponse::NoAccessToRequestedAudienceListOrProductGroup
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_SLASH_AUDIENCE_SIZING_NO_ACCESS_TO_REQUESTED_AUDIENCE_LIST_OR_PRODUCT_GROUP"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdGroupsSlashAudienceSizingResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_SLASH_AUDIENCE_SIZING_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter AdGroupAudienceSizingRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter AdGroupAudienceSizingRequest")),
                        }
            },

            // AdGroupsSlashCreate - POST /ad_accounts/{ad_account_id}/ad_groups
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_ad_group_create_request: Option<Vec<models::AdGroupCreateRequest>> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_ad_group_create_request) => param_ad_group_create_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter AdGroupCreateRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter AdGroupCreateRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_ad_group_create_request = match param_ad_group_create_request {
                                    Some(param_ad_group_create_request) => param_ad_group_create_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter AdGroupCreateRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter AdGroupCreateRequest")),
                                };

                                let result = api_impl.ad_groups_slash_create(
                                            param_ad_account_id,
                                            param_ad_group_create_request.as_ref(),
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdGroupsSlashCreateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_SLASH_CREATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdGroupsSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter AdGroupCreateRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter AdGroupCreateRequest")),
                        }
            },

            // AdGroupsSlashGet - GET /ad_accounts/{ad_account_id}/ad_groups/{ad_group_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AD_GROUP_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AD_GROUP_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AD_GROUP_ID in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AD_GROUP_ID.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_ad_group_id = match percent_encoding::percent_decode(path_params["ad_group_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_group_id) => match param_ad_group_id.parse::<String>() {
                        Ok(param_ad_group_id) => param_ad_group_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_group_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_group_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.ad_groups_slash_get(
                                            param_ad_account_id,
                                            param_ad_group_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdGroupsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdGroupsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdGroupsSlashList - GET /ad_accounts/{ad_account_id}/ad_groups
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_campaign_ids = query_params.iter().filter(|e| e.0 == "campaign_ids").map(|e| e.1.clone())
                    .filter_map(|param_campaign_ids| param_campaign_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_campaign_ids = if !param_campaign_ids.is_empty() {
                    Some(param_campaign_ids)
                } else {
                    None
                };
                let param_ad_group_ids = query_params.iter().filter(|e| e.0 == "ad_group_ids").map(|e| e.1.clone())
                    .filter_map(|param_ad_group_ids| param_ad_group_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_ad_group_ids = if !param_ad_group_ids.is_empty() {
                    Some(param_ad_group_ids)
                } else {
                    None
                };
                let param_entity_statuses = query_params.iter().filter(|e| e.0 == "entity_statuses").map(|e| e.1.clone())
                    .filter_map(|param_entity_statuses| param_entity_statuses.parse().ok())
                    .collect::<Vec<_>>();
                let param_entity_statuses = if !param_entity_statuses.is_empty() {
                    Some(param_entity_statuses)
                } else {
                    None
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_order = query_params.iter().filter(|e| e.0 == "order").map(|e| e.1.clone())
                    .next();
                let param_order = match param_order {
                    Some(param_order) => {
                        let param_order =
                            <String as std::str::FromStr>::from_str
                                (&param_order);
                        match param_order {
                            Ok(param_order) => Some(param_order),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter order - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter order")),
                        }
                    },
                    None => None,
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_translate_interests_to_names = query_params.iter().filter(|e| e.0 == "translate_interests_to_names").map(|e| e.1.clone())
                    .next();
                let param_translate_interests_to_names = match param_translate_interests_to_names {
                    Some(param_translate_interests_to_names) => {
                        let param_translate_interests_to_names =
                            <bool as std::str::FromStr>::from_str
                                (&param_translate_interests_to_names);
                        match param_translate_interests_to_names {
                            Ok(param_translate_interests_to_names) => Some(param_translate_interests_to_names),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter translate_interests_to_names - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter translate_interests_to_names")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.ad_groups_slash_list(
                                            param_ad_account_id,
                                            param_campaign_ids.as_ref(),
                                            param_ad_group_ids.as_ref(),
                                            param_entity_statuses.as_ref(),
                                            param_page_size,
                                            param_order,
                                            param_bookmark,
                                            param_translate_interests_to_names,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdGroupsSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdGroupsSlashListResponse::InvalidAdAccountGroupParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_SLASH_LIST_INVALID_AD_ACCOUNT_GROUP_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdGroupsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdGroupsSlashUpdate - PATCH /ad_accounts/{ad_account_id}/ad_groups
            hyper::Method::PATCH if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_ad_group_update_request: Option<Vec<models::AdGroupUpdateRequest>> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_ad_group_update_request) => param_ad_group_update_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter AdGroupUpdateRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter AdGroupUpdateRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_ad_group_update_request = match param_ad_group_update_request {
                                    Some(param_ad_group_update_request) => param_ad_group_update_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter AdGroupUpdateRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter AdGroupUpdateRequest")),
                                };

                                let result = api_impl.ad_groups_slash_update(
                                            param_ad_account_id,
                                            param_ad_group_update_request.as_ref(),
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdGroupsSlashUpdateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_SLASH_UPDATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdGroupsSlashUpdateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_SLASH_UPDATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter AdGroupUpdateRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter AdGroupUpdateRequest")),
                        }
            },

            // AdGroupsTargetingAnalyticsSlashGet - GET /ad_accounts/{ad_account_id}/ad_groups/targeting_analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_TARGETING_ANALYTICS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_TARGETING_ANALYTICS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_TARGETING_ANALYTICS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_TARGETING_ANALYTICS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_group_ids = query_params.iter().filter(|e| e.0 == "ad_group_ids").map(|e| e.1.clone())
                    .filter_map(|param_ad_group_ids| param_ad_group_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_start_date = query_params.iter().filter(|e| e.0 == "start_date").map(|e| e.1.clone())
                    .next();
                let param_start_date = match param_start_date {
                    Some(param_start_date) => {
                        let param_start_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_start_date);
                        match param_start_date {
                            Ok(param_start_date) => Some(param_start_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter start_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter start_date")),
                        }
                    },
                    None => None,
                };
                let param_start_date = match param_start_date {
                    Some(param_start_date) => param_start_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter start_date"))
                        .expect("Unable to create Bad Request response for missing query parameter start_date")),
                };
                let param_end_date = query_params.iter().filter(|e| e.0 == "end_date").map(|e| e.1.clone())
                    .next();
                let param_end_date = match param_end_date {
                    Some(param_end_date) => {
                        let param_end_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_end_date);
                        match param_end_date {
                            Ok(param_end_date) => Some(param_end_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter end_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter end_date")),
                        }
                    },
                    None => None,
                };
                let param_end_date = match param_end_date {
                    Some(param_end_date) => param_end_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter end_date"))
                        .expect("Unable to create Bad Request response for missing query parameter end_date")),
                };
                let param_targeting_types = query_params.iter().filter(|e| e.0 == "targeting_types").map(|e| e.1.clone())
                    .filter_map(|param_targeting_types| param_targeting_types.parse().ok())
                    .collect::<Vec<_>>();
                let param_columns = query_params.iter().filter(|e| e.0 == "columns").map(|e| e.1.clone())
                    .filter_map(|param_columns| param_columns.parse().ok())
                    .collect::<Vec<_>>();
                let param_granularity = query_params.iter().filter(|e| e.0 == "granularity").map(|e| e.1.clone())
                    .next();
                let param_granularity = match param_granularity {
                    Some(param_granularity) => {
                        let param_granularity =
                            <models::Granularity as std::str::FromStr>::from_str
                                (&param_granularity);
                        match param_granularity {
                            Ok(param_granularity) => Some(param_granularity),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter granularity - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter granularity")),
                        }
                    },
                    None => None,
                };
                let param_granularity = match param_granularity {
                    Some(param_granularity) => param_granularity,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter granularity"))
                        .expect("Unable to create Bad Request response for missing query parameter granularity")),
                };
                let param_click_window_days = query_params.iter().filter(|e| e.0 == "click_window_days").map(|e| e.1.clone())
                    .next();
                let param_click_window_days = match param_click_window_days {
                    Some(param_click_window_days) => {
                        let param_click_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_click_window_days);
                        match param_click_window_days {
                            Ok(param_click_window_days) => Some(param_click_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter click_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter click_window_days")),
                        }
                    },
                    None => None,
                };
                let param_engagement_window_days = query_params.iter().filter(|e| e.0 == "engagement_window_days").map(|e| e.1.clone())
                    .next();
                let param_engagement_window_days = match param_engagement_window_days {
                    Some(param_engagement_window_days) => {
                        let param_engagement_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_engagement_window_days);
                        match param_engagement_window_days {
                            Ok(param_engagement_window_days) => Some(param_engagement_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter engagement_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter engagement_window_days")),
                        }
                    },
                    None => None,
                };
                let param_view_window_days = query_params.iter().filter(|e| e.0 == "view_window_days").map(|e| e.1.clone())
                    .next();
                let param_view_window_days = match param_view_window_days {
                    Some(param_view_window_days) => {
                        let param_view_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_view_window_days);
                        match param_view_window_days {
                            Ok(param_view_window_days) => Some(param_view_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter view_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter view_window_days")),
                        }
                    },
                    None => None,
                };
                let param_conversion_report_time = query_params.iter().filter(|e| e.0 == "conversion_report_time").map(|e| e.1.clone())
                    .next();
                let param_conversion_report_time = match param_conversion_report_time {
                    Some(param_conversion_report_time) => {
                        let param_conversion_report_time =
                            <String as std::str::FromStr>::from_str
                                (&param_conversion_report_time);
                        match param_conversion_report_time {
                            Ok(param_conversion_report_time) => Some(param_conversion_report_time),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter conversion_report_time - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter conversion_report_time")),
                        }
                    },
                    None => None,
                };
                let param_attribution_types = query_params.iter().filter(|e| e.0 == "attribution_types").map(|e| e.1.clone())
                    .next();
                let param_attribution_types = match param_attribution_types {
                    Some(param_attribution_types) => {
                        let param_attribution_types =
                            <models::ConversionReportAttributionType as std::str::FromStr>::from_str
                                (&param_attribution_types);
                        match param_attribution_types {
                            Ok(param_attribution_types) => Some(param_attribution_types),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter attribution_types - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter attribution_types")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.ad_groups_targeting_analytics_slash_get(
                                            param_ad_account_id,
                                            param_ad_group_ids.as_ref(),
                                            param_start_date,
                                            param_end_date,
                                            param_targeting_types.as_ref(),
                                            param_columns.as_ref(),
                                            param_granularity,
                                            param_click_window_days,
                                            param_engagement_window_days,
                                            param_view_window_days,
                                            param_conversion_report_time,
                                            param_attribution_types,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdGroupsTargetingAnalyticsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_TARGETING_ANALYTICS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdGroupsTargetingAnalyticsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_GROUPS_TARGETING_ANALYTICS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdPreviewsSlashCreate - POST /ad_accounts/{ad_account_id}/ad_previews
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_PREVIEWS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_PREVIEWS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_AD_PREVIEWS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_PREVIEWS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_ad_preview_request: Option<models::AdPreviewRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_ad_preview_request) => param_ad_preview_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter AdPreviewRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter AdPreviewRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_ad_preview_request = match param_ad_preview_request {
                                    Some(param_ad_preview_request) => param_ad_preview_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter AdPreviewRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter AdPreviewRequest")),
                                };

                                let result = api_impl.ad_previews_slash_create(
                                            param_ad_account_id,
                                            param_ad_preview_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdPreviewsSlashCreateResponse::SuccessfulAdPreviewCreation
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_PREVIEWS_SLASH_CREATE_SUCCESSFUL_AD_PREVIEW_CREATION"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdPreviewsSlashCreateResponse::InvalidPinParametersResponse
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_PREVIEWS_SLASH_CREATE_INVALID_PIN_PARAMETERS_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdPreviewsSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_PREVIEWS_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter AdPreviewRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter AdPreviewRequest")),
                        }
            },

            // AdTargetingAnalyticsSlashGet - GET /ad_accounts/{ad_account_id}/ads/targeting_analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_TARGETING_ANALYTICS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_TARGETING_ANALYTICS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_TARGETING_ANALYTICS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_TARGETING_ANALYTICS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_ids = query_params.iter().filter(|e| e.0 == "ad_ids").map(|e| e.1.clone())
                    .filter_map(|param_ad_ids| param_ad_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_start_date = query_params.iter().filter(|e| e.0 == "start_date").map(|e| e.1.clone())
                    .next();
                let param_start_date = match param_start_date {
                    Some(param_start_date) => {
                        let param_start_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_start_date);
                        match param_start_date {
                            Ok(param_start_date) => Some(param_start_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter start_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter start_date")),
                        }
                    },
                    None => None,
                };
                let param_start_date = match param_start_date {
                    Some(param_start_date) => param_start_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter start_date"))
                        .expect("Unable to create Bad Request response for missing query parameter start_date")),
                };
                let param_end_date = query_params.iter().filter(|e| e.0 == "end_date").map(|e| e.1.clone())
                    .next();
                let param_end_date = match param_end_date {
                    Some(param_end_date) => {
                        let param_end_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_end_date);
                        match param_end_date {
                            Ok(param_end_date) => Some(param_end_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter end_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter end_date")),
                        }
                    },
                    None => None,
                };
                let param_end_date = match param_end_date {
                    Some(param_end_date) => param_end_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter end_date"))
                        .expect("Unable to create Bad Request response for missing query parameter end_date")),
                };
                let param_targeting_types = query_params.iter().filter(|e| e.0 == "targeting_types").map(|e| e.1.clone())
                    .filter_map(|param_targeting_types| param_targeting_types.parse().ok())
                    .collect::<Vec<_>>();
                let param_columns = query_params.iter().filter(|e| e.0 == "columns").map(|e| e.1.clone())
                    .filter_map(|param_columns| param_columns.parse().ok())
                    .collect::<Vec<_>>();
                let param_granularity = query_params.iter().filter(|e| e.0 == "granularity").map(|e| e.1.clone())
                    .next();
                let param_granularity = match param_granularity {
                    Some(param_granularity) => {
                        let param_granularity =
                            <models::Granularity as std::str::FromStr>::from_str
                                (&param_granularity);
                        match param_granularity {
                            Ok(param_granularity) => Some(param_granularity),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter granularity - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter granularity")),
                        }
                    },
                    None => None,
                };
                let param_granularity = match param_granularity {
                    Some(param_granularity) => param_granularity,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter granularity"))
                        .expect("Unable to create Bad Request response for missing query parameter granularity")),
                };
                let param_click_window_days = query_params.iter().filter(|e| e.0 == "click_window_days").map(|e| e.1.clone())
                    .next();
                let param_click_window_days = match param_click_window_days {
                    Some(param_click_window_days) => {
                        let param_click_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_click_window_days);
                        match param_click_window_days {
                            Ok(param_click_window_days) => Some(param_click_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter click_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter click_window_days")),
                        }
                    },
                    None => None,
                };
                let param_engagement_window_days = query_params.iter().filter(|e| e.0 == "engagement_window_days").map(|e| e.1.clone())
                    .next();
                let param_engagement_window_days = match param_engagement_window_days {
                    Some(param_engagement_window_days) => {
                        let param_engagement_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_engagement_window_days);
                        match param_engagement_window_days {
                            Ok(param_engagement_window_days) => Some(param_engagement_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter engagement_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter engagement_window_days")),
                        }
                    },
                    None => None,
                };
                let param_view_window_days = query_params.iter().filter(|e| e.0 == "view_window_days").map(|e| e.1.clone())
                    .next();
                let param_view_window_days = match param_view_window_days {
                    Some(param_view_window_days) => {
                        let param_view_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_view_window_days);
                        match param_view_window_days {
                            Ok(param_view_window_days) => Some(param_view_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter view_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter view_window_days")),
                        }
                    },
                    None => None,
                };
                let param_conversion_report_time = query_params.iter().filter(|e| e.0 == "conversion_report_time").map(|e| e.1.clone())
                    .next();
                let param_conversion_report_time = match param_conversion_report_time {
                    Some(param_conversion_report_time) => {
                        let param_conversion_report_time =
                            <String as std::str::FromStr>::from_str
                                (&param_conversion_report_time);
                        match param_conversion_report_time {
                            Ok(param_conversion_report_time) => Some(param_conversion_report_time),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter conversion_report_time - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter conversion_report_time")),
                        }
                    },
                    None => None,
                };
                let param_attribution_types = query_params.iter().filter(|e| e.0 == "attribution_types").map(|e| e.1.clone())
                    .next();
                let param_attribution_types = match param_attribution_types {
                    Some(param_attribution_types) => {
                        let param_attribution_types =
                            <models::ConversionReportAttributionType as std::str::FromStr>::from_str
                                (&param_attribution_types);
                        match param_attribution_types {
                            Ok(param_attribution_types) => Some(param_attribution_types),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter attribution_types - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter attribution_types")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.ad_targeting_analytics_slash_get(
                                            param_ad_account_id,
                                            param_ad_ids.as_ref(),
                                            param_start_date,
                                            param_end_date,
                                            param_targeting_types.as_ref(),
                                            param_columns.as_ref(),
                                            param_granularity,
                                            param_click_window_days,
                                            param_engagement_window_days,
                                            param_view_window_days,
                                            param_conversion_report_time,
                                            param_attribution_types,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdTargetingAnalyticsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_TARGETING_ANALYTICS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdTargetingAnalyticsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_TARGETING_ANALYTICS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdsSlashAnalytics - GET /ad_accounts/{ad_account_id}/ads/analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_ANALYTICS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_ANALYTICS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_ANALYTICS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_ANALYTICS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_start_date = query_params.iter().filter(|e| e.0 == "start_date").map(|e| e.1.clone())
                    .next();
                let param_start_date = match param_start_date {
                    Some(param_start_date) => {
                        let param_start_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_start_date);
                        match param_start_date {
                            Ok(param_start_date) => Some(param_start_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter start_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter start_date")),
                        }
                    },
                    None => None,
                };
                let param_start_date = match param_start_date {
                    Some(param_start_date) => param_start_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter start_date"))
                        .expect("Unable to create Bad Request response for missing query parameter start_date")),
                };
                let param_end_date = query_params.iter().filter(|e| e.0 == "end_date").map(|e| e.1.clone())
                    .next();
                let param_end_date = match param_end_date {
                    Some(param_end_date) => {
                        let param_end_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_end_date);
                        match param_end_date {
                            Ok(param_end_date) => Some(param_end_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter end_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter end_date")),
                        }
                    },
                    None => None,
                };
                let param_end_date = match param_end_date {
                    Some(param_end_date) => param_end_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter end_date"))
                        .expect("Unable to create Bad Request response for missing query parameter end_date")),
                };
                let param_ad_ids = query_params.iter().filter(|e| e.0 == "ad_ids").map(|e| e.1.clone())
                    .filter_map(|param_ad_ids| param_ad_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_columns = query_params.iter().filter(|e| e.0 == "columns").map(|e| e.1.clone())
                    .filter_map(|param_columns| param_columns.parse().ok())
                    .collect::<Vec<_>>();
                let param_granularity = query_params.iter().filter(|e| e.0 == "granularity").map(|e| e.1.clone())
                    .next();
                let param_granularity = match param_granularity {
                    Some(param_granularity) => {
                        let param_granularity =
                            <models::Granularity as std::str::FromStr>::from_str
                                (&param_granularity);
                        match param_granularity {
                            Ok(param_granularity) => Some(param_granularity),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter granularity - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter granularity")),
                        }
                    },
                    None => None,
                };
                let param_granularity = match param_granularity {
                    Some(param_granularity) => param_granularity,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter granularity"))
                        .expect("Unable to create Bad Request response for missing query parameter granularity")),
                };
                let param_click_window_days = query_params.iter().filter(|e| e.0 == "click_window_days").map(|e| e.1.clone())
                    .next();
                let param_click_window_days = match param_click_window_days {
                    Some(param_click_window_days) => {
                        let param_click_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_click_window_days);
                        match param_click_window_days {
                            Ok(param_click_window_days) => Some(param_click_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter click_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter click_window_days")),
                        }
                    },
                    None => None,
                };
                let param_engagement_window_days = query_params.iter().filter(|e| e.0 == "engagement_window_days").map(|e| e.1.clone())
                    .next();
                let param_engagement_window_days = match param_engagement_window_days {
                    Some(param_engagement_window_days) => {
                        let param_engagement_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_engagement_window_days);
                        match param_engagement_window_days {
                            Ok(param_engagement_window_days) => Some(param_engagement_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter engagement_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter engagement_window_days")),
                        }
                    },
                    None => None,
                };
                let param_view_window_days = query_params.iter().filter(|e| e.0 == "view_window_days").map(|e| e.1.clone())
                    .next();
                let param_view_window_days = match param_view_window_days {
                    Some(param_view_window_days) => {
                        let param_view_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_view_window_days);
                        match param_view_window_days {
                            Ok(param_view_window_days) => Some(param_view_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter view_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter view_window_days")),
                        }
                    },
                    None => None,
                };
                let param_conversion_report_time = query_params.iter().filter(|e| e.0 == "conversion_report_time").map(|e| e.1.clone())
                    .next();
                let param_conversion_report_time = match param_conversion_report_time {
                    Some(param_conversion_report_time) => {
                        let param_conversion_report_time =
                            <String as std::str::FromStr>::from_str
                                (&param_conversion_report_time);
                        match param_conversion_report_time {
                            Ok(param_conversion_report_time) => Some(param_conversion_report_time),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter conversion_report_time - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter conversion_report_time")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.ads_slash_analytics(
                                            param_ad_account_id,
                                            param_start_date,
                                            param_end_date,
                                            param_ad_ids.as_ref(),
                                            param_columns.as_ref(),
                                            param_granularity,
                                            param_click_window_days,
                                            param_engagement_window_days,
                                            param_view_window_days,
                                            param_conversion_report_time,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdsSlashAnalyticsResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ADS_SLASH_ANALYTICS_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdsSlashAnalyticsResponse::InvalidAdAccountAdsAnalyticsParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ADS_SLASH_ANALYTICS_INVALID_AD_ACCOUNT_ADS_ANALYTICS_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdsSlashAnalyticsResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ADS_SLASH_ANALYTICS_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdsSlashCreate - POST /ad_accounts/{ad_account_id}/ads
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_ADS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_ad_create_request: Option<Vec<models::AdCreateRequest>> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_ad_create_request) => param_ad_create_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter AdCreateRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter AdCreateRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_ad_create_request = match param_ad_create_request {
                                    Some(param_ad_create_request) => param_ad_create_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter AdCreateRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter AdCreateRequest")),
                                };

                                let result = api_impl.ads_slash_create(
                                            param_ad_account_id,
                                            param_ad_create_request.as_ref(),
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdsSlashCreateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ADS_SLASH_CREATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdsSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ADS_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter AdCreateRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter AdCreateRequest")),
                        }
            },

            // AdsSlashGet - GET /ad_accounts/{ad_account_id}/ads/{ad_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_AD_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_AD_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_AD_ID in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_AD_ID.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_ad_id = match percent_encoding::percent_decode(path_params["ad_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_id) => match param_ad_id.parse::<String>() {
                        Ok(param_ad_id) => param_ad_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.ads_slash_get(
                                            param_ad_account_id,
                                            param_ad_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ADS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ADS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdsSlashList - GET /ad_accounts/{ad_account_id}/ads
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_ADS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_campaign_ids = query_params.iter().filter(|e| e.0 == "campaign_ids").map(|e| e.1.clone())
                    .filter_map(|param_campaign_ids| param_campaign_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_campaign_ids = if !param_campaign_ids.is_empty() {
                    Some(param_campaign_ids)
                } else {
                    None
                };
                let param_ad_group_ids = query_params.iter().filter(|e| e.0 == "ad_group_ids").map(|e| e.1.clone())
                    .filter_map(|param_ad_group_ids| param_ad_group_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_ad_group_ids = if !param_ad_group_ids.is_empty() {
                    Some(param_ad_group_ids)
                } else {
                    None
                };
                let param_ad_ids = query_params.iter().filter(|e| e.0 == "ad_ids").map(|e| e.1.clone())
                    .filter_map(|param_ad_ids| param_ad_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_ad_ids = if !param_ad_ids.is_empty() {
                    Some(param_ad_ids)
                } else {
                    None
                };
                let param_entity_statuses = query_params.iter().filter(|e| e.0 == "entity_statuses").map(|e| e.1.clone())
                    .filter_map(|param_entity_statuses| param_entity_statuses.parse().ok())
                    .collect::<Vec<_>>();
                let param_entity_statuses = if !param_entity_statuses.is_empty() {
                    Some(param_entity_statuses)
                } else {
                    None
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_order = query_params.iter().filter(|e| e.0 == "order").map(|e| e.1.clone())
                    .next();
                let param_order = match param_order {
                    Some(param_order) => {
                        let param_order =
                            <String as std::str::FromStr>::from_str
                                (&param_order);
                        match param_order {
                            Ok(param_order) => Some(param_order),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter order - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter order")),
                        }
                    },
                    None => None,
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.ads_slash_list(
                                            param_ad_account_id,
                                            param_campaign_ids.as_ref(),
                                            param_ad_group_ids.as_ref(),
                                            param_ad_ids.as_ref(),
                                            param_entity_statuses.as_ref(),
                                            param_page_size,
                                            param_order,
                                            param_bookmark,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdsSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ADS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdsSlashListResponse::InvalidAdAccountAdsParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ADS_SLASH_LIST_INVALID_AD_ACCOUNT_ADS_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ADS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdsSlashUpdate - PATCH /ad_accounts/{ad_account_id}/ads
            hyper::Method::PATCH if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_ADS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_ad_update_request: Option<Vec<models::AdUpdateRequest>> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_ad_update_request) => param_ad_update_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter AdUpdateRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter AdUpdateRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_ad_update_request = match param_ad_update_request {
                                    Some(param_ad_update_request) => param_ad_update_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter AdUpdateRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter AdUpdateRequest")),
                                };

                                let result = api_impl.ads_slash_update(
                                            param_ad_account_id,
                                            param_ad_update_request.as_ref(),
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdsSlashUpdateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ADS_SLASH_UPDATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdsSlashUpdateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ADS_SLASH_UPDATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter AdUpdateRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter AdUpdateRequest")),
                        }
            },

            // AudienceInsightsScopeAndTypeSlashGet - GET /ad_accounts/{ad_account_id}/insights/audiences
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_INSIGHTS_AUDIENCES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_INSIGHTS_AUDIENCES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_INSIGHTS_AUDIENCES in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_INSIGHTS_AUDIENCES.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.audience_insights_scope_and_type_slash_get(
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AudienceInsightsScopeAndTypeSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUDIENCE_INSIGHTS_SCOPE_AND_TYPE_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AudienceInsightsScopeAndTypeSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUDIENCE_INSIGHTS_SCOPE_AND_TYPE_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AudienceInsightsSlashGet - GET /ad_accounts/{ad_account_id}/audience_insights
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCE_INSIGHTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCE_INSIGHTS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCE_INSIGHTS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCE_INSIGHTS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_audience_insight_type = query_params.iter().filter(|e| e.0 == "audience_insight_type").map(|e| e.1.clone())
                    .next();
                let param_audience_insight_type = match param_audience_insight_type {
                    Some(param_audience_insight_type) => {
                        let param_audience_insight_type =
                            <models::AudienceInsightType as std::str::FromStr>::from_str
                                (&param_audience_insight_type);
                        match param_audience_insight_type {
                            Ok(param_audience_insight_type) => Some(param_audience_insight_type),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter audience_insight_type - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter audience_insight_type")),
                        }
                    },
                    None => None,
                };
                let param_audience_insight_type = match param_audience_insight_type {
                    Some(param_audience_insight_type) => param_audience_insight_type,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter audience_insight_type"))
                        .expect("Unable to create Bad Request response for missing query parameter audience_insight_type")),
                };

                                let result = api_impl.audience_insights_slash_get(
                                            param_ad_account_id,
                                            param_audience_insight_type,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AudienceInsightsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUDIENCE_INSIGHTS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AudienceInsightsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUDIENCE_INSIGHTS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AudiencesSlashCreate - POST /ad_accounts/{ad_account_id}/audiences
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_audience_create_request: Option<models::AudienceCreateRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_audience_create_request) => param_audience_create_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter AudienceCreateRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter AudienceCreateRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_audience_create_request = match param_audience_create_request {
                                    Some(param_audience_create_request) => param_audience_create_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter AudienceCreateRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter AudienceCreateRequest")),
                                };

                                let result = api_impl.audiences_slash_create(
                                            param_ad_account_id,
                                            param_audience_create_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AudiencesSlashCreateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUDIENCES_SLASH_CREATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AudiencesSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUDIENCES_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter AudienceCreateRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter AudienceCreateRequest")),
                        }
            },

            // AudiencesSlashCreateCustom - POST /ad_accounts/{ad_account_id}/audiences/custom
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_CUSTOM) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_CUSTOM
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_CUSTOM in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_CUSTOM.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_audience_create_custom_request: Option<models::AudienceCreateCustomRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_audience_create_custom_request) => param_audience_create_custom_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter AudienceCreateCustomRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter AudienceCreateCustomRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_audience_create_custom_request = match param_audience_create_custom_request {
                                    Some(param_audience_create_custom_request) => param_audience_create_custom_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter AudienceCreateCustomRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter AudienceCreateCustomRequest")),
                                };

                                let result = api_impl.audiences_slash_create_custom(
                                            param_ad_account_id,
                                            param_audience_create_custom_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AudiencesSlashCreateCustomResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUDIENCES_SLASH_CREATE_CUSTOM_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AudiencesSlashCreateCustomResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUDIENCES_SLASH_CREATE_CUSTOM_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter AudienceCreateCustomRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter AudienceCreateCustomRequest")),
                        }
            },

            // AudiencesSlashGet - GET /ad_accounts/{ad_account_id}/audiences/{audience_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_AUDIENCE_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_AUDIENCE_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_AUDIENCE_ID in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_AUDIENCE_ID.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_audience_id = match percent_encoding::percent_decode(path_params["audience_id"].as_bytes()).decode_utf8() {
                    Ok(param_audience_id) => match param_audience_id.parse::<String>() {
                        Ok(param_audience_id) => param_audience_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter audience_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["audience_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.audiences_slash_get(
                                            param_ad_account_id,
                                            param_audience_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AudiencesSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUDIENCES_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AudiencesSlashGetResponse::AudienceNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUDIENCES_SLASH_GET_AUDIENCE_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AudiencesSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUDIENCES_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AudiencesSlashList - GET /ad_accounts/{ad_account_id}/audiences
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_order = query_params.iter().filter(|e| e.0 == "order").map(|e| e.1.clone())
                    .next();
                let param_order = match param_order {
                    Some(param_order) => {
                        let param_order =
                            <String as std::str::FromStr>::from_str
                                (&param_order);
                        match param_order {
                            Ok(param_order) => Some(param_order),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter order - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter order")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_ownership_type = query_params.iter().filter(|e| e.0 == "ownership_type").map(|e| e.1.clone())
                    .next();
                let param_ownership_type = match param_ownership_type {
                    Some(param_ownership_type) => {
                        let param_ownership_type =
                            <String as std::str::FromStr>::from_str
                                (&param_ownership_type);
                        match param_ownership_type {
                            Ok(param_ownership_type) => Some(param_ownership_type),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ownership_type - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ownership_type")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.audiences_slash_list(
                                            param_ad_account_id,
                                            param_bookmark,
                                            param_order,
                                            param_page_size,
                                            param_ownership_type,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AudiencesSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUDIENCES_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AudiencesSlashListResponse::InvalidAdAccountAudienceParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUDIENCES_SLASH_LIST_INVALID_AD_ACCOUNT_AUDIENCE_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AudiencesSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUDIENCES_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AudiencesSlashUpdate - PATCH /ad_accounts/{ad_account_id}/audiences/{audience_id}
            hyper::Method::PATCH if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_AUDIENCE_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_AUDIENCE_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_AUDIENCE_ID in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_AUDIENCE_ID.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_audience_id = match percent_encoding::percent_decode(path_params["audience_id"].as_bytes()).decode_utf8() {
                    Ok(param_audience_id) => match param_audience_id.parse::<String>() {
                        Ok(param_audience_id) => param_audience_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter audience_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["audience_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_audience_update_request: Option<models::AudienceUpdateRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_audience_update_request) => param_audience_update_request,
                                        Err(_) => None,
                                    }
                                } else {
                                    None
                                };

                                let result = api_impl.audiences_slash_update(
                                            param_ad_account_id,
                                            param_audience_id,
                                            param_audience_update_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AudiencesSlashUpdateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUDIENCES_SLASH_UPDATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AudiencesSlashUpdateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AUDIENCES_SLASH_UPDATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter AudienceUpdateRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter AudienceUpdateRequest")),
                        }
            },

            // AdsCreditSlashRedeem - POST /ad_accounts/{ad_account_id}/ads_credit/redeem
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_REDEEM) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                            "billing:write".to_string(), // Create, update, or delete billing data, billing profiles, etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_REDEEM
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_REDEEM in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_REDEEM.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_ads_credit_redeem_request: Option<models::AdsCreditRedeemRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_ads_credit_redeem_request) => param_ads_credit_redeem_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter AdsCreditRedeemRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter AdsCreditRedeemRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_ads_credit_redeem_request = match param_ads_credit_redeem_request {
                                    Some(param_ads_credit_redeem_request) => param_ads_credit_redeem_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter AdsCreditRedeemRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter AdsCreditRedeemRequest")),
                                };

                                let result = api_impl.ads_credit_slash_redeem(
                                            param_ad_account_id,
                                            param_ads_credit_redeem_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdsCreditSlashRedeemResponse::SuccessfullyRedeemedAdCredits
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ADS_CREDIT_SLASH_REDEEM_SUCCESSFULLY_REDEEMED_AD_CREDITS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdsCreditSlashRedeemResponse::ErrorThrownWhenUnableToRedeemOfferCode
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ADS_CREDIT_SLASH_REDEEM_ERROR_THROWN_WHEN_UNABLE_TO_REDEEM_OFFER_CODE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdsCreditSlashRedeemResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ADS_CREDIT_SLASH_REDEEM_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter AdsCreditRedeemRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter AdsCreditRedeemRequest")),
                        }
            },

            // AdsCreditsDiscountsSlashGet - GET /ad_accounts/{ad_account_id}/ads_credit/discounts
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_DISCOUNTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                            "billing:read".to_string(), // See all of your billing data, billing profile, etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_DISCOUNTS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_DISCOUNTS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_DISCOUNTS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.ads_credits_discounts_slash_get(
                                            param_ad_account_id,
                                            param_bookmark,
                                            param_page_size,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdsCreditsDiscountsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ADS_CREDITS_DISCOUNTS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdsCreditsDiscountsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ADS_CREDITS_DISCOUNTS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // BillingProfilesSlashGet - GET /ad_accounts/{ad_account_id}/billing_profiles
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BILLING_PROFILES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                            "billing:read".to_string(), // See all of your billing data, billing profile, etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_BILLING_PROFILES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_BILLING_PROFILES in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_BILLING_PROFILES.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_is_active = query_params.iter().filter(|e| e.0 == "is_active").map(|e| e.1.clone())
                    .next();
                let param_is_active = match param_is_active {
                    Some(param_is_active) => {
                        let param_is_active =
                            <bool as std::str::FromStr>::from_str
                                (&param_is_active);
                        match param_is_active {
                            Ok(param_is_active) => Some(param_is_active),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter is_active - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter is_active")),
                        }
                    },
                    None => None,
                };
                let param_is_active = match param_is_active {
                    Some(param_is_active) => param_is_active,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter is_active"))
                        .expect("Unable to create Bad Request response for missing query parameter is_active")),
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.billing_profiles_slash_get(
                                            param_ad_account_id,
                                            param_is_active,
                                            param_bookmark,
                                            param_page_size,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                BillingProfilesSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BILLING_PROFILES_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BillingProfilesSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BILLING_PROFILES_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // SsioAccountsSlashGet - GET /ad_accounts/{ad_account_id}/ssio/accounts
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ACCOUNTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ACCOUNTS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ACCOUNTS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ACCOUNTS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.ssio_accounts_slash_get(
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                SsioAccountsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_ACCOUNTS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SsioAccountsSlashGetResponse::InvalidRequestParameter
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_ACCOUNTS_SLASH_GET_INVALID_REQUEST_PARAMETER"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SsioAccountsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_ACCOUNTS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // SsioInsertionOrderSlashCreate - POST /ad_accounts/{ad_account_id}/ssio/insertion_orders
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_ssio_create_insertion_order_request: Option<models::SsioCreateInsertionOrderRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_ssio_create_insertion_order_request) => param_ssio_create_insertion_order_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter SsioCreateInsertionOrderRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter SsioCreateInsertionOrderRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_ssio_create_insertion_order_request = match param_ssio_create_insertion_order_request {
                                    Some(param_ssio_create_insertion_order_request) => param_ssio_create_insertion_order_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter SsioCreateInsertionOrderRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter SsioCreateInsertionOrderRequest")),
                                };

                                let result = api_impl.ssio_insertion_order_slash_create(
                                            param_ad_account_id,
                                            param_ssio_create_insertion_order_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                SsioInsertionOrderSlashCreateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_INSERTION_ORDER_SLASH_CREATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SsioInsertionOrderSlashCreateResponse::InvalidRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_INSERTION_ORDER_SLASH_CREATE_INVALID_REQUEST"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SsioInsertionOrderSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_INSERTION_ORDER_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter SsioCreateInsertionOrderRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter SsioCreateInsertionOrderRequest")),
                        }
            },

            // SsioInsertionOrderSlashEdit - PATCH /ad_accounts/{ad_account_id}/ssio/insertion_orders
            hyper::Method::PATCH if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_ssio_edit_insertion_order_request: Option<models::SsioEditInsertionOrderRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_ssio_edit_insertion_order_request) => param_ssio_edit_insertion_order_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter SsioEditInsertionOrderRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter SsioEditInsertionOrderRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_ssio_edit_insertion_order_request = match param_ssio_edit_insertion_order_request {
                                    Some(param_ssio_edit_insertion_order_request) => param_ssio_edit_insertion_order_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter SsioEditInsertionOrderRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter SsioEditInsertionOrderRequest")),
                                };

                                let result = api_impl.ssio_insertion_order_slash_edit(
                                            param_ad_account_id,
                                            param_ssio_edit_insertion_order_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                SsioInsertionOrderSlashEditResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_INSERTION_ORDER_SLASH_EDIT_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SsioInsertionOrderSlashEditResponse::InvalidRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_INSERTION_ORDER_SLASH_EDIT_INVALID_REQUEST"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SsioInsertionOrderSlashEditResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_INSERTION_ORDER_SLASH_EDIT_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter SsioEditInsertionOrderRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter SsioEditInsertionOrderRequest")),
                        }
            },

            // SsioInsertionOrdersStatusSlashGetByAdAccount - GET /ad_accounts/{ad_account_id}/ssio/insertion_orders/status
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_STATUS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_STATUS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_STATUS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_STATUS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.ssio_insertion_orders_status_slash_get_by_ad_account(
                                            param_ad_account_id,
                                            param_bookmark,
                                            param_page_size,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                SsioInsertionOrdersStatusSlashGetByAdAccountResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_INSERTION_ORDERS_STATUS_SLASH_GET_BY_AD_ACCOUNT_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SsioInsertionOrdersStatusSlashGetByAdAccountResponse::InvalidRequestParameter
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_INSERTION_ORDERS_STATUS_SLASH_GET_BY_AD_ACCOUNT_INVALID_REQUEST_PARAMETER"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SsioInsertionOrdersStatusSlashGetByAdAccountResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_INSERTION_ORDERS_STATUS_SLASH_GET_BY_AD_ACCOUNT_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // SsioInsertionOrdersStatusSlashGetByPinOrderId - GET /ad_accounts/{ad_account_id}/ssio/insertion_orders/{pin_order_id}/status
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_PIN_ORDER_ID_STATUS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_PIN_ORDER_ID_STATUS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_PIN_ORDER_ID_STATUS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_PIN_ORDER_ID_STATUS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_pin_order_id = match percent_encoding::percent_decode(path_params["pin_order_id"].as_bytes()).decode_utf8() {
                    Ok(param_pin_order_id) => match param_pin_order_id.parse::<String>() {
                        Ok(param_pin_order_id) => param_pin_order_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter pin_order_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["pin_order_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.ssio_insertion_orders_status_slash_get_by_pin_order_id(
                                            param_ad_account_id,
                                            param_pin_order_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                SsioInsertionOrdersStatusSlashGetByPinOrderIdResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_INSERTION_ORDERS_STATUS_SLASH_GET_BY_PIN_ORDER_ID_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SsioInsertionOrdersStatusSlashGetByPinOrderIdResponse::InvalidRequestParameter
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_INSERTION_ORDERS_STATUS_SLASH_GET_BY_PIN_ORDER_ID_INVALID_REQUEST_PARAMETER"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SsioInsertionOrdersStatusSlashGetByPinOrderIdResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_INSERTION_ORDERS_STATUS_SLASH_GET_BY_PIN_ORDER_ID_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // SsioOrderLinesSlashGetByAdAccount - GET /ad_accounts/{ad_account_id}/ssio/order_lines
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ORDER_LINES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ORDER_LINES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ORDER_LINES in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ORDER_LINES.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_pin_order_id = query_params.iter().filter(|e| e.0 == "pin_order_id").map(|e| e.1.clone())
                    .next();
                let param_pin_order_id = match param_pin_order_id {
                    Some(param_pin_order_id) => {
                        let param_pin_order_id =
                            <String as std::str::FromStr>::from_str
                                (&param_pin_order_id);
                        match param_pin_order_id {
                            Ok(param_pin_order_id) => Some(param_pin_order_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter pin_order_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter pin_order_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.ssio_order_lines_slash_get_by_ad_account(
                                            param_ad_account_id,
                                            param_bookmark,
                                            param_page_size,
                                            param_pin_order_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                SsioOrderLinesSlashGetByAdAccountResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_ORDER_LINES_SLASH_GET_BY_AD_ACCOUNT_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SsioOrderLinesSlashGetByAdAccountResponse::InvalidRequestParameter
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_ORDER_LINES_SLASH_GET_BY_AD_ACCOUNT_INVALID_REQUEST_PARAMETER"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SsioOrderLinesSlashGetByAdAccountResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SSIO_ORDER_LINES_SLASH_GET_BY_AD_ACCOUNT_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // BoardSectionsSlashCreate - POST /boards/{board_id}/sections
            hyper::Method::POST if path.matched(paths::ID_BOARDS_BOARD_ID_SECTIONS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "boards:write".to_string(), // Create, update, or delete your public boards
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BOARDS_BOARD_ID_SECTIONS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BOARDS_BOARD_ID_SECTIONS in set but failed match against \"{}\"", path, paths::REGEX_BOARDS_BOARD_ID_SECTIONS.as_str())
                    );

                let param_board_id = match percent_encoding::percent_decode(path_params["board_id"].as_bytes()).decode_utf8() {
                    Ok(param_board_id) => match param_board_id.parse::<String>() {
                        Ok(param_board_id) => param_board_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter board_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["board_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_board_section: Option<models::BoardSection> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_board_section) => param_board_section,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter BoardSection - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter BoardSection due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_board_section = match param_board_section {
                                    Some(param_board_section) => param_board_section,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter BoardSection"))
                                                        .expect("Unable to create Bad Request response for missing body parameter BoardSection")),
                                };

                                let result = api_impl.board_sections_slash_create(
                                            param_board_id,
                                            param_board_section,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                BoardSectionsSlashCreateResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_CREATE_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardSectionsSlashCreateResponse::InvalidBoardSectionParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_CREATE_INVALID_BOARD_SECTION_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardSectionsSlashCreateResponse::NotAuthorizedToCreateBoardSections
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_CREATE_NOT_AUTHORIZED_TO_CREATE_BOARD_SECTIONS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardSectionsSlashCreateResponse::CouldNotGetExclusiveAccessToTheBoardToCreateANewSection
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_CREATE_COULD_NOT_GET_EXCLUSIVE_ACCESS_TO_THE_BOARD_TO_CREATE_A_NEW_SECTION"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardSectionsSlashCreateResponse::CouldNotCreateANewBoardSection
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(500).expect("Unable to turn 500 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_CREATE_COULD_NOT_CREATE_A_NEW_BOARD_SECTION"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardSectionsSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter BoardSection: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter BoardSection")),
                        }
            },

            // BoardSectionsSlashDelete - DELETE /boards/{board_id}/sections/{section_id}
            hyper::Method::DELETE if path.matched(paths::ID_BOARDS_BOARD_ID_SECTIONS_SECTION_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "boards:write".to_string(), // Create, update, or delete your public boards
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BOARDS_BOARD_ID_SECTIONS_SECTION_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BOARDS_BOARD_ID_SECTIONS_SECTION_ID in set but failed match against \"{}\"", path, paths::REGEX_BOARDS_BOARD_ID_SECTIONS_SECTION_ID.as_str())
                    );

                let param_board_id = match percent_encoding::percent_decode(path_params["board_id"].as_bytes()).decode_utf8() {
                    Ok(param_board_id) => match param_board_id.parse::<String>() {
                        Ok(param_board_id) => param_board_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter board_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["board_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_section_id = match percent_encoding::percent_decode(path_params["section_id"].as_bytes()).decode_utf8() {
                    Ok(param_section_id) => match param_section_id.parse::<String>() {
                        Ok(param_section_id) => param_section_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter section_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["section_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.board_sections_slash_delete(
                                            param_board_id,
                                            param_section_id,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                BoardSectionsSlashDeleteResponse::BoardSectionDeletedSuccessfully
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(204).expect("Unable to turn 204 into a StatusCode");
                                                },
                                                BoardSectionsSlashDeleteResponse::NotAuthorizedToDeleteBoardSection
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_DELETE_NOT_AUTHORIZED_TO_DELETE_BOARD_SECTION"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardSectionsSlashDeleteResponse::BoardSectionNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_DELETE_BOARD_SECTION_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardSectionsSlashDeleteResponse::BoardSectionConflict
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_DELETE_BOARD_SECTION_CONFLICT"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardSectionsSlashDeleteResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_DELETE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // BoardSectionsSlashList - GET /boards/{board_id}/sections
            hyper::Method::GET if path.matched(paths::ID_BOARDS_BOARD_ID_SECTIONS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BOARDS_BOARD_ID_SECTIONS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BOARDS_BOARD_ID_SECTIONS in set but failed match against \"{}\"", path, paths::REGEX_BOARDS_BOARD_ID_SECTIONS.as_str())
                    );

                let param_board_id = match percent_encoding::percent_decode(path_params["board_id"].as_bytes()).decode_utf8() {
                    Ok(param_board_id) => match param_board_id.parse::<String>() {
                        Ok(param_board_id) => param_board_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter board_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["board_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.board_sections_slash_list(
                                            param_board_id,
                                            param_ad_account_id,
                                            param_bookmark,
                                            param_page_size,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                BoardSectionsSlashListResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_LIST_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardSectionsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // BoardSectionsSlashListPins - GET /boards/{board_id}/sections/{section_id}/pins
            hyper::Method::GET if path.matched(paths::ID_BOARDS_BOARD_ID_SECTIONS_SECTION_ID_PINS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "pins:read".to_string(), // See your public Pins
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BOARDS_BOARD_ID_SECTIONS_SECTION_ID_PINS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BOARDS_BOARD_ID_SECTIONS_SECTION_ID_PINS in set but failed match against \"{}\"", path, paths::REGEX_BOARDS_BOARD_ID_SECTIONS_SECTION_ID_PINS.as_str())
                    );

                let param_board_id = match percent_encoding::percent_decode(path_params["board_id"].as_bytes()).decode_utf8() {
                    Ok(param_board_id) => match param_board_id.parse::<String>() {
                        Ok(param_board_id) => param_board_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter board_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["board_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_section_id = match percent_encoding::percent_decode(path_params["section_id"].as_bytes()).decode_utf8() {
                    Ok(param_section_id) => match param_section_id.parse::<String>() {
                        Ok(param_section_id) => param_section_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter section_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["section_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.board_sections_slash_list_pins(
                                            param_board_id,
                                            param_section_id,
                                            param_ad_account_id,
                                            param_bookmark,
                                            param_page_size,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                BoardSectionsSlashListPinsResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_LIST_PINS_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardSectionsSlashListPinsResponse::NotAuthorizedToAccessPinsOnBoardSection
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_LIST_PINS_NOT_AUTHORIZED_TO_ACCESS_PINS_ON_BOARD_SECTION"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardSectionsSlashListPinsResponse::BoardOrSectionNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_LIST_PINS_BOARD_OR_SECTION_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardSectionsSlashListPinsResponse::BoardSectionConflict
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_LIST_PINS_BOARD_SECTION_CONFLICT"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardSectionsSlashListPinsResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_LIST_PINS_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // BoardSectionsSlashUpdate - PATCH /boards/{board_id}/sections/{section_id}
            hyper::Method::PATCH if path.matched(paths::ID_BOARDS_BOARD_ID_SECTIONS_SECTION_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "boards:write".to_string(), // Create, update, or delete your public boards
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BOARDS_BOARD_ID_SECTIONS_SECTION_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BOARDS_BOARD_ID_SECTIONS_SECTION_ID in set but failed match against \"{}\"", path, paths::REGEX_BOARDS_BOARD_ID_SECTIONS_SECTION_ID.as_str())
                    );

                let param_board_id = match percent_encoding::percent_decode(path_params["board_id"].as_bytes()).decode_utf8() {
                    Ok(param_board_id) => match param_board_id.parse::<String>() {
                        Ok(param_board_id) => param_board_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter board_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["board_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_section_id = match percent_encoding::percent_decode(path_params["section_id"].as_bytes()).decode_utf8() {
                    Ok(param_section_id) => match param_section_id.parse::<String>() {
                        Ok(param_section_id) => param_section_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter section_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["section_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_board_section: Option<models::BoardSection> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_board_section) => param_board_section,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter BoardSection - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter BoardSection due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_board_section = match param_board_section {
                                    Some(param_board_section) => param_board_section,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter BoardSection"))
                                                        .expect("Unable to create Bad Request response for missing body parameter BoardSection")),
                                };

                                let result = api_impl.board_sections_slash_update(
                                            param_board_id,
                                            param_section_id,
                                            param_board_section,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                BoardSectionsSlashUpdateResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_UPDATE_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardSectionsSlashUpdateResponse::InvalidBoardSectionParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_UPDATE_INVALID_BOARD_SECTION_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardSectionsSlashUpdateResponse::NotAuthorizedToUpdateBoardSection
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_UPDATE_NOT_AUTHORIZED_TO_UPDATE_BOARD_SECTION"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardSectionsSlashUpdateResponse::BoardSectionConflict
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_UPDATE_BOARD_SECTION_CONFLICT"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardSectionsSlashUpdateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARD_SECTIONS_SLASH_UPDATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter BoardSection: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter BoardSection")),
                        }
            },

            // BoardsSlashCreate - POST /boards
            hyper::Method::POST if path.matched(paths::ID_BOARDS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "boards:write".to_string(), // Create, update, or delete your public boards
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_board: Option<models::Board> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_board) => param_board,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter Board - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter Board due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_board = match param_board {
                                    Some(param_board) => param_board,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter Board"))
                                                        .expect("Unable to create Bad Request response for missing body parameter Board")),
                                };

                                let result = api_impl.boards_slash_create(
                                            param_board,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                BoardsSlashCreateResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_CREATE_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardsSlashCreateResponse::TheBoardNameIsInvalidOrDuplicated
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_CREATE_THE_BOARD_NAME_IS_INVALID_OR_DUPLICATED"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardsSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter Board: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter Board")),
                        }
            },

            // BoardsSlashDelete - DELETE /boards/{board_id}
            hyper::Method::DELETE if path.matched(paths::ID_BOARDS_BOARD_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "boards:write".to_string(), // Create, update, or delete your public boards
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BOARDS_BOARD_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BOARDS_BOARD_ID in set but failed match against \"{}\"", path, paths::REGEX_BOARDS_BOARD_ID.as_str())
                    );

                let param_board_id = match percent_encoding::percent_decode(path_params["board_id"].as_bytes()).decode_utf8() {
                    Ok(param_board_id) => match param_board_id.parse::<String>() {
                        Ok(param_board_id) => param_board_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter board_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["board_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.boards_slash_delete(
                                            param_board_id,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                BoardsSlashDeleteResponse::BoardDeletedSuccessfully
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(204).expect("Unable to turn 204 into a StatusCode");
                                                },
                                                BoardsSlashDeleteResponse::NotAuthorizedToDeleteTheBoard
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_DELETE_NOT_AUTHORIZED_TO_DELETE_THE_BOARD"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardsSlashDeleteResponse::BoardNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_DELETE_BOARD_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardsSlashDeleteResponse::CouldNotGetExclusiveAccessToDeleteTheBoard
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_DELETE_COULD_NOT_GET_EXCLUSIVE_ACCESS_TO_DELETE_THE_BOARD"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardsSlashDeleteResponse::ThisRequestExceededARateLimit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(429).expect("Unable to turn 429 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_DELETE_THIS_REQUEST_EXCEEDED_A_RATE_LIMIT"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardsSlashDeleteResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_DELETE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // BoardsSlashGet - GET /boards/{board_id}
            hyper::Method::GET if path.matched(paths::ID_BOARDS_BOARD_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BOARDS_BOARD_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BOARDS_BOARD_ID in set but failed match against \"{}\"", path, paths::REGEX_BOARDS_BOARD_ID.as_str())
                    );

                let param_board_id = match percent_encoding::percent_decode(path_params["board_id"].as_bytes()).decode_utf8() {
                    Ok(param_board_id) => match param_board_id.parse::<String>() {
                        Ok(param_board_id) => param_board_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter board_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["board_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.boards_slash_get(
                                            param_board_id,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                BoardsSlashGetResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_GET_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardsSlashGetResponse::BoardNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_GET_BOARD_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // BoardsSlashList - GET /boards
            hyper::Method::GET if path.matched(paths::ID_BOARDS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_privacy = query_params.iter().filter(|e| e.0 == "privacy").map(|e| e.1.clone())
                    .next();
                let param_privacy = match param_privacy {
                    Some(param_privacy) => {
                        let param_privacy =
                            <String as std::str::FromStr>::from_str
                                (&param_privacy);
                        match param_privacy {
                            Ok(param_privacy) => Some(param_privacy),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter privacy - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter privacy")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.boards_slash_list(
                                            param_ad_account_id,
                                            param_bookmark,
                                            param_page_size,
                                            param_privacy,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                BoardsSlashListResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_LIST_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // BoardsSlashListPins - GET /boards/{board_id}/pins
            hyper::Method::GET if path.matched(paths::ID_BOARDS_BOARD_ID_PINS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "pins:read".to_string(), // See your public Pins
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BOARDS_BOARD_ID_PINS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BOARDS_BOARD_ID_PINS in set but failed match against \"{}\"", path, paths::REGEX_BOARDS_BOARD_ID_PINS.as_str())
                    );

                let param_board_id = match percent_encoding::percent_decode(path_params["board_id"].as_bytes()).decode_utf8() {
                    Ok(param_board_id) => match param_board_id.parse::<String>() {
                        Ok(param_board_id) => param_board_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter board_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["board_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_creative_types = query_params.iter().filter(|e| e.0 == "creative_types").map(|e| e.1.clone())
                    .filter_map(|param_creative_types| param_creative_types.parse().ok())
                    .collect::<Vec<_>>();
                let param_creative_types = if !param_creative_types.is_empty() {
                    Some(param_creative_types)
                } else {
                    None
                };
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };
                let param_pin_metrics = query_params.iter().filter(|e| e.0 == "pin_metrics").map(|e| e.1.clone())
                    .next();
                let param_pin_metrics = match param_pin_metrics {
                    Some(param_pin_metrics) => {
                        let param_pin_metrics =
                            <bool as std::str::FromStr>::from_str
                                (&param_pin_metrics);
                        match param_pin_metrics {
                            Ok(param_pin_metrics) => Some(param_pin_metrics),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter pin_metrics - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter pin_metrics")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.boards_slash_list_pins(
                                            param_board_id,
                                            param_bookmark,
                                            param_page_size,
                                            param_creative_types.as_ref(),
                                            param_ad_account_id,
                                            param_pin_metrics,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                BoardsSlashListPinsResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_LIST_PINS_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardsSlashListPinsResponse::BoardNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_LIST_PINS_BOARD_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardsSlashListPinsResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_LIST_PINS_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // BoardsSlashUpdate - PATCH /boards/{board_id}
            hyper::Method::PATCH if path.matched(paths::ID_BOARDS_BOARD_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "boards:write".to_string(), // Create, update, or delete your public boards
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_BOARDS_BOARD_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE BOARDS_BOARD_ID in set but failed match against \"{}\"", path, paths::REGEX_BOARDS_BOARD_ID.as_str())
                    );

                let param_board_id = match percent_encoding::percent_decode(path_params["board_id"].as_bytes()).decode_utf8() {
                    Ok(param_board_id) => match param_board_id.parse::<String>() {
                        Ok(param_board_id) => param_board_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter board_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["board_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_board_update: Option<models::BoardUpdate> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_board_update) => param_board_update,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter BoardUpdate - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter BoardUpdate due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_board_update = match param_board_update {
                                    Some(param_board_update) => param_board_update,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter BoardUpdate"))
                                                        .expect("Unable to create Bad Request response for missing body parameter BoardUpdate")),
                                };

                                let result = api_impl.boards_slash_update(
                                            param_board_id,
                                            param_board_update,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                BoardsSlashUpdateResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_UPDATE_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardsSlashUpdateResponse::InvalidBoardParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_UPDATE_INVALID_BOARD_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardsSlashUpdateResponse::NotAuthorizedToUpdateTheBoard
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_UPDATE_NOT_AUTHORIZED_TO_UPDATE_THE_BOARD"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardsSlashUpdateResponse::ThisRequestExceededARateLimit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(429).expect("Unable to turn 429 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_UPDATE_THIS_REQUEST_EXCEEDED_A_RATE_LIMIT"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardsSlashUpdateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_SLASH_UPDATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter BoardUpdate: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter BoardUpdate")),
                        }
            },

            // BulkDownloadSlashCreate - POST /ad_accounts/{ad_account_id}/bulk/download
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_DOWNLOAD) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_DOWNLOAD
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_DOWNLOAD in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_DOWNLOAD.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_bulk_download_request: Option<models::BulkDownloadRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_bulk_download_request) => param_bulk_download_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter BulkDownloadRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter BulkDownloadRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_bulk_download_request = match param_bulk_download_request {
                                    Some(param_bulk_download_request) => param_bulk_download_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter BulkDownloadRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter BulkDownloadRequest")),
                                };

                                let result = api_impl.bulk_download_slash_create(
                                            param_ad_account_id,
                                            param_bulk_download_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                BulkDownloadSlashCreateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BULK_DOWNLOAD_SLASH_CREATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BulkDownloadSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BULK_DOWNLOAD_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter BulkDownloadRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter BulkDownloadRequest")),
                        }
            },

            // BulkRequestSlashGet - GET /ad_accounts/{ad_account_id}/bulk/{bulk_request_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_BULK_REQUEST_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_BULK_REQUEST_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_BULK_REQUEST_ID in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_BULK_REQUEST_ID.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_bulk_request_id = match percent_encoding::percent_decode(path_params["bulk_request_id"].as_bytes()).decode_utf8() {
                    Ok(param_bulk_request_id) => match param_bulk_request_id.parse::<String>() {
                        Ok(param_bulk_request_id) => param_bulk_request_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter bulk_request_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["bulk_request_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_include_details = query_params.iter().filter(|e| e.0 == "include_details").map(|e| e.1.clone())
                    .next();
                let param_include_details = match param_include_details {
                    Some(param_include_details) => {
                        let param_include_details =
                            <bool as std::str::FromStr>::from_str
                                (&param_include_details);
                        match param_include_details {
                            Ok(param_include_details) => Some(param_include_details),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter include_details - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter include_details")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.bulk_request_slash_get(
                                            param_ad_account_id,
                                            param_bulk_request_id,
                                            param_include_details,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                BulkRequestSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BULK_REQUEST_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BulkRequestSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BULK_REQUEST_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // BulkUpsertSlashCreate - POST /ad_accounts/{ad_account_id}/bulk/upsert
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_UPSERT) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_UPSERT
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_UPSERT in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_UPSERT.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_bulk_upsert_request: Option<models::BulkUpsertRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_bulk_upsert_request) => param_bulk_upsert_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter BulkUpsertRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter BulkUpsertRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_bulk_upsert_request = match param_bulk_upsert_request {
                                    Some(param_bulk_upsert_request) => param_bulk_upsert_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter BulkUpsertRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter BulkUpsertRequest")),
                                };

                                let result = api_impl.bulk_upsert_slash_create(
                                            param_ad_account_id,
                                            param_bulk_upsert_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                BulkUpsertSlashCreateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BULK_UPSERT_SLASH_CREATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BulkUpsertSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BULK_UPSERT_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter BulkUpsertRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter BulkUpsertRequest")),
                        }
            },

            // CampaignTargetingAnalyticsSlashGet - GET /ad_accounts/{ad_account_id}/campaigns/targeting_analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_TARGETING_ANALYTICS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_TARGETING_ANALYTICS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_TARGETING_ANALYTICS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_TARGETING_ANALYTICS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_campaign_ids = query_params.iter().filter(|e| e.0 == "campaign_ids").map(|e| e.1.clone())
                    .filter_map(|param_campaign_ids| param_campaign_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_start_date = query_params.iter().filter(|e| e.0 == "start_date").map(|e| e.1.clone())
                    .next();
                let param_start_date = match param_start_date {
                    Some(param_start_date) => {
                        let param_start_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_start_date);
                        match param_start_date {
                            Ok(param_start_date) => Some(param_start_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter start_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter start_date")),
                        }
                    },
                    None => None,
                };
                let param_start_date = match param_start_date {
                    Some(param_start_date) => param_start_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter start_date"))
                        .expect("Unable to create Bad Request response for missing query parameter start_date")),
                };
                let param_end_date = query_params.iter().filter(|e| e.0 == "end_date").map(|e| e.1.clone())
                    .next();
                let param_end_date = match param_end_date {
                    Some(param_end_date) => {
                        let param_end_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_end_date);
                        match param_end_date {
                            Ok(param_end_date) => Some(param_end_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter end_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter end_date")),
                        }
                    },
                    None => None,
                };
                let param_end_date = match param_end_date {
                    Some(param_end_date) => param_end_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter end_date"))
                        .expect("Unable to create Bad Request response for missing query parameter end_date")),
                };
                let param_targeting_types = query_params.iter().filter(|e| e.0 == "targeting_types").map(|e| e.1.clone())
                    .filter_map(|param_targeting_types| param_targeting_types.parse().ok())
                    .collect::<Vec<_>>();
                let param_columns = query_params.iter().filter(|e| e.0 == "columns").map(|e| e.1.clone())
                    .filter_map(|param_columns| param_columns.parse().ok())
                    .collect::<Vec<_>>();
                let param_granularity = query_params.iter().filter(|e| e.0 == "granularity").map(|e| e.1.clone())
                    .next();
                let param_granularity = match param_granularity {
                    Some(param_granularity) => {
                        let param_granularity =
                            <models::Granularity as std::str::FromStr>::from_str
                                (&param_granularity);
                        match param_granularity {
                            Ok(param_granularity) => Some(param_granularity),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter granularity - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter granularity")),
                        }
                    },
                    None => None,
                };
                let param_granularity = match param_granularity {
                    Some(param_granularity) => param_granularity,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter granularity"))
                        .expect("Unable to create Bad Request response for missing query parameter granularity")),
                };
                let param_click_window_days = query_params.iter().filter(|e| e.0 == "click_window_days").map(|e| e.1.clone())
                    .next();
                let param_click_window_days = match param_click_window_days {
                    Some(param_click_window_days) => {
                        let param_click_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_click_window_days);
                        match param_click_window_days {
                            Ok(param_click_window_days) => Some(param_click_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter click_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter click_window_days")),
                        }
                    },
                    None => None,
                };
                let param_engagement_window_days = query_params.iter().filter(|e| e.0 == "engagement_window_days").map(|e| e.1.clone())
                    .next();
                let param_engagement_window_days = match param_engagement_window_days {
                    Some(param_engagement_window_days) => {
                        let param_engagement_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_engagement_window_days);
                        match param_engagement_window_days {
                            Ok(param_engagement_window_days) => Some(param_engagement_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter engagement_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter engagement_window_days")),
                        }
                    },
                    None => None,
                };
                let param_view_window_days = query_params.iter().filter(|e| e.0 == "view_window_days").map(|e| e.1.clone())
                    .next();
                let param_view_window_days = match param_view_window_days {
                    Some(param_view_window_days) => {
                        let param_view_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_view_window_days);
                        match param_view_window_days {
                            Ok(param_view_window_days) => Some(param_view_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter view_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter view_window_days")),
                        }
                    },
                    None => None,
                };
                let param_conversion_report_time = query_params.iter().filter(|e| e.0 == "conversion_report_time").map(|e| e.1.clone())
                    .next();
                let param_conversion_report_time = match param_conversion_report_time {
                    Some(param_conversion_report_time) => {
                        let param_conversion_report_time =
                            <String as std::str::FromStr>::from_str
                                (&param_conversion_report_time);
                        match param_conversion_report_time {
                            Ok(param_conversion_report_time) => Some(param_conversion_report_time),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter conversion_report_time - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter conversion_report_time")),
                        }
                    },
                    None => None,
                };
                let param_attribution_types = query_params.iter().filter(|e| e.0 == "attribution_types").map(|e| e.1.clone())
                    .next();
                let param_attribution_types = match param_attribution_types {
                    Some(param_attribution_types) => {
                        let param_attribution_types =
                            <models::ConversionReportAttributionType as std::str::FromStr>::from_str
                                (&param_attribution_types);
                        match param_attribution_types {
                            Ok(param_attribution_types) => Some(param_attribution_types),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter attribution_types - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter attribution_types")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.campaign_targeting_analytics_slash_get(
                                            param_ad_account_id,
                                            param_campaign_ids.as_ref(),
                                            param_start_date,
                                            param_end_date,
                                            param_targeting_types.as_ref(),
                                            param_columns.as_ref(),
                                            param_granularity,
                                            param_click_window_days,
                                            param_engagement_window_days,
                                            param_view_window_days,
                                            param_conversion_report_time,
                                            param_attribution_types,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CampaignTargetingAnalyticsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CAMPAIGN_TARGETING_ANALYTICS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CampaignTargetingAnalyticsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CAMPAIGN_TARGETING_ANALYTICS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // CampaignsSlashAnalytics - GET /ad_accounts/{ad_account_id}/campaigns/analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_ANALYTICS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_ANALYTICS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_ANALYTICS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_ANALYTICS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_start_date = query_params.iter().filter(|e| e.0 == "start_date").map(|e| e.1.clone())
                    .next();
                let param_start_date = match param_start_date {
                    Some(param_start_date) => {
                        let param_start_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_start_date);
                        match param_start_date {
                            Ok(param_start_date) => Some(param_start_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter start_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter start_date")),
                        }
                    },
                    None => None,
                };
                let param_start_date = match param_start_date {
                    Some(param_start_date) => param_start_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter start_date"))
                        .expect("Unable to create Bad Request response for missing query parameter start_date")),
                };
                let param_end_date = query_params.iter().filter(|e| e.0 == "end_date").map(|e| e.1.clone())
                    .next();
                let param_end_date = match param_end_date {
                    Some(param_end_date) => {
                        let param_end_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_end_date);
                        match param_end_date {
                            Ok(param_end_date) => Some(param_end_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter end_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter end_date")),
                        }
                    },
                    None => None,
                };
                let param_end_date = match param_end_date {
                    Some(param_end_date) => param_end_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter end_date"))
                        .expect("Unable to create Bad Request response for missing query parameter end_date")),
                };
                let param_campaign_ids = query_params.iter().filter(|e| e.0 == "campaign_ids").map(|e| e.1.clone())
                    .filter_map(|param_campaign_ids| param_campaign_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_columns = query_params.iter().filter(|e| e.0 == "columns").map(|e| e.1.clone())
                    .filter_map(|param_columns| param_columns.parse().ok())
                    .collect::<Vec<_>>();
                let param_granularity = query_params.iter().filter(|e| e.0 == "granularity").map(|e| e.1.clone())
                    .next();
                let param_granularity = match param_granularity {
                    Some(param_granularity) => {
                        let param_granularity =
                            <models::Granularity as std::str::FromStr>::from_str
                                (&param_granularity);
                        match param_granularity {
                            Ok(param_granularity) => Some(param_granularity),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter granularity - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter granularity")),
                        }
                    },
                    None => None,
                };
                let param_granularity = match param_granularity {
                    Some(param_granularity) => param_granularity,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter granularity"))
                        .expect("Unable to create Bad Request response for missing query parameter granularity")),
                };
                let param_click_window_days = query_params.iter().filter(|e| e.0 == "click_window_days").map(|e| e.1.clone())
                    .next();
                let param_click_window_days = match param_click_window_days {
                    Some(param_click_window_days) => {
                        let param_click_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_click_window_days);
                        match param_click_window_days {
                            Ok(param_click_window_days) => Some(param_click_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter click_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter click_window_days")),
                        }
                    },
                    None => None,
                };
                let param_engagement_window_days = query_params.iter().filter(|e| e.0 == "engagement_window_days").map(|e| e.1.clone())
                    .next();
                let param_engagement_window_days = match param_engagement_window_days {
                    Some(param_engagement_window_days) => {
                        let param_engagement_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_engagement_window_days);
                        match param_engagement_window_days {
                            Ok(param_engagement_window_days) => Some(param_engagement_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter engagement_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter engagement_window_days")),
                        }
                    },
                    None => None,
                };
                let param_view_window_days = query_params.iter().filter(|e| e.0 == "view_window_days").map(|e| e.1.clone())
                    .next();
                let param_view_window_days = match param_view_window_days {
                    Some(param_view_window_days) => {
                        let param_view_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_view_window_days);
                        match param_view_window_days {
                            Ok(param_view_window_days) => Some(param_view_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter view_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter view_window_days")),
                        }
                    },
                    None => None,
                };
                let param_conversion_report_time = query_params.iter().filter(|e| e.0 == "conversion_report_time").map(|e| e.1.clone())
                    .next();
                let param_conversion_report_time = match param_conversion_report_time {
                    Some(param_conversion_report_time) => {
                        let param_conversion_report_time =
                            <String as std::str::FromStr>::from_str
                                (&param_conversion_report_time);
                        match param_conversion_report_time {
                            Ok(param_conversion_report_time) => Some(param_conversion_report_time),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter conversion_report_time - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter conversion_report_time")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.campaigns_slash_analytics(
                                            param_ad_account_id,
                                            param_start_date,
                                            param_end_date,
                                            param_campaign_ids.as_ref(),
                                            param_columns.as_ref(),
                                            param_granularity,
                                            param_click_window_days,
                                            param_engagement_window_days,
                                            param_view_window_days,
                                            param_conversion_report_time,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CampaignsSlashAnalyticsResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CAMPAIGNS_SLASH_ANALYTICS_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CampaignsSlashAnalyticsResponse::InvalidAdAccountCampaignAnalyticsParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CAMPAIGNS_SLASH_ANALYTICS_INVALID_AD_ACCOUNT_CAMPAIGN_ANALYTICS_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CampaignsSlashAnalyticsResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CAMPAIGNS_SLASH_ANALYTICS_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // CampaignsSlashCreate - POST /ad_accounts/{ad_account_id}/campaigns
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_campaign_create_request: Option<Vec<models::CampaignCreateRequest>> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_campaign_create_request) => param_campaign_create_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter CampaignCreateRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter CampaignCreateRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_campaign_create_request = match param_campaign_create_request {
                                    Some(param_campaign_create_request) => param_campaign_create_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter CampaignCreateRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter CampaignCreateRequest")),
                                };

                                let result = api_impl.campaigns_slash_create(
                                            param_ad_account_id,
                                            param_campaign_create_request.as_ref(),
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CampaignsSlashCreateResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CAMPAIGNS_SLASH_CREATE_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CampaignsSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CAMPAIGNS_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter CampaignCreateRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter CampaignCreateRequest")),
                        }
            },

            // CampaignsSlashGet - GET /ad_accounts/{ad_account_id}/campaigns/{campaign_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_CAMPAIGN_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_CAMPAIGN_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_CAMPAIGN_ID in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_CAMPAIGN_ID.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_campaign_id = match percent_encoding::percent_decode(path_params["campaign_id"].as_bytes()).decode_utf8() {
                    Ok(param_campaign_id) => match param_campaign_id.parse::<String>() {
                        Ok(param_campaign_id) => param_campaign_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter campaign_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["campaign_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.campaigns_slash_get(
                                            param_ad_account_id,
                                            param_campaign_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CampaignsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CAMPAIGNS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CampaignsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CAMPAIGNS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // CampaignsSlashList - GET /ad_accounts/{ad_account_id}/campaigns
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_campaign_ids = query_params.iter().filter(|e| e.0 == "campaign_ids").map(|e| e.1.clone())
                    .filter_map(|param_campaign_ids| param_campaign_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_campaign_ids = if !param_campaign_ids.is_empty() {
                    Some(param_campaign_ids)
                } else {
                    None
                };
                let param_entity_statuses = query_params.iter().filter(|e| e.0 == "entity_statuses").map(|e| e.1.clone())
                    .filter_map(|param_entity_statuses| param_entity_statuses.parse().ok())
                    .collect::<Vec<_>>();
                let param_entity_statuses = if !param_entity_statuses.is_empty() {
                    Some(param_entity_statuses)
                } else {
                    None
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_order = query_params.iter().filter(|e| e.0 == "order").map(|e| e.1.clone())
                    .next();
                let param_order = match param_order {
                    Some(param_order) => {
                        let param_order =
                            <String as std::str::FromStr>::from_str
                                (&param_order);
                        match param_order {
                            Ok(param_order) => Some(param_order),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter order - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter order")),
                        }
                    },
                    None => None,
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.campaigns_slash_list(
                                            param_ad_account_id,
                                            param_campaign_ids.as_ref(),
                                            param_entity_statuses.as_ref(),
                                            param_page_size,
                                            param_order,
                                            param_bookmark,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CampaignsSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CAMPAIGNS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CampaignsSlashListResponse::InvalidAdAccountCampaignParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CAMPAIGNS_SLASH_LIST_INVALID_AD_ACCOUNT_CAMPAIGN_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CampaignsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CAMPAIGNS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // CampaignsSlashUpdate - PATCH /ad_accounts/{ad_account_id}/campaigns
            hyper::Method::PATCH if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_campaign_update_request: Option<Vec<models::CampaignUpdateRequest>> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_campaign_update_request) => param_campaign_update_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter CampaignUpdateRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter CampaignUpdateRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_campaign_update_request = match param_campaign_update_request {
                                    Some(param_campaign_update_request) => param_campaign_update_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter CampaignUpdateRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter CampaignUpdateRequest")),
                                };

                                let result = api_impl.campaigns_slash_update(
                                            param_ad_account_id,
                                            param_campaign_update_request.as_ref(),
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CampaignsSlashUpdateResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CAMPAIGNS_SLASH_UPDATE_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CampaignsSlashUpdateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CAMPAIGNS_SLASH_UPDATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter CampaignUpdateRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter CampaignUpdateRequest")),
                        }
            },

            // CatalogsProductGroupPinsSlashList - GET /catalogs/product_groups/{product_group_id}/products
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "catalogs:read".to_string(), // See all of your catalogs data
                            "pins:read".to_string(), // See your public Pins
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCTS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCTS in set but failed match against \"{}\"", path, paths::REGEX_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCTS.as_str())
                    );

                let param_product_group_id = match percent_encoding::percent_decode(path_params["product_group_id"].as_bytes()).decode_utf8() {
                    Ok(param_product_group_id) => match param_product_group_id.parse::<String>() {
                        Ok(param_product_group_id) => param_product_group_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter product_group_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["product_group_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.catalogs_product_group_pins_slash_list(
                                            param_product_group_id,
                                            param_bookmark,
                                            param_page_size,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CatalogsProductGroupPinsSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUP_PINS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupPinsSlashListResponse::InvalidParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUP_PINS_SLASH_LIST_INVALID_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupPinsSlashListResponse::UnauthorizedAccess
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUP_PINS_SLASH_LIST_UNAUTHORIZED_ACCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupPinsSlashListResponse::CatalogsProductGroupNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUP_PINS_SLASH_LIST_CATALOGS_PRODUCT_GROUP_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupPinsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUP_PINS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // CatalogsProductGroupsSlashCreate - POST /catalogs/product_groups
            hyper::Method::POST if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "catalogs:write".to_string(), // Create, update, or delete your catalogs data
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_catalogs_product_groups_create_request: Option<models::CatalogsProductGroupsCreateRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_catalogs_product_groups_create_request) => param_catalogs_product_groups_create_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter CatalogsProductGroupsCreateRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter CatalogsProductGroupsCreateRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_catalogs_product_groups_create_request = match param_catalogs_product_groups_create_request {
                                    Some(param_catalogs_product_groups_create_request) => param_catalogs_product_groups_create_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter CatalogsProductGroupsCreateRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter CatalogsProductGroupsCreateRequest")),
                                };

                                let result = api_impl.catalogs_product_groups_slash_create(
                                            param_catalogs_product_groups_create_request,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CatalogsProductGroupsSlashCreateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_CREATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashCreateResponse::InvalidBody
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_CREATE_INVALID_BODY"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashCreateResponse::UnauthorizedAccess
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_CREATE_UNAUTHORIZED_ACCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashCreateResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_CREATE_FORBIDDEN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashCreateResponse::Conflict
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_CREATE_CONFLICT"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter CatalogsProductGroupsCreateRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter CatalogsProductGroupsCreateRequest")),
                        }
            },

            // CatalogsProductGroupsSlashDelete - DELETE /catalogs/product_groups/{product_group_id}
            hyper::Method::DELETE if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "catalogs:write".to_string(), // Create, update, or delete your catalogs data
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID in set but failed match against \"{}\"", path, paths::REGEX_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID.as_str())
                    );

                let param_product_group_id = match percent_encoding::percent_decode(path_params["product_group_id"].as_bytes()).decode_utf8() {
                    Ok(param_product_group_id) => match param_product_group_id.parse::<String>() {
                        Ok(param_product_group_id) => param_product_group_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter product_group_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["product_group_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.catalogs_product_groups_slash_delete(
                                            param_product_group_id,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CatalogsProductGroupsSlashDeleteResponse::CatalogsProductGroupDeletedSuccessfully
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(204).expect("Unable to turn 204 into a StatusCode");
                                                },
                                                CatalogsProductGroupsSlashDeleteResponse::InvalidCatalogsProductGroupIdParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_DELETE_INVALID_CATALOGS_PRODUCT_GROUP_ID_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashDeleteResponse::UnauthorizedAccess
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_DELETE_UNAUTHORIZED_ACCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashDeleteResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_DELETE_FORBIDDEN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashDeleteResponse::CatalogsProductGroupNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_DELETE_CATALOGS_PRODUCT_GROUP_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashDeleteResponse::Conflict
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_DELETE_CONFLICT"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashDeleteResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_DELETE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // CatalogsProductGroupsSlashGet - GET /catalogs/product_groups/{product_group_id}
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "catalogs:read".to_string(), // See all of your catalogs data
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID in set but failed match against \"{}\"", path, paths::REGEX_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID.as_str())
                    );

                let param_product_group_id = match percent_encoding::percent_decode(path_params["product_group_id"].as_bytes()).decode_utf8() {
                    Ok(param_product_group_id) => match param_product_group_id.parse::<String>() {
                        Ok(param_product_group_id) => param_product_group_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter product_group_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["product_group_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.catalogs_product_groups_slash_get(
                                            param_product_group_id,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CatalogsProductGroupsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashGetResponse::InvalidCatalogsProductGroupIdParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_GET_INVALID_CATALOGS_PRODUCT_GROUP_ID_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashGetResponse::UnauthorizedAccess
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_GET_UNAUTHORIZED_ACCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashGetResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_GET_FORBIDDEN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashGetResponse::CatalogsProductGroupNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_GET_CATALOGS_PRODUCT_GROUP_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashGetResponse::Conflict
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_GET_CONFLICT"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // CatalogsProductGroupsSlashList - GET /catalogs/product_groups
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "catalogs:read".to_string(), // See all of your catalogs data
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_feed_id = query_params.iter().filter(|e| e.0 == "feed_id").map(|e| e.1.clone())
                    .next();
                let param_feed_id = match param_feed_id {
                    Some(param_feed_id) => {
                        let param_feed_id =
                            <String as std::str::FromStr>::from_str
                                (&param_feed_id);
                        match param_feed_id {
                            Ok(param_feed_id) => Some(param_feed_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter feed_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter feed_id")),
                        }
                    },
                    None => None,
                };
                let param_catalog_id = query_params.iter().filter(|e| e.0 == "catalog_id").map(|e| e.1.clone())
                    .next();
                let param_catalog_id = match param_catalog_id {
                    Some(param_catalog_id) => {
                        let param_catalog_id =
                            <String as std::str::FromStr>::from_str
                                (&param_catalog_id);
                        match param_catalog_id {
                            Ok(param_catalog_id) => Some(param_catalog_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter catalog_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter catalog_id")),
                        }
                    },
                    None => None,
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.catalogs_product_groups_slash_list(
                                            param_feed_id,
                                            param_catalog_id,
                                            param_bookmark,
                                            param_page_size,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CatalogsProductGroupsSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashListResponse::InvalidFeedParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_LIST_INVALID_FEED_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashListResponse::UnauthorizedAccess
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_LIST_UNAUTHORIZED_ACCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashListResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_LIST_FORBIDDEN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashListResponse::DataFeedNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_LIST_DATA_FEED_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashListResponse::Conflict
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_LIST_CONFLICT"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // CatalogsProductGroupsSlashProductCountsGet - GET /catalogs/product_groups/{product_group_id}/product_counts
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCT_COUNTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "catalogs:read".to_string(), // See all of your catalogs data
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCT_COUNTS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCT_COUNTS in set but failed match against \"{}\"", path, paths::REGEX_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCT_COUNTS.as_str())
                    );

                let param_product_group_id = match percent_encoding::percent_decode(path_params["product_group_id"].as_bytes()).decode_utf8() {
                    Ok(param_product_group_id) => match param_product_group_id.parse::<String>() {
                        Ok(param_product_group_id) => param_product_group_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter product_group_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["product_group_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.catalogs_product_groups_slash_product_counts_get(
                                            param_product_group_id,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CatalogsProductGroupsSlashProductCountsGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_PRODUCT_COUNTS_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashProductCountsGetResponse::ProductGroupNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_PRODUCT_COUNTS_GET_PRODUCT_GROUP_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashProductCountsGetResponse::Can
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_PRODUCT_COUNTS_GET_CAN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashProductCountsGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_PRODUCT_COUNTS_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // CatalogsProductGroupsSlashUpdate - PATCH /catalogs/product_groups/{product_group_id}
            hyper::Method::PATCH if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "catalogs:write".to_string(), // Create, update, or delete your catalogs data
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID in set but failed match against \"{}\"", path, paths::REGEX_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID.as_str())
                    );

                let param_product_group_id = match percent_encoding::percent_decode(path_params["product_group_id"].as_bytes()).decode_utf8() {
                    Ok(param_product_group_id) => match param_product_group_id.parse::<String>() {
                        Ok(param_product_group_id) => param_product_group_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter product_group_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["product_group_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_catalogs_product_groups_update_request: Option<models::CatalogsProductGroupsUpdateRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_catalogs_product_groups_update_request) => param_catalogs_product_groups_update_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter CatalogsProductGroupsUpdateRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter CatalogsProductGroupsUpdateRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_catalogs_product_groups_update_request = match param_catalogs_product_groups_update_request {
                                    Some(param_catalogs_product_groups_update_request) => param_catalogs_product_groups_update_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter CatalogsProductGroupsUpdateRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter CatalogsProductGroupsUpdateRequest")),
                                };

                                let result = api_impl.catalogs_product_groups_slash_update(
                                            param_product_group_id,
                                            param_catalogs_product_groups_update_request,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CatalogsProductGroupsSlashUpdateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_UPDATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashUpdateResponse::InvalidParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_UPDATE_INVALID_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashUpdateResponse::UnauthorizedAccess
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_UPDATE_UNAUTHORIZED_ACCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashUpdateResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_UPDATE_FORBIDDEN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashUpdateResponse::CatalogsProductGroupNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_UPDATE_CATALOGS_PRODUCT_GROUP_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashUpdateResponse::Conflict
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_UPDATE_CONFLICT"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsProductGroupsSlashUpdateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_PRODUCT_GROUPS_SLASH_UPDATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter CatalogsProductGroupsUpdateRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter CatalogsProductGroupsUpdateRequest")),
                        }
            },

            // CatalogsSlashList - GET /catalogs
            hyper::Method::GET if path.matched(paths::ID_CATALOGS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "catalogs:read".to_string(), // See all of your catalogs data
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.catalogs_slash_list(
                                            param_bookmark,
                                            param_page_size,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CatalogsSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsSlashListResponse::InvalidParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_SLASH_LIST_INVALID_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsSlashListResponse::UnauthorizedAccess
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_SLASH_LIST_UNAUTHORIZED_ACCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CatalogsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CATALOGS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // FeedProcessingResultsSlashList - GET /catalogs/feeds/{feed_id}/processing_results
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_FEEDS_FEED_ID_PROCESSING_RESULTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "catalogs:read".to_string(), // See all of your catalogs data
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CATALOGS_FEEDS_FEED_ID_PROCESSING_RESULTS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CATALOGS_FEEDS_FEED_ID_PROCESSING_RESULTS in set but failed match against \"{}\"", path, paths::REGEX_CATALOGS_FEEDS_FEED_ID_PROCESSING_RESULTS.as_str())
                    );

                let param_feed_id = match percent_encoding::percent_decode(path_params["feed_id"].as_bytes()).decode_utf8() {
                    Ok(param_feed_id) => match param_feed_id.parse::<String>() {
                        Ok(param_feed_id) => param_feed_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter feed_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["feed_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.feed_processing_results_slash_list(
                                            param_feed_id,
                                            param_bookmark,
                                            param_page_size,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                FeedProcessingResultsSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEED_PROCESSING_RESULTS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedProcessingResultsSlashListResponse::InvalidParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEED_PROCESSING_RESULTS_SLASH_LIST_INVALID_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedProcessingResultsSlashListResponse::UnauthorizedAccess
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEED_PROCESSING_RESULTS_SLASH_LIST_UNAUTHORIZED_ACCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedProcessingResultsSlashListResponse::FeedNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEED_PROCESSING_RESULTS_SLASH_LIST_FEED_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedProcessingResultsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEED_PROCESSING_RESULTS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // FeedsSlashCreate - POST /catalogs/feeds
            hyper::Method::POST if path.matched(paths::ID_CATALOGS_FEEDS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "catalogs:read".to_string(), // See all of your catalogs data
                            "catalogs:write".to_string(), // Create, update, or delete your catalogs data
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_feeds_create_request: Option<models::FeedsCreateRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_feeds_create_request) => param_feeds_create_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter FeedsCreateRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter FeedsCreateRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_feeds_create_request = match param_feeds_create_request {
                                    Some(param_feeds_create_request) => param_feeds_create_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter FeedsCreateRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter FeedsCreateRequest")),
                                };

                                let result = api_impl.feeds_slash_create(
                                            param_feeds_create_request,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                FeedsSlashCreateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_CREATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashCreateResponse::InvalidFeedParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_CREATE_INVALID_FEED_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashCreateResponse::UnauthorizedAccess
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_CREATE_UNAUTHORIZED_ACCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashCreateResponse::BusinessAccountRequired
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_CREATE_BUSINESS_ACCOUNT_REQUIRED"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashCreateResponse::UserWebsiteRequired
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_CREATE_USER_WEBSITE_REQUIRED"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashCreateResponse::UniqueFeedNameIsRequired
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(422).expect("Unable to turn 422 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_CREATE_UNIQUE_FEED_NAME_IS_REQUIRED"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashCreateResponse::NotImplemented
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(501).expect("Unable to turn 501 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_CREATE_NOT_IMPLEMENTED"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter FeedsCreateRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter FeedsCreateRequest")),
                        }
            },

            // FeedsSlashDelete - DELETE /catalogs/feeds/{feed_id}
            hyper::Method::DELETE if path.matched(paths::ID_CATALOGS_FEEDS_FEED_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "catalogs:read".to_string(), // See all of your catalogs data
                            "catalogs:write".to_string(), // Create, update, or delete your catalogs data
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CATALOGS_FEEDS_FEED_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CATALOGS_FEEDS_FEED_ID in set but failed match against \"{}\"", path, paths::REGEX_CATALOGS_FEEDS_FEED_ID.as_str())
                    );

                let param_feed_id = match percent_encoding::percent_decode(path_params["feed_id"].as_bytes()).decode_utf8() {
                    Ok(param_feed_id) => match param_feed_id.parse::<String>() {
                        Ok(param_feed_id) => param_feed_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter feed_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["feed_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.feeds_slash_delete(
                                            param_feed_id,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                FeedsSlashDeleteResponse::FeedDeletedSuccessfully
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(204).expect("Unable to turn 204 into a StatusCode");
                                                },
                                                FeedsSlashDeleteResponse::InvalidFeedParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_DELETE_INVALID_FEED_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashDeleteResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_DELETE_FORBIDDEN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashDeleteResponse::DataFeedNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_DELETE_DATA_FEED_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashDeleteResponse::Conflict
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_DELETE_CONFLICT"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashDeleteResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_DELETE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // FeedsSlashGet - GET /catalogs/feeds/{feed_id}
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_FEEDS_FEED_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "catalogs:read".to_string(), // See all of your catalogs data
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CATALOGS_FEEDS_FEED_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CATALOGS_FEEDS_FEED_ID in set but failed match against \"{}\"", path, paths::REGEX_CATALOGS_FEEDS_FEED_ID.as_str())
                    );

                let param_feed_id = match percent_encoding::percent_decode(path_params["feed_id"].as_bytes()).decode_utf8() {
                    Ok(param_feed_id) => match param_feed_id.parse::<String>() {
                        Ok(param_feed_id) => param_feed_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter feed_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["feed_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.feeds_slash_get(
                                            param_feed_id,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                FeedsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashGetResponse::InvalidFeedParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_GET_INVALID_FEED_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashGetResponse::UnauthorizedAccess
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_GET_UNAUTHORIZED_ACCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashGetResponse::DataFeedNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_GET_DATA_FEED_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // FeedsSlashList - GET /catalogs/feeds
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_FEEDS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "catalogs:read".to_string(), // See all of your catalogs data
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_catalog_id = query_params.iter().filter(|e| e.0 == "catalog_id").map(|e| e.1.clone())
                    .next();
                let param_catalog_id = match param_catalog_id {
                    Some(param_catalog_id) => {
                        let param_catalog_id =
                            <String as std::str::FromStr>::from_str
                                (&param_catalog_id);
                        match param_catalog_id {
                            Ok(param_catalog_id) => Some(param_catalog_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter catalog_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter catalog_id")),
                        }
                    },
                    None => None,
                };
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.feeds_slash_list(
                                            param_bookmark,
                                            param_page_size,
                                            param_catalog_id,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                FeedsSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashListResponse::InvalidParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_LIST_INVALID_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashListResponse::UnauthorizedAccess
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_LIST_UNAUTHORIZED_ACCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // FeedsSlashUpdate - PATCH /catalogs/feeds/{feed_id}
            hyper::Method::PATCH if path.matched(paths::ID_CATALOGS_FEEDS_FEED_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "catalogs:read".to_string(), // See all of your catalogs data
                            "catalogs:write".to_string(), // Create, update, or delete your catalogs data
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CATALOGS_FEEDS_FEED_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CATALOGS_FEEDS_FEED_ID in set but failed match against \"{}\"", path, paths::REGEX_CATALOGS_FEEDS_FEED_ID.as_str())
                    );

                let param_feed_id = match percent_encoding::percent_decode(path_params["feed_id"].as_bytes()).decode_utf8() {
                    Ok(param_feed_id) => match param_feed_id.parse::<String>() {
                        Ok(param_feed_id) => param_feed_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter feed_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["feed_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_feeds_update_request: Option<models::FeedsUpdateRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_feeds_update_request) => param_feeds_update_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter FeedsUpdateRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter FeedsUpdateRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_feeds_update_request = match param_feeds_update_request {
                                    Some(param_feeds_update_request) => param_feeds_update_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter FeedsUpdateRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter FeedsUpdateRequest")),
                                };

                                let result = api_impl.feeds_slash_update(
                                            param_feed_id,
                                            param_feeds_update_request,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                FeedsSlashUpdateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_UPDATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashUpdateResponse::InvalidFeedParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_UPDATE_INVALID_FEED_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashUpdateResponse::Forbidden
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_UPDATE_FORBIDDEN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashUpdateResponse::DataFeedNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_UPDATE_DATA_FEED_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FeedsSlashUpdateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FEEDS_SLASH_UPDATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter FeedsUpdateRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter FeedsUpdateRequest")),
                        }
            },

            // ItemsBatchSlashGet - GET /catalogs/items/batch/{batch_id}
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_ITEMS_BATCH_BATCH_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "catalogs:read".to_string(), // See all of your catalogs data
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CATALOGS_ITEMS_BATCH_BATCH_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CATALOGS_ITEMS_BATCH_BATCH_ID in set but failed match against \"{}\"", path, paths::REGEX_CATALOGS_ITEMS_BATCH_BATCH_ID.as_str())
                    );

                let param_batch_id = match percent_encoding::percent_decode(path_params["batch_id"].as_bytes()).decode_utf8() {
                    Ok(param_batch_id) => match param_batch_id.parse::<String>() {
                        Ok(param_batch_id) => param_batch_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter batch_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["batch_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.items_batch_slash_get(
                                            param_batch_id,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                ItemsBatchSlashGetResponse::ResponseContainingTheRequestedCatalogsItemsBatch
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_BATCH_SLASH_GET_RESPONSE_CONTAINING_THE_REQUESTED_CATALOGS_ITEMS_BATCH"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ItemsBatchSlashGetResponse::NotAuthenticatedToAccessCatalogsItemsBatch
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_BATCH_SLASH_GET_NOT_AUTHENTICATED_TO_ACCESS_CATALOGS_ITEMS_BATCH"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ItemsBatchSlashGetResponse::NotAuthorizedToAccessCatalogsItemsBatch
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_BATCH_SLASH_GET_NOT_AUTHORIZED_TO_ACCESS_CATALOGS_ITEMS_BATCH"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ItemsBatchSlashGetResponse::CatalogsItemsBatchNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_BATCH_SLASH_GET_CATALOGS_ITEMS_BATCH_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ItemsBatchSlashGetResponse::MethodNotAllowed
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(405).expect("Unable to turn 405 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_BATCH_SLASH_GET_METHOD_NOT_ALLOWED"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ItemsBatchSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_BATCH_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // ItemsBatchSlashPost - POST /catalogs/items/batch
            hyper::Method::POST if path.matched(paths::ID_CATALOGS_ITEMS_BATCH) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "catalogs:read".to_string(), // See all of your catalogs data
                            "catalogs:write".to_string(), // Create, update, or delete your catalogs data
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_items_batch_post_request: Option<models::ItemsBatchPostRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_items_batch_post_request) => param_items_batch_post_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter ItemsBatchPostRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter ItemsBatchPostRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_items_batch_post_request = match param_items_batch_post_request {
                                    Some(param_items_batch_post_request) => param_items_batch_post_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter ItemsBatchPostRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter ItemsBatchPostRequest")),
                                };

                                let result = api_impl.items_batch_slash_post(
                                            param_items_batch_post_request,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                ItemsBatchSlashPostResponse::ResponseContainingTheRequestedCatalogsItemsBatch
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_BATCH_SLASH_POST_RESPONSE_CONTAINING_THE_REQUESTED_CATALOGS_ITEMS_BATCH"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ItemsBatchSlashPostResponse::InvalidRequestParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_BATCH_SLASH_POST_INVALID_REQUEST_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ItemsBatchSlashPostResponse::NotAuthenticatedToPostCatalogsItems
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_BATCH_SLASH_POST_NOT_AUTHENTICATED_TO_POST_CATALOGS_ITEMS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ItemsBatchSlashPostResponse::NotAuthorizedToPostCatalogsItems
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_BATCH_SLASH_POST_NOT_AUTHORIZED_TO_POST_CATALOGS_ITEMS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ItemsBatchSlashPostResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_BATCH_SLASH_POST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter ItemsBatchPostRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter ItemsBatchPostRequest")),
                        }
            },

            // ItemsIssuesSlashList - GET /catalogs/processing_results/{processing_result_id}/item_issues
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_PROCESSING_RESULTS_PROCESSING_RESULT_ID_ITEM_ISSUES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "catalogs:read".to_string(), // See all of your catalogs data
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_CATALOGS_PROCESSING_RESULTS_PROCESSING_RESULT_ID_ITEM_ISSUES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE CATALOGS_PROCESSING_RESULTS_PROCESSING_RESULT_ID_ITEM_ISSUES in set but failed match against \"{}\"", path, paths::REGEX_CATALOGS_PROCESSING_RESULTS_PROCESSING_RESULT_ID_ITEM_ISSUES.as_str())
                    );

                let param_processing_result_id = match percent_encoding::percent_decode(path_params["processing_result_id"].as_bytes()).decode_utf8() {
                    Ok(param_processing_result_id) => match param_processing_result_id.parse::<String>() {
                        Ok(param_processing_result_id) => param_processing_result_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter processing_result_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["processing_result_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_item_numbers = query_params.iter().filter(|e| e.0 == "item_numbers").map(|e| e.1.clone())
                    .filter_map(|param_item_numbers| param_item_numbers.parse().ok())
                    .collect::<Vec<_>>();
                let param_item_numbers = if !param_item_numbers.is_empty() {
                    Some(param_item_numbers)
                } else {
                    None
                };
                let param_item_validation_issue = query_params.iter().filter(|e| e.0 == "item_validation_issue").map(|e| e.1.clone())
                    .next();
                let param_item_validation_issue = match param_item_validation_issue {
                    Some(param_item_validation_issue) => {
                        let param_item_validation_issue =
                            <models::CatalogsItemValidationIssue as std::str::FromStr>::from_str
                                (&param_item_validation_issue);
                        match param_item_validation_issue {
                            Ok(param_item_validation_issue) => Some(param_item_validation_issue),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter item_validation_issue - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter item_validation_issue")),
                        }
                    },
                    None => None,
                };
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.items_issues_slash_list(
                                            param_processing_result_id,
                                            param_bookmark,
                                            param_page_size,
                                            param_item_numbers.as_ref(),
                                            param_item_validation_issue,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                ItemsIssuesSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_ISSUES_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ItemsIssuesSlashListResponse::UnauthorizedAccess
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_ISSUES_SLASH_LIST_UNAUTHORIZED_ACCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ItemsIssuesSlashListResponse::ProcessingResultNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_ISSUES_SLASH_LIST_PROCESSING_RESULT_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ItemsIssuesSlashListResponse::NotImplemented
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(501).expect("Unable to turn 501 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_ISSUES_SLASH_LIST_NOT_IMPLEMENTED"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ItemsIssuesSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_ISSUES_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // ItemsSlashGet - GET /catalogs/items
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_ITEMS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "catalogs:read".to_string(), // See all of your catalogs data
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };
                let param_country = query_params.iter().filter(|e| e.0 == "country").map(|e| e.1.clone())
                    .next();
                let param_country = match param_country {
                    Some(param_country) => {
                        let param_country =
                            <String as std::str::FromStr>::from_str
                                (&param_country);
                        match param_country {
                            Ok(param_country) => Some(param_country),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter country - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter country")),
                        }
                    },
                    None => None,
                };
                let param_country = match param_country {
                    Some(param_country) => param_country,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter country"))
                        .expect("Unable to create Bad Request response for missing query parameter country")),
                };
                let param_language = query_params.iter().filter(|e| e.0 == "language").map(|e| e.1.clone())
                    .next();
                let param_language = match param_language {
                    Some(param_language) => {
                        let param_language =
                            <String as std::str::FromStr>::from_str
                                (&param_language);
                        match param_language {
                            Ok(param_language) => Some(param_language),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter language - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter language")),
                        }
                    },
                    None => None,
                };
                let param_language = match param_language {
                    Some(param_language) => param_language,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter language"))
                        .expect("Unable to create Bad Request response for missing query parameter language")),
                };
                let param_item_ids = query_params.iter().filter(|e| e.0 == "item_ids").map(|e| e.1.clone())
                    .filter_map(|param_item_ids| param_item_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_item_ids = if !param_item_ids.is_empty() {
                    Some(param_item_ids)
                } else {
                    None
                };
                let param_filters = query_params.iter().filter(|e| e.0 == "filters").map(|e| e.1.clone())
                    .next();
                let param_filters = match param_filters {
                    Some(param_filters) => {
                        let param_filters =
                            <models::CatalogsItemsFilters as std::str::FromStr>::from_str
                                (&param_filters);
                        match param_filters {
                            Ok(param_filters) => Some(param_filters),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter filters - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter filters")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.items_slash_get(
                                            param_country,
                                            param_language,
                                            param_ad_account_id,
                                            param_item_ids.as_ref(),
                                            param_filters,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                ItemsSlashGetResponse::ResponseContainingTheRequestedCatalogsItems
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_SLASH_GET_RESPONSE_CONTAINING_THE_REQUESTED_CATALOGS_ITEMS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ItemsSlashGetResponse::InvalidRequestParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_SLASH_GET_INVALID_REQUEST_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ItemsSlashGetResponse::NotAuthorizedToAccessCatalogsItems
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_SLASH_GET_NOT_AUTHORIZED_TO_ACCESS_CATALOGS_ITEMS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ItemsSlashGetResponse::NotAuthorizedToAccessCatalogsItems_2
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_SLASH_GET_NOT_AUTHORIZED_TO_ACCESS_CATALOGS_ITEMS_2"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ItemsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ITEMS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // ProductsByProductGroupFilterSlashList - POST /catalogs/products/get_by_product_group_filters
            hyper::Method::POST if path.matched(paths::ID_CATALOGS_PRODUCTS_GET_BY_PRODUCT_GROUP_FILTERS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "catalogs:read".to_string(), // See all of your catalogs data
                            "pins:read".to_string(), // See your public Pins
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_catalogs_list_products_by_filter_request: Option<models::CatalogsListProductsByFilterRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_catalogs_list_products_by_filter_request) => param_catalogs_list_products_by_filter_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter CatalogsListProductsByFilterRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter CatalogsListProductsByFilterRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_catalogs_list_products_by_filter_request = match param_catalogs_list_products_by_filter_request {
                                    Some(param_catalogs_list_products_by_filter_request) => param_catalogs_list_products_by_filter_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter CatalogsListProductsByFilterRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter CatalogsListProductsByFilterRequest")),
                                };

                                let result = api_impl.products_by_product_group_filter_slash_list(
                                            param_catalogs_list_products_by_filter_request,
                                            param_bookmark,
                                            param_page_size,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                ProductsByProductGroupFilterSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PRODUCTS_BY_PRODUCT_GROUP_FILTER_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ProductsByProductGroupFilterSlashListResponse::UnauthorizedAccess
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PRODUCTS_BY_PRODUCT_GROUP_FILTER_SLASH_LIST_UNAUTHORIZED_ACCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ProductsByProductGroupFilterSlashListResponse::Conflict
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PRODUCTS_BY_PRODUCT_GROUP_FILTER_SLASH_LIST_CONFLICT"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ProductsByProductGroupFilterSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PRODUCTS_BY_PRODUCT_GROUP_FILTER_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter CatalogsListProductsByFilterRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter CatalogsListProductsByFilterRequest")),
                        }
            },

            // EventsSlashCreate - POST /ad_accounts/{ad_account_id}/events
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_EVENTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_EVENTS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_EVENTS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_EVENTS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_test = query_params.iter().filter(|e| e.0 == "test").map(|e| e.1.clone())
                    .next();
                let param_test = match param_test {
                    Some(param_test) => {
                        let param_test =
                            <bool as std::str::FromStr>::from_str
                                (&param_test);
                        match param_test {
                            Ok(param_test) => Some(param_test),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter test - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter test")),
                        }
                    },
                    None => None,
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_conversion_events: Option<models::ConversionEvents> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_conversion_events) => param_conversion_events,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter ConversionEvents - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter ConversionEvents due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_conversion_events = match param_conversion_events {
                                    Some(param_conversion_events) => param_conversion_events,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter ConversionEvents"))
                                                        .expect("Unable to create Bad Request response for missing body parameter ConversionEvents")),
                                };

                                let result = api_impl.events_slash_create(
                                            param_ad_account_id,
                                            param_conversion_events,
                                            param_test,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                EventsSlashCreateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for EVENTS_SLASH_CREATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                EventsSlashCreateResponse::TheRequestWasInvalid
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for EVENTS_SLASH_CREATE_THE_REQUEST_WAS_INVALID"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                EventsSlashCreateResponse::NotAuthorizedToSendConversionEvents
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for EVENTS_SLASH_CREATE_NOT_AUTHORIZED_TO_SEND_CONVERSION_EVENTS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                EventsSlashCreateResponse::UnauthorizedAccess
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for EVENTS_SLASH_CREATE_UNAUTHORIZED_ACCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                EventsSlashCreateResponse::NotAllEventsWereSuccessfullyProcessed
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(422).expect("Unable to turn 422 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for EVENTS_SLASH_CREATE_NOT_ALL_EVENTS_WERE_SUCCESSFULLY_PROCESSED"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                EventsSlashCreateResponse::ThisRequestExceededARateLimit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(429).expect("Unable to turn 429 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for EVENTS_SLASH_CREATE_THIS_REQUEST_EXCEEDED_A_RATE_LIMIT"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                EventsSlashCreateResponse::TheEndpointHasBeenRampedDownAndIsCurrentlyNotAcceptingAnyTraffic
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(503).expect("Unable to turn 503 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for EVENTS_SLASH_CREATE_THE_ENDPOINT_HAS_BEEN_RAMPED_DOWN_AND_IS_CURRENTLY_NOT_ACCEPTING_ANY_TRAFFIC"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                EventsSlashCreateResponse::UnexpectedErrors
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for EVENTS_SLASH_CREATE_UNEXPECTED_ERRORS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter ConversionEvents: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter ConversionEvents")),
                        }
            },

            // ConversionTagsSlashCreate - POST /ad_accounts/{ad_account_id}/conversion_tags
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_conversion_tag_create: Option<models::ConversionTagCreate> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_conversion_tag_create) => param_conversion_tag_create,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter ConversionTagCreate - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter ConversionTagCreate due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_conversion_tag_create = match param_conversion_tag_create {
                                    Some(param_conversion_tag_create) => param_conversion_tag_create,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter ConversionTagCreate"))
                                                        .expect("Unable to create Bad Request response for missing body parameter ConversionTagCreate")),
                                };

                                let result = api_impl.conversion_tags_slash_create(
                                            param_ad_account_id,
                                            param_conversion_tag_create,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                ConversionTagsSlashCreateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CONVERSION_TAGS_SLASH_CREATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ConversionTagsSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CONVERSION_TAGS_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter ConversionTagCreate: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter ConversionTagCreate")),
                        }
            },

            // ConversionTagsSlashGet - GET /ad_accounts/{ad_account_id}/conversion_tags/{conversion_tag_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_CONVERSION_TAG_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_CONVERSION_TAG_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_CONVERSION_TAG_ID in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_CONVERSION_TAG_ID.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_conversion_tag_id = match percent_encoding::percent_decode(path_params["conversion_tag_id"].as_bytes()).decode_utf8() {
                    Ok(param_conversion_tag_id) => match param_conversion_tag_id.parse::<String>() {
                        Ok(param_conversion_tag_id) => param_conversion_tag_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter conversion_tag_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["conversion_tag_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.conversion_tags_slash_get(
                                            param_ad_account_id,
                                            param_conversion_tag_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                ConversionTagsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CONVERSION_TAGS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ConversionTagsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CONVERSION_TAGS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // ConversionTagsSlashList - GET /ad_accounts/{ad_account_id}/conversion_tags
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_filter_deleted = query_params.iter().filter(|e| e.0 == "filter_deleted").map(|e| e.1.clone())
                    .next();
                let param_filter_deleted = match param_filter_deleted {
                    Some(param_filter_deleted) => {
                        let param_filter_deleted =
                            <bool as std::str::FromStr>::from_str
                                (&param_filter_deleted);
                        match param_filter_deleted {
                            Ok(param_filter_deleted) => Some(param_filter_deleted),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter filter_deleted - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter filter_deleted")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.conversion_tags_slash_list(
                                            param_ad_account_id,
                                            param_filter_deleted,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                ConversionTagsSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CONVERSION_TAGS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ConversionTagsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CONVERSION_TAGS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // OcpmEligibleConversionTagsSlashGet - GET /ad_accounts/{ad_account_id}/conversion_tags/ocpm_eligible
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_OCPM_ELIGIBLE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_OCPM_ELIGIBLE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_OCPM_ELIGIBLE in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_OCPM_ELIGIBLE.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.ocpm_eligible_conversion_tags_slash_get(
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                OcpmEligibleConversionTagsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for OCPM_ELIGIBLE_CONVERSION_TAGS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                OcpmEligibleConversionTagsSlashGetResponse::UnexpectedErrors
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for OCPM_ELIGIBLE_CONVERSION_TAGS_SLASH_GET_UNEXPECTED_ERRORS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // PageVisitConversionTagsSlashGet - GET /ad_accounts/{ad_account_id}/conversion_tags/page_visit
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_PAGE_VISIT) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_PAGE_VISIT
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_PAGE_VISIT in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_PAGE_VISIT.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_order = query_params.iter().filter(|e| e.0 == "order").map(|e| e.1.clone())
                    .next();
                let param_order = match param_order {
                    Some(param_order) => {
                        let param_order =
                            <String as std::str::FromStr>::from_str
                                (&param_order);
                        match param_order {
                            Ok(param_order) => Some(param_order),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter order - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter order")),
                        }
                    },
                    None => None,
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.page_visit_conversion_tags_slash_get(
                                            param_ad_account_id,
                                            param_page_size,
                                            param_order,
                                            param_bookmark,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                PageVisitConversionTagsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PAGE_VISIT_CONVERSION_TAGS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PageVisitConversionTagsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PAGE_VISIT_CONVERSION_TAGS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // CustomerListsSlashCreate - POST /ad_accounts/{ad_account_id}/customer_lists
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_customer_list_request: Option<models::CustomerListRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_customer_list_request) => param_customer_list_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter CustomerListRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter CustomerListRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_customer_list_request = match param_customer_list_request {
                                    Some(param_customer_list_request) => param_customer_list_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter CustomerListRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter CustomerListRequest")),
                                };

                                let result = api_impl.customer_lists_slash_create(
                                            param_ad_account_id,
                                            param_customer_list_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CustomerListsSlashCreateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CUSTOMER_LISTS_SLASH_CREATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CustomerListsSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CUSTOMER_LISTS_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter CustomerListRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter CustomerListRequest")),
                        }
            },

            // CustomerListsSlashGet - GET /ad_accounts/{ad_account_id}/customer_lists/{customer_list_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS_CUSTOMER_LIST_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS_CUSTOMER_LIST_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS_CUSTOMER_LIST_ID in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS_CUSTOMER_LIST_ID.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_customer_list_id = match percent_encoding::percent_decode(path_params["customer_list_id"].as_bytes()).decode_utf8() {
                    Ok(param_customer_list_id) => match param_customer_list_id.parse::<String>() {
                        Ok(param_customer_list_id) => param_customer_list_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter customer_list_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["customer_list_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.customer_lists_slash_get(
                                            param_ad_account_id,
                                            param_customer_list_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CustomerListsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CUSTOMER_LISTS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CustomerListsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CUSTOMER_LISTS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // CustomerListsSlashList - GET /ad_accounts/{ad_account_id}/customer_lists
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_order = query_params.iter().filter(|e| e.0 == "order").map(|e| e.1.clone())
                    .next();
                let param_order = match param_order {
                    Some(param_order) => {
                        let param_order =
                            <String as std::str::FromStr>::from_str
                                (&param_order);
                        match param_order {
                            Ok(param_order) => Some(param_order),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter order - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter order")),
                        }
                    },
                    None => None,
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.customer_lists_slash_list(
                                            param_ad_account_id,
                                            param_page_size,
                                            param_order,
                                            param_bookmark,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CustomerListsSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CUSTOMER_LISTS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CustomerListsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CUSTOMER_LISTS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // CustomerListsSlashUpdate - PATCH /ad_accounts/{ad_account_id}/customer_lists/{customer_list_id}
            hyper::Method::PATCH if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS_CUSTOMER_LIST_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS_CUSTOMER_LIST_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS_CUSTOMER_LIST_ID in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS_CUSTOMER_LIST_ID.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_customer_list_id = match percent_encoding::percent_decode(path_params["customer_list_id"].as_bytes()).decode_utf8() {
                    Ok(param_customer_list_id) => match param_customer_list_id.parse::<String>() {
                        Ok(param_customer_list_id) => param_customer_list_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter customer_list_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["customer_list_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_customer_list_update_request: Option<models::CustomerListUpdateRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_customer_list_update_request) => param_customer_list_update_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter CustomerListUpdateRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter CustomerListUpdateRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_customer_list_update_request = match param_customer_list_update_request {
                                    Some(param_customer_list_update_request) => param_customer_list_update_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter CustomerListUpdateRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter CustomerListUpdateRequest")),
                                };

                                let result = api_impl.customer_lists_slash_update(
                                            param_ad_account_id,
                                            param_customer_list_id,
                                            param_customer_list_update_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CustomerListsSlashUpdateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CUSTOMER_LISTS_SLASH_UPDATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CustomerListsSlashUpdateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for CUSTOMER_LISTS_SLASH_UPDATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter CustomerListUpdateRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter CustomerListUpdateRequest")),
                        }
            },

            // IntegrationsCommerceSlashDel - DELETE /integrations/commerce/{external_business_id}
            hyper::Method::DELETE if path.matched(paths::ID_INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID in set but failed match against \"{}\"", path, paths::REGEX_INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID.as_str())
                    );

                let param_external_business_id = match percent_encoding::percent_decode(path_params["external_business_id"].as_bytes()).decode_utf8() {
                    Ok(param_external_business_id) => match param_external_business_id.parse::<String>() {
                        Ok(param_external_business_id) => param_external_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter external_business_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["external_business_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.integrations_commerce_slash_del(
                                            param_external_business_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                IntegrationsCommerceSlashDelResponse::CommerceIntegrationDeletedSuccessfully
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(204).expect("Unable to turn 204 into a StatusCode");
                                                },
                                                IntegrationsCommerceSlashDelResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_COMMERCE_SLASH_DEL_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // IntegrationsCommerceSlashGet - GET /integrations/commerce/{external_business_id}
            hyper::Method::GET if path.matched(paths::ID_INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID in set but failed match against \"{}\"", path, paths::REGEX_INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID.as_str())
                    );

                let param_external_business_id = match percent_encoding::percent_decode(path_params["external_business_id"].as_bytes()).decode_utf8() {
                    Ok(param_external_business_id) => match param_external_business_id.parse::<String>() {
                        Ok(param_external_business_id) => param_external_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter external_business_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["external_business_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.integrations_commerce_slash_get(
                                            param_external_business_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                IntegrationsCommerceSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_COMMERCE_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                IntegrationsCommerceSlashGetResponse::IntegrationNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_COMMERCE_SLASH_GET_INTEGRATION_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                IntegrationsCommerceSlashGetResponse::Can
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_COMMERCE_SLASH_GET_CAN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                IntegrationsCommerceSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_COMMERCE_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // IntegrationsCommerceSlashPatch - PATCH /integrations/commerce/{external_business_id}
            hyper::Method::PATCH if path.matched(paths::ID_INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID in set but failed match against \"{}\"", path, paths::REGEX_INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID.as_str())
                    );

                let param_external_business_id = match percent_encoding::percent_decode(path_params["external_business_id"].as_bytes()).decode_utf8() {
                    Ok(param_external_business_id) => match param_external_business_id.parse::<String>() {
                        Ok(param_external_business_id) => param_external_business_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter external_business_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["external_business_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_integration_request_patch: Option<models::IntegrationRequestPatch> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_integration_request_patch) => param_integration_request_patch,
                                        Err(_) => None,
                                    }
                                } else {
                                    None
                                };

                                let result = api_impl.integrations_commerce_slash_patch(
                                            param_external_business_id,
                                            param_integration_request_patch,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                IntegrationsCommerceSlashPatchResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_COMMERCE_SLASH_PATCH_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                IntegrationsCommerceSlashPatchResponse::IntegrationNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_COMMERCE_SLASH_PATCH_INTEGRATION_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                IntegrationsCommerceSlashPatchResponse::Can
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_COMMERCE_SLASH_PATCH_CAN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                IntegrationsCommerceSlashPatchResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_COMMERCE_SLASH_PATCH_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter IntegrationRequestPatch: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter IntegrationRequestPatch")),
                        }
            },

            // IntegrationsCommerceSlashPost - POST /integrations/commerce
            hyper::Method::POST if path.matched(paths::ID_INTEGRATIONS_COMMERCE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_integration_request: Option<models::IntegrationRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_integration_request) => param_integration_request,
                                        Err(_) => None,
                                    }
                                } else {
                                    None
                                };

                                let result = api_impl.integrations_commerce_slash_post(
                                            param_integration_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                IntegrationsCommerceSlashPostResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_COMMERCE_SLASH_POST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                IntegrationsCommerceSlashPostResponse::IntegrationNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_COMMERCE_SLASH_POST_INTEGRATION_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                IntegrationsCommerceSlashPostResponse::Can
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(409).expect("Unable to turn 409 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_COMMERCE_SLASH_POST_CAN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                IntegrationsCommerceSlashPostResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_COMMERCE_SLASH_POST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter IntegrationRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter IntegrationRequest")),
                        }
            },

            // IntegrationsLogsSlashPost - POST /integrations/logs
            hyper::Method::POST if path.matched(paths::ID_INTEGRATIONS_LOGS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_integration_logs_request: Option<models::IntegrationLogsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_integration_logs_request) => param_integration_logs_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter IntegrationLogsRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter IntegrationLogsRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_integration_logs_request = match param_integration_logs_request {
                                    Some(param_integration_logs_request) => param_integration_logs_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter IntegrationLogsRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter IntegrationLogsRequest")),
                                };

                                let result = api_impl.integrations_logs_slash_post(
                                            param_integration_logs_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                IntegrationsLogsSlashPostResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_LOGS_SLASH_POST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                IntegrationsLogsSlashPostResponse::BadRequest
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_LOGS_SLASH_POST_BAD_REQUEST"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                IntegrationsLogsSlashPostResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_LOGS_SLASH_POST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter IntegrationLogsRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter IntegrationLogsRequest")),
                        }
            },

            // IntegrationsSlashGetById - GET /integrations/{id}
            hyper::Method::GET if path.matched(paths::ID_INTEGRATIONS_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_INTEGRATIONS_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE INTEGRATIONS_ID in set but failed match against \"{}\"", path, paths::REGEX_INTEGRATIONS_ID.as_str())
                    );

                let param_id = match percent_encoding::percent_decode(path_params["id"].as_bytes()).decode_utf8() {
                    Ok(param_id) => match param_id.parse::<String>() {
                        Ok(param_id) => param_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.integrations_slash_get_by_id(
                                            param_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                IntegrationsSlashGetByIdResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_SLASH_GET_BY_ID_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                IntegrationsSlashGetByIdResponse::IntegrationNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_SLASH_GET_BY_ID_INTEGRATION_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                IntegrationsSlashGetByIdResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_SLASH_GET_BY_ID_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // IntegrationsSlashGetList - GET /integrations
            hyper::Method::GET if path.matched(paths::ID_INTEGRATIONS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.integrations_slash_get_list(
                                            param_bookmark,
                                            param_page_size,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                IntegrationsSlashGetListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_SLASH_GET_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                IntegrationsSlashGetListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEGRATIONS_SLASH_GET_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // CountryKeywordsMetricsSlashGet - GET /ad_accounts/{ad_account_id}/keywords/metrics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS_METRICS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS_METRICS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS_METRICS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS_METRICS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_country_code = query_params.iter().filter(|e| e.0 == "country_code").map(|e| e.1.clone())
                    .next();
                let param_country_code = match param_country_code {
                    Some(param_country_code) => {
                        let param_country_code =
                            <String as std::str::FromStr>::from_str
                                (&param_country_code);
                        match param_country_code {
                            Ok(param_country_code) => Some(param_country_code),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter country_code - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter country_code")),
                        }
                    },
                    None => None,
                };
                let param_country_code = match param_country_code {
                    Some(param_country_code) => param_country_code,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter country_code"))
                        .expect("Unable to create Bad Request response for missing query parameter country_code")),
                };
                let param_keywords = query_params.iter().filter(|e| e.0 == "keywords").map(|e| e.1.clone())
                    .filter_map(|param_keywords| param_keywords.parse().ok())
                    .collect::<Vec<_>>();

                                let result = api_impl.country_keywords_metrics_slash_get(
                                            param_ad_account_id,
                                            param_country_code,
                                            param_keywords.as_ref(),
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                CountryKeywordsMetricsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for COUNTRY_KEYWORDS_METRICS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                CountryKeywordsMetricsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for COUNTRY_KEYWORDS_METRICS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // KeywordsSlashCreate - POST /ad_accounts/{ad_account_id}/keywords
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_keywords_request: Option<models::KeywordsRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_keywords_request) => param_keywords_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter KeywordsRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter KeywordsRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_keywords_request = match param_keywords_request {
                                    Some(param_keywords_request) => param_keywords_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter KeywordsRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter KeywordsRequest")),
                                };

                                let result = api_impl.keywords_slash_create(
                                            param_ad_account_id,
                                            param_keywords_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                KeywordsSlashCreateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for KEYWORDS_SLASH_CREATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                KeywordsSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for KEYWORDS_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter KeywordsRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter KeywordsRequest")),
                        }
            },

            // KeywordsSlashGet - GET /ad_accounts/{ad_account_id}/keywords
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_campaign_id = query_params.iter().filter(|e| e.0 == "campaign_id").map(|e| e.1.clone())
                    .next();
                let param_campaign_id = match param_campaign_id {
                    Some(param_campaign_id) => {
                        let param_campaign_id =
                            <String as std::str::FromStr>::from_str
                                (&param_campaign_id);
                        match param_campaign_id {
                            Ok(param_campaign_id) => Some(param_campaign_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter campaign_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter campaign_id")),
                        }
                    },
                    None => None,
                };
                let param_ad_group_id = query_params.iter().filter(|e| e.0 == "ad_group_id").map(|e| e.1.clone())
                    .next();
                let param_ad_group_id = match param_ad_group_id {
                    Some(param_ad_group_id) => {
                        let param_ad_group_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_group_id);
                        match param_ad_group_id {
                            Ok(param_ad_group_id) => Some(param_ad_group_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_group_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_group_id")),
                        }
                    },
                    None => None,
                };
                let param_match_types = query_params.iter().filter(|e| e.0 == "match_types").map(|e| e.1.clone())
                    .filter_map(|param_match_types| param_match_types.parse().ok())
                    .collect::<Vec<_>>();
                let param_match_types = if !param_match_types.is_empty() {
                    Some(param_match_types)
                } else {
                    None
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.keywords_slash_get(
                                            param_ad_account_id,
                                            param_campaign_id,
                                            param_ad_group_id,
                                            param_match_types.as_ref(),
                                            param_page_size,
                                            param_bookmark,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                KeywordsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for KEYWORDS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                KeywordsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for KEYWORDS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // KeywordsSlashUpdate - PATCH /ad_accounts/{ad_account_id}/keywords
            hyper::Method::PATCH if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_keyword_update_body: Option<models::KeywordUpdateBody> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_keyword_update_body) => param_keyword_update_body,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter KeywordUpdateBody - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter KeywordUpdateBody due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_keyword_update_body = match param_keyword_update_body {
                                    Some(param_keyword_update_body) => param_keyword_update_body,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter KeywordUpdateBody"))
                                                        .expect("Unable to create Bad Request response for missing body parameter KeywordUpdateBody")),
                                };

                                let result = api_impl.keywords_slash_update(
                                            param_ad_account_id,
                                            param_keyword_update_body,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                KeywordsSlashUpdateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for KEYWORDS_SLASH_UPDATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                KeywordsSlashUpdateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for KEYWORDS_SLASH_UPDATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter KeywordUpdateBody: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter KeywordUpdateBody")),
                        }
            },

            // TrendingKeywordsSlashList - GET /trends/keywords/{region}/top/{trend_type}
            hyper::Method::GET if path.matched(paths::ID_TRENDS_KEYWORDS_REGION_TOP_TREND_TYPE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "user_accounts:read".to_string(), // See your user accounts and followers
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_TRENDS_KEYWORDS_REGION_TOP_TREND_TYPE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE TRENDS_KEYWORDS_REGION_TOP_TREND_TYPE in set but failed match against \"{}\"", path, paths::REGEX_TRENDS_KEYWORDS_REGION_TOP_TREND_TYPE.as_str())
                    );

                let param_region = match percent_encoding::percent_decode(path_params["region"].as_bytes()).decode_utf8() {
                    Ok(param_region) => match param_region.parse::<models::TrendsSupportedRegion>() {
                        Ok(param_region) => param_region,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter region: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["region"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_trend_type = match percent_encoding::percent_decode(path_params["trend_type"].as_bytes()).decode_utf8() {
                    Ok(param_trend_type) => match param_trend_type.parse::<models::TrendType>() {
                        Ok(param_trend_type) => param_trend_type,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter trend_type: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["trend_type"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_interests = query_params.iter().filter(|e| e.0 == "interests").map(|e| e.1.clone())
                    .filter_map(|param_interests| param_interests.parse().ok())
                    .collect::<Vec<_>>();
                let param_interests = if !param_interests.is_empty() {
                    Some(param_interests)
                } else {
                    None
                };
                let param_genders = query_params.iter().filter(|e| e.0 == "genders").map(|e| e.1.clone())
                    .filter_map(|param_genders| param_genders.parse().ok())
                    .collect::<Vec<_>>();
                let param_genders = if !param_genders.is_empty() {
                    Some(param_genders)
                } else {
                    None
                };
                let param_ages = query_params.iter().filter(|e| e.0 == "ages").map(|e| e.1.clone())
                    .filter_map(|param_ages| param_ages.parse().ok())
                    .collect::<Vec<_>>();
                let param_ages = if !param_ages.is_empty() {
                    Some(param_ages)
                } else {
                    None
                };
                let param_normalize_against_group = query_params.iter().filter(|e| e.0 == "normalize_against_group").map(|e| e.1.clone())
                    .next();
                let param_normalize_against_group = match param_normalize_against_group {
                    Some(param_normalize_against_group) => {
                        let param_normalize_against_group =
                            <bool as std::str::FromStr>::from_str
                                (&param_normalize_against_group);
                        match param_normalize_against_group {
                            Ok(param_normalize_against_group) => Some(param_normalize_against_group),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter normalize_against_group - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter normalize_against_group")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.trending_keywords_slash_list(
                                            param_region,
                                            param_trend_type,
                                            param_interests.as_ref(),
                                            param_genders.as_ref(),
                                            param_ages.as_ref(),
                                            param_normalize_against_group,
                                            param_limit,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                TrendingKeywordsSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for TRENDING_KEYWORDS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                TrendingKeywordsSlashListResponse::InvalidTrendingKeywordsRequestParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for TRENDING_KEYWORDS_SLASH_LIST_INVALID_TRENDING_KEYWORDS_REQUEST_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                TrendingKeywordsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for TRENDING_KEYWORDS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdAccountsSubscriptionsSlashDelById - DELETE /ad_accounts/{ad_account_id}/leads/subscriptions/{subscription_id}
            hyper::Method::DELETE if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS_SUBSCRIPTION_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS_SUBSCRIPTION_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS_SUBSCRIPTION_ID in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS_SUBSCRIPTION_ID.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_subscription_id = match percent_encoding::percent_decode(path_params["subscription_id"].as_bytes()).decode_utf8() {
                    Ok(param_subscription_id) => match param_subscription_id.parse::<String>() {
                        Ok(param_subscription_id) => param_subscription_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter subscription_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["subscription_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.ad_accounts_subscriptions_slash_del_by_id(
                                            param_ad_account_id,
                                            param_subscription_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdAccountsSubscriptionsSlashDelByIdResponse::SubscriptionDeletedSuccessfully
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(204).expect("Unable to turn 204 into a StatusCode");
                                                },
                                                AdAccountsSubscriptionsSlashDelByIdResponse::InvalidInputParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SUBSCRIPTIONS_SLASH_DEL_BY_ID_INVALID_INPUT_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsSubscriptionsSlashDelByIdResponse::YouAreNotAuthorizedToDeleteThisSubscription
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SUBSCRIPTIONS_SLASH_DEL_BY_ID_YOU_ARE_NOT_AUTHORIZED_TO_DELETE_THIS_SUBSCRIPTION"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsSubscriptionsSlashDelByIdResponse::SubscriptionNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SUBSCRIPTIONS_SLASH_DEL_BY_ID_SUBSCRIPTION_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsSubscriptionsSlashDelByIdResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SUBSCRIPTIONS_SLASH_DEL_BY_ID_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdAccountsSubscriptionsSlashGetById - GET /ad_accounts/{ad_account_id}/leads/subscriptions/{subscription_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS_SUBSCRIPTION_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS_SUBSCRIPTION_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS_SUBSCRIPTION_ID in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS_SUBSCRIPTION_ID.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_subscription_id = match percent_encoding::percent_decode(path_params["subscription_id"].as_bytes()).decode_utf8() {
                    Ok(param_subscription_id) => match param_subscription_id.parse::<String>() {
                        Ok(param_subscription_id) => param_subscription_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter subscription_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["subscription_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.ad_accounts_subscriptions_slash_get_by_id(
                                            param_ad_account_id,
                                            param_subscription_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdAccountsSubscriptionsSlashGetByIdResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SUBSCRIPTIONS_SLASH_GET_BY_ID_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsSubscriptionsSlashGetByIdResponse::InvalidInputParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SUBSCRIPTIONS_SLASH_GET_BY_ID_INVALID_INPUT_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsSubscriptionsSlashGetByIdResponse::Can
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SUBSCRIPTIONS_SLASH_GET_BY_ID_CAN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsSubscriptionsSlashGetByIdResponse::SubscriptionNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SUBSCRIPTIONS_SLASH_GET_BY_ID_SUBSCRIPTION_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsSubscriptionsSlashGetByIdResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SUBSCRIPTIONS_SLASH_GET_BY_ID_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdAccountsSubscriptionsSlashGetList - GET /ad_accounts/{ad_account_id}/leads/subscriptions
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.ad_accounts_subscriptions_slash_get_list(
                                            param_ad_account_id,
                                            param_page_size,
                                            param_bookmark,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdAccountsSubscriptionsSlashGetListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SUBSCRIPTIONS_SLASH_GET_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsSubscriptionsSlashGetListResponse::Can
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SUBSCRIPTIONS_SLASH_GET_LIST_CAN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsSubscriptionsSlashGetListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SUBSCRIPTIONS_SLASH_GET_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdAccountsSubscriptionsSlashPost - POST /ad_accounts/{ad_account_id}/leads/subscriptions
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_ad_account_create_subscription_request: Option<models::AdAccountCreateSubscriptionRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_ad_account_create_subscription_request) => param_ad_account_create_subscription_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter AdAccountCreateSubscriptionRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter AdAccountCreateSubscriptionRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_ad_account_create_subscription_request = match param_ad_account_create_subscription_request {
                                    Some(param_ad_account_create_subscription_request) => param_ad_account_create_subscription_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter AdAccountCreateSubscriptionRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter AdAccountCreateSubscriptionRequest")),
                                };

                                let result = api_impl.ad_accounts_subscriptions_slash_post(
                                            param_ad_account_id,
                                            param_ad_account_create_subscription_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdAccountsSubscriptionsSlashPostResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SUBSCRIPTIONS_SLASH_POST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsSubscriptionsSlashPostResponse::InvalidInputParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SUBSCRIPTIONS_SLASH_POST_INVALID_INPUT_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsSubscriptionsSlashPostResponse::Can
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SUBSCRIPTIONS_SLASH_POST_CAN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsSubscriptionsSlashPostResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_SUBSCRIPTIONS_SLASH_POST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter AdAccountCreateSubscriptionRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter AdAccountCreateSubscriptionRequest")),
                        }
            },

            // LeadFormSlashGet - GET /ad_accounts/{ad_account_id}/lead_forms/{lead_form_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_lead_form_id = match percent_encoding::percent_decode(path_params["lead_form_id"].as_bytes()).decode_utf8() {
                    Ok(param_lead_form_id) => match param_lead_form_id.parse::<String>() {
                        Ok(param_lead_form_id) => param_lead_form_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter lead_form_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["lead_form_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.lead_form_slash_get(
                                            param_ad_account_id,
                                            param_lead_form_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                LeadFormSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LEAD_FORM_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                LeadFormSlashGetResponse::InvalidAdAccountLeadFormsParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LEAD_FORM_SLASH_GET_INVALID_AD_ACCOUNT_LEAD_FORMS_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                LeadFormSlashGetResponse::TheLeadFormIDForTheGivenAdAccountIDDoesNotExist
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LEAD_FORM_SLASH_GET_THE_LEAD_FORM_ID_FOR_THE_GIVEN_AD_ACCOUNT_ID_DOES_NOT_EXIST"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                LeadFormSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LEAD_FORM_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // LeadFormTestSlashCreate - POST /ad_accounts/{ad_account_id}/lead_forms/{lead_form_id}/test
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID_TEST) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID_TEST
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID_TEST in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID_TEST.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_lead_form_id = match percent_encoding::percent_decode(path_params["lead_form_id"].as_bytes()).decode_utf8() {
                    Ok(param_lead_form_id) => match param_lead_form_id.parse::<String>() {
                        Ok(param_lead_form_id) => param_lead_form_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter lead_form_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["lead_form_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_lead_form_test_request: Option<models::LeadFormTestRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_lead_form_test_request) => param_lead_form_test_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter LeadFormTestRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter LeadFormTestRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_lead_form_test_request = match param_lead_form_test_request {
                                    Some(param_lead_form_test_request) => param_lead_form_test_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter LeadFormTestRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter LeadFormTestRequest")),
                                };

                                let result = api_impl.lead_form_test_slash_create(
                                            param_ad_account_id,
                                            param_lead_form_id,
                                            param_lead_form_test_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                LeadFormTestSlashCreateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LEAD_FORM_TEST_SLASH_CREATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                LeadFormTestSlashCreateResponse::InvalidParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LEAD_FORM_TEST_SLASH_CREATE_INVALID_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                LeadFormTestSlashCreateResponse::LeadNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LEAD_FORM_TEST_SLASH_CREATE_LEAD_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                LeadFormTestSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LEAD_FORM_TEST_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter LeadFormTestRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter LeadFormTestRequest")),
                        }
            },

            // LeadFormsSlashList - GET /ad_accounts/{ad_account_id}/lead_forms
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_order = query_params.iter().filter(|e| e.0 == "order").map(|e| e.1.clone())
                    .next();
                let param_order = match param_order {
                    Some(param_order) => {
                        let param_order =
                            <String as std::str::FromStr>::from_str
                                (&param_order);
                        match param_order {
                            Ok(param_order) => Some(param_order),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter order - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter order")),
                        }
                    },
                    None => None,
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.lead_forms_slash_list(
                                            param_ad_account_id,
                                            param_page_size,
                                            param_order,
                                            param_bookmark,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                LeadFormsSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LEAD_FORMS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                LeadFormsSlashListResponse::InvalidAdAccountLeadFormsParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LEAD_FORMS_SLASH_LIST_INVALID_AD_ACCOUNT_LEAD_FORMS_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                LeadFormsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LEAD_FORMS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // MediaSlashCreate - POST /media
            hyper::Method::POST if path.matched(paths::ID_MEDIA) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "pins:read".to_string(), // See your public Pins
                            "pins:write".to_string(), // Create, update, or delete your public Pins
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_media_upload_request: Option<models::MediaUploadRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_media_upload_request) => param_media_upload_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter MediaUploadRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter MediaUploadRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_media_upload_request = match param_media_upload_request {
                                    Some(param_media_upload_request) => param_media_upload_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter MediaUploadRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter MediaUploadRequest")),
                                };

                                let result = api_impl.media_slash_create(
                                            param_media_upload_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                MediaSlashCreateResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for MEDIA_SLASH_CREATE_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                MediaSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for MEDIA_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter MediaUploadRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter MediaUploadRequest")),
                        }
            },

            // MediaSlashGet - GET /media/{media_id}
            hyper::Method::GET if path.matched(paths::ID_MEDIA_MEDIA_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "pins:read".to_string(), // See your public Pins
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_MEDIA_MEDIA_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE MEDIA_MEDIA_ID in set but failed match against \"{}\"", path, paths::REGEX_MEDIA_MEDIA_ID.as_str())
                    );

                let param_media_id = match percent_encoding::percent_decode(path_params["media_id"].as_bytes()).decode_utf8() {
                    Ok(param_media_id) => match param_media_id.parse::<String>() {
                        Ok(param_media_id) => param_media_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter media_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["media_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.media_slash_get(
                                            param_media_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                MediaSlashGetResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for MEDIA_SLASH_GET_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                MediaSlashGetResponse::MediaUploadNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for MEDIA_SLASH_GET_MEDIA_UPLOAD_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                MediaSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for MEDIA_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // MediaSlashList - GET /media
            hyper::Method::GET if path.matched(paths::ID_MEDIA) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "pins:read".to_string(), // See your public Pins
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.media_slash_list(
                                            param_bookmark,
                                            param_page_size,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                MediaSlashListResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for MEDIA_SLASH_LIST_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                MediaSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for MEDIA_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // OauthSlashToken - POST /oauth/token
            hyper::Method::POST if path.matched(paths::ID_OAUTH_TOKEN) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };
                }

                                // Form parameters
                                let param_grant_type = "grant_type_example".to_string();

                                let result = api_impl.oauth_slash_token(
                                            param_grant_type,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                OauthSlashTokenResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for OAUTH_SLASH_TOKEN_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                OauthSlashTokenResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for OAUTH_SLASH_TOKEN_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // OrderLinesSlashGet - GET /ad_accounts/{ad_account_id}/order_lines/{order_line_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES_ORDER_LINE_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES_ORDER_LINE_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES_ORDER_LINE_ID in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES_ORDER_LINE_ID.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_order_line_id = match percent_encoding::percent_decode(path_params["order_line_id"].as_bytes()).decode_utf8() {
                    Ok(param_order_line_id) => match param_order_line_id.parse::<String>() {
                        Ok(param_order_line_id) => param_order_line_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter order_line_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["order_line_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.order_lines_slash_get(
                                            param_ad_account_id,
                                            param_order_line_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                OrderLinesSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ORDER_LINES_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                OrderLinesSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ORDER_LINES_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // OrderLinesSlashList - GET /ad_accounts/{ad_account_id}/order_lines
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_order = query_params.iter().filter(|e| e.0 == "order").map(|e| e.1.clone())
                    .next();
                let param_order = match param_order {
                    Some(param_order) => {
                        let param_order =
                            <String as std::str::FromStr>::from_str
                                (&param_order);
                        match param_order {
                            Ok(param_order) => Some(param_order),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter order - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter order")),
                        }
                    },
                    None => None,
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.order_lines_slash_list(
                                            param_ad_account_id,
                                            param_page_size,
                                            param_order,
                                            param_bookmark,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                OrderLinesSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ORDER_LINES_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                OrderLinesSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for ORDER_LINES_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // PinsSlashAnalytics - GET /pins/{pin_id}/analytics
            hyper::Method::GET if path.matched(paths::ID_PINS_PIN_ID_ANALYTICS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "pins:read".to_string(), // See your public Pins
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_PINS_PIN_ID_ANALYTICS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE PINS_PIN_ID_ANALYTICS in set but failed match against \"{}\"", path, paths::REGEX_PINS_PIN_ID_ANALYTICS.as_str())
                    );

                let param_pin_id = match percent_encoding::percent_decode(path_params["pin_id"].as_bytes()).decode_utf8() {
                    Ok(param_pin_id) => match param_pin_id.parse::<String>() {
                        Ok(param_pin_id) => param_pin_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter pin_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["pin_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_start_date = query_params.iter().filter(|e| e.0 == "start_date").map(|e| e.1.clone())
                    .next();
                let param_start_date = match param_start_date {
                    Some(param_start_date) => {
                        let param_start_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_start_date);
                        match param_start_date {
                            Ok(param_start_date) => Some(param_start_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter start_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter start_date")),
                        }
                    },
                    None => None,
                };
                let param_start_date = match param_start_date {
                    Some(param_start_date) => param_start_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter start_date"))
                        .expect("Unable to create Bad Request response for missing query parameter start_date")),
                };
                let param_end_date = query_params.iter().filter(|e| e.0 == "end_date").map(|e| e.1.clone())
                    .next();
                let param_end_date = match param_end_date {
                    Some(param_end_date) => {
                        let param_end_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_end_date);
                        match param_end_date {
                            Ok(param_end_date) => Some(param_end_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter end_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter end_date")),
                        }
                    },
                    None => None,
                };
                let param_end_date = match param_end_date {
                    Some(param_end_date) => param_end_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter end_date"))
                        .expect("Unable to create Bad Request response for missing query parameter end_date")),
                };
                let param_app_types = query_params.iter().filter(|e| e.0 == "app_types").map(|e| e.1.clone())
                    .next();
                let param_app_types = match param_app_types {
                    Some(param_app_types) => {
                        let param_app_types =
                            <String as std::str::FromStr>::from_str
                                (&param_app_types);
                        match param_app_types {
                            Ok(param_app_types) => Some(param_app_types),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter app_types - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter app_types")),
                        }
                    },
                    None => None,
                };
                let param_metric_types = query_params.iter().filter(|e| e.0 == "metric_types").map(|e| e.1.clone())
                    .filter_map(|param_metric_types| param_metric_types.parse().ok())
                    .collect::<Vec<_>>();
                let param_split_field = query_params.iter().filter(|e| e.0 == "split_field").map(|e| e.1.clone())
                    .next();
                let param_split_field = match param_split_field {
                    Some(param_split_field) => {
                        let param_split_field =
                            <String as std::str::FromStr>::from_str
                                (&param_split_field);
                        match param_split_field {
                            Ok(param_split_field) => Some(param_split_field),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter split_field - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter split_field")),
                        }
                    },
                    None => None,
                };
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.pins_slash_analytics(
                                            param_pin_id,
                                            param_start_date,
                                            param_end_date,
                                            param_metric_types.as_ref(),
                                            param_app_types,
                                            param_split_field,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                PinsSlashAnalyticsResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_ANALYTICS_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashAnalyticsResponse::InvalidPinsAnalyticsParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_ANALYTICS_INVALID_PINS_ANALYTICS_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashAnalyticsResponse::NotAuthorizedToAccessBoardOrPin
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_ANALYTICS_NOT_AUTHORIZED_TO_ACCESS_BOARD_OR_PIN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashAnalyticsResponse::PinNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_ANALYTICS_PIN_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashAnalyticsResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_ANALYTICS_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // PinsSlashCreate - POST /pins
            hyper::Method::POST if path.matched(paths::ID_PINS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "boards:write".to_string(), // Create, update, or delete your public boards
                            "pins:read".to_string(), // See your public Pins
                            "pins:write".to_string(), // Create, update, or delete your public Pins
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_pin_create: Option<models::PinCreate> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_pin_create) => param_pin_create,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter PinCreate - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter PinCreate due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_pin_create = match param_pin_create {
                                    Some(param_pin_create) => param_pin_create,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter PinCreate"))
                                                        .expect("Unable to create Bad Request response for missing body parameter PinCreate")),
                                };

                                let result = api_impl.pins_slash_create(
                                            param_pin_create,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                PinsSlashCreateResponse::SuccessfulPinCreation
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_CREATE_SUCCESSFUL_PIN_CREATION"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashCreateResponse::InvalidPinParametersResponse
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_CREATE_INVALID_PIN_PARAMETERS_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashCreateResponse::ThePin
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_CREATE_THE_PIN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashCreateResponse::BoardOrSectionNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_CREATE_BOARD_OR_SECTION_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashCreateResponse::ThisRequestExceededARateLimit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(429).expect("Unable to turn 429 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_CREATE_THIS_REQUEST_EXCEEDED_A_RATE_LIMIT"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter PinCreate: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter PinCreate")),
                        }
            },

            // PinsSlashDelete - DELETE /pins/{pin_id}
            hyper::Method::DELETE if path.matched(paths::ID_PINS_PIN_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "boards:write".to_string(), // Create, update, or delete your public boards
                            "pins:read".to_string(), // See your public Pins
                            "pins:write".to_string(), // Create, update, or delete your public Pins
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_PINS_PIN_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE PINS_PIN_ID in set but failed match against \"{}\"", path, paths::REGEX_PINS_PIN_ID.as_str())
                    );

                let param_pin_id = match percent_encoding::percent_decode(path_params["pin_id"].as_bytes()).decode_utf8() {
                    Ok(param_pin_id) => match param_pin_id.parse::<String>() {
                        Ok(param_pin_id) => param_pin_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter pin_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["pin_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.pins_slash_delete(
                                            param_pin_id,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                PinsSlashDeleteResponse::SuccessfullyDeletedPin
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(204).expect("Unable to turn 204 into a StatusCode");
                                                },
                                                PinsSlashDeleteResponse::NotAuthorizedToAccessBoardOrPin
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_DELETE_NOT_AUTHORIZED_TO_ACCESS_BOARD_OR_PIN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashDeleteResponse::PinNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_DELETE_PIN_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashDeleteResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_DELETE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // PinsSlashGet - GET /pins/{pin_id}
            hyper::Method::GET if path.matched(paths::ID_PINS_PIN_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "pins:read".to_string(), // See your public Pins
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_PINS_PIN_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE PINS_PIN_ID in set but failed match against \"{}\"", path, paths::REGEX_PINS_PIN_ID.as_str())
                    );

                let param_pin_id = match percent_encoding::percent_decode(path_params["pin_id"].as_bytes()).decode_utf8() {
                    Ok(param_pin_id) => match param_pin_id.parse::<String>() {
                        Ok(param_pin_id) => param_pin_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter pin_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["pin_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_pin_metrics = query_params.iter().filter(|e| e.0 == "pin_metrics").map(|e| e.1.clone())
                    .next();
                let param_pin_metrics = match param_pin_metrics {
                    Some(param_pin_metrics) => {
                        let param_pin_metrics =
                            <bool as std::str::FromStr>::from_str
                                (&param_pin_metrics);
                        match param_pin_metrics {
                            Ok(param_pin_metrics) => Some(param_pin_metrics),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter pin_metrics - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter pin_metrics")),
                        }
                    },
                    None => None,
                };
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.pins_slash_get(
                                            param_pin_id,
                                            param_pin_metrics,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                PinsSlashGetResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_GET_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashGetResponse::NotAuthorizedToAccessBoardOrPin
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_GET_NOT_AUTHORIZED_TO_ACCESS_BOARD_OR_PIN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashGetResponse::PinNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_GET_PIN_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // PinsSlashList - GET /pins
            hyper::Method::GET if path.matched(paths::ID_PINS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "pins:read".to_string(), // See your public Pins
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_pin_filter = query_params.iter().filter(|e| e.0 == "pin_filter").map(|e| e.1.clone())
                    .next();
                let param_pin_filter = match param_pin_filter {
                    Some(param_pin_filter) => {
                        let param_pin_filter =
                            <String as std::str::FromStr>::from_str
                                (&param_pin_filter);
                        match param_pin_filter {
                            Ok(param_pin_filter) => Some(param_pin_filter),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter pin_filter - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter pin_filter")),
                        }
                    },
                    None => None,
                };
                let param_include_protected_pins = query_params.iter().filter(|e| e.0 == "include_protected_pins").map(|e| e.1.clone())
                    .next();
                let param_include_protected_pins = match param_include_protected_pins {
                    Some(param_include_protected_pins) => {
                        let param_include_protected_pins =
                            <bool as std::str::FromStr>::from_str
                                (&param_include_protected_pins);
                        match param_include_protected_pins {
                            Ok(param_include_protected_pins) => Some(param_include_protected_pins),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter include_protected_pins - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter include_protected_pins")),
                        }
                    },
                    None => None,
                };
                let param_pin_type = query_params.iter().filter(|e| e.0 == "pin_type").map(|e| e.1.clone())
                    .next();
                let param_pin_type = match param_pin_type {
                    Some(param_pin_type) => {
                        let param_pin_type =
                            <String as std::str::FromStr>::from_str
                                (&param_pin_type);
                        match param_pin_type {
                            Ok(param_pin_type) => Some(param_pin_type),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter pin_type - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter pin_type")),
                        }
                    },
                    None => None,
                };
                let param_creative_types = query_params.iter().filter(|e| e.0 == "creative_types").map(|e| e.1.clone())
                    .filter_map(|param_creative_types| param_creative_types.parse().ok())
                    .collect::<Vec<_>>();
                let param_creative_types = if !param_creative_types.is_empty() {
                    Some(param_creative_types)
                } else {
                    None
                };
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };
                let param_pin_metrics = query_params.iter().filter(|e| e.0 == "pin_metrics").map(|e| e.1.clone())
                    .next();
                let param_pin_metrics = match param_pin_metrics {
                    Some(param_pin_metrics) => {
                        let param_pin_metrics =
                            <bool as std::str::FromStr>::from_str
                                (&param_pin_metrics);
                        match param_pin_metrics {
                            Ok(param_pin_metrics) => Some(param_pin_metrics),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter pin_metrics - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter pin_metrics")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.pins_slash_list(
                                            param_bookmark,
                                            param_page_size,
                                            param_pin_filter,
                                            param_include_protected_pins,
                                            param_pin_type,
                                            param_creative_types.as_ref(),
                                            param_ad_account_id,
                                            param_pin_metrics,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                PinsSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashListResponse::InvalidPinFilterValue
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_LIST_INVALID_PIN_FILTER_VALUE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // PinsSlashSave - POST /pins/{pin_id}/save
            hyper::Method::POST if path.matched(paths::ID_PINS_PIN_ID_SAVE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "boards:write".to_string(), // Create, update, or delete your public boards
                            "pins:read".to_string(), // See your public Pins
                            "pins:write".to_string(), // Create, update, or delete your public Pins
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_PINS_PIN_ID_SAVE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE PINS_PIN_ID_SAVE in set but failed match against \"{}\"", path, paths::REGEX_PINS_PIN_ID_SAVE.as_str())
                    );

                let param_pin_id = match percent_encoding::percent_decode(path_params["pin_id"].as_bytes()).decode_utf8() {
                    Ok(param_pin_id) => match param_pin_id.parse::<String>() {
                        Ok(param_pin_id) => param_pin_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter pin_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["pin_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_pins_save_request: Option<models::PinsSaveRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_pins_save_request) => param_pins_save_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter PinsSaveRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter PinsSaveRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_pins_save_request = match param_pins_save_request {
                                    Some(param_pins_save_request) => param_pins_save_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter PinsSaveRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter PinsSaveRequest")),
                                };

                                let result = api_impl.pins_slash_save(
                                            param_pin_id,
                                            param_pins_save_request,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                PinsSlashSaveResponse::SuccessfullySavedPin
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(201).expect("Unable to turn 201 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_SAVE_SUCCESSFULLY_SAVED_PIN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashSaveResponse::NotAuthorizedToAccessBoardOrPin
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_SAVE_NOT_AUTHORIZED_TO_ACCESS_BOARD_OR_PIN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashSaveResponse::BoardOrPinNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_SAVE_BOARD_OR_PIN_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashSaveResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_SAVE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter PinsSaveRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter PinsSaveRequest")),
                        }
            },

            // PinsSlashUpdate - PATCH /pins/{pin_id}
            hyper::Method::PATCH if path.matched(paths::ID_PINS_PIN_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "boards:write".to_string(), // Create, update, or delete your public boards
                            "pins:read".to_string(), // See your public Pins
                            "pins:write".to_string(), // Create, update, or delete your public Pins
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_PINS_PIN_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE PINS_PIN_ID in set but failed match against \"{}\"", path, paths::REGEX_PINS_PIN_ID.as_str())
                    );

                let param_pin_id = match percent_encoding::percent_decode(path_params["pin_id"].as_bytes()).decode_utf8() {
                    Ok(param_pin_id) => match param_pin_id.parse::<String>() {
                        Ok(param_pin_id) => param_pin_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter pin_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["pin_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_pin_update: Option<models::PinUpdate> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_pin_update) => param_pin_update,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter PinUpdate - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter PinUpdate due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_pin_update = match param_pin_update {
                                    Some(param_pin_update) => param_pin_update,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter PinUpdate"))
                                                        .expect("Unable to create Bad Request response for missing body parameter PinUpdate")),
                                };

                                let result = api_impl.pins_slash_update(
                                            param_pin_id,
                                            param_pin_update,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                PinsSlashUpdateResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_UPDATE_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashUpdateResponse::NotAuthorizedToUpdatePin
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_UPDATE_NOT_AUTHORIZED_TO_UPDATE_PIN"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashUpdateResponse::PinNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_UPDATE_PIN_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashUpdateResponse::ThisRequestExceededARateLimit
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(429).expect("Unable to turn 429 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_UPDATE_THIS_REQUEST_EXCEEDED_A_RATE_LIMIT"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                PinsSlashUpdateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PINS_SLASH_UPDATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter PinUpdate: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter PinUpdate")),
                        }
            },

            // ProductGroupPromotionsSlashCreate - POST /ad_accounts/{ad_account_id}/product_group_promotions
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_product_group_promotion_create_request: Option<models::ProductGroupPromotionCreateRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_product_group_promotion_create_request) => param_product_group_promotion_create_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter ProductGroupPromotionCreateRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter ProductGroupPromotionCreateRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_product_group_promotion_create_request = match param_product_group_promotion_create_request {
                                    Some(param_product_group_promotion_create_request) => param_product_group_promotion_create_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter ProductGroupPromotionCreateRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter ProductGroupPromotionCreateRequest")),
                                };

                                let result = api_impl.product_group_promotions_slash_create(
                                            param_ad_account_id,
                                            param_product_group_promotion_create_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                ProductGroupPromotionsSlashCreateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PRODUCT_GROUP_PROMOTIONS_SLASH_CREATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ProductGroupPromotionsSlashCreateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PRODUCT_GROUP_PROMOTIONS_SLASH_CREATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter ProductGroupPromotionCreateRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter ProductGroupPromotionCreateRequest")),
                        }
            },

            // ProductGroupPromotionsSlashGet - GET /ad_accounts/{ad_account_id}/product_group_promotions/{product_group_promotion_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS_PRODUCT_GROUP_PROMOTION_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS_PRODUCT_GROUP_PROMOTION_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS_PRODUCT_GROUP_PROMOTION_ID in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS_PRODUCT_GROUP_PROMOTION_ID.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                let param_product_group_promotion_id = match percent_encoding::percent_decode(path_params["product_group_promotion_id"].as_bytes()).decode_utf8() {
                    Ok(param_product_group_promotion_id) => match param_product_group_promotion_id.parse::<String>() {
                        Ok(param_product_group_promotion_id) => param_product_group_promotion_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter product_group_promotion_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["product_group_promotion_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.product_group_promotions_slash_get(
                                            param_ad_account_id,
                                            param_product_group_promotion_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                ProductGroupPromotionsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PRODUCT_GROUP_PROMOTIONS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ProductGroupPromotionsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PRODUCT_GROUP_PROMOTIONS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // ProductGroupPromotionsSlashList - GET /ad_accounts/{ad_account_id}/product_group_promotions
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_product_group_promotion_ids = query_params.iter().filter(|e| e.0 == "product_group_promotion_ids").map(|e| e.1.clone())
                    .filter_map(|param_product_group_promotion_ids| param_product_group_promotion_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_product_group_promotion_ids = if !param_product_group_promotion_ids.is_empty() {
                    Some(param_product_group_promotion_ids)
                } else {
                    None
                };
                let param_entity_statuses = query_params.iter().filter(|e| e.0 == "entity_statuses").map(|e| e.1.clone())
                    .filter_map(|param_entity_statuses| param_entity_statuses.parse().ok())
                    .collect::<Vec<_>>();
                let param_entity_statuses = if !param_entity_statuses.is_empty() {
                    Some(param_entity_statuses)
                } else {
                    None
                };
                let param_ad_group_id = query_params.iter().filter(|e| e.0 == "ad_group_id").map(|e| e.1.clone())
                    .next();
                let param_ad_group_id = match param_ad_group_id {
                    Some(param_ad_group_id) => {
                        let param_ad_group_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_group_id);
                        match param_ad_group_id {
                            Ok(param_ad_group_id) => Some(param_ad_group_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_group_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_group_id")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_order = query_params.iter().filter(|e| e.0 == "order").map(|e| e.1.clone())
                    .next();
                let param_order = match param_order {
                    Some(param_order) => {
                        let param_order =
                            <String as std::str::FromStr>::from_str
                                (&param_order);
                        match param_order {
                            Ok(param_order) => Some(param_order),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter order - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter order")),
                        }
                    },
                    None => None,
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.product_group_promotions_slash_list(
                                            param_ad_account_id,
                                            param_product_group_promotion_ids.as_ref(),
                                            param_entity_statuses.as_ref(),
                                            param_ad_group_id,
                                            param_page_size,
                                            param_order,
                                            param_bookmark,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                ProductGroupPromotionsSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PRODUCT_GROUP_PROMOTIONS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ProductGroupPromotionsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PRODUCT_GROUP_PROMOTIONS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // ProductGroupPromotionsSlashUpdate - PATCH /ad_accounts/{ad_account_id}/product_group_promotions
            hyper::Method::PATCH if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_product_group_promotion_update_request: Option<models::ProductGroupPromotionUpdateRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_product_group_promotion_update_request) => param_product_group_promotion_update_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter ProductGroupPromotionUpdateRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter ProductGroupPromotionUpdateRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_product_group_promotion_update_request = match param_product_group_promotion_update_request {
                                    Some(param_product_group_promotion_update_request) => param_product_group_promotion_update_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter ProductGroupPromotionUpdateRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter ProductGroupPromotionUpdateRequest")),
                                };

                                let result = api_impl.product_group_promotions_slash_update(
                                            param_ad_account_id,
                                            param_product_group_promotion_update_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                ProductGroupPromotionsSlashUpdateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PRODUCT_GROUP_PROMOTIONS_SLASH_UPDATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ProductGroupPromotionsSlashUpdateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PRODUCT_GROUP_PROMOTIONS_SLASH_UPDATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter ProductGroupPromotionUpdateRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter ProductGroupPromotionUpdateRequest")),
                        }
            },

            // ProductGroupsSlashAnalytics - GET /ad_accounts/{ad_account_id}/product_groups/analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_ANALYTICS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_ANALYTICS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_ANALYTICS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_ANALYTICS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_start_date = query_params.iter().filter(|e| e.0 == "start_date").map(|e| e.1.clone())
                    .next();
                let param_start_date = match param_start_date {
                    Some(param_start_date) => {
                        let param_start_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_start_date);
                        match param_start_date {
                            Ok(param_start_date) => Some(param_start_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter start_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter start_date")),
                        }
                    },
                    None => None,
                };
                let param_start_date = match param_start_date {
                    Some(param_start_date) => param_start_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter start_date"))
                        .expect("Unable to create Bad Request response for missing query parameter start_date")),
                };
                let param_end_date = query_params.iter().filter(|e| e.0 == "end_date").map(|e| e.1.clone())
                    .next();
                let param_end_date = match param_end_date {
                    Some(param_end_date) => {
                        let param_end_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_end_date);
                        match param_end_date {
                            Ok(param_end_date) => Some(param_end_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter end_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter end_date")),
                        }
                    },
                    None => None,
                };
                let param_end_date = match param_end_date {
                    Some(param_end_date) => param_end_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter end_date"))
                        .expect("Unable to create Bad Request response for missing query parameter end_date")),
                };
                let param_product_group_ids = query_params.iter().filter(|e| e.0 == "product_group_ids").map(|e| e.1.clone())
                    .filter_map(|param_product_group_ids| param_product_group_ids.parse().ok())
                    .collect::<Vec<_>>();
                let param_columns = query_params.iter().filter(|e| e.0 == "columns").map(|e| e.1.clone())
                    .filter_map(|param_columns| param_columns.parse().ok())
                    .collect::<Vec<_>>();
                let param_granularity = query_params.iter().filter(|e| e.0 == "granularity").map(|e| e.1.clone())
                    .next();
                let param_granularity = match param_granularity {
                    Some(param_granularity) => {
                        let param_granularity =
                            <models::Granularity as std::str::FromStr>::from_str
                                (&param_granularity);
                        match param_granularity {
                            Ok(param_granularity) => Some(param_granularity),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter granularity - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter granularity")),
                        }
                    },
                    None => None,
                };
                let param_granularity = match param_granularity {
                    Some(param_granularity) => param_granularity,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter granularity"))
                        .expect("Unable to create Bad Request response for missing query parameter granularity")),
                };
                let param_click_window_days = query_params.iter().filter(|e| e.0 == "click_window_days").map(|e| e.1.clone())
                    .next();
                let param_click_window_days = match param_click_window_days {
                    Some(param_click_window_days) => {
                        let param_click_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_click_window_days);
                        match param_click_window_days {
                            Ok(param_click_window_days) => Some(param_click_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter click_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter click_window_days")),
                        }
                    },
                    None => None,
                };
                let param_engagement_window_days = query_params.iter().filter(|e| e.0 == "engagement_window_days").map(|e| e.1.clone())
                    .next();
                let param_engagement_window_days = match param_engagement_window_days {
                    Some(param_engagement_window_days) => {
                        let param_engagement_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_engagement_window_days);
                        match param_engagement_window_days {
                            Ok(param_engagement_window_days) => Some(param_engagement_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter engagement_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter engagement_window_days")),
                        }
                    },
                    None => None,
                };
                let param_view_window_days = query_params.iter().filter(|e| e.0 == "view_window_days").map(|e| e.1.clone())
                    .next();
                let param_view_window_days = match param_view_window_days {
                    Some(param_view_window_days) => {
                        let param_view_window_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_view_window_days);
                        match param_view_window_days {
                            Ok(param_view_window_days) => Some(param_view_window_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter view_window_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter view_window_days")),
                        }
                    },
                    None => None,
                };
                let param_conversion_report_time = query_params.iter().filter(|e| e.0 == "conversion_report_time").map(|e| e.1.clone())
                    .next();
                let param_conversion_report_time = match param_conversion_report_time {
                    Some(param_conversion_report_time) => {
                        let param_conversion_report_time =
                            <String as std::str::FromStr>::from_str
                                (&param_conversion_report_time);
                        match param_conversion_report_time {
                            Ok(param_conversion_report_time) => Some(param_conversion_report_time),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter conversion_report_time - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter conversion_report_time")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.product_groups_slash_analytics(
                                            param_ad_account_id,
                                            param_start_date,
                                            param_end_date,
                                            param_product_group_ids.as_ref(),
                                            param_columns.as_ref(),
                                            param_granularity,
                                            param_click_window_days,
                                            param_engagement_window_days,
                                            param_view_window_days,
                                            param_conversion_report_time,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                ProductGroupsSlashAnalyticsResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PRODUCT_GROUPS_SLASH_ANALYTICS_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ProductGroupsSlashAnalyticsResponse::InvalidAdAccountAdsAnalyticsParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PRODUCT_GROUPS_SLASH_ANALYTICS_INVALID_AD_ACCOUNT_ADS_ANALYTICS_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                ProductGroupsSlashAnalyticsResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for PRODUCT_GROUPS_SLASH_ANALYTICS_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdAccountsCatalogsProductGroupsSlashList - GET /ad_accounts/{ad_account_id}/product_groups/catalogs
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_CATALOGS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:write".to_string(), // Create, update, or delete ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_CATALOGS
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_CATALOGS in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_CATALOGS.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_feed_profile_id = query_params.iter().filter(|e| e.0 == "feed_profile_id").map(|e| e.1.clone())
                    .next();
                let param_feed_profile_id = match param_feed_profile_id {
                    Some(param_feed_profile_id) => {
                        let param_feed_profile_id =
                            <String as std::str::FromStr>::from_str
                                (&param_feed_profile_id);
                        match param_feed_profile_id {
                            Ok(param_feed_profile_id) => Some(param_feed_profile_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter feed_profile_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter feed_profile_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.ad_accounts_catalogs_product_groups_slash_list(
                                            param_ad_account_id,
                                            param_feed_profile_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdAccountsCatalogsProductGroupsSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_CATALOGS_PRODUCT_GROUPS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsCatalogsProductGroupsSlashListResponse::InvalidAdAccountAdsParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_CATALOGS_PRODUCT_GROUPS_SLASH_LIST_INVALID_AD_ACCOUNT_ADS_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsCatalogsProductGroupsSlashListResponse::AccessDenied
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_CATALOGS_PRODUCT_GROUPS_SLASH_LIST_ACCESS_DENIED"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsCatalogsProductGroupsSlashListResponse::MerchantDataNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_CATALOGS_PRODUCT_GROUPS_SLASH_LIST_MERCHANT_DATA_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountsCatalogsProductGroupsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNTS_CATALOGS_PRODUCT_GROUPS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // AdAccountCountriesSlashGet - GET /resources/ad_account_countries
            hyper::Method::GET if path.matched(paths::ID_RESOURCES_AD_ACCOUNT_COUNTRIES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                                let result = api_impl.ad_account_countries_slash_get(
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                AdAccountCountriesSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNT_COUNTRIES_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                AdAccountCountriesSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for AD_ACCOUNT_COUNTRIES_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // DeliveryMetricsSlashGet - GET /resources/delivery_metrics
            hyper::Method::GET if path.matched(paths::ID_RESOURCES_DELIVERY_METRICS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                            "pins:read".to_string(), // See your public Pins
                            "user_accounts:read".to_string(), // See your user accounts and followers
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_report_type = query_params.iter().filter(|e| e.0 == "report_type").map(|e| e.1.clone())
                    .next();
                let param_report_type = match param_report_type {
                    Some(param_report_type) => {
                        let param_report_type =
                            <String as std::str::FromStr>::from_str
                                (&param_report_type);
                        match param_report_type {
                            Ok(param_report_type) => Some(param_report_type),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter report_type - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter report_type")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.delivery_metrics_slash_get(
                                            param_report_type,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                DeliveryMetricsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELIVERY_METRICS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                DeliveryMetricsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for DELIVERY_METRICS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // InterestTargetingOptionsSlashGet - GET /resources/targeting/interests/{interest_id}
            hyper::Method::GET if path.matched(paths::ID_RESOURCES_TARGETING_INTERESTS_INTEREST_ID) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_RESOURCES_TARGETING_INTERESTS_INTEREST_ID
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE RESOURCES_TARGETING_INTERESTS_INTEREST_ID in set but failed match against \"{}\"", path, paths::REGEX_RESOURCES_TARGETING_INTERESTS_INTEREST_ID.as_str())
                    );

                let param_interest_id = match percent_encoding::percent_decode(path_params["interest_id"].as_bytes()).decode_utf8() {
                    Ok(param_interest_id) => match param_interest_id.parse::<String>() {
                        Ok(param_interest_id) => param_interest_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter interest_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["interest_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                                let result = api_impl.interest_targeting_options_slash_get(
                                            param_interest_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                InterestTargetingOptionsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEREST_TARGETING_OPTIONS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                InterestTargetingOptionsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for INTEREST_TARGETING_OPTIONS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // LeadFormQuestionsSlashGet - GET /resources/lead_form_questions
            hyper::Method::GET if path.matched(paths::ID_RESOURCES_LEAD_FORM_QUESTIONS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                                let result = api_impl.lead_form_questions_slash_get(
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                LeadFormQuestionsSlashGetResponse::Success
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                },
                                                LeadFormQuestionsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LEAD_FORM_QUESTIONS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // MetricsReadyStateSlashGet - GET /resources/metrics_ready_state
            hyper::Method::GET if path.matched(paths::ID_RESOURCES_METRICS_READY_STATE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_date = query_params.iter().filter(|e| e.0 == "date").map(|e| e.1.clone())
                    .next();
                let param_date = match param_date {
                    Some(param_date) => {
                        let param_date =
                            <String as std::str::FromStr>::from_str
                                (&param_date);
                        match param_date {
                            Ok(param_date) => Some(param_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter date")),
                        }
                    },
                    None => None,
                };
                let param_date = match param_date {
                    Some(param_date) => param_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter date"))
                        .expect("Unable to create Bad Request response for missing query parameter date")),
                };

                                let result = api_impl.metrics_ready_state_slash_get(
                                            param_date,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                MetricsReadyStateSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for METRICS_READY_STATE_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                MetricsReadyStateSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for METRICS_READY_STATE_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // TargetingOptionsSlashGet - GET /resources/targeting/{targeting_type}
            hyper::Method::GET if path.matched(paths::ID_RESOURCES_TARGETING_TARGETING_TYPE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_RESOURCES_TARGETING_TARGETING_TYPE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE RESOURCES_TARGETING_TARGETING_TYPE in set but failed match against \"{}\"", path, paths::REGEX_RESOURCES_TARGETING_TARGETING_TYPE.as_str())
                    );

                let param_targeting_type = match percent_encoding::percent_decode(path_params["targeting_type"].as_bytes()).decode_utf8() {
                    Ok(param_targeting_type) => match param_targeting_type.parse::<String>() {
                        Ok(param_targeting_type) => param_targeting_type,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter targeting_type: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["targeting_type"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_client_id = query_params.iter().filter(|e| e.0 == "client_id").map(|e| e.1.clone())
                    .next();
                let param_client_id = match param_client_id {
                    Some(param_client_id) => {
                        let param_client_id =
                            <String as std::str::FromStr>::from_str
                                (&param_client_id);
                        match param_client_id {
                            Ok(param_client_id) => Some(param_client_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter client_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter client_id")),
                        }
                    },
                    None => None,
                };
                let param_oauth_signature = query_params.iter().filter(|e| e.0 == "oauth_signature").map(|e| e.1.clone())
                    .next();
                let param_oauth_signature = match param_oauth_signature {
                    Some(param_oauth_signature) => {
                        let param_oauth_signature =
                            <String as std::str::FromStr>::from_str
                                (&param_oauth_signature);
                        match param_oauth_signature {
                            Ok(param_oauth_signature) => Some(param_oauth_signature),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter oauth_signature - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter oauth_signature")),
                        }
                    },
                    None => None,
                };
                let param_timestamp = query_params.iter().filter(|e| e.0 == "timestamp").map(|e| e.1.clone())
                    .next();
                let param_timestamp = match param_timestamp {
                    Some(param_timestamp) => {
                        let param_timestamp =
                            <String as std::str::FromStr>::from_str
                                (&param_timestamp);
                        match param_timestamp {
                            Ok(param_timestamp) => Some(param_timestamp),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter timestamp - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter timestamp")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.targeting_options_slash_get(
                                            param_targeting_type,
                                            param_client_id,
                                            param_oauth_signature,
                                            param_timestamp,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                TargetingOptionsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for TARGETING_OPTIONS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                TargetingOptionsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for TARGETING_OPTIONS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // SearchPartnerPins - GET /search/partner/pins
            hyper::Method::GET if path.matched(paths::ID_SEARCH_PARTNER_PINS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "pins:read".to_string(), // See your public Pins
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_term = query_params.iter().filter(|e| e.0 == "term").map(|e| e.1.clone())
                    .next();
                let param_term = match param_term {
                    Some(param_term) => {
                        let param_term =
                            <String as std::str::FromStr>::from_str
                                (&param_term);
                        match param_term {
                            Ok(param_term) => Some(param_term),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter term - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter term")),
                        }
                    },
                    None => None,
                };
                let param_term = match param_term {
                    Some(param_term) => param_term,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter term"))
                        .expect("Unable to create Bad Request response for missing query parameter term")),
                };
                let param_country_code = query_params.iter().filter(|e| e.0 == "country_code").map(|e| e.1.clone())
                    .next();
                let param_country_code = match param_country_code {
                    Some(param_country_code) => {
                        let param_country_code =
                            <String as std::str::FromStr>::from_str
                                (&param_country_code);
                        match param_country_code {
                            Ok(param_country_code) => Some(param_country_code),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter country_code - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter country_code")),
                        }
                    },
                    None => None,
                };
                let param_country_code = match param_country_code {
                    Some(param_country_code) => param_country_code,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter country_code"))
                        .expect("Unable to create Bad Request response for missing query parameter country_code")),
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_locale = query_params.iter().filter(|e| e.0 == "locale").map(|e| e.1.clone())
                    .next();
                let param_locale = match param_locale {
                    Some(param_locale) => {
                        let param_locale =
                            <String as std::str::FromStr>::from_str
                                (&param_locale);
                        match param_locale {
                            Ok(param_locale) => Some(param_locale),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter locale - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter locale")),
                        }
                    },
                    None => None,
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.search_partner_pins(
                                            param_term,
                                            param_country_code,
                                            param_bookmark,
                                            param_locale,
                                            param_limit,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                SearchPartnerPinsResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SEARCH_PARTNER_PINS_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SearchPartnerPinsResponse::InvalidPins
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SEARCH_PARTNER_PINS_INVALID_PINS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SearchPartnerPinsResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SEARCH_PARTNER_PINS_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // SearchUserBoardsSlashGet - GET /search/boards
            hyper::Method::GET if path.matched(paths::ID_SEARCH_BOARDS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "boards:read_secret".to_string(), // See your secret boards
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_query = query_params.iter().filter(|e| e.0 == "query").map(|e| e.1.clone())
                    .next();
                let param_query = match param_query {
                    Some(param_query) => {
                        let param_query =
                            <String as std::str::FromStr>::from_str
                                (&param_query);
                        match param_query {
                            Ok(param_query) => Some(param_query),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter query - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter query")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.search_user_boards_slash_get(
                                            param_ad_account_id,
                                            param_bookmark,
                                            param_page_size,
                                            param_query,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                SearchUserBoardsSlashGetResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SEARCH_USER_BOARDS_SLASH_GET_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SearchUserBoardsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SEARCH_USER_BOARDS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // SearchUserPinsSlashList - GET /search/pins
            hyper::Method::GET if path.matched(paths::ID_SEARCH_PINS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "boards:read".to_string(), // See your public boards, including group boards you join
                            "boards:read_secret".to_string(), // See your secret boards
                            "pins:read".to_string(), // See your public Pins
                            "pins:read_secret".to_string(), // See your secret Pins
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };
                let param_query = query_params.iter().filter(|e| e.0 == "query").map(|e| e.1.clone())
                    .next();
                let param_query = match param_query {
                    Some(param_query) => {
                        let param_query =
                            <String as std::str::FromStr>::from_str
                                (&param_query);
                        match param_query {
                            Ok(param_query) => Some(param_query),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter query - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter query")),
                        }
                    },
                    None => None,
                };
                let param_query = match param_query {
                    Some(param_query) => param_query,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter query"))
                        .expect("Unable to create Bad Request response for missing query parameter query")),
                };
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.search_user_pins_slash_list(
                                            param_query,
                                            param_ad_account_id,
                                            param_bookmark,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                SearchUserPinsSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SEARCH_USER_PINS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SearchUserPinsSlashListResponse::UserNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SEARCH_USER_PINS_SLASH_LIST_USER_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                SearchUserPinsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for SEARCH_USER_PINS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // TermsRelatedSlashList - GET /terms/related
            hyper::Method::GET if path.matched(paths::ID_TERMS_RELATED) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_terms = query_params.iter().filter(|e| e.0 == "terms").map(|e| e.1.clone())
                    .filter_map(|param_terms| param_terms.parse().ok())
                    .collect::<Vec<_>>();

                                let result = api_impl.terms_related_slash_list(
                                            param_terms.as_ref(),
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                TermsRelatedSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for TERMS_RELATED_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                TermsRelatedSlashListResponse::InvalidTermsRelatedParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for TERMS_RELATED_SLASH_LIST_INVALID_TERMS_RELATED_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                TermsRelatedSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for TERMS_RELATED_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // TermsSuggestedSlashList - GET /terms/suggested
            hyper::Method::GET if path.matched(paths::ID_TERMS_SUGGESTED) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_term = query_params.iter().filter(|e| e.0 == "term").map(|e| e.1.clone())
                    .next();
                let param_term = match param_term {
                    Some(param_term) => {
                        let param_term =
                            <String as std::str::FromStr>::from_str
                                (&param_term);
                        match param_term {
                            Ok(param_term) => Some(param_term),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter term - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter term")),
                        }
                    },
                    None => None,
                };
                let param_term = match param_term {
                    Some(param_term) => param_term,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter term"))
                        .expect("Unable to create Bad Request response for missing query parameter term")),
                };
                let param_limit = query_params.iter().filter(|e| e.0 == "limit").map(|e| e.1.clone())
                    .next();
                let param_limit = match param_limit {
                    Some(param_limit) => {
                        let param_limit =
                            <i32 as std::str::FromStr>::from_str
                                (&param_limit);
                        match param_limit {
                            Ok(param_limit) => Some(param_limit),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter limit - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter limit")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.terms_suggested_slash_list(
                                            param_term,
                                            param_limit,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                TermsSuggestedSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for TERMS_SUGGESTED_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                TermsSuggestedSlashListResponse::InvalidTermsSuggestedParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for TERMS_SUGGESTED_SLASH_LIST_INVALID_TERMS_SUGGESTED_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                TermsSuggestedSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for TERMS_SUGGESTED_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // TermsOfServiceSlashGet - GET /ad_accounts/{ad_account_id}/terms_of_service
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_TERMS_OF_SERVICE) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "ads:read".to_string(), // See all of your advertising data, including ads, ad groups, campaigns etc.
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_TERMS_OF_SERVICE
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE AD_ACCOUNTS_AD_ACCOUNT_ID_TERMS_OF_SERVICE in set but failed match against \"{}\"", path, paths::REGEX_AD_ACCOUNTS_AD_ACCOUNT_ID_TERMS_OF_SERVICE.as_str())
                    );

                let param_ad_account_id = match percent_encoding::percent_decode(path_params["ad_account_id"].as_bytes()).decode_utf8() {
                    Ok(param_ad_account_id) => match param_ad_account_id.parse::<String>() {
                        Ok(param_ad_account_id) => param_ad_account_id,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter ad_account_id: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["ad_account_id"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_include_html = query_params.iter().filter(|e| e.0 == "include_html").map(|e| e.1.clone())
                    .next();
                let param_include_html = match param_include_html {
                    Some(param_include_html) => {
                        let param_include_html =
                            <bool as std::str::FromStr>::from_str
                                (&param_include_html);
                        match param_include_html {
                            Ok(param_include_html) => Some(param_include_html),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter include_html - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter include_html")),
                        }
                    },
                    None => None,
                };
                let param_tos_type = query_params.iter().filter(|e| e.0 == "tos_type").map(|e| e.1.clone())
                    .next();
                let param_tos_type = match param_tos_type {
                    Some(param_tos_type) => {
                        let param_tos_type =
                            <String as std::str::FromStr>::from_str
                                (&param_tos_type);
                        match param_tos_type {
                            Ok(param_tos_type) => Some(param_tos_type),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter tos_type - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter tos_type")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.terms_of_service_slash_get(
                                            param_ad_account_id,
                                            param_include_html,
                                            param_tos_type,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                TermsOfServiceSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for TERMS_OF_SERVICE_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                TermsOfServiceSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for TERMS_OF_SERVICE_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // BoardsUserFollowsSlashList - GET /user_account/following/boards
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_FOLLOWING_BOARDS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "user_accounts:read".to_string(), // See your user accounts and followers
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_explicit_following = query_params.iter().filter(|e| e.0 == "explicit_following").map(|e| e.1.clone())
                    .next();
                let param_explicit_following = match param_explicit_following {
                    Some(param_explicit_following) => {
                        let param_explicit_following =
                            <bool as std::str::FromStr>::from_str
                                (&param_explicit_following);
                        match param_explicit_following {
                            Ok(param_explicit_following) => Some(param_explicit_following),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter explicit_following - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter explicit_following")),
                        }
                    },
                    None => None,
                };
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.boards_user_follows_slash_list(
                                            param_bookmark,
                                            param_page_size,
                                            param_explicit_following,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                BoardsUserFollowsSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_USER_FOLLOWS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardsUserFollowsSlashListResponse::InvalidUserId
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_USER_FOLLOWS_SLASH_LIST_INVALID_USER_ID"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                BoardsUserFollowsSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for BOARDS_USER_FOLLOWS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // FollowUserSlashUpdate - POST /user_account/following/{username}
            hyper::Method::POST if path.matched(paths::ID_USER_ACCOUNT_FOLLOWING_USERNAME) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "user_accounts:write".to_string(), // Update your user accounts and followers
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_USER_ACCOUNT_FOLLOWING_USERNAME
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE USER_ACCOUNT_FOLLOWING_USERNAME in set but failed match against \"{}\"", path, paths::REGEX_USER_ACCOUNT_FOLLOWING_USERNAME.as_str())
                    );

                let param_username = match percent_encoding::percent_decode(path_params["username"].as_bytes()).decode_utf8() {
                    Ok(param_username) => match param_username.parse::<String>() {
                        Ok(param_username) => param_username,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter username: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["username"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_follow_user_request: Option<models::FollowUserRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_follow_user_request) => param_follow_user_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter FollowUserRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter FollowUserRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_follow_user_request = match param_follow_user_request {
                                    Some(param_follow_user_request) => param_follow_user_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter FollowUserRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter FollowUserRequest")),
                                };

                                let result = api_impl.follow_user_slash_update(
                                            param_username,
                                            param_follow_user_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                FollowUserSlashUpdateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FOLLOW_USER_SLASH_UPDATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FollowUserSlashUpdateResponse::UserNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FOLLOW_USER_SLASH_UPDATE_USER_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FollowUserSlashUpdateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FOLLOW_USER_SLASH_UPDATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter FollowUserRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter FollowUserRequest")),
                        }
            },

            // FollowersSlashList - GET /user_account/followers
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_FOLLOWERS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "user_accounts:read".to_string(), // See your user accounts and followers
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.followers_slash_list(
                                            param_bookmark,
                                            param_page_size,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                FollowersSlashListResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FOLLOWERS_SLASH_LIST_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FollowersSlashListResponse::InvalidUserId
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FOLLOWERS_SLASH_LIST_INVALID_USER_ID"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                FollowersSlashListResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for FOLLOWERS_SLASH_LIST_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // LinkedBusinessAccountsSlashGet - GET /user_account/businesses
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_BUSINESSES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "user_accounts:read".to_string(), // See your user accounts and followers
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                                let result = api_impl.linked_business_accounts_slash_get(
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                LinkedBusinessAccountsSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LINKED_BUSINESS_ACCOUNTS_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                LinkedBusinessAccountsSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for LINKED_BUSINESS_ACCOUNTS_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // UnverifyWebsiteSlashDelete - DELETE /user_account/websites
            hyper::Method::DELETE if path.matched(paths::ID_USER_ACCOUNT_WEBSITES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "user_accounts:write".to_string(), // Update your user accounts and followers
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_website = query_params.iter().filter(|e| e.0 == "website").map(|e| e.1.clone())
                    .next();
                let param_website = match param_website {
                    Some(param_website) => {
                        let param_website =
                            <String as std::str::FromStr>::from_str
                                (&param_website);
                        match param_website {
                            Ok(param_website) => Some(param_website),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter website - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter website")),
                        }
                    },
                    None => None,
                };
                let param_website = match param_website {
                    Some(param_website) => param_website,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter website"))
                        .expect("Unable to create Bad Request response for missing query parameter website")),
                };

                                let result = api_impl.unverify_website_slash_delete(
                                            param_website,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                UnverifyWebsiteSlashDeleteResponse::SuccessfullyUnverifiedWebsite
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(204).expect("Unable to turn 204 into a StatusCode");
                                                },
                                                UnverifyWebsiteSlashDeleteResponse::WebsiteNotInUserList
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UNVERIFY_WEBSITE_SLASH_DELETE_WEBSITE_NOT_IN_USER_LIST"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                UnverifyWebsiteSlashDeleteResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for UNVERIFY_WEBSITE_SLASH_DELETE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // UserAccountSlashAnalytics - GET /user_account/analytics
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_ANALYTICS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "user_accounts:read".to_string(), // See your user accounts and followers
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_start_date = query_params.iter().filter(|e| e.0 == "start_date").map(|e| e.1.clone())
                    .next();
                let param_start_date = match param_start_date {
                    Some(param_start_date) => {
                        let param_start_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_start_date);
                        match param_start_date {
                            Ok(param_start_date) => Some(param_start_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter start_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter start_date")),
                        }
                    },
                    None => None,
                };
                let param_start_date = match param_start_date {
                    Some(param_start_date) => param_start_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter start_date"))
                        .expect("Unable to create Bad Request response for missing query parameter start_date")),
                };
                let param_end_date = query_params.iter().filter(|e| e.0 == "end_date").map(|e| e.1.clone())
                    .next();
                let param_end_date = match param_end_date {
                    Some(param_end_date) => {
                        let param_end_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_end_date);
                        match param_end_date {
                            Ok(param_end_date) => Some(param_end_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter end_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter end_date")),
                        }
                    },
                    None => None,
                };
                let param_end_date = match param_end_date {
                    Some(param_end_date) => param_end_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter end_date"))
                        .expect("Unable to create Bad Request response for missing query parameter end_date")),
                };
                let param_from_claimed_content = query_params.iter().filter(|e| e.0 == "from_claimed_content").map(|e| e.1.clone())
                    .next();
                let param_from_claimed_content = match param_from_claimed_content {
                    Some(param_from_claimed_content) => {
                        let param_from_claimed_content =
                            <String as std::str::FromStr>::from_str
                                (&param_from_claimed_content);
                        match param_from_claimed_content {
                            Ok(param_from_claimed_content) => Some(param_from_claimed_content),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter from_claimed_content - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter from_claimed_content")),
                        }
                    },
                    None => None,
                };
                let param_pin_format = query_params.iter().filter(|e| e.0 == "pin_format").map(|e| e.1.clone())
                    .next();
                let param_pin_format = match param_pin_format {
                    Some(param_pin_format) => {
                        let param_pin_format =
                            <String as std::str::FromStr>::from_str
                                (&param_pin_format);
                        match param_pin_format {
                            Ok(param_pin_format) => Some(param_pin_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter pin_format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter pin_format")),
                        }
                    },
                    None => None,
                };
                let param_app_types = query_params.iter().filter(|e| e.0 == "app_types").map(|e| e.1.clone())
                    .next();
                let param_app_types = match param_app_types {
                    Some(param_app_types) => {
                        let param_app_types =
                            <String as std::str::FromStr>::from_str
                                (&param_app_types);
                        match param_app_types {
                            Ok(param_app_types) => Some(param_app_types),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter app_types - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter app_types")),
                        }
                    },
                    None => None,
                };
                let param_content_type = query_params.iter().filter(|e| e.0 == "content_type").map(|e| e.1.clone())
                    .next();
                let param_content_type = match param_content_type {
                    Some(param_content_type) => {
                        let param_content_type =
                            <String as std::str::FromStr>::from_str
                                (&param_content_type);
                        match param_content_type {
                            Ok(param_content_type) => Some(param_content_type),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter content_type - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter content_type")),
                        }
                    },
                    None => None,
                };
                let param_source = query_params.iter().filter(|e| e.0 == "source").map(|e| e.1.clone())
                    .next();
                let param_source = match param_source {
                    Some(param_source) => {
                        let param_source =
                            <String as std::str::FromStr>::from_str
                                (&param_source);
                        match param_source {
                            Ok(param_source) => Some(param_source),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter source - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter source")),
                        }
                    },
                    None => None,
                };
                let param_metric_types = query_params.iter().filter(|e| e.0 == "metric_types").map(|e| e.1.clone())
                    .filter_map(|param_metric_types| param_metric_types.parse().ok())
                    .collect::<Vec<_>>();
                let param_metric_types = if !param_metric_types.is_empty() {
                    Some(param_metric_types)
                } else {
                    None
                };
                let param_split_field = query_params.iter().filter(|e| e.0 == "split_field").map(|e| e.1.clone())
                    .next();
                let param_split_field = match param_split_field {
                    Some(param_split_field) => {
                        let param_split_field =
                            <String as std::str::FromStr>::from_str
                                (&param_split_field);
                        match param_split_field {
                            Ok(param_split_field) => Some(param_split_field),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter split_field - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter split_field")),
                        }
                    },
                    None => None,
                };
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.user_account_slash_analytics(
                                            param_start_date,
                                            param_end_date,
                                            param_from_claimed_content,
                                            param_pin_format,
                                            param_app_types,
                                            param_content_type,
                                            param_source,
                                            param_metric_types.as_ref(),
                                            param_split_field,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                UserAccountSlashAnalyticsResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_ANALYTICS_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                UserAccountSlashAnalyticsResponse::InvalidUserAccountsAnalyticsParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_ANALYTICS_INVALID_USER_ACCOUNTS_ANALYTICS_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                UserAccountSlashAnalyticsResponse::NotAuthorizedToAccessTheUserAccountAnalytics
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_ANALYTICS_NOT_AUTHORIZED_TO_ACCESS_THE_USER_ACCOUNT_ANALYTICS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                UserAccountSlashAnalyticsResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_ANALYTICS_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // UserAccountSlashAnalyticsSlashTopPins - GET /user_account/analytics/top_pins
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_ANALYTICS_TOP_PINS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "pins:read".to_string(), // See your public Pins
                            "user_accounts:read".to_string(), // See your user accounts and followers
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_start_date = query_params.iter().filter(|e| e.0 == "start_date").map(|e| e.1.clone())
                    .next();
                let param_start_date = match param_start_date {
                    Some(param_start_date) => {
                        let param_start_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_start_date);
                        match param_start_date {
                            Ok(param_start_date) => Some(param_start_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter start_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter start_date")),
                        }
                    },
                    None => None,
                };
                let param_start_date = match param_start_date {
                    Some(param_start_date) => param_start_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter start_date"))
                        .expect("Unable to create Bad Request response for missing query parameter start_date")),
                };
                let param_end_date = query_params.iter().filter(|e| e.0 == "end_date").map(|e| e.1.clone())
                    .next();
                let param_end_date = match param_end_date {
                    Some(param_end_date) => {
                        let param_end_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_end_date);
                        match param_end_date {
                            Ok(param_end_date) => Some(param_end_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter end_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter end_date")),
                        }
                    },
                    None => None,
                };
                let param_end_date = match param_end_date {
                    Some(param_end_date) => param_end_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter end_date"))
                        .expect("Unable to create Bad Request response for missing query parameter end_date")),
                };
                let param_sort_by = query_params.iter().filter(|e| e.0 == "sort_by").map(|e| e.1.clone())
                    .next();
                let param_sort_by = match param_sort_by {
                    Some(param_sort_by) => {
                        let param_sort_by =
                            <String as std::str::FromStr>::from_str
                                (&param_sort_by);
                        match param_sort_by {
                            Ok(param_sort_by) => Some(param_sort_by),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter sort_by - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter sort_by")),
                        }
                    },
                    None => None,
                };
                let param_sort_by = match param_sort_by {
                    Some(param_sort_by) => param_sort_by,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter sort_by"))
                        .expect("Unable to create Bad Request response for missing query parameter sort_by")),
                };
                let param_from_claimed_content = query_params.iter().filter(|e| e.0 == "from_claimed_content").map(|e| e.1.clone())
                    .next();
                let param_from_claimed_content = match param_from_claimed_content {
                    Some(param_from_claimed_content) => {
                        let param_from_claimed_content =
                            <String as std::str::FromStr>::from_str
                                (&param_from_claimed_content);
                        match param_from_claimed_content {
                            Ok(param_from_claimed_content) => Some(param_from_claimed_content),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter from_claimed_content - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter from_claimed_content")),
                        }
                    },
                    None => None,
                };
                let param_pin_format = query_params.iter().filter(|e| e.0 == "pin_format").map(|e| e.1.clone())
                    .next();
                let param_pin_format = match param_pin_format {
                    Some(param_pin_format) => {
                        let param_pin_format =
                            <String as std::str::FromStr>::from_str
                                (&param_pin_format);
                        match param_pin_format {
                            Ok(param_pin_format) => Some(param_pin_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter pin_format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter pin_format")),
                        }
                    },
                    None => None,
                };
                let param_app_types = query_params.iter().filter(|e| e.0 == "app_types").map(|e| e.1.clone())
                    .next();
                let param_app_types = match param_app_types {
                    Some(param_app_types) => {
                        let param_app_types =
                            <String as std::str::FromStr>::from_str
                                (&param_app_types);
                        match param_app_types {
                            Ok(param_app_types) => Some(param_app_types),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter app_types - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter app_types")),
                        }
                    },
                    None => None,
                };
                let param_content_type = query_params.iter().filter(|e| e.0 == "content_type").map(|e| e.1.clone())
                    .next();
                let param_content_type = match param_content_type {
                    Some(param_content_type) => {
                        let param_content_type =
                            <String as std::str::FromStr>::from_str
                                (&param_content_type);
                        match param_content_type {
                            Ok(param_content_type) => Some(param_content_type),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter content_type - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter content_type")),
                        }
                    },
                    None => None,
                };
                let param_source = query_params.iter().filter(|e| e.0 == "source").map(|e| e.1.clone())
                    .next();
                let param_source = match param_source {
                    Some(param_source) => {
                        let param_source =
                            <String as std::str::FromStr>::from_str
                                (&param_source);
                        match param_source {
                            Ok(param_source) => Some(param_source),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter source - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter source")),
                        }
                    },
                    None => None,
                };
                let param_metric_types = query_params.iter().filter(|e| e.0 == "metric_types").map(|e| e.1.clone())
                    .filter_map(|param_metric_types| param_metric_types.parse().ok())
                    .collect::<Vec<_>>();
                let param_metric_types = if !param_metric_types.is_empty() {
                    Some(param_metric_types)
                } else {
                    None
                };
                let param_num_of_pins = query_params.iter().filter(|e| e.0 == "num_of_pins").map(|e| e.1.clone())
                    .next();
                let param_num_of_pins = match param_num_of_pins {
                    Some(param_num_of_pins) => {
                        let param_num_of_pins =
                            <i32 as std::str::FromStr>::from_str
                                (&param_num_of_pins);
                        match param_num_of_pins {
                            Ok(param_num_of_pins) => Some(param_num_of_pins),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter num_of_pins - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter num_of_pins")),
                        }
                    },
                    None => None,
                };
                let param_created_in_last_n_days = query_params.iter().filter(|e| e.0 == "created_in_last_n_days").map(|e| e.1.clone())
                    .next();
                let param_created_in_last_n_days = match param_created_in_last_n_days {
                    Some(param_created_in_last_n_days) => {
                        let param_created_in_last_n_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_created_in_last_n_days);
                        match param_created_in_last_n_days {
                            Ok(param_created_in_last_n_days) => Some(param_created_in_last_n_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter created_in_last_n_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter created_in_last_n_days")),
                        }
                    },
                    None => None,
                };
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.user_account_slash_analytics_slash_top_pins(
                                            param_start_date,
                                            param_end_date,
                                            param_sort_by,
                                            param_from_claimed_content,
                                            param_pin_format,
                                            param_app_types,
                                            param_content_type,
                                            param_source,
                                            param_metric_types.as_ref(),
                                            param_num_of_pins,
                                            param_created_in_last_n_days,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                UserAccountSlashAnalyticsSlashTopPinsResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_ANALYTICS_SLASH_TOP_PINS_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                UserAccountSlashAnalyticsSlashTopPinsResponse::NotAuthorizedToAccessTheUserAccountAnalytics
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_ANALYTICS_SLASH_TOP_PINS_NOT_AUTHORIZED_TO_ACCESS_THE_USER_ACCOUNT_ANALYTICS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                UserAccountSlashAnalyticsSlashTopPinsResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_ANALYTICS_SLASH_TOP_PINS_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // UserAccountSlashAnalyticsSlashTopVideoPins - GET /user_account/analytics/top_video_pins
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_ANALYTICS_TOP_VIDEO_PINS) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "pins:read".to_string(), // See your public Pins
                            "user_accounts:read".to_string(), // See your user accounts and followers
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_start_date = query_params.iter().filter(|e| e.0 == "start_date").map(|e| e.1.clone())
                    .next();
                let param_start_date = match param_start_date {
                    Some(param_start_date) => {
                        let param_start_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_start_date);
                        match param_start_date {
                            Ok(param_start_date) => Some(param_start_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter start_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter start_date")),
                        }
                    },
                    None => None,
                };
                let param_start_date = match param_start_date {
                    Some(param_start_date) => param_start_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter start_date"))
                        .expect("Unable to create Bad Request response for missing query parameter start_date")),
                };
                let param_end_date = query_params.iter().filter(|e| e.0 == "end_date").map(|e| e.1.clone())
                    .next();
                let param_end_date = match param_end_date {
                    Some(param_end_date) => {
                        let param_end_date =
                            <chrono::naive::NaiveDate as std::str::FromStr>::from_str
                                (&param_end_date);
                        match param_end_date {
                            Ok(param_end_date) => Some(param_end_date),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter end_date - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter end_date")),
                        }
                    },
                    None => None,
                };
                let param_end_date = match param_end_date {
                    Some(param_end_date) => param_end_date,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter end_date"))
                        .expect("Unable to create Bad Request response for missing query parameter end_date")),
                };
                let param_sort_by = query_params.iter().filter(|e| e.0 == "sort_by").map(|e| e.1.clone())
                    .next();
                let param_sort_by = match param_sort_by {
                    Some(param_sort_by) => {
                        let param_sort_by =
                            <String as std::str::FromStr>::from_str
                                (&param_sort_by);
                        match param_sort_by {
                            Ok(param_sort_by) => Some(param_sort_by),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter sort_by - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter sort_by")),
                        }
                    },
                    None => None,
                };
                let param_sort_by = match param_sort_by {
                    Some(param_sort_by) => param_sort_by,
                    None => return Ok(Response::builder()
                        .status(StatusCode::BAD_REQUEST)
                        .body(Body::from("Missing required query parameter sort_by"))
                        .expect("Unable to create Bad Request response for missing query parameter sort_by")),
                };
                let param_from_claimed_content = query_params.iter().filter(|e| e.0 == "from_claimed_content").map(|e| e.1.clone())
                    .next();
                let param_from_claimed_content = match param_from_claimed_content {
                    Some(param_from_claimed_content) => {
                        let param_from_claimed_content =
                            <String as std::str::FromStr>::from_str
                                (&param_from_claimed_content);
                        match param_from_claimed_content {
                            Ok(param_from_claimed_content) => Some(param_from_claimed_content),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter from_claimed_content - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter from_claimed_content")),
                        }
                    },
                    None => None,
                };
                let param_pin_format = query_params.iter().filter(|e| e.0 == "pin_format").map(|e| e.1.clone())
                    .next();
                let param_pin_format = match param_pin_format {
                    Some(param_pin_format) => {
                        let param_pin_format =
                            <String as std::str::FromStr>::from_str
                                (&param_pin_format);
                        match param_pin_format {
                            Ok(param_pin_format) => Some(param_pin_format),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter pin_format - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter pin_format")),
                        }
                    },
                    None => None,
                };
                let param_app_types = query_params.iter().filter(|e| e.0 == "app_types").map(|e| e.1.clone())
                    .next();
                let param_app_types = match param_app_types {
                    Some(param_app_types) => {
                        let param_app_types =
                            <String as std::str::FromStr>::from_str
                                (&param_app_types);
                        match param_app_types {
                            Ok(param_app_types) => Some(param_app_types),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter app_types - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter app_types")),
                        }
                    },
                    None => None,
                };
                let param_content_type = query_params.iter().filter(|e| e.0 == "content_type").map(|e| e.1.clone())
                    .next();
                let param_content_type = match param_content_type {
                    Some(param_content_type) => {
                        let param_content_type =
                            <String as std::str::FromStr>::from_str
                                (&param_content_type);
                        match param_content_type {
                            Ok(param_content_type) => Some(param_content_type),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter content_type - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter content_type")),
                        }
                    },
                    None => None,
                };
                let param_source = query_params.iter().filter(|e| e.0 == "source").map(|e| e.1.clone())
                    .next();
                let param_source = match param_source {
                    Some(param_source) => {
                        let param_source =
                            <String as std::str::FromStr>::from_str
                                (&param_source);
                        match param_source {
                            Ok(param_source) => Some(param_source),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter source - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter source")),
                        }
                    },
                    None => None,
                };
                let param_metric_types = query_params.iter().filter(|e| e.0 == "metric_types").map(|e| e.1.clone())
                    .filter_map(|param_metric_types| param_metric_types.parse().ok())
                    .collect::<Vec<_>>();
                let param_metric_types = if !param_metric_types.is_empty() {
                    Some(param_metric_types)
                } else {
                    None
                };
                let param_num_of_pins = query_params.iter().filter(|e| e.0 == "num_of_pins").map(|e| e.1.clone())
                    .next();
                let param_num_of_pins = match param_num_of_pins {
                    Some(param_num_of_pins) => {
                        let param_num_of_pins =
                            <i32 as std::str::FromStr>::from_str
                                (&param_num_of_pins);
                        match param_num_of_pins {
                            Ok(param_num_of_pins) => Some(param_num_of_pins),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter num_of_pins - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter num_of_pins")),
                        }
                    },
                    None => None,
                };
                let param_created_in_last_n_days = query_params.iter().filter(|e| e.0 == "created_in_last_n_days").map(|e| e.1.clone())
                    .next();
                let param_created_in_last_n_days = match param_created_in_last_n_days {
                    Some(param_created_in_last_n_days) => {
                        let param_created_in_last_n_days =
                            <i32 as std::str::FromStr>::from_str
                                (&param_created_in_last_n_days);
                        match param_created_in_last_n_days {
                            Ok(param_created_in_last_n_days) => Some(param_created_in_last_n_days),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter created_in_last_n_days - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter created_in_last_n_days")),
                        }
                    },
                    None => None,
                };
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.user_account_slash_analytics_slash_top_video_pins(
                                            param_start_date,
                                            param_end_date,
                                            param_sort_by,
                                            param_from_claimed_content,
                                            param_pin_format,
                                            param_app_types,
                                            param_content_type,
                                            param_source,
                                            param_metric_types.as_ref(),
                                            param_num_of_pins,
                                            param_created_in_last_n_days,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                UserAccountSlashAnalyticsSlashTopVideoPinsResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_ANALYTICS_SLASH_TOP_VIDEO_PINS_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                UserAccountSlashAnalyticsSlashTopVideoPinsResponse::NotAuthorizedToAccessTheUserAccountAnalytics
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_ANALYTICS_SLASH_TOP_VIDEO_PINS_NOT_AUTHORIZED_TO_ACCESS_THE_USER_ACCOUNT_ANALYTICS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                UserAccountSlashAnalyticsSlashTopVideoPinsResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_ANALYTICS_SLASH_TOP_VIDEO_PINS_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // UserAccountSlashFollowedInterests - GET /users/{username}/interests/follow
            hyper::Method::GET if path.matched(paths::ID_USERS_USERNAME_INTERESTS_FOLLOW) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "user_accounts:read".to_string(), // See your user accounts and followers
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Path parameters
                let path: &str = uri.path();
                let path_params =
                    paths::REGEX_USERS_USERNAME_INTERESTS_FOLLOW
                    .captures(path)
                    .unwrap_or_else(||
                        panic!("Path {} matched RE USERS_USERNAME_INTERESTS_FOLLOW in set but failed match against \"{}\"", path, paths::REGEX_USERS_USERNAME_INTERESTS_FOLLOW.as_str())
                    );

                let param_username = match percent_encoding::percent_decode(path_params["username"].as_bytes()).decode_utf8() {
                    Ok(param_username) => match param_username.parse::<String>() {
                        Ok(param_username) => param_username,
                        Err(e) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't parse path parameter username: {}", e)))
                                        .expect("Unable to create Bad Request response for invalid path parameter")),
                    },
                    Err(_) => return Ok(Response::builder()
                                        .status(StatusCode::BAD_REQUEST)
                                        .body(Body::from(format!("Couldn't percent-decode path parameter as UTF-8: {}", &path_params["username"])))
                                        .expect("Unable to create Bad Request response for invalid percent decode"))
                };

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.user_account_slash_followed_interests(
                                            param_username,
                                            param_bookmark,
                                            param_page_size,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                UserAccountSlashFollowedInterestsResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_FOLLOWED_INTERESTS_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                UserAccountSlashFollowedInterestsResponse::InvalidParameters
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(400).expect("Unable to turn 400 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_FOLLOWED_INTERESTS_INVALID_PARAMETERS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                UserAccountSlashFollowedInterestsResponse::AuthorizationFailed
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(401).expect("Unable to turn 401 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_FOLLOWED_INTERESTS_AUTHORIZATION_FAILED"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                UserAccountSlashFollowedInterestsResponse::UserNotFound
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(404).expect("Unable to turn 404 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_FOLLOWED_INTERESTS_USER_NOT_FOUND"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                UserAccountSlashFollowedInterestsResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_FOLLOWED_INTERESTS_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // UserAccountSlashGet - GET /user_account
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "user_accounts:read".to_string(), // See your user accounts and followers
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.user_account_slash_get(
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                UserAccountSlashGetResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_GET_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                UserAccountSlashGetResponse::NotAuthorizedToAccessTheUserAccount
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_GET_NOT_AUTHORIZED_TO_ACCESS_THE_USER_ACCOUNT"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                UserAccountSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_ACCOUNT_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // UserFollowingSlashGet - GET /user_account/following
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_FOLLOWING) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "user_accounts:read".to_string(), // See your user accounts and followers
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };
                let param_feed_type = query_params.iter().filter(|e| e.0 == "feed_type").map(|e| e.1.clone())
                    .next();
                let param_feed_type = match param_feed_type {
                    Some(param_feed_type) => {
                        let param_feed_type =
                            <models::UserFollowingFeedType as std::str::FromStr>::from_str
                                (&param_feed_type);
                        match param_feed_type {
                            Ok(param_feed_type) => Some(param_feed_type),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter feed_type - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter feed_type")),
                        }
                    },
                    None => None,
                };
                let param_explicit_following = query_params.iter().filter(|e| e.0 == "explicit_following").map(|e| e.1.clone())
                    .next();
                let param_explicit_following = match param_explicit_following {
                    Some(param_explicit_following) => {
                        let param_explicit_following =
                            <bool as std::str::FromStr>::from_str
                                (&param_explicit_following);
                        match param_explicit_following {
                            Ok(param_explicit_following) => Some(param_explicit_following),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter explicit_following - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter explicit_following")),
                        }
                    },
                    None => None,
                };
                let param_ad_account_id = query_params.iter().filter(|e| e.0 == "ad_account_id").map(|e| e.1.clone())
                    .next();
                let param_ad_account_id = match param_ad_account_id {
                    Some(param_ad_account_id) => {
                        let param_ad_account_id =
                            <String as std::str::FromStr>::from_str
                                (&param_ad_account_id);
                        match param_ad_account_id {
                            Ok(param_ad_account_id) => Some(param_ad_account_id),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter ad_account_id - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter ad_account_id")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.user_following_slash_get(
                                            param_bookmark,
                                            param_page_size,
                                            param_feed_type,
                                            param_explicit_following,
                                            param_ad_account_id,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                UserFollowingSlashGetResponse::Response
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_FOLLOWING_SLASH_GET_RESPONSE"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                UserFollowingSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_FOLLOWING_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // UserWebsitesSlashGet - GET /user_account/websites
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_WEBSITES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "user_accounts:read".to_string(), // See your user accounts and followers
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Query parameters (note that non-required or collection query parameters will ignore garbage values, rather than causing a 400 response)
                let query_params = form_urlencoded::parse(uri.query().unwrap_or_default().as_bytes()).collect::<Vec<_>>();
                let param_bookmark = query_params.iter().filter(|e| e.0 == "bookmark").map(|e| e.1.clone())
                    .next();
                let param_bookmark = match param_bookmark {
                    Some(param_bookmark) => {
                        let param_bookmark =
                            <String as std::str::FromStr>::from_str
                                (&param_bookmark);
                        match param_bookmark {
                            Ok(param_bookmark) => Some(param_bookmark),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter bookmark - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter bookmark")),
                        }
                    },
                    None => None,
                };
                let param_page_size = query_params.iter().filter(|e| e.0 == "page_size").map(|e| e.1.clone())
                    .next();
                let param_page_size = match param_page_size {
                    Some(param_page_size) => {
                        let param_page_size =
                            <i32 as std::str::FromStr>::from_str
                                (&param_page_size);
                        match param_page_size {
                            Ok(param_page_size) => Some(param_page_size),
                            Err(e) => return Ok(Response::builder()
                                .status(StatusCode::BAD_REQUEST)
                                .body(Body::from(format!("Couldn't parse query parameter page_size - doesn't match schema: {}", e)))
                                .expect("Unable to create Bad Request response for invalid query parameter page_size")),
                        }
                    },
                    None => None,
                };

                                let result = api_impl.user_websites_slash_get(
                                            param_bookmark,
                                            param_page_size,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                UserWebsitesSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_WEBSITES_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                UserWebsitesSlashGetResponse::NotAuthorizedToAccessTheUserWebsiteList
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_WEBSITES_SLASH_GET_NOT_AUTHORIZED_TO_ACCESS_THE_USER_WEBSITE_LIST"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                UserWebsitesSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for USER_WEBSITES_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            // VerifyWebsiteSlashUpdate - POST /user_account/websites
            hyper::Method::POST if path.matched(paths::ID_USER_ACCOUNT_WEBSITES) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "user_accounts:write".to_string(), // Update your user accounts and followers
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                // Body parameters (note that non-required body parameters will ignore garbage
                // values, rather than causing a 400 response). Produce warning header and logs for
                // any unused fields.
                let result = body.into_raw().await;
                match result {
                            Ok(body) => {
                                let mut unused_elements = Vec::new();
                                let param_user_website_verify_request: Option<models::UserWebsiteVerifyRequest> = if !body.is_empty() {
                                    let deserializer = &mut serde_json::Deserializer::from_slice(&body);
                                    match serde_ignored::deserialize(deserializer, |path| {
                                            warn!("Ignoring unknown field in body: {}", path);
                                            unused_elements.push(path.to_string());
                                    }) {
                                        Ok(param_user_website_verify_request) => param_user_website_verify_request,
                                        Err(e) => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from(format!("Couldn't parse body parameter UserWebsiteVerifyRequest - doesn't match schema: {}", e)))
                                                        .expect("Unable to create Bad Request response for invalid body parameter UserWebsiteVerifyRequest due to schema")),
                                    }
                                } else {
                                    None
                                };
                                let param_user_website_verify_request = match param_user_website_verify_request {
                                    Some(param_user_website_verify_request) => param_user_website_verify_request,
                                    None => return Ok(Response::builder()
                                                        .status(StatusCode::BAD_REQUEST)
                                                        .body(Body::from("Missing required body parameter UserWebsiteVerifyRequest"))
                                                        .expect("Unable to create Bad Request response for missing body parameter UserWebsiteVerifyRequest")),
                                };

                                let result = api_impl.verify_website_slash_update(
                                            param_user_website_verify_request,
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        if !unused_elements.is_empty() {
                                            response.headers_mut().insert(
                                                HeaderName::from_static("warning"),
                                                HeaderValue::from_str(format!("Ignoring unknown fields in body: {:?}", unused_elements).as_str())
                                                    .expect("Unable to create Warning header value"));
                                        }

                                        match result {
                                            Ok(rsp) => match rsp {
                                                VerifyWebsiteSlashUpdateResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for VERIFY_WEBSITE_SLASH_UPDATE_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                VerifyWebsiteSlashUpdateResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for VERIFY_WEBSITE_SLASH_UPDATE_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
                            },
                            Err(e) => Ok(Response::builder()
                                                .status(StatusCode::BAD_REQUEST)
                                                .body(Body::from(format!("Couldn't read body parameter UserWebsiteVerifyRequest: {}", e)))
                                                .expect("Unable to create Bad Request response due to unable to read body parameter UserWebsiteVerifyRequest")),
                        }
            },

            // WebsiteVerificationSlashGet - GET /user_account/websites/verification
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_WEBSITES_VERIFICATION) => {
                {
                    let authorization = match *(&context as &dyn Has<Option<Authorization>>).get() {
                        Some(ref authorization) => authorization,
                        None => return Ok(Response::builder()
                                                .status(StatusCode::FORBIDDEN)
                                                .body(Body::from("Unauthenticated"))
                                                .expect("Unable to create Authentication Forbidden response")),
                    };

                    // Authorization
                    if let Scopes::Some(ref scopes) = authorization.scopes {
                        let required_scopes: std::collections::BTreeSet<String> = vec![
                            "user_accounts:read".to_string(), // See your user accounts and followers
                        ].into_iter().collect();

                        if !required_scopes.is_subset(scopes) {
                            let missing_scopes = required_scopes.difference(scopes);
                            return Ok(Response::builder()
                                .status(StatusCode::FORBIDDEN)
                                .body(Body::from(missing_scopes.fold(
                                    "Insufficient authorization, missing scopes".to_string(),
                                    |s, scope| format!("{} {}", s, scope))
                                ))
                                .expect("Unable to create Authentication Insufficient response")
                            );
                        }
                    }
                }

                                let result = api_impl.website_verification_slash_get(
                                        &context
                                    ).await;
                                let mut response = Response::new(Body::empty());
                                response.headers_mut().insert(
                                            HeaderName::from_static("x-span-id"),
                                            HeaderValue::from_str((&context as &dyn Has<XSpanIdString>).get().0.clone().as_str())
                                                .expect("Unable to create X-Span-ID header value"));

                                        match result {
                                            Ok(rsp) => match rsp {
                                                WebsiteVerificationSlashGetResponse::Success
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(200).expect("Unable to turn 200 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for WEBSITE_VERIFICATION_SLASH_GET_SUCCESS"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                WebsiteVerificationSlashGetResponse::NotAuthorizedToAccessTheUserVerificationCodeForWebsiteClaiming
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(403).expect("Unable to turn 403 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for WEBSITE_VERIFICATION_SLASH_GET_NOT_AUTHORIZED_TO_ACCESS_THE_USER_VERIFICATION_CODE_FOR_WEBSITE_CLAIMING"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                                WebsiteVerificationSlashGetResponse::UnexpectedError
                                                    (body)
                                                => {
                                                    *response.status_mut() = StatusCode::from_u16(0).expect("Unable to turn 0 into a StatusCode");
                                                    response.headers_mut().insert(
                                                        CONTENT_TYPE,
                                                        HeaderValue::from_str("application/json")
                                                            .expect("Unable to create Content-Type header for WEBSITE_VERIFICATION_SLASH_GET_UNEXPECTED_ERROR"));
                                                    let body_content = serde_json::to_string(&body).expect("impossible to fail to serialize");
                                                    *response.body_mut() = Body::from(body_content);
                                                },
                                            },
                                            Err(_) => {
                                                // Application code returned an error. This should not happen, as the implementation should
                                                // return a valid response.
                                                *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
                                                *response.body_mut() = Body::from("An internal error occurred");
                                            },
                                        }

                                        Ok(response)
            },

            _ if path.matched(paths::ID_AD_ACCOUNTS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_ANALYTICS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AUDIENCE_SIZING) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_TARGETING_ANALYTICS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AD_GROUP_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_PREVIEWS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_ANALYTICS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_TARGETING_ANALYTICS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_AD_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_DISCOUNTS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_REDEEM) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ANALYTICS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCE_INSIGHTS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_CUSTOM) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_AUDIENCE_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BID_FLOOR) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BILLING_PROFILES) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_DOWNLOAD) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_UPSERT) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_BULK_REQUEST_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_ANALYTICS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_TARGETING_ANALYTICS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_CAMPAIGN_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_OCPM_ELIGIBLE) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_PAGE_VISIT) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_CONVERSION_TAG_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS_CUSTOMER_LIST_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_EVENTS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_INSIGHTS_AUDIENCES) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS_METRICS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID_TEST) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS_SUBSCRIPTION_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_MMM_REPORTS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES_ORDER_LINE_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS_PRODUCT_GROUP_PROMOTION_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_ANALYTICS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_CATALOGS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_REPORTS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SANDBOX) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ACCOUNTS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_STATUS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_PIN_ORDER_ID_STATUS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ORDER_LINES) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_TARGETING_ANALYTICS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES_TEMPLATE_ID_REPORTS) => method_not_allowed(),
            _ if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_TERMS_OF_SERVICE) => method_not_allowed(),
            _ if path.matched(paths::ID_BOARDS) => method_not_allowed(),
            _ if path.matched(paths::ID_BOARDS_BOARD_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_BOARDS_BOARD_ID_PINS) => method_not_allowed(),
            _ if path.matched(paths::ID_BOARDS_BOARD_ID_SECTIONS) => method_not_allowed(),
            _ if path.matched(paths::ID_BOARDS_BOARD_ID_SECTIONS_SECTION_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_BOARDS_BOARD_ID_SECTIONS_SECTION_ID_PINS) => method_not_allowed(),
            _ if path.matched(paths::ID_CATALOGS) => method_not_allowed(),
            _ if path.matched(paths::ID_CATALOGS_FEEDS) => method_not_allowed(),
            _ if path.matched(paths::ID_CATALOGS_FEEDS_FEED_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_CATALOGS_FEEDS_FEED_ID_PROCESSING_RESULTS) => method_not_allowed(),
            _ if path.matched(paths::ID_CATALOGS_ITEMS) => method_not_allowed(),
            _ if path.matched(paths::ID_CATALOGS_ITEMS_BATCH) => method_not_allowed(),
            _ if path.matched(paths::ID_CATALOGS_ITEMS_BATCH_BATCH_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_CATALOGS_PROCESSING_RESULTS_PROCESSING_RESULT_ID_ITEM_ISSUES) => method_not_allowed(),
            _ if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS) => method_not_allowed(),
            _ if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCT_COUNTS) => method_not_allowed(),
            _ if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCTS) => method_not_allowed(),
            _ if path.matched(paths::ID_CATALOGS_PRODUCTS_GET_BY_PRODUCT_GROUP_FILTERS) => method_not_allowed(),
            _ if path.matched(paths::ID_INTEGRATIONS) => method_not_allowed(),
            _ if path.matched(paths::ID_INTEGRATIONS_COMMERCE) => method_not_allowed(),
            _ if path.matched(paths::ID_INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_INTEGRATIONS_LOGS) => method_not_allowed(),
            _ if path.matched(paths::ID_INTEGRATIONS_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_MEDIA) => method_not_allowed(),
            _ if path.matched(paths::ID_MEDIA_MEDIA_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_OAUTH_TOKEN) => method_not_allowed(),
            _ if path.matched(paths::ID_PINS) => method_not_allowed(),
            _ if path.matched(paths::ID_PINS_PIN_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_PINS_PIN_ID_ANALYTICS) => method_not_allowed(),
            _ if path.matched(paths::ID_PINS_PIN_ID_SAVE) => method_not_allowed(),
            _ if path.matched(paths::ID_RESOURCES_AD_ACCOUNT_COUNTRIES) => method_not_allowed(),
            _ if path.matched(paths::ID_RESOURCES_DELIVERY_METRICS) => method_not_allowed(),
            _ if path.matched(paths::ID_RESOURCES_LEAD_FORM_QUESTIONS) => method_not_allowed(),
            _ if path.matched(paths::ID_RESOURCES_METRICS_READY_STATE) => method_not_allowed(),
            _ if path.matched(paths::ID_RESOURCES_TARGETING_INTERESTS_INTEREST_ID) => method_not_allowed(),
            _ if path.matched(paths::ID_RESOURCES_TARGETING_TARGETING_TYPE) => method_not_allowed(),
            _ if path.matched(paths::ID_SEARCH_BOARDS) => method_not_allowed(),
            _ if path.matched(paths::ID_SEARCH_PARTNER_PINS) => method_not_allowed(),
            _ if path.matched(paths::ID_SEARCH_PINS) => method_not_allowed(),
            _ if path.matched(paths::ID_TERMS_RELATED) => method_not_allowed(),
            _ if path.matched(paths::ID_TERMS_SUGGESTED) => method_not_allowed(),
            _ if path.matched(paths::ID_TRENDS_KEYWORDS_REGION_TOP_TREND_TYPE) => method_not_allowed(),
            _ if path.matched(paths::ID_USER_ACCOUNT) => method_not_allowed(),
            _ if path.matched(paths::ID_USER_ACCOUNT_ANALYTICS) => method_not_allowed(),
            _ if path.matched(paths::ID_USER_ACCOUNT_ANALYTICS_TOP_PINS) => method_not_allowed(),
            _ if path.matched(paths::ID_USER_ACCOUNT_ANALYTICS_TOP_VIDEO_PINS) => method_not_allowed(),
            _ if path.matched(paths::ID_USER_ACCOUNT_BUSINESSES) => method_not_allowed(),
            _ if path.matched(paths::ID_USER_ACCOUNT_FOLLOWERS) => method_not_allowed(),
            _ if path.matched(paths::ID_USER_ACCOUNT_FOLLOWING) => method_not_allowed(),
            _ if path.matched(paths::ID_USER_ACCOUNT_FOLLOWING_BOARDS) => method_not_allowed(),
            _ if path.matched(paths::ID_USER_ACCOUNT_FOLLOWING_USERNAME) => method_not_allowed(),
            _ if path.matched(paths::ID_USER_ACCOUNT_WEBSITES) => method_not_allowed(),
            _ if path.matched(paths::ID_USER_ACCOUNT_WEBSITES_VERIFICATION) => method_not_allowed(),
            _ if path.matched(paths::ID_USERS_USERNAME_INTERESTS_FOLLOW) => method_not_allowed(),
            _ => Ok(Response::builder().status(StatusCode::NOT_FOUND)
                    .body(Body::empty())
                    .expect("Unable to create Not Found response"))
        }
    } Box::pin(run(self.api_impl.clone(), req)) }
}

/// Request parser for `Api`.
pub struct ApiRequestParser;
impl<T> RequestParser<T> for ApiRequestParser {
    fn parse_operation_id(request: &Request<T>) -> Option<&'static str> {
        let path = paths::GLOBAL_REGEX_SET.matches(request.uri().path());
        match *request.method() {
            // AdAccountSlashAnalytics - GET /ad_accounts/{ad_account_id}/analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ANALYTICS) => Some("AdAccountSlashAnalytics"),
            // AdAccountTargetingAnalyticsSlashGet - GET /ad_accounts/{ad_account_id}/targeting_analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_TARGETING_ANALYTICS) => Some("AdAccountTargetingAnalyticsSlashGet"),
            // AdAccountsSlashCreate - POST /ad_accounts
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS) => Some("AdAccountsSlashCreate"),
            // AdAccountsSlashGet - GET /ad_accounts/{ad_account_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID) => Some("AdAccountsSlashGet"),
            // AdAccountsSlashList - GET /ad_accounts
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS) => Some("AdAccountsSlashList"),
            // AnalyticsSlashCreateMmmReport - POST /ad_accounts/{ad_account_id}/mmm_reports
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_MMM_REPORTS) => Some("AnalyticsSlashCreateMmmReport"),
            // AnalyticsSlashCreateReport - POST /ad_accounts/{ad_account_id}/reports
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_REPORTS) => Some("AnalyticsSlashCreateReport"),
            // AnalyticsSlashCreateTemplateReport - POST /ad_accounts/{ad_account_id}/templates/{template_id}/reports
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES_TEMPLATE_ID_REPORTS) => Some("AnalyticsSlashCreateTemplateReport"),
            // AnalyticsSlashGetMmmReport - GET /ad_accounts/{ad_account_id}/mmm_reports
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_MMM_REPORTS) => Some("AnalyticsSlashGetMmmReport"),
            // AnalyticsSlashGetReport - GET /ad_accounts/{ad_account_id}/reports
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_REPORTS) => Some("AnalyticsSlashGetReport"),
            // SandboxSlashDelete - DELETE /ad_accounts/{ad_account_id}/sandbox
            hyper::Method::DELETE if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SANDBOX) => Some("SandboxSlashDelete"),
            // TemplatesSlashList - GET /ad_accounts/{ad_account_id}/templates
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_TEMPLATES) => Some("TemplatesSlashList"),
            // AdGroupsBidFloorSlashGet - POST /ad_accounts/{ad_account_id}/bid_floor
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BID_FLOOR) => Some("AdGroupsBidFloorSlashGet"),
            // AdGroupsSlashAnalytics - GET /ad_accounts/{ad_account_id}/ad_groups/analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_ANALYTICS) => Some("AdGroupsSlashAnalytics"),
            // AdGroupsSlashAudienceSizing - GET /ad_accounts/{ad_account_id}/ad_groups/audience_sizing
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AUDIENCE_SIZING) => Some("AdGroupsSlashAudienceSizing"),
            // AdGroupsSlashCreate - POST /ad_accounts/{ad_account_id}/ad_groups
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS) => Some("AdGroupsSlashCreate"),
            // AdGroupsSlashGet - GET /ad_accounts/{ad_account_id}/ad_groups/{ad_group_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_AD_GROUP_ID) => Some("AdGroupsSlashGet"),
            // AdGroupsSlashList - GET /ad_accounts/{ad_account_id}/ad_groups
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS) => Some("AdGroupsSlashList"),
            // AdGroupsSlashUpdate - PATCH /ad_accounts/{ad_account_id}/ad_groups
            hyper::Method::PATCH if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS) => Some("AdGroupsSlashUpdate"),
            // AdGroupsTargetingAnalyticsSlashGet - GET /ad_accounts/{ad_account_id}/ad_groups/targeting_analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_GROUPS_TARGETING_ANALYTICS) => Some("AdGroupsTargetingAnalyticsSlashGet"),
            // AdPreviewsSlashCreate - POST /ad_accounts/{ad_account_id}/ad_previews
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AD_PREVIEWS) => Some("AdPreviewsSlashCreate"),
            // AdTargetingAnalyticsSlashGet - GET /ad_accounts/{ad_account_id}/ads/targeting_analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_TARGETING_ANALYTICS) => Some("AdTargetingAnalyticsSlashGet"),
            // AdsSlashAnalytics - GET /ad_accounts/{ad_account_id}/ads/analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_ANALYTICS) => Some("AdsSlashAnalytics"),
            // AdsSlashCreate - POST /ad_accounts/{ad_account_id}/ads
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS) => Some("AdsSlashCreate"),
            // AdsSlashGet - GET /ad_accounts/{ad_account_id}/ads/{ad_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_AD_ID) => Some("AdsSlashGet"),
            // AdsSlashList - GET /ad_accounts/{ad_account_id}/ads
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS) => Some("AdsSlashList"),
            // AdsSlashUpdate - PATCH /ad_accounts/{ad_account_id}/ads
            hyper::Method::PATCH if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS) => Some("AdsSlashUpdate"),
            // AudienceInsightsScopeAndTypeSlashGet - GET /ad_accounts/{ad_account_id}/insights/audiences
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_INSIGHTS_AUDIENCES) => Some("AudienceInsightsScopeAndTypeSlashGet"),
            // AudienceInsightsSlashGet - GET /ad_accounts/{ad_account_id}/audience_insights
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCE_INSIGHTS) => Some("AudienceInsightsSlashGet"),
            // AudiencesSlashCreate - POST /ad_accounts/{ad_account_id}/audiences
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES) => Some("AudiencesSlashCreate"),
            // AudiencesSlashCreateCustom - POST /ad_accounts/{ad_account_id}/audiences/custom
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_CUSTOM) => Some("AudiencesSlashCreateCustom"),
            // AudiencesSlashGet - GET /ad_accounts/{ad_account_id}/audiences/{audience_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_AUDIENCE_ID) => Some("AudiencesSlashGet"),
            // AudiencesSlashList - GET /ad_accounts/{ad_account_id}/audiences
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES) => Some("AudiencesSlashList"),
            // AudiencesSlashUpdate - PATCH /ad_accounts/{ad_account_id}/audiences/{audience_id}
            hyper::Method::PATCH if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_AUDIENCES_AUDIENCE_ID) => Some("AudiencesSlashUpdate"),
            // AdsCreditSlashRedeem - POST /ad_accounts/{ad_account_id}/ads_credit/redeem
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_REDEEM) => Some("AdsCreditSlashRedeem"),
            // AdsCreditsDiscountsSlashGet - GET /ad_accounts/{ad_account_id}/ads_credit/discounts
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ADS_CREDIT_DISCOUNTS) => Some("AdsCreditsDiscountsSlashGet"),
            // BillingProfilesSlashGet - GET /ad_accounts/{ad_account_id}/billing_profiles
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BILLING_PROFILES) => Some("BillingProfilesSlashGet"),
            // SsioAccountsSlashGet - GET /ad_accounts/{ad_account_id}/ssio/accounts
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ACCOUNTS) => Some("SsioAccountsSlashGet"),
            // SsioInsertionOrderSlashCreate - POST /ad_accounts/{ad_account_id}/ssio/insertion_orders
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS) => Some("SsioInsertionOrderSlashCreate"),
            // SsioInsertionOrderSlashEdit - PATCH /ad_accounts/{ad_account_id}/ssio/insertion_orders
            hyper::Method::PATCH if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS) => Some("SsioInsertionOrderSlashEdit"),
            // SsioInsertionOrdersStatusSlashGetByAdAccount - GET /ad_accounts/{ad_account_id}/ssio/insertion_orders/status
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_STATUS) => Some("SsioInsertionOrdersStatusSlashGetByAdAccount"),
            // SsioInsertionOrdersStatusSlashGetByPinOrderId - GET /ad_accounts/{ad_account_id}/ssio/insertion_orders/{pin_order_id}/status
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_INSERTION_ORDERS_PIN_ORDER_ID_STATUS) => Some("SsioInsertionOrdersStatusSlashGetByPinOrderId"),
            // SsioOrderLinesSlashGetByAdAccount - GET /ad_accounts/{ad_account_id}/ssio/order_lines
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_SSIO_ORDER_LINES) => Some("SsioOrderLinesSlashGetByAdAccount"),
            // BoardSectionsSlashCreate - POST /boards/{board_id}/sections
            hyper::Method::POST if path.matched(paths::ID_BOARDS_BOARD_ID_SECTIONS) => Some("BoardSectionsSlashCreate"),
            // BoardSectionsSlashDelete - DELETE /boards/{board_id}/sections/{section_id}
            hyper::Method::DELETE if path.matched(paths::ID_BOARDS_BOARD_ID_SECTIONS_SECTION_ID) => Some("BoardSectionsSlashDelete"),
            // BoardSectionsSlashList - GET /boards/{board_id}/sections
            hyper::Method::GET if path.matched(paths::ID_BOARDS_BOARD_ID_SECTIONS) => Some("BoardSectionsSlashList"),
            // BoardSectionsSlashListPins - GET /boards/{board_id}/sections/{section_id}/pins
            hyper::Method::GET if path.matched(paths::ID_BOARDS_BOARD_ID_SECTIONS_SECTION_ID_PINS) => Some("BoardSectionsSlashListPins"),
            // BoardSectionsSlashUpdate - PATCH /boards/{board_id}/sections/{section_id}
            hyper::Method::PATCH if path.matched(paths::ID_BOARDS_BOARD_ID_SECTIONS_SECTION_ID) => Some("BoardSectionsSlashUpdate"),
            // BoardsSlashCreate - POST /boards
            hyper::Method::POST if path.matched(paths::ID_BOARDS) => Some("BoardsSlashCreate"),
            // BoardsSlashDelete - DELETE /boards/{board_id}
            hyper::Method::DELETE if path.matched(paths::ID_BOARDS_BOARD_ID) => Some("BoardsSlashDelete"),
            // BoardsSlashGet - GET /boards/{board_id}
            hyper::Method::GET if path.matched(paths::ID_BOARDS_BOARD_ID) => Some("BoardsSlashGet"),
            // BoardsSlashList - GET /boards
            hyper::Method::GET if path.matched(paths::ID_BOARDS) => Some("BoardsSlashList"),
            // BoardsSlashListPins - GET /boards/{board_id}/pins
            hyper::Method::GET if path.matched(paths::ID_BOARDS_BOARD_ID_PINS) => Some("BoardsSlashListPins"),
            // BoardsSlashUpdate - PATCH /boards/{board_id}
            hyper::Method::PATCH if path.matched(paths::ID_BOARDS_BOARD_ID) => Some("BoardsSlashUpdate"),
            // BulkDownloadSlashCreate - POST /ad_accounts/{ad_account_id}/bulk/download
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_DOWNLOAD) => Some("BulkDownloadSlashCreate"),
            // BulkRequestSlashGet - GET /ad_accounts/{ad_account_id}/bulk/{bulk_request_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_BULK_REQUEST_ID) => Some("BulkRequestSlashGet"),
            // BulkUpsertSlashCreate - POST /ad_accounts/{ad_account_id}/bulk/upsert
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_BULK_UPSERT) => Some("BulkUpsertSlashCreate"),
            // CampaignTargetingAnalyticsSlashGet - GET /ad_accounts/{ad_account_id}/campaigns/targeting_analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_TARGETING_ANALYTICS) => Some("CampaignTargetingAnalyticsSlashGet"),
            // CampaignsSlashAnalytics - GET /ad_accounts/{ad_account_id}/campaigns/analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_ANALYTICS) => Some("CampaignsSlashAnalytics"),
            // CampaignsSlashCreate - POST /ad_accounts/{ad_account_id}/campaigns
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS) => Some("CampaignsSlashCreate"),
            // CampaignsSlashGet - GET /ad_accounts/{ad_account_id}/campaigns/{campaign_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS_CAMPAIGN_ID) => Some("CampaignsSlashGet"),
            // CampaignsSlashList - GET /ad_accounts/{ad_account_id}/campaigns
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS) => Some("CampaignsSlashList"),
            // CampaignsSlashUpdate - PATCH /ad_accounts/{ad_account_id}/campaigns
            hyper::Method::PATCH if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CAMPAIGNS) => Some("CampaignsSlashUpdate"),
            // CatalogsProductGroupPinsSlashList - GET /catalogs/product_groups/{product_group_id}/products
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCTS) => Some("CatalogsProductGroupPinsSlashList"),
            // CatalogsProductGroupsSlashCreate - POST /catalogs/product_groups
            hyper::Method::POST if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS) => Some("CatalogsProductGroupsSlashCreate"),
            // CatalogsProductGroupsSlashDelete - DELETE /catalogs/product_groups/{product_group_id}
            hyper::Method::DELETE if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID) => Some("CatalogsProductGroupsSlashDelete"),
            // CatalogsProductGroupsSlashGet - GET /catalogs/product_groups/{product_group_id}
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID) => Some("CatalogsProductGroupsSlashGet"),
            // CatalogsProductGroupsSlashList - GET /catalogs/product_groups
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS) => Some("CatalogsProductGroupsSlashList"),
            // CatalogsProductGroupsSlashProductCountsGet - GET /catalogs/product_groups/{product_group_id}/product_counts
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID_PRODUCT_COUNTS) => Some("CatalogsProductGroupsSlashProductCountsGet"),
            // CatalogsProductGroupsSlashUpdate - PATCH /catalogs/product_groups/{product_group_id}
            hyper::Method::PATCH if path.matched(paths::ID_CATALOGS_PRODUCT_GROUPS_PRODUCT_GROUP_ID) => Some("CatalogsProductGroupsSlashUpdate"),
            // CatalogsSlashList - GET /catalogs
            hyper::Method::GET if path.matched(paths::ID_CATALOGS) => Some("CatalogsSlashList"),
            // FeedProcessingResultsSlashList - GET /catalogs/feeds/{feed_id}/processing_results
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_FEEDS_FEED_ID_PROCESSING_RESULTS) => Some("FeedProcessingResultsSlashList"),
            // FeedsSlashCreate - POST /catalogs/feeds
            hyper::Method::POST if path.matched(paths::ID_CATALOGS_FEEDS) => Some("FeedsSlashCreate"),
            // FeedsSlashDelete - DELETE /catalogs/feeds/{feed_id}
            hyper::Method::DELETE if path.matched(paths::ID_CATALOGS_FEEDS_FEED_ID) => Some("FeedsSlashDelete"),
            // FeedsSlashGet - GET /catalogs/feeds/{feed_id}
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_FEEDS_FEED_ID) => Some("FeedsSlashGet"),
            // FeedsSlashList - GET /catalogs/feeds
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_FEEDS) => Some("FeedsSlashList"),
            // FeedsSlashUpdate - PATCH /catalogs/feeds/{feed_id}
            hyper::Method::PATCH if path.matched(paths::ID_CATALOGS_FEEDS_FEED_ID) => Some("FeedsSlashUpdate"),
            // ItemsBatchSlashGet - GET /catalogs/items/batch/{batch_id}
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_ITEMS_BATCH_BATCH_ID) => Some("ItemsBatchSlashGet"),
            // ItemsBatchSlashPost - POST /catalogs/items/batch
            hyper::Method::POST if path.matched(paths::ID_CATALOGS_ITEMS_BATCH) => Some("ItemsBatchSlashPost"),
            // ItemsIssuesSlashList - GET /catalogs/processing_results/{processing_result_id}/item_issues
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_PROCESSING_RESULTS_PROCESSING_RESULT_ID_ITEM_ISSUES) => Some("ItemsIssuesSlashList"),
            // ItemsSlashGet - GET /catalogs/items
            hyper::Method::GET if path.matched(paths::ID_CATALOGS_ITEMS) => Some("ItemsSlashGet"),
            // ProductsByProductGroupFilterSlashList - POST /catalogs/products/get_by_product_group_filters
            hyper::Method::POST if path.matched(paths::ID_CATALOGS_PRODUCTS_GET_BY_PRODUCT_GROUP_FILTERS) => Some("ProductsByProductGroupFilterSlashList"),
            // EventsSlashCreate - POST /ad_accounts/{ad_account_id}/events
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_EVENTS) => Some("EventsSlashCreate"),
            // ConversionTagsSlashCreate - POST /ad_accounts/{ad_account_id}/conversion_tags
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS) => Some("ConversionTagsSlashCreate"),
            // ConversionTagsSlashGet - GET /ad_accounts/{ad_account_id}/conversion_tags/{conversion_tag_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_CONVERSION_TAG_ID) => Some("ConversionTagsSlashGet"),
            // ConversionTagsSlashList - GET /ad_accounts/{ad_account_id}/conversion_tags
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS) => Some("ConversionTagsSlashList"),
            // OcpmEligibleConversionTagsSlashGet - GET /ad_accounts/{ad_account_id}/conversion_tags/ocpm_eligible
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_OCPM_ELIGIBLE) => Some("OcpmEligibleConversionTagsSlashGet"),
            // PageVisitConversionTagsSlashGet - GET /ad_accounts/{ad_account_id}/conversion_tags/page_visit
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CONVERSION_TAGS_PAGE_VISIT) => Some("PageVisitConversionTagsSlashGet"),
            // CustomerListsSlashCreate - POST /ad_accounts/{ad_account_id}/customer_lists
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS) => Some("CustomerListsSlashCreate"),
            // CustomerListsSlashGet - GET /ad_accounts/{ad_account_id}/customer_lists/{customer_list_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS_CUSTOMER_LIST_ID) => Some("CustomerListsSlashGet"),
            // CustomerListsSlashList - GET /ad_accounts/{ad_account_id}/customer_lists
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS) => Some("CustomerListsSlashList"),
            // CustomerListsSlashUpdate - PATCH /ad_accounts/{ad_account_id}/customer_lists/{customer_list_id}
            hyper::Method::PATCH if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_CUSTOMER_LISTS_CUSTOMER_LIST_ID) => Some("CustomerListsSlashUpdate"),
            // IntegrationsCommerceSlashDel - DELETE /integrations/commerce/{external_business_id}
            hyper::Method::DELETE if path.matched(paths::ID_INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID) => Some("IntegrationsCommerceSlashDel"),
            // IntegrationsCommerceSlashGet - GET /integrations/commerce/{external_business_id}
            hyper::Method::GET if path.matched(paths::ID_INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID) => Some("IntegrationsCommerceSlashGet"),
            // IntegrationsCommerceSlashPatch - PATCH /integrations/commerce/{external_business_id}
            hyper::Method::PATCH if path.matched(paths::ID_INTEGRATIONS_COMMERCE_EXTERNAL_BUSINESS_ID) => Some("IntegrationsCommerceSlashPatch"),
            // IntegrationsCommerceSlashPost - POST /integrations/commerce
            hyper::Method::POST if path.matched(paths::ID_INTEGRATIONS_COMMERCE) => Some("IntegrationsCommerceSlashPost"),
            // IntegrationsLogsSlashPost - POST /integrations/logs
            hyper::Method::POST if path.matched(paths::ID_INTEGRATIONS_LOGS) => Some("IntegrationsLogsSlashPost"),
            // IntegrationsSlashGetById - GET /integrations/{id}
            hyper::Method::GET if path.matched(paths::ID_INTEGRATIONS_ID) => Some("IntegrationsSlashGetById"),
            // IntegrationsSlashGetList - GET /integrations
            hyper::Method::GET if path.matched(paths::ID_INTEGRATIONS) => Some("IntegrationsSlashGetList"),
            // CountryKeywordsMetricsSlashGet - GET /ad_accounts/{ad_account_id}/keywords/metrics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS_METRICS) => Some("CountryKeywordsMetricsSlashGet"),
            // KeywordsSlashCreate - POST /ad_accounts/{ad_account_id}/keywords
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS) => Some("KeywordsSlashCreate"),
            // KeywordsSlashGet - GET /ad_accounts/{ad_account_id}/keywords
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS) => Some("KeywordsSlashGet"),
            // KeywordsSlashUpdate - PATCH /ad_accounts/{ad_account_id}/keywords
            hyper::Method::PATCH if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_KEYWORDS) => Some("KeywordsSlashUpdate"),
            // TrendingKeywordsSlashList - GET /trends/keywords/{region}/top/{trend_type}
            hyper::Method::GET if path.matched(paths::ID_TRENDS_KEYWORDS_REGION_TOP_TREND_TYPE) => Some("TrendingKeywordsSlashList"),
            // AdAccountsSubscriptionsSlashDelById - DELETE /ad_accounts/{ad_account_id}/leads/subscriptions/{subscription_id}
            hyper::Method::DELETE if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS_SUBSCRIPTION_ID) => Some("AdAccountsSubscriptionsSlashDelById"),
            // AdAccountsSubscriptionsSlashGetById - GET /ad_accounts/{ad_account_id}/leads/subscriptions/{subscription_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS_SUBSCRIPTION_ID) => Some("AdAccountsSubscriptionsSlashGetById"),
            // AdAccountsSubscriptionsSlashGetList - GET /ad_accounts/{ad_account_id}/leads/subscriptions
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS) => Some("AdAccountsSubscriptionsSlashGetList"),
            // AdAccountsSubscriptionsSlashPost - POST /ad_accounts/{ad_account_id}/leads/subscriptions
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEADS_SUBSCRIPTIONS) => Some("AdAccountsSubscriptionsSlashPost"),
            // LeadFormSlashGet - GET /ad_accounts/{ad_account_id}/lead_forms/{lead_form_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID) => Some("LeadFormSlashGet"),
            // LeadFormTestSlashCreate - POST /ad_accounts/{ad_account_id}/lead_forms/{lead_form_id}/test
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS_LEAD_FORM_ID_TEST) => Some("LeadFormTestSlashCreate"),
            // LeadFormsSlashList - GET /ad_accounts/{ad_account_id}/lead_forms
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_LEAD_FORMS) => Some("LeadFormsSlashList"),
            // MediaSlashCreate - POST /media
            hyper::Method::POST if path.matched(paths::ID_MEDIA) => Some("MediaSlashCreate"),
            // MediaSlashGet - GET /media/{media_id}
            hyper::Method::GET if path.matched(paths::ID_MEDIA_MEDIA_ID) => Some("MediaSlashGet"),
            // MediaSlashList - GET /media
            hyper::Method::GET if path.matched(paths::ID_MEDIA) => Some("MediaSlashList"),
            // OauthSlashToken - POST /oauth/token
            hyper::Method::POST if path.matched(paths::ID_OAUTH_TOKEN) => Some("OauthSlashToken"),
            // OrderLinesSlashGet - GET /ad_accounts/{ad_account_id}/order_lines/{order_line_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES_ORDER_LINE_ID) => Some("OrderLinesSlashGet"),
            // OrderLinesSlashList - GET /ad_accounts/{ad_account_id}/order_lines
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_ORDER_LINES) => Some("OrderLinesSlashList"),
            // PinsSlashAnalytics - GET /pins/{pin_id}/analytics
            hyper::Method::GET if path.matched(paths::ID_PINS_PIN_ID_ANALYTICS) => Some("PinsSlashAnalytics"),
            // PinsSlashCreate - POST /pins
            hyper::Method::POST if path.matched(paths::ID_PINS) => Some("PinsSlashCreate"),
            // PinsSlashDelete - DELETE /pins/{pin_id}
            hyper::Method::DELETE if path.matched(paths::ID_PINS_PIN_ID) => Some("PinsSlashDelete"),
            // PinsSlashGet - GET /pins/{pin_id}
            hyper::Method::GET if path.matched(paths::ID_PINS_PIN_ID) => Some("PinsSlashGet"),
            // PinsSlashList - GET /pins
            hyper::Method::GET if path.matched(paths::ID_PINS) => Some("PinsSlashList"),
            // PinsSlashSave - POST /pins/{pin_id}/save
            hyper::Method::POST if path.matched(paths::ID_PINS_PIN_ID_SAVE) => Some("PinsSlashSave"),
            // PinsSlashUpdate - PATCH /pins/{pin_id}
            hyper::Method::PATCH if path.matched(paths::ID_PINS_PIN_ID) => Some("PinsSlashUpdate"),
            // ProductGroupPromotionsSlashCreate - POST /ad_accounts/{ad_account_id}/product_group_promotions
            hyper::Method::POST if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS) => Some("ProductGroupPromotionsSlashCreate"),
            // ProductGroupPromotionsSlashGet - GET /ad_accounts/{ad_account_id}/product_group_promotions/{product_group_promotion_id}
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS_PRODUCT_GROUP_PROMOTION_ID) => Some("ProductGroupPromotionsSlashGet"),
            // ProductGroupPromotionsSlashList - GET /ad_accounts/{ad_account_id}/product_group_promotions
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS) => Some("ProductGroupPromotionsSlashList"),
            // ProductGroupPromotionsSlashUpdate - PATCH /ad_accounts/{ad_account_id}/product_group_promotions
            hyper::Method::PATCH if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUP_PROMOTIONS) => Some("ProductGroupPromotionsSlashUpdate"),
            // ProductGroupsSlashAnalytics - GET /ad_accounts/{ad_account_id}/product_groups/analytics
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_ANALYTICS) => Some("ProductGroupsSlashAnalytics"),
            // AdAccountsCatalogsProductGroupsSlashList - GET /ad_accounts/{ad_account_id}/product_groups/catalogs
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_PRODUCT_GROUPS_CATALOGS) => Some("AdAccountsCatalogsProductGroupsSlashList"),
            // AdAccountCountriesSlashGet - GET /resources/ad_account_countries
            hyper::Method::GET if path.matched(paths::ID_RESOURCES_AD_ACCOUNT_COUNTRIES) => Some("AdAccountCountriesSlashGet"),
            // DeliveryMetricsSlashGet - GET /resources/delivery_metrics
            hyper::Method::GET if path.matched(paths::ID_RESOURCES_DELIVERY_METRICS) => Some("DeliveryMetricsSlashGet"),
            // InterestTargetingOptionsSlashGet - GET /resources/targeting/interests/{interest_id}
            hyper::Method::GET if path.matched(paths::ID_RESOURCES_TARGETING_INTERESTS_INTEREST_ID) => Some("InterestTargetingOptionsSlashGet"),
            // LeadFormQuestionsSlashGet - GET /resources/lead_form_questions
            hyper::Method::GET if path.matched(paths::ID_RESOURCES_LEAD_FORM_QUESTIONS) => Some("LeadFormQuestionsSlashGet"),
            // MetricsReadyStateSlashGet - GET /resources/metrics_ready_state
            hyper::Method::GET if path.matched(paths::ID_RESOURCES_METRICS_READY_STATE) => Some("MetricsReadyStateSlashGet"),
            // TargetingOptionsSlashGet - GET /resources/targeting/{targeting_type}
            hyper::Method::GET if path.matched(paths::ID_RESOURCES_TARGETING_TARGETING_TYPE) => Some("TargetingOptionsSlashGet"),
            // SearchPartnerPins - GET /search/partner/pins
            hyper::Method::GET if path.matched(paths::ID_SEARCH_PARTNER_PINS) => Some("SearchPartnerPins"),
            // SearchUserBoardsSlashGet - GET /search/boards
            hyper::Method::GET if path.matched(paths::ID_SEARCH_BOARDS) => Some("SearchUserBoardsSlashGet"),
            // SearchUserPinsSlashList - GET /search/pins
            hyper::Method::GET if path.matched(paths::ID_SEARCH_PINS) => Some("SearchUserPinsSlashList"),
            // TermsRelatedSlashList - GET /terms/related
            hyper::Method::GET if path.matched(paths::ID_TERMS_RELATED) => Some("TermsRelatedSlashList"),
            // TermsSuggestedSlashList - GET /terms/suggested
            hyper::Method::GET if path.matched(paths::ID_TERMS_SUGGESTED) => Some("TermsSuggestedSlashList"),
            // TermsOfServiceSlashGet - GET /ad_accounts/{ad_account_id}/terms_of_service
            hyper::Method::GET if path.matched(paths::ID_AD_ACCOUNTS_AD_ACCOUNT_ID_TERMS_OF_SERVICE) => Some("TermsOfServiceSlashGet"),
            // BoardsUserFollowsSlashList - GET /user_account/following/boards
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_FOLLOWING_BOARDS) => Some("BoardsUserFollowsSlashList"),
            // FollowUserSlashUpdate - POST /user_account/following/{username}
            hyper::Method::POST if path.matched(paths::ID_USER_ACCOUNT_FOLLOWING_USERNAME) => Some("FollowUserSlashUpdate"),
            // FollowersSlashList - GET /user_account/followers
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_FOLLOWERS) => Some("FollowersSlashList"),
            // LinkedBusinessAccountsSlashGet - GET /user_account/businesses
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_BUSINESSES) => Some("LinkedBusinessAccountsSlashGet"),
            // UnverifyWebsiteSlashDelete - DELETE /user_account/websites
            hyper::Method::DELETE if path.matched(paths::ID_USER_ACCOUNT_WEBSITES) => Some("UnverifyWebsiteSlashDelete"),
            // UserAccountSlashAnalytics - GET /user_account/analytics
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_ANALYTICS) => Some("UserAccountSlashAnalytics"),
            // UserAccountSlashAnalyticsSlashTopPins - GET /user_account/analytics/top_pins
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_ANALYTICS_TOP_PINS) => Some("UserAccountSlashAnalyticsSlashTopPins"),
            // UserAccountSlashAnalyticsSlashTopVideoPins - GET /user_account/analytics/top_video_pins
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_ANALYTICS_TOP_VIDEO_PINS) => Some("UserAccountSlashAnalyticsSlashTopVideoPins"),
            // UserAccountSlashFollowedInterests - GET /users/{username}/interests/follow
            hyper::Method::GET if path.matched(paths::ID_USERS_USERNAME_INTERESTS_FOLLOW) => Some("UserAccountSlashFollowedInterests"),
            // UserAccountSlashGet - GET /user_account
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT) => Some("UserAccountSlashGet"),
            // UserFollowingSlashGet - GET /user_account/following
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_FOLLOWING) => Some("UserFollowingSlashGet"),
            // UserWebsitesSlashGet - GET /user_account/websites
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_WEBSITES) => Some("UserWebsitesSlashGet"),
            // VerifyWebsiteSlashUpdate - POST /user_account/websites
            hyper::Method::POST if path.matched(paths::ID_USER_ACCOUNT_WEBSITES) => Some("VerifyWebsiteSlashUpdate"),
            // WebsiteVerificationSlashGet - GET /user_account/websites/verification
            hyper::Method::GET if path.matched(paths::ID_USER_ACCOUNT_WEBSITES_VERIFICATION) => Some("WebsiteVerificationSlashGet"),
            _ => None,
        }
    }
}
